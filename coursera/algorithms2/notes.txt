###############
# week1
###############
- introduction
	Graph. Set of vertices connected pairwise by edges.
	Path. Sequence of vertices connected by edges.
	Cycle. Path whose first and last vertices are the same.
	
	graph 			vertex 					edge
	communication 	telephone, computer 	fiber optic cable

- API
	compute the degree of v									compute maximum degree									compute average degree									count self - loops                                 
	####################################################    ####################################################    ####################################################    ####################################################
	# public static int degree(Graph G, int v) {       #    # public static int maxDegree(Graph G) {           #    # public static double averageDegree(Graph G) {    #    # public static int numberOfSelfLoops(Graph G) {   #
	#     int degree = 0;                              #    #     int max = 0;                                 #    #     return 2.0 * G.E() / G.V();                  #    #     int count = 0;                               #
	#     for (int w : G.adj(v))                       #    #     for (int v = 0; v < G.V(); v ++)             #    # }                                                #    #     for (int v = 0; v < G.V(); v ++)             #
	#         degree ++;                               #    #         if (degree(G, v) > max)                  #    ####################################################    #         for (int w : G.adj(v))                   #
	#     return degree;                               #    #             max = degree(G, v);                  #                                                            #             if (v == w)                          #
	# }                                                #    #     return max;                                  #                                                            #                 count ++;                        #
	####################################################    # }                                                #                                                            #     return count / 2; // each edge counted twice #
	                                                        ####################################################                                                            # }                                                #
	                                                                                                                                                                        ####################################################
	Adjacency-list graph representation
	############################################	#############################################
	# +--------------------------------------+ #    # public class Graph {                      #
	# | 0| 1| 2| 3| 4| 5| 6| 7| 8| 9|10|11|12| #    #     private final int V;                  #
	# +--------------------------------------+ #    #     private Bag<Integer> [] adj;          #
	#   6  0  0  5  5  3  0  8  7 11  9  9 11  #    #     public Graph(int V) {                 #
	#   2        4  6  4  4       10    12  6  #    #         this.V = V;                       #
	#   7           3  0          12           #    #         adj = (Bag<Integer> [])new Bag[V];#
	#   5                                      #    #         for (int v = 0; v < V; v ++)      #
	############################################    #             adj[v] = new Bag<Integer>();  #
	                                                #                                           #
	                                                #     }                                     #
	                                                #     public void addEdge(int v, int w) {   #
	                                                #         adj[v].add(w);                    #
	                                                #         adj[w].add(v);                    #
	                                                #     }                                     #
	                                                #     public Iterable<Integer> adj(int v) { #
	                                                #         return adj[v];                    #
	                                                #     }                                     #
	                                                # }                                         #
	                                                #############################################
	
- depth-first search
	
	Algorithm.																																################################################
	・Use recursion (ball of string).                                                                                                        # public class DepthFirstPaths {               # 
	・Mark each visited vertex (and keep track of edge taken to visit it).                                                                   #     private boolean[] marked;                # 
	・Return (retrace steps) when no unvisited options.                                                                                      #     private int[] edgeTo;                    # 
	                                                                                                                                        #     private int s;                           #
	graph							fin all vertices connected to s                                                                         #     public DepthFirstPaths(Graph G, int s) { #
	##########################		v	marked[]	edgeTo[v]                                                                               # 		//init data structures                 #
	# +--------------------+ #		0	T			-			step1 - mark with T (check 6 2 1 5)                                         #         dfs(G, s);                           #
	# | 0| 1| 2| 3| 4| 5| 6| #		1	T			0			step7 - mark with T came from 0 (check 0)                                   #     }                                        #
	# +--------------------+ #		2	T			0           step6 - mark with T came from 0 (check 0)                                   #     private void dfs(Graph G, int v) {       #
	#   5  0  0  5  5  3  0  #		3	T			5           step5 - mark with T came from 5 (check 5 4)	both 5 4 already visited        #         marked[v] = true;                    #
	#   1        4  6  4  4  #		4	T			6           step3 - mark with T came from 6 (check 5 6 3)                               #         for (int w : G.adj(v))               #
	#   2           3  0     #		5	T			4           step4 - mark with T came from 4 (check 3 4 0)                               #             if (!marked[w]) {                #
	#   6                    #		6	T			0           step2 - mark with T came from 0 (check 0 4)                                 #                 dfs(G, w);                   #
	##########################		7	F			-                                                                                       #                 edgeTo[w] = v;               #
	                                                                                                                                        #             }                                #
	                                                                                                                                        #     }                                        #
	                                                                                                                                        # }                                            #
	                                                                                                                                        ################################################

- breadth-first search
	Algorithm																																			####################################################
	Put s onto a FIFO queue, and mark s as visited.                                                                                                     # public class BreadthFirstPaths {                 #
	Repeat until the queue is empty:                                                                                                                    #     private boolean[] marked;                    #
 	- remove the least recently added vertex v                                                                                                          #     private int[] edgeTo;                        #
 	- add each of v's unvisited neighbors to the queue,and mark them as visited.                                                                        #     …                                            #
	                                                                                                                                                    #     private void bfs(Graph G, int s) {           #
	graph						                                                                                                                        #         Queue<Integer> q = new Queue<Integer>(); #
	#######################		v	edgeTo[v]	distTo[]                                                                                                #         q.enqueue(s);                            #
	# +-----------------+ # 	0	-			0			step1 - add 0 to queue (0), deque 0, add 0`s adj`s to queue that are not marked (2 1 5)     #         marked[s] = true;                        #
	# | 0| 1| 2| 3| 4| 5| # 	1	0		    1           step1                                                                                       #         while (!q.isEmpty()) {                   #
	# +-----------------+ # 	2	0           1           step1                                                                                       #             int v = q.dequeue();                 #
	#   5  0  0  5  2  3  # 	3	2           2           step2 - deque 2, add 2`s adj`s to queue (1 5 3)                                             #             for (int w : G.adj(v)) {             #
	#   1     3  4  3  0  # 	4	2           2           step1 - add 2`s adj`s to queue (1 5 3 4)                                                    #                 if (!marked[w]) {                #
	#   2     4  2        # 	5	0           1           step1                                                                                       #                     q.enqueue(w);                #
	####################### 	                                                                                                                        #                     marked[w] = true;            #
	                                                                                                                                                    #                     edgeTo[w] = v;               #
	Depth-first search. Put unvisited vertices on a stack.                                                                                              #                 }                                #
	Breadth-first search. Put unvisited vertices on a queue                                                                                             #             }                                    #
	                                                                                                                                                    #         }                                        #
                                                                                                                                                        #     }                                            #
                                                                                                                                                        # }                                                #
                                                                                                                                                        ####################################################

- connected components																							Finding connected components with DFS 			Finding connected components with DFS
																												##############################################	######################################
	Initialize all vertices v as unmarked.                                                                      # public class CC {                          #  # public int count() {               #
	For each unmarked vertex v, run DFS to identify all vertices discovered as part of the same component.      #     private boolean[] marked;              #  #     return count;                  #
                                                                                                                #     private int[] id;                      #  # }                                  #
	##########################		v	marked[]	cc[]											            #     private int count;                     #  # public int id(int v) {             #
	#      +-+               #      0	T			0		1 visit0: check 6 2 1 5 (cc 0)                      #     public CC(Graph G) {                   #  #     return id[v];                  #
	#      |0|--\            #      1	T		    0       7 visit1: check 0 (cc 0)                            #         marked = new boolean[G.V()];       #  # }                                  #
	#      +-+-\ ---\        #      2	T           0       6 visit2: check 0 (cc 0)                            #         id = new int[G.V()];               #  # private void dfs(Graph G, int v) { #
	#     / \   --\  ---\    #      3	T           0       5 visit3: check 5 4 (cc 0)                          #         for (int v = 0; v < G.V(); v ++) { #  #     marked[v] = true;              #
	#    |   +-+   +-+   +-+ #      4	T           0       3 visit4: check 5 6 3  (cc 0)                       #             if (!marked[v]) {              #  #     id[v] = count;                 #
	#    /   |1|   |2|   |6| #      5	T           0       4 visit5: check 3 4 0 (cc 0)                        #                 dfs(G, v);                 #  #     for (int w : G.adj(v))         #
	#   |    +-+   +-+   +-+ #		6   T           0		2 visit6: check 0 4 (cc 0)                          #                 count ++;                  #  #         if (!marked[w])            #
	#   /                /   #                                                                                  #             }                              #  #             dfs(G, w);             #
	#  |      +-+     +-+    #		To visit a vertex v :	                                                    #         }                                  #  #                                    #
	#  /    /-|3|-----|4|    #      ・Mark vertex v as visited.                                                  #     }                                      #  #                                    # 
	# |   /-  +-+ /---+-+    #      ・Recursively visit all unmarked vertices adjacent to v.                     #     public int count()                     #  # }                                  # 
	# +-+-  /-----           #                                                                                  #     public int id(int v)                   #  ######################################
	# |5|---                 #                                                                                  #     private void dfs(Graph G, int v)       #
	# +-+                    #                                                                                  # }                                          #
	##########################                                                                                  ##############################################

		
- graph challenges
	P1 roblem. Is a graph bipartite?
	bipartite - whose vertices can be divided into two disjoint and independent sets U and V such that every edge connects a vertex in U to one in V.
	solution: dfs
	##########################		2 Problem. Find cycle - use dfs (0 5 4 6 0)
	#                        #		3 Problem. Bridges of Konigsberg (cycle use every edge once).Yes if all vertices have even degree
	#      +-+               #		4 Find a (general) cycle that uses every edge exactly once.
	#     u|0|--\            #		5 Find a cycle that visits every vertex exactly once. Hamiltonian cycle. hard one
	#      +-+-\ ---\        #		6 Are two graphs identical except for vertex names? graph isomorphism is longstanding open problem. hard one
	#     / \   --\  ---\    #		7 Lay out a graph in the plane without crossing edges? linear-time DFS-based planarity algorithm discovered by Tarjan in 1970s. hard one
	#    |   +-+   +-+   +-+ #
	#    /  v|1|  v|2|  v|6| #
	#   |    +-+   +-+   +-+ #
	#   /      \   /  \  /   #
	#  |        +-+   +-+    #
	#  /       u|3|  u|4|    #
	# |         +-+   +-+    #
	# +-+           /---     #
	#v|5|     /-----         #
	# +-+ ----               #
	##########################	

- directed graphs
	Digraph. Set of vertices connected pairwise by directed edges.
	
	#############################################	0->5			applications:																				############################################## 
	#      +-+<-------------      ----<----     #	0->1			Road network					Vertex = intersection; 		edge = one-way street.          # public class Diraph {                      #
	#      |0|<----\         \   /         \    #	0->5			Political blogosphere graph		Vertex = political blog; 	edge = link                     #     private final int V;                   #
	#      +-+      +-+       +-+--->+-+    +-+ #	2->0			Overnight interbank loan graph	Vertex = bank; 				edge = overnight loan.          #     private final Bag<Integer> [] adj;     #	<-- adj lists
	#     | | +-+   |2|       |6|    |8|    |7| #	2->3			Implication graph				Vertex = variable; 			edge = logical implication.     #     public Diraph(int V) {                 #
	#     /  >|1|   +-+       +-+<---+-+    +-+ #	3->5			Combinational circuit			Vertex = logical gate; 		edge = wire.                    #         this.V = V;                        #  <-- create empty Diraph with V vertices
	#    |    +-+  /> ^      /   \         /    #	3->2			WordNet graph					Vertex = synset; 			edge = hypernym relationship.   #         adj = (Bag<Integer> [])new Bag[V]; #
	#    /       < /  |     /     \       /     #	4->3			web								web page					hyperlink                       #         for (int v = 0; v < V; v ++)       #
	#   /     +-+ /   |    /       >    <-      #	5->4			scheduling						task						precedence constraint           #             adj[v] = new Bag<Integer>();   #
	#  |    /-|3|/    |   /         +-+    +--+ #	11->4			financial						bank						transaction                     #                                            #
	#  Y  /<  +-+   +-+  /          |9|--->|10| #	11->12			game							board position 				legal move                      #     }                                      #
	# +-+-          |4|<-           +-+<-\ +--+ #	12->9			citation						journal article				citation                        #     public void addEdge(int v, int w) {    #	<-- add edge v-w
	# |5|>--------->+-+              Y    \   ^ #					inheritance hierarchy			class						inherits from                   #         adj[v].add(w);                     #
	# +-+                           +--+   +--| #					control flow					code block					jump                            #                                            #
	#                               |11|---|12| #			                                                                                                    #     }                                      #
	#                               +--+   +--+ #			                                                                                                    #     public Iterable<Integer> adj(int v) {  #	<-- iterator for vertices adj to v
	#                                           #			                                                                                                    #         return adj[v];                     #
	#############################################			                                                                                                    #     }                                      #
                                                                                                                                                                # }                                          #
- Adjacency-lists digraph representation                                                                                                                        ##############################################
	#############################################
	# +--------------------------------------+  #
	# | 0| 1| 2| 3| 4| 5| 6| 7| 8| 9|10|11|12|  #
	# +--------------------------------------+  #
	#   5     0  5  3  4  9  6  6 11 12 12  9   #
	#   1     3  2  2     4  8    10            #
	#                     8                     #
	#                     0                     #
	#############################################
	
- digraph search
	Depth-first search in digraphs																										Depth-first search in digraphs summary
	##############################################	Mark v as visited.																	DFS enables direct solution of simple digraph problems.
    # public class DirectedDFS {                 #	Recursively visit all unmarked vertices w pointing from v.                          ・Reachability.
    #     private boolean[] marked;              #                                                                                      ・Path finding.
    #     public DirectedDFS(Digraph G, int s) { #	Applications:                                                                       ・Topological sort.
    #         marked = new boolean[G.V()];       #	Reachability application: program control-flow analysis:                            ・Directed cycle detection.
    #         dfs(G, s);                         #		Every program is a digraph.                                                     Basis for solving difficult digraph problems.
    #     }                                      #  	・Vertex = basic block of instructions (straight-line program).                   ・2-satisfiability. 
    #     private void dfs(Digraph G, int v) {   #  	・Edge = jump.                                                                    ・Directed Euler path. 
    #         marked[v] = true;                  #                                                                                      ・Strongly-connected components.
    #         for (int w : G.adj(v))             #	Reachability application: mark-sweep garbage collector
    #             if (!marked[w])                #		Every data structure is a digraph.
    #                 dfs(G, w);                 #      ・Vertex = object.
    #     }                                      #      ・Edge = reference.
    #     public boolean visited(int v) {        #		Roots. Objects known to be directly accessible by program (e.g., stack).
    #         return marked[v];                  #		Reachable objects. Objects indirectly accessible by program
    #     }                                      #
	# }                                          #
	##############################################

	Breadth-first search in digraphs								BFS web crawler
	Same method as for undirected graphs.							################################################## 
	Put s onto a FIFO queue, and mark s as visited.                 # Queue<String> queue = new Queue<String>();     #	<-- queue of websites to crawl
		Repeat until the queue is empty:                            # SET<String> marked = new SET<String>();        #  <-- set of marked websites
 		- remove the least recently added vertex v                  # String root = "http://www.princeton.edu";      #
 		- for each unmarked vertex pointing from v:                 # queue.enqueue(root);                           #	<-- start crawling from root website
 		add to queue and mark as visited.                           # marked.add(root);                              #
		                                                            # while (!queue.isEmpty()) {                     #
	Q. How to implement multi-source shortest paths algorithm?      #     String v = queue.dequeue();                #	<-- read in raw html from nextwebsite in queue
	A. Use BFS, but initialize by enqueuing all source vertices.    #     StdOut.println(v);                         #
	                                                                #     In in = new In(v);                         #
	                                                                #     String input = in.readAll();               #
	                                                                #     String regexp = "http://(\\w+\\.)*(\\w+)"; #	<-- use regular expression to find all URLs in website of form http://xxx.yyy.zzz
	                                                                #     Pattern pattern = Pattern.compile(regexp); #
	                                                                #     Matcher matcher = pattern.matcher(input);  #
	                                                                #     while (matcher.find()) {                   #
	                                                                #         String w = matcher.group();            #
	                                                                #         if (!marked.contains(w)) {             #	<-- if unmarked, mark it and put on the queue
	                                                                #             marked.add(w);                     #
	                                                                #             queue.enqueue(w);                  #
	                                                                #         }                                      #
	                                                                #     }                                          #
	                                                                # }                                              #
	                                                                ##################################################
	
- topological sort
	DAG. Directed acyclic graph.
	Topological sort. Redraw DAG so all edges point upwards.
	DAG											Topological sort. Redraw DAG so all edges point upwards			algorithm:								step1  visit0: check 1 2 5 	(mark 0)
	##########################	0->5			###################################################				-run dfs                                step2  visit1: check 4 		(mark 1)
	#      +-+--------\      #	0->1            #             /-------------------------->\       #				-return vertices in reverse postorder   step3  visit4: done			(mark 4)	postorder 4
	#      |0|         \     #  3->5            #            /     /--------------->\      \      #                                                     step4  visit1: done						postorder 4 1
	#    />+-+----\     \    #  5->2            #           /     //-------->\       \      \     #                                                     step5  visit2: done			(mark 2)	postorder 4 1 2
	#    |  \>     >     >   #  6->0            # +-+    +-+    +-+    +-+    +-+     +-+    +-+  #                                                     step6  visit5: done			(mark 5)	postorder 4 1 2 5
	#    |   +-+   +-+   +-+ #  1->4            # |3|--->|6|--->|0|--->|5|--->|2|     |1|--->|4|  #                                                     step7  visit0: done						postorder 4 1 2 5 0
	#    /   |2|   |5|   |1| #  0->2            # +-+    +-+    +-+    +-+    +-+     +-+    +-+  #                                                     step8  visit3: check 6		(mark 3)
	#   |    +-+  >+-+   +-+ #  3->6            # \\\\->/             /      /              /     #                                                     step9  visit6: done			(mark 6)	postorder 4 1 2 5 0 6
	#   /     ^  /         | #  3->4            #  \\\-------------->/      /              /      #                                                     step10 visit3: done						postorder 4 1 2 5 0 6 3
	#  |      +-+     +-+  / #  6->4            #   \\-------------------->/              /       #                                                     
	#  /     /|3|---->|4|</  #  3->2            #    \---------------------------------->/        #                                                     
	# |     / +-+     +-+    #                  #	                                              #                                                     
	# +-+<-/         ^       #                  ###################################################                                                     
	# |6|-----------/        #  
	# +-+                    #  
	##########################  
	
	Depth-first search order
	################################################								applications:
	# public class DepthFirstOrder {               #                                Directed cycle detection application: precedence scheduling
	#     private boolean[] marked;                #                                Directed cycle detection application: cyclic inheritance (The Java compiler does cycle detection.)
	#     private Stack<Integer> reversePost;      #                                Directed cycle detection application: spreadsheet recalculation (Microsoft Excel does cycle detection (and has a circular reference toolbar!))
	#     public DepthFirstOrder(Digraph G) {      #
	#         reversePost = new Stack<Integer>();  #
	#         marked = new boolean[G.V()];         #
	#         for (int v = 0; v < G.V(); v ++)     #
	#             if (!marked[v])                  #
	#                 dfs(G, v);                   #
	#     }                                        #
	#     private void dfs(Digraph G, int v) {     #
	#         marked[v] = true;                    #
	#         for (int w : G.adj(v))               #
	#             if (!marked[w])                  #
	#                 dfs(G, w);                   #
	#         reversePost.push(v);                 #
	#     }                                        #
	#     public Iterable<Integer> reversePost() { #
	#         return reversePost;                  #	<--returns all vertices in 
	#     }                                        #	   “reverse DFS postorder”
	# }                                            #
	################################################
	
- strong components
	Vertices v and w are strongly connected if there is both a directed path from v to w and a directed path from w to v.
	・If v is strongly connected to w, then w is strongly connected to v.
	・If v is strongly connected to w and w to x, then v is strongly connected to x.
	A strong component is a maximal subset of strongly-connected vertices.
	
	Kosaraju-Sharir algorithm: intuition								Phase 1. Compute reverse postorder in GR.
	Reverse graph. Strong components in G are same as in GR.			Phase 2. Run DFS in G, visiting unmarked vertices in reverse postorder of GR.
	Kernel DAG. Contract each strong component into a single vertex.																					reverse 1 0 2 4 5 3 11 9 12 10 6 7 8
	Idea.																phase1:																			phase2 (run dfs visiting reverse vertices)
	・Compute topological order (reverse postorder) in kernel DAG.		step1  visit0: 	check 6 2  	(mark 0)                                            step1  visit1: 	done	  	(scc 0)
	・Run DFS, considering vertices in reverse topological order.       	step2  visit6: 	check 8 7	(mark 6)                                            step2  visit0: 	check 5		(scc 1)
	#############################################			            step3  visit8: 	done		(mark 8)	reverse 8                               step3  visit5: 	check 4		(scc 1)
	#      +-+------->------      ---->----     #			            step4  visit6: 	check 7                                                         step4  visit4: 	check 3 2	(scc 1)
	#   /->|0|----\         \    /         \    #			            step5  visit7: 	done		(mark 7)	reverse 7 8                             step5  visit3:	check 5 2	(scc 1)
	#  |   +-+     >+-+      >+-+--->+-+    +-+ #			            step5,5visit6: 	done					reverse 6 7 8                           step6  visit2: 	check 0		(scc 1)
	#  |    | +-+   |2|       |6|    |8|    |7| #			            step6  visit2: 	check 4 3	(mark 2)                                            step6  visit2: 	done
	#  |     <|1|   +-+     />+-+<---+-+  />+-+ #			            step7  visit4:  check 11 6 5(mark 4)                                            step7  visit3:  done
	#  |      +-+  /> |    /     ^       /      #			            step8  visit11: check 9		(mark 11)                                           step8  visit4:  done
	#  |         <//  |   /       \     /       #			            step9  visit9:	check 12 7 6(mark 9)                                            step9  visit5:	done
	#  |      +-+ /   |  /         \   /        #			            step10 visit12: check 10 11	(mark 12)                                           step10 visit0:  done
	#  |   /->|3|/    Y /           +-+    +--+ #			            step11 visit10:	done	  	(mark 10)	reverse 10 6 7 8                        step11 visit11:	check 4 12	(scc 2)
	#  |  /   +-+\->+-+/            |9|<---|10| #			            step12 visit12:	done					reverse 12 10 6 7 8                     step12 visit12:	check 9		(scc 2)
	# +-+-          |4|             +-+\   +--+ #			            step13 visit9: 	done					reverse 9 12 10 6 7 8                   step13 visit9: 	check 10 11	(scc 2)
	# |5|<--------- +-+\             ^  \     ^ #			            step14 visit11:	done					reverse 11 9 12 10 6 7 8                step14 visit10:	check 12	(scc 2)
	# +-+               \           +--+ \>+--| #			            step15 visit4:	check 5                                                         step15 visit10:	done
	#                    \--------->|11|<--|12| #			            step16 visit5: 	check 3 0	(mark 5)                                            step16 visit9: 	done
	#                               +--+   +--+ #			            step17 visit3: 	done		(mark 3)	reverse 3 11 9 12 10 6 7 8              step17 visit12: done
	#                                           #			            step18 visit5: 	done					reverse 5 3 11 9 12 10 6 7 8            step18 visit11: done
	#############################################			            step19 visit4: 	done					reverse 4 5 3 11 9 12 10 6 7 8          step19 visit6: 	check 8		(scc 3)
	                                                                    step20 visit2: 	done					reverse 2 4 5 3 11 9 12 10 6 7 8        step20 visit8: 	check 6		(scc 3)
																		step21 visit0: 	done					reverse 0 2 4 5 3 11 9 12 10 6 7 8      step21 visit8: 	done
																		step22 visit1: 	done					reverse 1 0 2 4 5 3 11 9 12 10 6 7 8    step22 visit6: 	done
																																						step23 visit 7: done		(scc 4)
	Strong components in a digraph (with two DFSs)
	####################################################################
	# public class KosarajuSharirSCC {                                 #
	#     private boolean marked[];                                    #
	#     private int[] id;                                            #
	#     private int count;                                           #
	#     public KosarajuSharirSCC(Digraph G) {                        #
	#         marked = new boolean[G.V()];                             #
	#         id = new int[G.V()];                                     #
	#         DepthFirstOrder dfs = new DepthFirstOrder(G.reverse());  #
	#         for (int v : dfs.reversePost()) {                        #
	#             if (!marked[v]) {                                    #
	#                 dfs(G, v);                                       #
	#                 count ++;                                        #
	#             }                                                    #
	#         }                                                        #
	#     }                                                            #
	#     private void dfs(Digraph G, int v) {                         #
	#         marked[v] = true;                                        #
	#         id[v] = count;                                           #
	#         for (int w : G.adj(v))                                   #
	#             if (!marked[w])                                      #
	#                 dfs(G, w);                                       #
	#     }                                                            #
	#     public boolean stronglyConnected(int v, int w) {             #
	#         return id[v] == id[w];                                   #
	#     }                                                            #
	# }                                                                #
	#                                                                  #
	####################################################################
	
	
	
	


###############
# week2
###############

- MSTs
	A spanning tree of G is a subgraph T that is both a tree (connected and acyclic) 
	and spanning (includes all of the vertices).													
	###############################################################################		MST is fundamental problem with diverse applications.
    #                                          0.29                               #     ・Dithering.									 ・Find road networks in satellite and aerial imagery.
    #                                  ┌·················┐                        #     ・Cluster analysis.                           ・Reducing data storage in sequencing amino acids in a protein. 
    #                                  :                 :                        #     ・Max bottleneck paths.                       ・Model locality of particle interactions in turbulent fluid flows. 
    #              ╔═══════╗  0.32   ╔═══════╗         ╔═══════╗                  #     ・Real-time face verification.                ・Autoconfig protocol for Ethernet bridging to avoid cycles in a network. 
    #           ┌─ ║   5   ║ ······· ║   1   ║ ·┐      ║   3   ║ ···············┐ #     ・LDPC codes for error correction.            ・Approximation algorithms for NP-hard problems (e.g., TSP, Steiner tree).
    #           │  ╚═══════╝         ╚═══════╝  :      ╚═══════╝                : #     ・Image registration with Renyi entropy.      ・Network design (communication, electrical, hydraulic, computer, road). 
    #           │    │                 │        :        │                      : #
    #           │    │ 0.28            │ 0.19   : 0.36   │ 0.17                 : #
    #           │    │                 │        :        │                      : #
    #           │    │      ╔═══════╗  │        :      ╔═══════╗                : #
    #           │    └───── ║       ║ ─┘        └····· ║       ║                : #
    #           │           ║       ║                  ║       ║                : #
    #           │           ║       ║          0.34    ║       ║                : #
    #           │           ║   7   ║ ················ ║   2   ║                : #
    #           │           ║       ║                  ║       ║                : #
    #           │           ║       ║          0.26    ║       ║                : #
    #  ┌········┼·········· ║       ║  ┌────────────── ║       ║ ──────┐        : #
    #  :        │           ╚═══════╝  │               ╚═══════╝       │        : #
    #  :        │             │      ╔═══════╗  0.58                   │        : #
    #  : 0.37   │             └───── ║   0   ║ ···················┐    │ 0.40   : #
    #  :        │                    ╚═══════╝                    :    │        : #
    #  :      ╔═══╗  0.93              :                        ╔═══╗  │        : #
    #  └····· ║ 4 ║ ···················┼······················· ║ 6 ║ ─┘        : #
    #         ╚═══╝                    :                        ╚═══╝           : #
    #           :   0.38               :                          :   0.52      : #
    #           └······················┘                          └·············┘ #
    #                                                                             #
    ###############################################################################


- Greedy algorithms
	Greedy MST																			cut graph into 2 partition [0 1 4 5 7] and [2 3 6]									divide graph into 2 partition [5] and [1 7 4 ...]													
	・Start with all edges colored gray.													find cut between 2 partitions with min weight and paint it black					find cut between 2 partitions with min weight and paint it black									
	・Find cut with no black crossing edges; color its min-weight edge black.			min cut is 0 2 among ([1 3],[0 2],[2 7],[1 2],[6 9],[6 4])							min cut is 5 7 
	・Repeat until V - 1 edges are colored black.										MST 0 2,														                    MST [0 2], [5 7]
	###############################################################################		###############################################################################		###############################################################################
    #                                          0.29                               #     #                                          0.29                               #     #                                          0.29                               #
    #                                  ┌·················┐                        #     #                                  ┌·················┐                        #     #                                  ┌·················┐                        #
    #                                  :                 :                        #     #                                  :                 :                        #     #                                  :                 :                        #
    #              ┌───────┐  0.32   ┌───────┐         ┌───────┐                  #     #              ╔═══════╗  0.32   ╔═══════╗         ┌───────┐                  #     #              ╔═══════╗  0.32   ┌───────┐         ┌───────┐                  #
    #           ┌· │   5   │ ······· │   1   │ ·┐      │   3   │ ···············┐ #     #           ┌· ║   5   ║ ······· ║   1   ║ ·┐      │   3   │ ···············┐ #     #           ┌· ║   5   ║ ······· │   1   │ ·┐      │   3   │ ···············┐ #
    #           :  └───────┘         └───────┘  :      └───────┘                : #     #           :  ╚═══════╝         ╚═══════╝  :      └───────┘                : #     #           :  ╚═══════╝         └───────┘  :      └───────┘                : #
    #           :    :                 :        :        :                      : #     #           :    :                 :        :        :                      : #     #           :    │                 :        :        :                      : #
    #           :    : 0.28            : 0.19   : 0.36   : 0.17                 : #     #           :    : 0.28            : 0.19   : 0.36   : 0.17                 : #     #           :    │ 0.28            : 0.19   : 0.36   : 0.17                 : #
    #           :    :                 :        :        :                      : #     #           :    :                 :        :        :                      : #     #           :    │                 :        :        :                      : #
    #           :    :      ┌───────┐  :        :      ┌───────┐                : #     #           :    :      ╔═══════╗  :        :      ┌───────┐                : #     #           :    │      ╔═══════╗  :        :      ╔═══════╗                : #
    #           :    └····· │       │ ·┘        └····· │       │                : #     #           :    └····· ║       ║ ·┘        └····· │       │                : #     #           :    └───── ║       ║ ·┘        └····· ║       ║                : #
    #           :           │       │                  │       │                : #     #           :           ║       ║                  │       │                : #     #           :           ║       ║                  ║       ║                : #
    #           :           │       │          0.34    │       │                : #     #           :           ║       ║          0.34    │       │                : #     #           :           ║       ║          0.34    ║       ║                : #
    #           :           │   7   │ ················ │   2   │                : #     #           :           ║   7   ║ ················ │   2   │                : #     #           :           ║   7   ║ ················ ║   2   ║                : #
    #           :           │       │                  │       │                : #     #           :           ║       ║                  │       │                : #     #           :           ║       ║                  ║       ║                : #
    #           :           │       │          0.26    │       │                : #     #           :           ║       ║          0.26    │       │                : #     #           :           ║       ║          0.26    ║       ║                : #
    #  ┌········┼·········· │       │  ┌·············· │       │ ······┐        : #     #  ┌········┼·········· ║       ║  ┌────────────── │       │ ······┐        : #     #  ┌········┼·········· ║       ║  ┌────────────── ║       ║ ······┐        : #
    #  :        :           └───────┘  :               └───────┘       :        : #     #  :        :           ╚═══════╝  │               └───────┘       :        : #     #  :        :           ╚═══════╝  │               ╚═══════╝       :        : #
    #  :        :             :      ┌───────┐  0.58                   :        : #     #  :        :             :      ╔═══════╗  0.58                   :        : #     #  :        :             :      ╔═══════╗  0.58                   :        : #
    #  : 0.37   :             └····· │   0   │ ···················┐    : 0.40   : #     #  : 0.37   :             └····· ║   0   ║ ···················┐    : 0.40   : #     #  : 0.37   :             └····· ║   0   ║ ···················┐    : 0.40   : #
    #  :        :                    └───────┘                    :    :        : #     #  :        :                    ╚═══════╝                    :    :        : #     #  :        :                    ╚═══════╝                    :    :        : #
    #  :      ┌───┐  0.93              :                        ┌───┐  :        : #     #  :      ╔═══╗  0.93              :                        ┌───┐  :        : #     #  :      ┌───┐  0.93              :                        ┌───┐  :        : #
    #  └····· │ 4 │ ···················┼······················· │ 6 │ ·┘        : #     #  └····· ║ 4 ║ ···················┼······················· │ 6 │ ·┘        : #     #  └····· │ 4 │ ···················┼······················· │ 6 │ ·┘        : #
    #         └───┘                    :                        └───┘           : #     #         ╚═══╝                    :                        └───┘           : #     #         └───┘                    :                        └───┘           : #
    #           :   0.38               :                          :   0.52      : #     #           :   0.38               :                          :   0.52      : #     #           :   0.38               :                          :   0.52      : #
    #           └······················┘                          └·············┘ #     #           └······················┘                          └·············┘ #     #           └······················┘                          └·············┘ #
    #                                                                             #     #                                                                             #     #                                                                             #
    ###############################################################################     ###############################################################################     ###############################################################################

	divide graph into 2 partition [6] and [3 2 0 4...]
	MST [0 2], [5 7], [6 2]
	divide graph into 2 partition [5 7 1 3] and [4 0 2 6]
	MST [0 2], [5 7], [6 2], [7 0]
	divide graph into 2 partition [5 7 0 2 6 4] and [1 3]
	MST [0 2], [5 7], [6 2], [7 0], [3 2]
	divide graph into 2 partition [5 7 0 2 6 3] and [1 4]
	MST [0 2], [5 7], [6 2], [7 0], [3 2], [1 7]
	divide graph into 2 partition [5 7 0 2 6 3 1] and [4]
	MST [0 2], [5 7], [6 2], [7 0], [3 2], [1 7], [4 5]	

- Edge-Weighed Graph API
	Add Edge class																		Edge-weighted graph
	####################################################   either			other		###########################################
	# public class Edge implements Comparable<Edge> {  #	+-+    weight    +-+        # public class EdgeWeightedGraph {        #
	#     private final int v,                         #    |v|--------------|w|        #     private final int V;                #
	#     w;                                           #    +-+              +-+        #     private final Bag<Edge> [] adj;     #
	#     private final double weight;                 #                                #     public EdgeWeightedGraph(int V) {   #
	#     public Edge(int v, int w, double weight) {   #                                #         this.V = V;                     #
	#         this.v = v;                              #                                #         adj = (Bag<Edge> [])new Bag[V]; #
	#         this.w = w;                              #                                #         for (int v = 0; v < V; v ++)    #
	#         this.weight = weight;                    #                                #             adj[v] = new Bag<Edge>();   #
	#     }                                            #                                #     }                                   #
	#     public int either() {                        #                                #     public void addEdge(Edge e) {       #
	#         return v;                                #	<-- either endpoint         #         int v = e.either(),             #
	#     }                                            #                                #         w = e.other(v);                 #
	#     public int other(int vertex) {               #	<-- other endpoint          #         adj[v].add(e);                  #
	#         if (vertex == v)                         #                                #         adj[w].add(e);                  #
	#             return w;                            #                                #     }                                   #
	#          else                                    #                                #     public Iterable<Edge> adj(int v) {  #
	#             return v;                            #                                #         return adj[v];                  #
	#     }                                            #                                #     }                                   #
	#     public int compareTo(Edge that) {            #                                # }                                       #
	#         if (this.weight < that.weight)           #                                ###########################################
	#             return -1;                           #
	#          else if (this.weight > that.weight)     #
	#             return + 1;                          #
	#          else                                    #
	#             return 0;                            #
	#     }                                            #
	# }                                                #
	####################################################
	
- Kruskal's Algorithm
	Consider edges in ascending order of weight.
	・Add next edge to tree T unless doing so would create a cycle.						sorted wights												Kruskal's Algorithm
	###############################################################################		0-7 0.16			step1  no cycle - add					#############################################################
	#                                          0.29!(6)                           #		2-3 0.17            step2  no cycle - add                   # public class KruskalMST {                                 #
	#                                  ┌·················┐                        #		1-7 0.19            step3  no cycle - add                   #     private Queue<Edge> mst = new Queue<Edge>();          #
	#                                  :                 :                        #		0-2 0.26            step4  no cycle - add                   #     public KruskalMST(EdgeWeightedGraph G) {              #
	#              ╔═══════╗0.32!(7) ╔═══════╗         ╔═══════╗                  #		5-7 0.28            step5  no cycle - add                   #         MinPQ<Edge> pq = new MinPQ<Edge>();               #  <-- build priority queue
	#           ┌─ ║   5   ║ ······· ║   1   ║ ·┐      ║   3   ║ ···············┐ #		1-3 0.29            step6  cycle - no add                   #         for (Edge e : G.edges())                          #
	#           │  ╚═══════╝         ╚═══════╝  :      ╚═══════╝                : #		1-5 0.32            step7  cycle - no add                   #             pq.insert(e);                                 #
	#           │    │                 │        :        │                      : #		2-7 0.34            step8  cycle - no add                   #                                                           #
	#           │    │0.28(4)          │0.19(3) :0.36!10 │ 0.17(2)              : #		4-5 0.35            step9  no cycle - add                   #         UF uf = new UF(G.V());                            #
	#           │    │                 │        :        │                      : #		1-2 0.36            step10 cycle - no add                   #         while (!pq.isEmpty() && mst.size() < G.V() - 1) { #
	#           │    │      ╔═══════╗  │        :      ╔═══════╗                : #		4-7 0.37            step11 cycle - no add                   #             Edge e = pq.delMin();                         #
	#           │    └───── ║       ║ ─┘        └····· ║       ║                : #		0-4 0.38            step12 cycle - no add                   #             int v = e.either(),                           #  <-- greedily add edges to MST
	#           │           ║       ║                  ║       ║                : #		6-2 0.40            step13 no cycle - add	MST is ready    #             w = e.other(v);                               #
	#           │0.35(9)    ║       ║      0.34!(8)    ║       ║                : #		3-6 0.52                                                    #             if (!uf.connected(v, w)) {                    #  <-- edge v-w does not create a cycle
	#           │           ║   7   ║ ················ ║   2   ║                : #		6-0 0.58                                                    #                 uf.union(v, w);                           #  <-- merge sets
	#           │           ║       ║                  ║       ║                : #		6-4 0.93                                                    #                 mst.enqueue(e);                           #  <-- add edges to MST
	#           │           ║       ║       0.26(4)    ║       ║                : #                                                                 #             }                                             #
	#  ┌········┼·········· ║       ║  ┌────────────── ║       ║ ──────┐        : #                                                                 #         }                                                 #
	#  :        │           ╚═══════╝  │               ╚═══════╝       │        : #                                                                 #     }                                                     #
	#  :        │             │      ╔═══════╗  0.58                   │        : #                                                                 #     public Iterable<Edge> edges() {                       #
	#  :0.37!11 │             └───── ║   0   ║ ···················┐    │0.40(13): #                                                                 #         return mst;                                       #
	#  :        │            0.16(1) ╚═══════╝                    :    │        : #                                                                 #     }                                                     #
	#  :      ╔═══╗  0.93              :                        ╔═══╗  │        : #                                                                 # }                                                         #
	#  └····· ║ 4 ║ ···················┼······················· ║ 6 ║ ─┘        : #                                                                 #############################################################
	#         ╚═══╝                    :                        ╚═══╝           : #
	#           :   0.38!12            :                          :   0.52      : #
	#           └······················┘                          └·············┘ #
	#                                                                             #
	###############################################################################	
	
- Prim's Algorithm
	・Start with vertex 0 and greedily grow tree T.
	・Add to T the min weight edge with exactly one endpoint in T.
	・Repeat until V - 1 edges.																						min-PQ		MST
	###############################################################################		add edges of 0 to min PQ	0-7			0-7
	#                                          0.29                               #     add edges of 7 to min PQ	1-7			0-7 1-7
	#                                  ┌·················┐                        #     add edges of 1 to min PQ	0-2			0-7 1-7 0-2
	#                                  :                 :                        #     add edges of 2 to min PQ	2-3			0-7 1-7 0-2 2-3
	#              ╔═══════╗0.32     ╔═══════╗         ╔═══════╗                  #     add edges of 3 to min PQ	5-7			0-7 1-7 0-2 2-3 5-7
	#           ┌─ ║   5   ║ ······· ║   1   ║ ·┐      ║   3   ║ ···············┐ #     add edges of 5 to min PQ	5-4			0-7 1-7 0-2 2-3 5-7 5-4
	#           │  ╚═══════╝         ╚═══════╝  :      ╚═══════╝                : #     add edges of 4 to min PQ	6-2			0-7 1-7 0-2 2-3 5-7 5-4 6-2
	#           │    │                 │        :        │                      : #     
	#           │    │0.28(5)          │0.19(2) :0.36    │ 0.17(4)              : #     #############################################################
	#           │    │                 │        :        │                      : #     # public class LazyPrimMST {                                #
	#           │    │      ╔═══════╗  │        :      ╔═══════╗                : #     #     private boolean[] marked; 	// MST vertices         #
	#           │    └───── ║       ║ ─┘        └····· ║       ║                : #     #     private Queue<Edge> mst; 		// MST edges            #
	#           │           ║       ║                  ║       ║                : #     #     private MinPQ<Edge> pq; 		// PQ of edges          #
	#           │0.35(6)    ║       ║      0.34        ║       ║                : #     #     public LazyPrimMST(WeightedGraph G) {                 #
	#           │           ║   7   ║ ················ ║   2   ║                : #     #         pq = new MinPQ<Edge>();                           #
	#           │           ║       ║                  ║       ║                : #     #         mst = new Queue<Edge>();                          #
	#           │           ║       ║       0.26(3)    ║       ║                : #     #         marked = new boolean[G.V()];                      #
	#  ┌········┼·········· ║       ║  ┌────────────── ║       ║ ──────┐        : #     #         visit(G, 0);                                      #  <-- assume G is connected
	#  :        │           ╚═══════╝  │               ╚═══════╝       │        : #     #         while (!pq.isEmpty() && mst.size() < G.V() - 1) { #
	#  :        │             │      ╔═══════╗  0.58                   │        : #     #             Edge e = pq.delMin();                         #  <-- repeatedly delete the min weight edge e = v–w from PQ
	#  :0.37    │             └───── ║   0   ║ ···················┐    │0.40(7  : #     #             int v = e.either(),                           #
	#  :        │            0.16(1) ╚═══════╝                    :    │        : #     #             w = e.other(v);                               #
	#  :      ╔═══╗  0.93              :                        ╔═══╗  │        : #     #             if (marked[v] && marked[w]) continue;         #  <-- ignore if both endpoints in T
	#  └····· ║ 4 ║ ···················┼······················· ║ 6 ║ ─┘        : #     #                                                           #
	#         ╚═══╝                    :                        ╚═══╝           : #     #             mst.enqueue(e);                               #  <-- add edge e to tree
	#           :   0.38               :                          :   0.52      : #     #             if (!marked[v]) visit(G, v);                  #  <-- add v or w to tree
	#           └······················┘                          └·············┘ #     #             if (!marked[w]) visit(G, w);                  #
	#                                                                             #     #         }                                                 #
	###############################################################################     #     }                                                     #
                                                                                        #     private void visit(WeightedGraph G, int v) {          #
                                                                                        #         marked[v] = true;                                 #  <-- add v to T
                                                                                        #         for (Edge e : G.adj(v))                           #
                                                                                        #             if (!marked[e.other(v)])                      #
                                                                                        #                 pq.insert(e);                             #  <-- for each edge e = v–w, add to PQ if w not already in T
                                                                                        #     }                                                     #
                                                                                        #     public Iterable<Edge> mst() {return mst;}             #
                                                                                        # }                                                         #
                                                                                        #############################################################

- Prim's Algorithm (eager)
	step1: MST 0-7					step2: MST 0-7 1-7			step3: MST 0-7 1-7 0-2
	add vertices 7 2 4 6 to PQ      add vertices 1 5 to PQ      add vertices 3 to PQ
	v 	edgeTo[] 	distTo[]        v 	edgeTo[] 	distTo[]    v 	edgeTo[] 	distTo[]
	0 	- 			-               0 	- 			-           0 	- 			-
	7 	0–7 		0.16            *1 	1–7 		0.19        2 	0–2 		0.26
	2 	0–2 		0.26            2 	0–2 		0.26        5	5-7			0.28
	4 	0–4 		0.38            *5	5-7			0.28        3	1-3			0.29
	6 	6–0 		0.58            4 	0–4 		0.38        4 	0–4 		0.38
                                    6 	6–0 		0.58        6 	6–0 		0.58 
                                    not adding 7-4 7-2          not adding 3-6 3-2

- Shortest Paths APIs																		DirectedEdge													representation
	#################################################################################		###########################################################		###############################		###################################################
	#  ┌·········································································┐  #       # public class DirectedEdge {                             #     # +-+    +--------++--------+ #     # public class EdgeWeightedDigraph {              #
	#  :                                                                         :  #       #     private final int v,                                #     # |0|--->|0-2 0.26||0-4 0.38| #     #     private final int V;                        #
	#  :            0.35    ┌───────┐  0.32   ┌───┐  0.29   ┌───┐  0.52          :  #       #     w;                                                  #     # +-+    +--------++--------+ #     #     private final Bag<DirectedEdge> [] adj;     #
	#  :        ┌··········>│   5   │ ······> │ 1 │ ······> │ 3 │ ··········┐    :  #       #     private final double weight;                        #     # |1|--->...                  #     #     public EdgeWeightedDigraph(int V) {         #
	#  :        :           └───────┘         └───┘         └───┘           :    :  #       #     public DirectedEdge(int v, int w, double weight) {  #     # +-+                         #     #         this.V = V;                             #
	#  : 0.93   :             ∧                         	  ∧         	:    :  #       #         this.v = v;                                     #     # |2|--->...                  #     #         adj = (Bag<DirectedEdge> [])new Bag[V]; #
	#  :        :             : 0.28                          :             :    :  #       #         this.w = w;                                     #     # +-+                         #     #         for (int v = 0; v < V; v ++)            #
	#  :        ∨       	  ∨                 	          :             :    :  #       #         this.weight = weight;                           #     ###############################     #             adj[v] = new Bag<DirectedEdge>();   #
	#  :      ┌───┐  0.37   ┌───────┐  0.39                   :             :    :  #       #     }                                                   #                                         #     }                                           #
	#  └····> │ 4 │ ······> │   7   │ ························┘             :    :  #       #     public int from() {                                 #                                         #     public void addEdge(DirectedEdge e) {       #
	#         └───┘         └───────┘                                       :    :  #       #         return v;                                       #                                         #         int v = e.from();                       #  <-- add edgle e=b-w to
    #           ∧          	  ∧                                        	    :    :  #       #     }                                                   #                                         #         adj[v].add(e);                          #      only v`s adj list
    #           :             : 0.34                                        :    :  #       #     public int to() {                                   #                                         #     }                                           #
    #           :             :                                             ∨	 :  #       #         return w;                                       #                                         #     public Iterable<DirectedEdge> adj(int v) {  #
    #           :           ┌───────┐                             0.40    ┌───┐  :  #       #     }                                                   #                                         #         return adj[v];                          #
    #           :           │   2   │ <·································· │ 6 │ ·┘  #       #     public int weight() {                               #                                         #     }                                           #
    #           :           └───────┘                                     └───┘     #       #         return weight;                                  #                                         # }                                               #
    #           :             ∧                                         	:       #       #     }                                                   #                                         ###################################################
    #           :             : 0.26                                        :       #       # }                                                       #
    #           :             :                                             :       #       ###########################################################
    #           :   0.38    ┌───────┐          0.58                         :       #
    #           └·········· │   0   │ <·····································┘       #
    #                       └───────┘                                               #
    #################################################################################
    
	Find the shortest path from s to every other vertex.	#########################################################################
		edgeTo[]	distTo[]                                # public double distTo(int v) {                                         #
     0 	null 		0                                       #     return distTo[v];                                                 #
     1 	5->1 0.32 	1.05                                    # }                                                                     #
     2 	0->2 0.26 	0.26                                    # public Iterable<DirectedEdge> pathTo(int v) {                         #
     3 	7->3 0.37 	0.97                                    #     Stack<DirectedEdge> path = new Stack<DirectedEdge>();             #
     4 	0->4 0.38 	0.38                                    #     for (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.from()]) #
     5 	4->5 0.35 	0.73                                    #         path.push(e);                                                 #
     6 	3->6 0.52 	1.49                                    #     return path;                                                      #
     7  2->7 0.34   0.60                                    # }                                                                     #
                                                            #########################################################################

	Edge relaxation
	Relax edge e = v→w.																		#################################################
	・ distTo[v] is length of shortest known path from s to v.                               # private void relax(DirectedEdge e) {          # 
	・ distTo[w] is length of shortest known path from s to w.                               #     int v = e.from(),                         # 
	・ edgeTo[w] is last edge on shortest known path from s to w.                            #     w = e.to();                               # 
	・If e = v→w gives shorter path to w through v, update both distTo[w] and edgeTo[w].     #     if (distTo[w] > distTo[v] + e.weight()) { # 
                                                                                            #         distTo[w] = distTo[v] + e.weight();   #
                                                                                            #         edgeTo[w] = e;                        #
                                                                                            #     }                                         #
                                                                                            # }                                             #
                                                                                            #################################################

	Optimality conditions
	distTo array represents shortest path distances from source if nelow 2 conditions hold
	・For each vertex v, distTo[v] is the length of some path from s to v.
	・For each edge e = v→w, distTo[w] ≤ distTo[v] + e.weight().
	Proof
	・Suppose that distTo[w] > distTo[v] + e.weight() for some edge e = v→w.
	・Then, e gives a path from s to w (through v) of length less than distTo[w].	

	Generic shortest-paths algorithm
	Generic algorithm (to compute SPT from s)
	Initialize distTo[s] = 0 and distTo[v] = ∞ for all other vertices.
	Repeat until optimality conditions are satisfied:
		- Relax any edge.


- Dijkstra's Algorithm
	・Consider vertices in increasing order of distance from s
	(non-tree vertex with the lowest distTo[] value).
	・Add vertex to tree and relax all edges pointing from that vertex.				SPT
	############################################################################	###########################################################################		########################################################	#################################################
    #  					      ╔════╗        15    ╔════╗                       #    #                         ╔════╗        15    ╔════╗                      #     #public class DijkstraSP {                             #    # private void relax(DirectedEdge e) {          #
    #                         ║    ║ ···········> ║ 3  ║ ········┐             #    #                         ║    ║ ···········> ║ 3  ║ ········┐            #     #    private DirectedEdge[] edgeTo;                    #    #     int v = e.from(),                         #
    #                         ║ 1  ║              ╚════╝         :             #    #                         ║ 1  ║              ╚════╝         :            #     #    private double[] distTo;                          #    #     w = e.to();                               #
    # ╔══════════╗       5    ║    ║  12            ∧        	 :             #    # ╔══════════╗       5    ║    ║  12            ∧            :            #     #    private IndexMinPQ<Double> pq;                    #    #     if (distTo[w] > distTo[v] + e.weight()) { #
    # ║    0     ║ ·········> ║    ║ ········┐      : 3          :             #    # ║    0     ║ ─────────> ║    ║ ········┐      │ 3          :            #     #    public DijkstraSP(EdgeWeightedDigraph G, int s) { #    #         distTo[w] = distTo[v] + e.weight();   #
    # ╚══════════╝            ╚════╝         :      :            :             #    # ╚══════════╝            ╚════╝         :      │            :            #     #        edgeTo = new DirectedEdge[G.V()];             #    #         edgeTo[w] = e;                        #
    #   :     :                 :            :    ╔════╗         :             #    #   │     │                 :            :    ╔════╗         :            #     #        distTo = new double[G.V()];                   #    #         if (pq.contains(w))                   #
    #   :     : 8               : 4          └··> ║    ║         :             #    #   │     │ 8               : 4          └··> ║    ║         :            #     #        pq = new IndexMinPQ<Double>(G.V());           #    #             pq.decreaseKey(w, distTo[w]);     #
    #   :     :                 ∨	              ║    ║         :             #    #   │     │                 ∨             	  ║    ║         :            #     #        for (int v = 0; v < G.V(); v ++)              #    #          else                                 #
    #   :     :   ╔════════════════╗        7     ║    ║         :             #    #   │     │   ╔════════════════╗        7     ║    ║         :            #     #            distTo[v] = Double.POSITIVE_INFINITY;     #    #             pq.insert(w, distTo[w]);          #
    #   : 9   └·> ║                ║ ···········> ║ 2  ║         : 9           #    #   │ 9   └─> ║                ║ ···········> ║ 2  ║         : 9          #     #        distTo[s] = 0.0;                              #    #      }                                        #
    #   ∨     	  ║       7        ║              ║    ║         ∨         	   #    #   ∨     	  ║       7        ║              ║    ║         ∨            #     #        pq.insert(s, 0.0);                            #    # }                                             #
    # ╔════╗  5   ║                ║              ║    ║  11   ╔════════════╗  #    # ╔════╗  5   ║                ║              ║    ║  11   ╔════════════╗ #     #        while (!pq.isEmpty()) {                       #    #################################################
    # ║    ║ ···> ║                ║              ║    ║ ····> ║     6      ║  #    # ║    ║ ···> ║                ║              ║    ║ ────> ║     6      ║ #     #            int v = pq.delMin();                      #
    # ║    ║      ╚════════════════╝              ╚════╝       ╚════════════╝  #    # ║    ║      ╚════════════════╝              ╚════╝       ╚════════════╝ #     #            for (DirectedEdge e : G.adj(v))           #
    # ║    ║        :                               ∧        	 ∧      ∧  	   #    # ║    ║        :                               ∧        	 ∧  	∧ 	  #     #                relax(e);                             #
    # ║ 4  ║        : 6                             : 1          : 20   : 13   #    # ║ 4  ║        : 6                             │ 1          : 20   : 13  #     #        }                                             #
    # ║    ║        ∨                            	:        	 :      :      #    # ║    ║        ∨                           	│            :      :     #     #    }                                                 #
    # ║    ║  4   ╔════╗                            :            :      :      #    # ║    ║  4   ╔════╗                            │            :      :     #     #}                                                     #
    # ║    ║ ···> ║    ║ ···························┘            :      :      #    # ║    ║ ───> ║    ║ ───────────────────────────┘            :      :     #     ########################################################
    # ╚════╝      ║ 5  ║                                         :      :      #    # ╚════╝      ║ 5  ║                                         :      :     #
    #   :         ║    ║                                         :      :      #    #   :         ║    ║                                         :      :     #
    #   :         ║    ║ ········································┼······┘      #    #   :         ║    ║ ········································┼······┘     #
    #   :         ╚════╝                                         :             #    #   :         ╚════╝                                         :            #
    #   :                                                        :             #    #   :                                                        :            #
	#   └························································┘             #    #   └························································┘            #
    ############################################################################    ###########################################################################

	step1						| step2							| step3							| step4							| step5							| step6							| step7
	- add 0 to SPT as closest   | - add 1 to SPT as closest     | - add 7 to SPT as closest     | - add 4 to SPT as closest     | - add 5 to SPT as closest     | - add 2 to SPT as closest     | - add 3 to SPT as closest
	- relax all edges from 0    | - relax all edges from 1      | - relax all edges from 7      | - relax all edges from 4      | - relax all edges from 5      | - relax all edges from 2      | - relax all edges from 3
	v 	distTo[] 	edgeTo[]    | v 	distTo[] 	edgeTo[]    | v 	distTo[] 	edgeTo[]    | v 	distTo[] 	edgeTo[]    | v 	distTo[] 	edgeTo[]    | v 	distTo[] 	edgeTo[]    | v 	distTo[] 	edgeTo[]
	0# 	0.0 		-		    | 0# 	0.0 		-           | 0# 	0.0 		-           | 0# 	0.0 		-           | 0# 	0.0 		-           | 0# 	0.0 		-           | 0# 	0.0 		-
	1* 	5.0 		0-1         | 1# 	5.0 		0-1         | 1# 	5.0 		0-1         | 1# 	5.0 		0-1         | 1# 	5.0 		0-1         | 1# 	5.0 		0-1         | 1# 	5.0 		0-1
	2 	                        | 2*	17.0		1-2 	    | 2*	15.0		7-2(change) | 2		15.0		7-2	        | 2*	14.0		5-2(change) | 2#	14.0		5-2         | 2#	14.0		5-2
	3 	                        | 3*	20.0		1-3 	    | 3		20.0		1-3 	    | 3		20.0		1-3 	    | 3		20.0		1-3 	    | 3*	17.0		2-3(change) | 3#	17.0		2-3	
	4* 	9.0 		0-4         | 4 	9.0 		0-4         | 4 	9.0 		0-4         | 4# 	9.0 		0-4         | 4# 	9.0 		0-4         | 4# 	9.0 		0-4         | 4# 	9.0 		0-4
	5 	                        | 5 	                        | 5*	14.0		7-5 	    | 5*	13.0		4-5(change) | 5#	13.0		4-5         | 5#	13.0		4-5         | 5#	13.0		4-5
	6 	                        | 6 	                        | 6 	                        | 6*	29.0		4-6 	    | 6*	26.0		5-6(change)	| 6*	25.0		2-6(change) | 6*	25.0		2-6(same)
	7* 	8.0 		0-7         | 7* 	8.0 		0-7 (same)  | 7# 	8.0 		0-7         | 7#* 	8.0 		0-7         | 7# 	8.0 		0-7         | 7# 	8.0 		0-7         | 7# 	8.0 		0-7


- Edge-Weighted DAGs
	It is easier to find shortest path in edge wighted graph without directed cycles then in general graph
	・Consider vertices in topological order.
	・Relax all edges pointing from that vertex.
	############################################################################	Algorithm
    #  					      ╔════╗        15    ╔════╗                       #	consider vertices in topologocal order
    #                         ║    ║ ···········> ║ 3  ║ ········┐             #	since there is no cycles - we know there is a topological ordering where we lay out the graph and all the edges pointing to vertices we have not seen yet
    #                         ║ 1  ║              ╚════╝         :             #	relax all edges point from each vertex taken in topologival order
    # ╔══════════╗       5    ║    ║  12            ∧        	 :             #
    # ║    0     ║ ·········> ║    ║ ········┐      : 3          :             #	topological order 0 1 4 7 5 2 3 6
    # ╚══════════╝            ╚════╝         :      :            :             #	step1						|step2						|step3						|step4							###########################################################################
    #   :     :                 :            :    ╔════╗         :             #	*                           |  *                        |    *                      |      *                        #                         ╔════╗        15    ╔════╗                      #
    #   :     : 8               : 4          └··> ║    ║         :             #    0 1 4 7 5 2 3 6             |0 1 4 7 5 2 3 6            |0 1 4 7 5 2 3 6            |0 1 4 7 5 2 3 6                #                         ║    ║ ···········> ║ 3  ║ ········┐            #
    #   :     :                 ∨	              ║    ║         :             #	relax all edges from 0      |relax all edges from 1     |relax all edges from 4     |relax all edges from 7         #                         ║ 1  ║              ╚════╝         :            #
    #   :     :   ╔════════════════╗        7     ║    ║         :             #    v 	distTo[] 	edgeTo[]    |v 	distTo[] 	edgeTo[]    |v 	distTo[] 	edgeTo[]    |v 	distTo[] 	edgeTo[]        # ╔══════════╗       5    ║    ║  12            ∧            :            #
    #   : 9   └·> ║                ║ ···········> ║ 2  ║         : 9           #    0 	0.0 		-           |0 	0 			-           |0 	0 			-           |0 	0 			-               # ║    0     ║ ─────────> ║    ║ ········┐      │ 3          :            #
    #   ∨     	  ║       7        ║              ║    ║         ∨         	   #    1* 	5.0 		0-1         |1 	5 			0-1         |1 	5 			0-1         |1 	5 			0-1             # ╚══════════╝            ╚════╝         :      │            :            #
    # ╔════╗  5   ║                ║              ║    ║  11   ╔════════════╗  #    2 	                        |2*	17			1-2(change) |2 	17			1-2         |2*	15			7-2(change)     #   │     │                 :            :    ╔════╗         :            #
    # ║    ║ ···> ║                ║              ║    ║ ····> ║     6      ║  #    3 	                        |3*	20			1-3(change) |3 	20			1-3         |3 	20			1-3             #   │     │ 8               : 4          └··> ║    ║         :            #
    # ║    ║      ╚════════════════╝              ╚════╝       ╚════════════╝  #    4* 	9.0 		0-4         |4 	9 			0-4         |4 	9 			0-4         |4 	9 			0-4             #   │     │                 ∨             	  ║    ║         :            #
    # ║    ║        :                               ∧        	 ∧      ∧  	   #    5 	                        |5 	                        |5*	13 			4-5(change) |5*	13 			4-5(same)       #   │     │   ╔════════════════╗        7     ║    ║         :            #
    # ║ 4  ║        : 6                             : 1          : 20   : 13   #    6 	                        |6 	                        |6* 29			4-6(change)	|6 	29			4-6	            #   │ 9   └─> ║                ║ ···········> ║ 2  ║         : 9          #
    # ║    ║        ∨                            	:        	 :      :      #    7* 	8.0 		0-7         |7*	8 			0-7(same)   |7*	8 			0-7(same)   |7	8 			0-7             #   ∨     	  ║       7        ║              ║    ║         ∨            #
    # ║    ║  4   ╔════╗                            :            :      :      #                                                                                                                        # ╔════╗  5   ║                ║              ║    ║  11   ╔════════════╗ #
    # ║    ║ ···> ║    ║ ···························┘            :      :      #                                                                                                                        # ║    ║ ···> ║                ║              ║    ║ ────> ║     6      ║ #
    # ╚════╝      ║ 5  ║                                         :      :      #	|step5						|step6						|step7							|step7                      # ║    ║      ╚════════════════╝              ╚════╝       ╚════════════╝ #
    #   :         ║    ║                                         :      :      #    |        *                  |          *                |            *                  |              *            # ║    ║        :                               ∧        	 ∧  	∧ 	  #
    #   :         ║    ║ ········································┼······┘      #    |0 1 4 7 5 2 3 6            |0 1 4 7 5 2 3 6            |0 1 4 7 5 2 3 6                |0 1 4 7 5 2 3 6            # ║ 4  ║        : 6                             │ 1          : 20   : 13  #
    #   :         ╚════╝                                         :             #    |relax all edges from 5     |relax all edges from 2     |relax all edges from 3         |relax all edges from 6     # ║    ║        ∨                           	│            :      :     #
    #   :                                                        :             #    |v 	distTo[] 	edgeTo[]    |v 	distTo[] 	edgeTo[]    |v 	distTo[] 	edgeTo[]        |v 	distTo[] 	edgeTo[]    # ║    ║  4   ╔════╗                            │            :      :     #
    #   └························································┘             #    |0 	0 			-           |0 	0 			-           |0 	0 			-               |0 	0 			-           # ║    ║ ───> ║    ║ ───────────────────────────┘            :      :     #
    ############################################################################    |1 	5 			0-1         |1 	5 			0-1         |1 	5 			0-1             |1 	5 			0-1         # ╚════╝      ║ 5  ║                                         :      :     #
                                                                                    |2*	14			5-2(change) |2	14			5-2         |2	14			5-2             |2	14			5-2         #   :         ║    ║                                         :      :     #
                                                                                    |3 	20			1-3         |3*	17			2-3(change) |3	17			1-3		        |3	17			1-3         #   :         ║    ║ ········································┼······┘     #
    #########################################################                       |4 	9 			0-4         |4 	9 			0-4         |4 	9 			0-4             |4 	9 			0-4         #   :         ╚════╝                                         :            #
    # public class AcyclicSP {                              #                       |5	13 			4-5         |5	13 			4-5         |5	13 			4-5             |5	13 			4-5         #   :                                                        :            #
    #     private DirectedEdge[] edgeTo;                    #                       |6*	26			5-6(change)	|6*	25			2-6(change) |6*	25			5-6             |6	25			5-6         #   └························································┘            #
    #     private double[] distTo;                          #                       |7	8 			0-7         |7	8 			0-7         |7	8 			0-7             |7	8 			0-7         ###########################################################################
    #     public AcyclicSP(EdgeWeightedDigraph G, int s) {  #
    #         edgeTo = new DirectedEdge[G.V()];             #	
    #         distTo = new double[G.V()];                   #	
    #         for (int v = 0; v < G.V(); v ++)              #	
    #             distTo[v] = Double.POSITIVE_INFINITY;     #	
    #                                                       #	
    #         distTo[s] = 0.0;                              #
    #         Topological topological = new Topological(G); #
    #         for (int v : topological.order())             #
    #             for (DirectedEdge e : G.adj(v))           #
    #                 relax(e);                             #
    #     }                                                 #
    # }                                                     #
    #########################################################

	Applications:
    Seam carving - resize image (retargeted)
    
    Longest paths in edge-weighted DAGs - negate all weights and run shortyest paths (in acyclic):
    	- Parallel job scheduling
		- get min completion time
					must complete|															###################################################################################		Critical path method
	job	duration	before		 |		#############################################       # +-+  41  +-+                  +-+    51     +-+                                 #		CPM. To solve a parallel job-scheduling problem, create edge-weighted DAG:
	0 	41.0 		1 7 9        |      #        +---------------+                  #       # |0|------|0|------------------|1|-----------|1|-----                            #     ・Source and sink vertices.
	1 	51.0 		2            |      #        |      1        |                  #       # +-+      +-+                  +-+           +-+     \   +-+  50   +-+           #     ・Two vertices (begin and end) for each job.
	2 	50.0		             |      #        +-------------+-------+            #       #           |                                          ---|2|-------|2|-------    #     ・Three edges for each job.
	3 	36.0		             |      #        |    7   |    |   3   |            #       #           |                +-+ 32  +-+   +-+ 32 +-+ /   +-+       +-+       \   #     – begin to end (weighted by duration)
	4 	38.0		             |      # +------+-----+-------+------+-----------+ #       #           |----------------|7|-----|7|---|8|----|8|/                         |  #     – source to begin (0 weight)
	5 	45.0		             |      # |  0   |  9  |   6   |  8   |     2     | #       #           |                +-+     +-+   +-+    +-+                          |  #     – end to sink (0 weight)
	6 	21.0 		3 8          |      # +------+-----+---+---+---+--+-----------+ #       #           |                                                                  |  #     ・One edge for each precedence constraint (0 weight).
	7 	32.0 		3 8          |      # |   5    |       |   4   |                #       #           |                +-+21+-+      +-+ 36 +-+                          |  #
	8 	32.0 		2            |      # +--------+       +-------+                #       #           |               -|6|--|6|------|3|----|3|------------------------- |  #		CPM. Use longest path from the source to schedule each job.
	9 	29.0 		4 6          |      # -------+-----+-------+------+-----------+ #       #           |              / +-+  +-+      +-+    +-+                         \|  #
                                        #       43    70      91    123         173 #       #           |             /                                                    |  #
                                        #############################################       #           |   +-+ 29 +-+                                                     |  #
                                                                                            #           |---|9|----|9|                                                     |  #
                                                                                            #               +-+    +-+                                                     |  #
                                                                                            #                         \                                                    |  #
                                                                                            #                          \ +-+  38   +-+                                    +-+ #
                                                                                            #                           -|4|-------|4|------------------------------------|e| #
                                                                                            #                            +-+       +-+                                    +-+ #
                                                                                            #                            +-+   45     +-+                                /    #
                                                                                            #                            |5|----------|5|--------------------------------     #
                                                                                            #                            +-+          +-+                                     #
                                                                                            ###################################################################################

- Negative Weights
																				
	###############		Dijkstra. Doesn’t work with negative edge weights.		
    # +-+  4  +-+ #		Dijkstra selects vertex 3 immediately after 0.			
    # |0|---->|1| #		But shortest path from 0 to 3 is 0→1→2→3.
    # +-+     +-+ #
    #  |2      |6 #		Topological sort wont work as here is a cycle
    #  v       v  #
    # +-+     +-+ #		Negative cycles
    # |3|<----|2| #     A negative cycle is a directed cycle whose sum of edge weights is negative.
    # +-+ -9  +-+ #     One can go around a negative cycle many times and get a shortest path which is wrong.
    ###############		If there is no negative cycles - then there is a shortest path tree
						If there is a shortest path tree - then there is no negative cycles

	Bellman-Ford Algorithm
	Repeat V times: relax all E edges												PASS1: 0-1 0-4 0-7 1-2 1-3 1-7 2-3 2-6 3-6 4-5 4-6 4-7 5-2 5-6 7-5 7-2
	############################################################################	step1						|step2						|step3						|step4						###########################################################################
	#  					      ╔════╗        15    ╔════╗                       #	relax edges from 0          |relax edges from 1         |relax edges from 2         |relax edges from 3         #                         ╔════╗        15    ╔════╗                      #
	#                         ║    ║ ···········> ║ 3  ║ ········┐             #	v 	distTo[] 	edgeTo[]    |v 	distTo[] 	edgeTo[]    |v 	distTo[] 	edgeTo[]    |v 	distTo[] 	edgeTo[]    #                         ║    ║ ···········> ║ 3  ║ ········┐            #
	#                         ║ 1  ║              ╚════╝         :             #    0 	0.0 		-           |0 	0.0 		-           |0 	0.0 		-           |0 	0.0 		-           #                         ║ 1  ║              ╚════╝         :            #
	# ╔══════════╗       5    ║    ║  12            ∧        	 :             #    1* 	5.0 		0-1         |1 	5.0 		0-1         |1 	5.0 		0-1         |1 	5.0 		0-1         # ╔══════════╗       5    ║    ║  12            ∧            :            #
	# ║    0     ║ ·········> ║    ║ ········┐      : 3          :             #    2                           |2* 17			1-2         |2  17			1-2         |2  17			1-2         # ║    0     ║ ─────────> ║    ║ ········┐      │ 3          :            #
	# ╚══════════╝            ╚════╝         :      :            :             #    3                           |3*	20			1-3         |3* 20          1-3         |3  20          1-3         # ╚══════════╝            ╚════╝         :      │            :            #
	#   :     :                 :            :    ╔════╗         :             #    4* 	9.0 		0-4         |4 	9.0 		0-4         |4 	9.0 		0-4         |4 	9.0 		0-4         #   │     │                 :            :    ╔════╗         :            #
	#   :     : 8               : 4          └··> ║    ║         :             #    5                           |5                          |5                          |5                          #   │     │ 8               : 4          └··> ║    ║         :            #
	#   :     :                 ∨	              ║    ║         :             #    6                           |6                          |6* 28			2-6         |6* 28			2-6         #   │     │                 ∨             	  ║    ║         :            #
	#   :     :   ╔════════════════╗        7     ║    ║         :             #    7* 	8.0 		0-7         |7*	8.0 		0-7			|7 	8.0 		0-7         |7 	8.0 		0-7         #   │     │   ╔════════════════╗        7     ║    ║         :            #
	#   : 9   └·> ║                ║ ···········> ║ 2  ║         : 9           #                                                                                                                    #   │ 9   └─> ║                ║ ···········> ║ 2  ║         : 9          #
	#   ∨     	  ║       7        ║              ║    ║         ∨         	   #                                                                                                                    #   ∨     	  ║       7        ║              ║    ║         ∨            #
	# ╔════╗  5   ║                ║              ║    ║  11   ╔════════════╗  #	step5						|step6						|step7                                                  # ╔════╗  5   ║                ║              ║    ║  11   ╔════════════╗ #
	# ║    ║ ···> ║                ║              ║    ║ ····> ║     6      ║  #    relax edges from 4          |relax edges from 5         |relax edges from 6                                     # ║    ║ ···> ║                ║              ║    ║ ────> ║     6      ║ #
	# ║    ║      ╚════════════════╝              ╚════╝       ╚════════════╝  #    v 	distTo[] 	edgeTo[]    |v 	distTo[] 	edgeTo[]    |v 	distTo[] 	edgeTo[]                                # ║    ║      ╚════════════════╝              ╚════╝       ╚════════════╝ #
	# ║    ║        :                               ∧        	 ∧      ∧  	   #    0 	0.0 		-           |0 	0.0 		-           |0 	0.0 		-                                       # ║    ║        :                               ∧        	 ∧  	∧ 	  #
	# ║ 4  ║        : 6                             : 1          : 20   : 13   #    1 	5.0 		0-1         |1 	5.0 		0-1         |1 	5.0 		0-1                                     # ║ 4  ║        : 6                             │ 1          : 20   : 13  #
	# ║    ║        ∨                            	:        	 :      :      #    2 	17			1-2         |2*	14			5-2         |2*	14			5-2                                     # ║    ║        ∨                           	│            :      :     #
	# ║    ║  4   ╔════╗                            :            :      :      #    3	20          1-3         |3	20          1-3         |3	20          1-3                                     # ║    ║  4   ╔════╗                            │            :      :     #
	# ║    ║ ···> ║    ║ ···························┘            :      :      #    4	9.0 		0-4         |4	9.0 		0-4         |4	9.0 		0-4                                     # ║    ║ ───> ║    ║ ───────────────────────────┘            :      :     #
	# ╚════╝      ║ 5  ║                                         :      :      #    5* 	13			4-5         |5	13			4-5         |5*	13			4-5                                     # ╚════╝      ║ 5  ║                                         :      :     #
	#   :         ║    ║                                         :      :      #    6* 	28			2-6         |6*	26			5-6         |6	26			5-6                                     #   :         ║    ║                                         :      :     #
    #   :         ║    ║ ········································┼······┘      #    7* 	8.0 		0-7         |7	8.0 		0-7         |7	8.0 		0-7                                     #   :         ║    ║ ········································┼······┘     #
    #   :         ╚════╝                                         :             #                                                                                                                    #   :         ╚════╝                                         :            #
    #   :                                                        :             #	PASS2: 0-1 0-4 0-7 1-2 1-3 1-7 2-3 2-6 3-6 4-5 4-6 4-7 5-2 5-6 7-5 7-2                                          #   :                                                        :            #
    #   └························································┘             #	|step3						2-3 successfully relaxed                                                            #   └························································┘            #
    ############################################################################    |relax edges from 2     	in pass 1, but not pass 0                                                           ###########################################################################
	                                                                                |v 	distTo[] 	edgeTo[]	because in pass 0 path to 2 was longer
	##############################################################################  |0 	0.0 		-      
	# algorithm 	|restriction 	|typical case 	|worst case 	|extra space #  |1 	5.0 		0-1    		FIFO implementation. Maintain queue of vertices whose distTo[] changed.
	# topological	|no directed	|	E + V		|	E + V		|V           #  |2	14			5-2    
	# sort  		|cycles         |               |               |            #  |3*	17          1-3    
	#	 			|               |               |               |            #  |4	9.0 		0-4    
	# Dijkstra		|no negative	|	E log V		|	E log V		|V           #  |5	13			4-5     
	# (binary heap)	|weights        |               |               |            #  |6	26			5-6    
	# 				|               |               |               |            #  |7	8.0 		0-7     
    # Bellman-Ford	|no negative	|	E V			|	E V			|V           #  
	# 				|cycles         |               |               |            #  
	# 				|               |               |               |            #  
	# Bellman-Ford	|no negative	|	E + V		|	E V			|V           #  
	# (queue-based)	|cycles         |               |               |            #  
	##############################################################################  
																					
	Negative cycle application: arbitrage detection			Negative cycle application: arbitrage detection					Model as a negative cycle detection problem by taking logs.					
	############################							Currency exchange graph.						                ・Let weight of edge v→w be - ln (exchange rate from currency v to w).
	# 		USD	EUR	GBP	CHF	CAD#                            ・Vertex = currency.                                             ・Multiplication turns to addition; > 1 turns to < 0. 
	# USD	1	0.7	0.6	1.0	1.0#                            ・Edge = transaction, with weight equal to exchange rate.        ・Find a directed cycle whose sum of edge weights is < 0 (negative cycle). 
	# EUR	1.3	1	0.8	1.4	1.3#                            ・Find a directed cycle whose product of edge weights is > 1.
	# GBP	1.5	1.1	1	1.6	1.5#								>0.741			0.741 * 1.366 * .995 = 1.00714497
	# CHF	0.9	0.6	0.6	1	0.9#							+---+     +---+
	# CAD	0.9	0.7	0.6	1.0	1  #                            |USD|<--->|EUR|				replace each weight with ln
	############################                            +---+     +---+				-ln(.741) -ln(1.366) -ln(.995)		(ln(x) - time needed to grow to x with 100% continusos compund)
	                                                         ^   ^   ^   ^ >1.366		.2998 - .3119 + .0050 = -.0071		e - constant 2.718
	                                                         |    \ /    | 													e^3 is 20.08. After 3 units of time, we end up with 20.08 times what we started with.
	                                                         |     /<0.99| 													log(x) tells you what power you must raise 10 to get x
	                                                         |    / \    |                                                  ln(x) is log with base e 2.718
	                                                         v   v   v   v                                                  ln(x) tells you what power you must raise e to get x
                                                            +---+     +---+
	                                                        |CHF|<--->|CAD|
                                                            +---+     +---+
###############
# week3
###############

- MaxFlow
																			Minimum st-cut (mincut) problem. Find a cut of minimum capacity. 			Maximum st-flow (maxflow) problem. Find a flow of maximum value.
	###################################################################		A st-cut (cut) is a partition of the vertices into two disjoint sets,		An st-flow (flow) is an assignment of values to the edges such that:
	#            10    ╔═════════╗        9     ╔═════╗               #		with s in one set A and t in the other set B.                               ・Capacity constraint: 0 ≤ edge's flow ≤ edge's capacity.
	#   ┌············> ║    1    ║ ···········> ║  2  ║ ········┐     #		Its capacity is the sum of the capacities of the edges from A to B.         ・Local equilibrium: inflow = outflow at every vertex (except s and t).
	#   :              ╚═════════╝              ╚═════╝         :     #		capacity in below cut is 30 ( s 1, s 3, s 5)								The value of a flow is the inflow at t.
	#   :                :     :                  :             :     #		###################################################################			######################################################################################
	#   :                :     :                  : 15          :     #     #            10    ╔═════════╗        9     ╔═════╗ 			  #         #            10/10    ╔════════════╗           5/9     ╔═══════╗                     #
	#   :                :     :                  ∨         	:     #     #   ┌────────────> ║    1    ║ ···········> ║  2  ║ ········┐ 	  #         #   ┌···············> ║     1      ║ ················> ║   2   ║ ···········┐        #
	#   :                :     :          15    ╔═════╗         :     #     #   │              ╚═════════╝              ╚═════╝         : 	  #         #   :                 ╚════════════╝                   ╚═══════╝            :        #
	#   :                : 4   └··············> ║     ║         : 10  #     #   │                :     :                  :             : 	  #         #   :                   :        │                       :                  :        #
	#   :                ∨                  	║  4  ║         ∨ 	  #     #   │                :     :                  : 15          : 	  #         #   :                   :        │                       : 0/15             :        #
	# ╔═══╗      5     ╔═════════╗        8     ║     ║  10   ╔═════╗ #     #   │                :     :                  ∨             : 	  #         #   :                   :        │                       ∨              	:        #
	# ║ s ║ ·········> ║    3    ║ ···········> ║     ║ ····> ║  t  ║ #     #   │                :     :          15    ╔═════╗         : 	  #         #   :                   :        │             5/15    ╔═══════╗            :        #
	# ╚═══╝            ╚═════════╝              ╚═════╝       ╚═════╝ #     #   │                : 4   └··············> ║     ║         : 10  #         #   :                   : 5/15   └───────────────────> ║       ║            : 5/10   #
	#   :                :     :                  :             ∧ 	  #     #   │                ∨                  	║  4  ║         ∨ 	  #         #   :                   ∨                          	   ║   4   ║            ∨   	 #
	#   :                :     :                  :             : 10  #     # ╔═══╗      5     ╔═════════╗        8     ║     ║  10   ╔═════╗ #         # ╔═══╗      5/5      ╔════════════╗           5/8     ║       ║  10/10   ╔════════╗ #
	#   :                :     :                  :             :     #     # ║ s ║ ─────────> ║    3    ║ ···········> ║     ║ ····> ║  t  ║ #         # ║ s ║ ············> ║     3      ║ ────────────────> ║       ║ ───────> ║   t    ║ #
	#   :                :     :   15             :             :     #     # ╚═══╝            ╚═════════╝              ╚═════╝       ╚═════╝ #         # ╚═══╝               ╚════════════╝                   ╚═══════╝          ╚════════╝ #
	#   :                : 4   └···········┐      : 15          :     #     #   │                :     :                  :             ∧ 	  #         #   :                   :        :                       :                  ∧    	 #
	#   :                ∨                 ∨     ∨             :     # 	#   │                :     :                  :             : 10  #         #   :                   :        :                       :                  : 10/10  #
	#   :        15    ╔═════════╗  16   ╔════════════╗         :     #     #   │                :     :                  :             : 	  #         #   :                   :        :                       :                  :        #
	#   └············> ║    5    ║ ····> ║     6      ║ ········┘     #     #   │                :     :   15             :             : 	  #         #   :                   :        :   0/6                 :                  :        #
	#                  ╚═════════╝       ╚════════════╝               #     #   │                : 4   └···········┐      : 15          : 	  #         #   :                   : 0/4    └··············┐        : 0/15             :        #
	###################################################################     #   │                ∨             	   ∨  	  ∨         	: 	  #         #   :                   ∨                       ∨    	 ∨              	:    	 #
	                                                                        #   │        15    ╔═════════╗  16   ╔════════════╗         : 	  #         #   :        10/15    ╔════════════╗  10/16   ╔════════════════╗            :        #
	                                                                        #   └────────────> ║    5    ║ ····> ║     6      ║ ········┘ 	  #         #   └···············> ║     5      ║ ·······> ║       6        ║ ···········┘        #
	                                                                        #                  ╚═════════╝       ╚════════════╝ 			  #         #                     ╚════════════╝          ╚════════════════╝                     #
	                                                                        ###################################################################         ######################################################################################
	
- Ford-Fulkerson algorithm												Augmenting path. Find an undirected path from s to t such that:
	Initialization. Start with 0 flow.										・Can increase flow on forward edges (not full).
	###################################################################		1st augmenting path  s-1-4-t (10 units)
    #          0/10    ╔═════════╗        0/9   ╔═════╗               #     2nd augmenting path  s-5-6-t (10 units)
    #   ┌············> ║    1    ║ ···········> ║  2  ║ ········┐     #		3rd augmenting path  s-3-4-1-2-t (add 5 in 3-4 and remove 5 in backward 4-1) total 25
    #   :              ╚═════════╝              ╚═════╝         :     #  	4th augmenting path  s-5-6-3-4-1-2-t ( e more units as 3-4 had left capacity of 3) total 28	   
    #   :                :     :                  :             :     # 	###################################################################################### 			Termination. All paths from s to t are blocked by either a   
    #   :                :     :                  : 0/15        :     #     #            10/10    ╔═══════════╗          8/9      ╔═══════╗ 					 #          ・Full forward edge.
    #   :                :     :                  ∨         	:     #     #   ┌───────────────> ║     1     ║ ················> ║   2   ║ ···········┐ 		 #          ・Empty backward edge.
    #   :                :     :        0/15    ╔═════╗         :     #     #   │                 ╚═══════════╝                   ╚═══════╝            : 		 #
    #   :                :0/4  └··············> ║     ║         :0/10 #     #   │                   :       │                       :                  : 		 #			Algorithm
    #   :                ∨                  	║  4  ║         ∨ 	  #     #   │                   :       │                       : 0/15             : 	 	 #			Start with 0 flow.
    # ╔═══╗      0/5   ╔═════════╗        0/8   ║     ║  0/10 ╔═════╗ #     #   │                   :       │                       ∨              	   : 		 #          While there exists an augmenting path:
    # ║ s ║ ·········> ║    3    ║ ···········> ║     ║ ····> ║  t  ║ #     #   │                   :       │            2/15     ╔═══════╗            : 		 #           - find an augmenting path
    # ╚═══╝            ╚═════════╝              ╚═════╝       ╚═════╝ #     #   │                   : 0/4   └───────────────────> ║       ║            : 8/10 	 #           - compute bottleneck capacity
    #   :                :     :                  :             ∧ 	  #     #   │                   ∨                          	  ║   4   ║            ∨ 		 #           - increase flow on that path by bottleneck capacity
    #   :                :     :                  :             :0/10 #     # ╔═══╗      5/5      ╔═══════════╗          8/8      ║       ║  10/10   ╔═══════╗ 	 #
    #   :                :     :                  :             :     #     # ║ s ║ ············> ║     3     ║ ················> ║       ║ ───────> ║   t   ║ 	 #
    #   :                :     :   0/6            :             :     #     # ╚═══╝               ╚═══════════╝                   ╚═══════╝          ╚═══════╝ 	 #
    #   :                :0/4  └···········┐      :0/15         :     #     #   :                   :       ^                       :                  ∧ 		 #
    #   :                ∨                 ∨     ∨             :     #     #   :                   :       :                       :                  : 10/10 	 #    
    #   :       0/15   ╔═════════╗  0/16 ╔════════════╗         :     #     #   :                   :       :                       :                  : 		 #
    #   └············> ║    5    ║ ····> ║     6      ║ ········┘     #     #   :                   :       :   3/6                 :                  : 		 #
    #                  ╚═════════╝       ╚════════════╝               #     #   :                   : 0/4   └·············┐         : 0/15             : 		 #
    ###################################################################     #   :                   ∨                  	  :     	∨                  : 		 #
                                                                            #   :        13/15    ╔═══════════╗  13/16  ╔═════════════════╗            : 		 #
                                                                            #   └···············> ║     5     ║ ······> ║        6        ║ ···········┘ 		 #
                                                                            #                     ╚═══════════╝         ╚═════════════════╝ 					 #
                                                                            ######################################################################################

- maxflow-mincut theorem
	#####################################################################################	Computing a mincut from a maxflow
    #            10/10    ┌───────────┐          0/9     ┌───────┐                      #	・Compute A = set of vertices connected to s by an undirected path
    #   ┌···············> │     1     │ ···············> │   2   │ ···········┐         #	with no full forward or empty backward edges.
    #   :                 └───────────┘                  └───────┘            :         #	in left example A is s-5-3-6
    #   :                   :       :                      :                  :         #
    #   :                   :       :                      : 0/15             :         #
    #   :                   :       :                      ∨              	  :         #
    #   :                   :       :            2/15    ┌───────┐            :         #
    #   :                   : 0/4   └··················> │       │            : 10/10   #
    #   :                   ∨                        	 │   4   │            ∨     	#
    # ╔═══╗      5/5      ╔═══════════╗          8/8     │       │  10/10   ┌────────┐  #
    # ║ s ║ ············> ║     3     ║ ···············> │       │ ·······> │   t    │  #
    # ╚═══╝               ╚═══════════╝                  └───────┘          └────────┘  #
    #   :                   :       :                      :                  ∧     	#
    #   :                   :       :                      :                  : 10/10   #
    #   :                   :       :                      :                  :         #
    #   :                   :       :   6/6                :                  :         #
    #   :                   : 3/4   └·············┐        : 0/15             :         #
    #   :                   ∨                     ∨    	   ∨              	  :     	#
    #   :        13/15    ╔═══════════╗  0/16   ╔════════════════╗            :         #
    #   └···············> ║     5     ║ ······> ║       6        ║ ···········┘         #
    #                     ╚═══════════╝         ╚════════════════╝                      #
    #####################################################################################


- implementation
	Flow edge data type. Associate flow fe and capacity ce with edge e = v→w.													###################################################################### 	#############################################################
	Flow network data type. Need to process edge e = v→w in either direction: Include e in both v and w's adjacency lists.      # public class FlowEdge {                                            #  # public double residualCapacityTo(int vertex) {            #
	Residual capacity.                                                                                                          #     private final int v,w; // from and to                          #  #     if (vertex == v) return flow;                         #  <-- backward edge
	・Forward edge: residual capacity = ce - fe.                                                                                 #     private final double capacity; // capacity                     #  #      else if (vertex == w) return capacity - flow;        #  <-- forward edge 
	・Backward edge: residual capacity = fe.                                                                                     #     private double flow; // flow                                   #  #      else throw new IllegalArgumentException();           # 
	Augment flow.                                                                                                               #     public FlowEdge(int v, int w, double capacity) {               #  #                                                           #
	・Forward edge: add ∆.                                                                                                       #         this.v = v;                                                #  # }                                                         # 
	・Backward edge: subtract ∆.                                                                                                 #         this.w = w;                                                #  # public void addResidualFlowTo(int vertex, double delta) { # 
	original network						residual network:                                                                   #         this.capacity = capacity;                                  #  #     if (vertex == v) flow -= delta;                       #  <-- backward edge
	#####################################	same but:					Augmenting path in original network is equivalent to    #     }                                                              #  #      else if (vertex == w) flow += delta;                 #  <-- forward edge
	#           +-+  9/9  +-+           #	s-1 = 1; 1-s = 9			directed path in residual network.                      #     public int from() {return v;}                                  #  #      else throw new IllegalArgumentException();           #
	#          >|1|------>|2|\          #	s-3 = 1; 3-s = 4                                                                    #     public int to() {return w;}                                    #  # }                                                         #
	#        -/ +-+       +-+ -\        #	1-3 = 4;                                                                            #     public double capacity() {return capacity;}                    #  #############################################################
	#   9/10/    ^ -\4/4   |    \9/10   #	s-3 = 1; 3-s = 4                                                                    #     public double flow() {return flow;}                            #
	#     -/  4/4|   --\   v     -\     #	2-1 = 9                                                                             #     public int other(int vertex) {                                 #
	# +-+/      +-+     ->+-+      >+-+ #	4-1 = 4                                                                             #         if (vertex == v) return w;                                 #
	# |s|------>|3|------>|4|------>|t| #	3-4 = 8 (cause was empty)                                                           #          else if (vertex == w) return v;                           #
	# +-+  4/5  +-+  0/8  +-+  4/10 +-+ #	2-4 = 15 (cause was empty)                                                          #          else throw new RuntimeException("Illegal endpoint");      #
	#####################################	4-t = 6; t-4 = 4                                                                    #                                                                    #
											2-t = 1; t-2 = 9                                                                    #     }                                                              #
	                                                                                                                            #     public double residualCapacityTo(int vertex) {...}             #
	                                                                                                                            #     public void addResidualFlowTo(int vertex, double delta) {...}  #
                                                                                                                                # }                                                                  #
                                                                                                                                ######################################################################

	############################################### 								Ford-Fulkerson: Java implementation
    # public class FlowNetwork {                  #                                 ############################################################################### 							#################################################################### 
    #     private final int V;                    #		same as EdgeWeightedGraph,  # public class FordFulkerson {                                                #                             # private boolean hasAugmentingPath(FlowNetwork G, int s, int t) { #
    #     private Bag<FlowEdge> [] adj;           #  <--but adjacency lists of      #     private boolean[] marked; // true if s->v path in residual network      #                             #     edgeTo = new FlowEdge[G.V()];                                #
    #                                             #		FlowEdges instead of Edges  #     private FlowEdge[] edgeTo; // last edge on s->v path                    #                             #     marked = new boolean[G.V()];                                 #
    #     public FlowNetwork(int V) {             #                                 #     private double value; // value of flow                                  #                             #     Queue<Integer> queue = new Queue<Integer>();                 #
    #         this.V = V;                         #                                 #     public FordFulkerson(FlowNetwork G, int s, int t) {                     #                             #     queue.enqueue(s);                                            #
    #         adj = (Bag<FlowEdge> [])new Bag[V]; #                                 #         value = 0.0;                                                        #                             #     marked[s] = true;                                            #
    #         for (int v = 0; v < V; v ++)        #                                 #         while (hasAugmentingPath(G, s, t)) {                                #                             #     while (!queue.isEmpty()) {                                   #
    #             adj[v] = new Bag<FlowEdge>();   #                                 #             double bottle = Double.POSITIVE_INFINITY;                       #                             #         int v = queue.dequeue();                                 #
    #     }                                       #                                 #             for (int v = t; v != s; v = edgeTo[v].other(v))                 #  <-- compute                #         for (FlowEdge e : G.adj(v)) {                            #
    #     public void addEdge(FlowEdge e) {       #                                 #                 bottle = Math.min(bottle, edgeTo[v].residualCapacityTo(v)); #		 bottleneck capacity    #             int w = e.other(v);                                  #
    #         int v = e.from();                   #                                 #             for (int v = t; v != s; v = edgeTo[v].other(v))                 #  <-- augment flow           #             if (e.residualCapacityTo(w) > 0 && !marked[w]) {     #  <-- found path from s to win the residual network?
    #         int w = e.to();                     #                                 #                 edgeTo[v].addResidualFlowTo(v, bottle);                     #                             #                 edgeTo[w] = e;                                   #	  save last edge on path to w;
    #         adj[v].add(e);                      #  <--add forward edge            #             value += bottle;                                                #                             #                 marked[w] = true;                                #  <-- mark w;
    #         adj[w].add(e);                      #  <--add backward edge           #         }                                                                   #                             #                 queue.enqueue(w);                                #	  add w to the queue
    #     }                                       #                                 #     }                                                                       #                             #             }                                                    #
    #     public Iterable<FlowEdge> adj(int v) {  #                                 #     private boolean hasAugmentingPath(FlowNetwork G, int s, int t) {        #                             #         }                                                        #
    #         return adj[v];                      #                                 #         /* See next slide. */                                               #                             #     }                                                            #
    #     }                                       #                                 #     }                                                                       #                             #     return marked[t];                                            #
    # }                                           #                                 #     public double value() {return value;}                                   #                             # }                                                                #
    ###############################################                                 #     public boolean inCut(int v) {return marked[v];}                         #                             ####################################################################
                                                                                    # }                                                                           #
                                                                                    ###############################################################################

- applications
	Maxflow/mincut is a widely applicable problem-solving model.
	・Data mining.
	・Open-pit mining.
	・Bipartite matching.
	・Network reliability.
	・Baseball elimination.
	・Image segmentation.
	・Network connectivity.
	・Distributed computing.
	・Security of statistical data.
	・Egalitarian stable matching.
	・Multi-camera scene reconstruction.
	・Sensor placement for homeland security.
	・Many, many, more.

- Strings
	How to efficiently reverse a string?									How to efficiently form array of suffixes?							How long to compute length of longest common prefix?
	String																	String
	##################################################						###############################################						#################################################
    # public static String reverse(String s) {       #                      # public static String[] suffixes(String s) { #                     # public static int lcp(String s, String t) {   #
    #     String rev = "";                           #                      #     int N = s.length();                     #                     #     int N = Math.min(s.length(), t.length()); #
    #     for (int i = s.length() - 1; i >= 0; i --) #                      #     String[] suffixes = new String[N];      #                     #     for (int i = 0; i < N; i ++)              #
    #         rev += s.charAt(i);                    #  <-- quadratic       #     for (int i = 0; i < N; i ++)            #  <-- linear         #         if (s.charAt(i) != t.charAt(i))       #  <-- linear worse
    #                                                #                      #         suffixes[i] = s.substring(i, N);    #                     #             return i;                         #	   sublinear typical
    #     return rev;                                #                      #                                             #                     #     return N;                                 #
    # }                                              #                      #     return suffixes;                        #                     # }                                             #
    ##################################################                      # }                                           #                     #################################################
    StringBuilder                                                           ###############################################
    ##################################################                      StringBuilder
    # public static String reverse(String s) {       #                      ###############################################
    #     StringBuilder rev = new StringBuilder();   #                      # public static String[] suffixes(String s) { #
    #     for (int i = s.length() - 1; i >= 0; i --) #                      #     int N = s.length();                     #
    #         rev.append(s.charAt(i));               #  <-- linear          #     StringBuilder sb = new StringBuilder(s);#  <-- quadratic
    #                                                #                      #     String[] suffixes = new String[N];      #
    #     return rev.toString();                     #                      #     for (int i = 0; i < N; i ++)            #
    # }                                              #                      #         suffixes[i] = sb.substring(i, N);   #
    ##################################################                      #                                             #
                                                                            #     return suffixes;                        #
                                                                            # }                                           #
                                                                            ###############################################

- key-indexed counting							
	Keys used to sort are small integeres													Applications:						
                                                                                            ・Sort string by first letter.       
	Goal. Sort an array a[] of N integers between 0 and R - 1.                              ・Sort class roster by section.      
	#################################						                                ・Sort phone numbers by area code.                   
	#     +-----------------------+ #                                                       ・Subroutine in a sorting algorithm. 
    # a[i]|d|a|c|f|f|b|d|b|f|b|e|a| #                                                 
    #     +-----------------------+ #	  count frquencies using key as index                                                 
    # i    0 1 2 3 4 5 6 7 8 9 1011 #	  ###########################                                                 
    #################################     # 		  offset by 1   #                                                
                                          # 	    +-------------+ #                                                
    #################################	  # count[r]|0|2|3|1|2|1|3| #                                                
    #int N = a.length;              #     # 	    +-/-/-/-/-/-/-+ #                                                
    #int[] count = new int[R + 1];  #     # r		a b c d e f     #                                                
    #for (int i = 0; i < N; i ++)   #  <--###########################                                                
    #    count[a[i] + 1]++;         #     compute cumulitives                                                                  
    #                               #     # 	    +--------------+#	go through count array and at each step                                                
    #for (int r = 0; r < R; r ++)   #  <--# count[r]|0|2|5|6|8|9|12|#   add current one to sum computed so far                                                                   
    #    count[r + 1] += count[r];  #     # 	    +-/-/-/-/-/-/--+#                                                
    #                               #     # r		 a b c d e f    #
    #for (int i = 0; i < N; i ++)   #     ###################################	6 keys <d 8 keys <e so d`s go in a[6] and a[]7
    #    aux[count[a[i]]++] = a[i]; #  <--#       +-----------------------+ #	go through all array to be sorted and move each key where it has to go
    #                               #     # aux[i]|a|a|b|b|b|c|d|d|e|f|f|f| #	last step move back to original array
    #for (int i = 0; i < N; i ++)   #     #       +-----------------------+ #
    #    a[i] = aux[i];             #     # i      0 1 2 3 4 5 6 7 8 9 1011 #
    #################################     ###################################

- LSD radix sort
	Least-significant-digit-first string sort									good to sort one million 32-bit integers.
	LSD string (radix) sort.
	・Consider characters from right to left.
	・Stably sort using dth character as the key (using key-indexed counting)
															LSD string sort: Java implementation
					sort key	sort key	sort key		########################################################
					(d = 2)		(d = 1)		(d = 1)         # public class LSD {                                   #
	#################################################       #     public static void sort(String[] a, int W) {     #  <-- fixed-length W strings
	# 				     *		   *	     *      #       #         int R = 256;                                 #  <-- radix R
	#   +-----+     +-----+     +-----+     +-----+ #       #         int N = a.length;                            #
	#  0|d a|b|    0|d a|b|    0|d|a|b|    0|a|c e| #       #         String[] aux = new String[N];                #      do key-indexed counting
	#  1|a d|d|    1|c a|b|    1|c|a|b|    1|a|d d| #       #         for (int d = W - 1; d >= 0; d --) {          #  <-- for each digit from right to left
	#  2|c a|b|    2|e b|b|    2|f|a|d|    2|b|a d| #       #             int[] count = new int[R + 1];            #
	#  3|f a|d|    3|a d|d|    3|b|a|d|    3|b|e d| #       #             for (int i = 0; i < N; i ++)             #
	#  4|f e|e|    4|f a|d|    4|d|a|d|    4|b|e e| #       #                 count[a[i].charAt(d) + 1]++;         #
	#  5|b a|d|    5|b a|d|    5|e|b|b|    5|c|a b| #       #             for (int r = 0; r < R; r ++)             #  <-- key-indexed counting
	#  6|d a|d|    6|d a|d|    6|a|c|e|    6|d|a b| #       #                 count[r + 1] += count[r];            #
	#  7|b e|e|    7|f e|d|    7|a|d|d|    7|d|a d| #       #             for (int i = 0; i < N; i ++)             #
	#  8|f e|d|    8|b e|d|    8|f|e|d|    8|e|b b| #       #                 aux[count[a[i].charAt(d)]++] = a[i]; #
	#  9|b e|d|    9|f e|e|    9|b|e|d|    9|f|a d| #       #                                                      #
	# 10|e b|b|   10|b e|e|   10|f|e|e|   10|f|e d| #       #             for (int i = 0; i < N; i ++)             #
	# 11|a c|e|   11|a c|e|   11|b|e|e|   11|f|e e| #       #                 a[i] = aux[i];                       #
	#   +-----+     +-----+     +-----+     +-----+ #       #         }                                            #
	#################################################       #     }                                                #
	                                                        # }                                                    #
	                                                        ########################################################
	
- MSD radix sort																																	MSD string sort: Java implementation
	MSD string (radix) sort.																														###############################################################################
	・Partition array into R pieces according to first character(use key-indexed counting).                                                          # public static void sort(String[] a) {                                       # 
	・Recursively sort all strings that start with each character (key-indexed counts delineate subarrays to sort).                                  #     aux = new String[a.length];                                             # 
	                                                                                                                                                #     sort(a, aux, 0, a.length - 1, 0);                                       #
											sort subarrays			Variable-length strings					                                        # }                                                                           #
				   *		count[]			recursively				Treat strings as if they had an extra char at end (smaller than any char).      # private static void sort(String[] a, String[] aux, int lo, int hi, int d) { #
	  +-----+	  +-----+                  +-----+					  +--------+				################################################	#     if (hi <= lo)                                                           #
	 0|d a b|    0|a|d d|           ----->0|a d d|			         0|s e a +1|                # private static int charAt(String s, int d) { #    #         return;                                                             #
	 1|a d d|    1|a|c e|          /      1|a c e|        	          +--------------------+    #     if (d < s.length()) return s.charAt(d);  #    #     int[] count = new int[R + 2];                                           #
	 2|c a b|    2|b|a d|         /        +-----+        	         1|s e a s h e l l s +1|    #      else  return -1;                        #    #     for (int i = lo; i <= hi; i ++)                                         #
	 3|f a d|    3|b|e e|    +--+/     -->2|b a d|        	          +--------------------+    # }                                            #    #         count[charAt(a[i], d) + 2]++;                                       #
	 4|f e e|    4|b|e d|   a|0 |     /   3|b e e|        	         2|s e l l s +1|            ################################################    #     for (int r = 0; r < R + 1; r ++)                                        #
	 5|b a d|    5|c|a b|   b|2 |-----    4|b e d|        	          +------------+                                                                #         count[r + 1] += count[r];                                           #
	 6|d a d|    6|d|a b|   c|5 |-----     +-----+        	         3|s h e +1|				Observation 1.                                      #     for (int i = lo; i <= hi; i ++)                                         #
	 7|b e e|    7|d|a d|   d|6 |---  \-->5|c a b|        	          +--------+                Much too slow for small subarrays.                  #         aux[count[charAt(a[i], d) + 1]++] = a[i];                           #
	 8|f e d|    8|e|b b|   e|8 |-  \      +-----+        	         4|s h e +1|                ・Each function call needs its own count[] array.    #     for (int i = lo; i <= hi; i ++)                                         #
	 9|b e d|    9|f|a d|   f|9 | \  ---->6|d a b|        	          +--------------+          ・ASCII (256 counts): 100x slower than copy pass     #         a[i] = aux[i - lo];                                                 #
	10|e b b|   10|f|e e|   ++12|\ \      7|d a d|        	         5|s h e l l s +1|          for N = 2.                                          #     for (int r = 0; r < R; r ++)                                            #  <-- sort R subarrays recursively
	11|a c e|   11|f|e d|    +--+ \ \      +-----+        	          +--------------+          ・Unicode (65,536 counts): 32,000x slower            #         sort(a, aux, lo + count[r], lo + count[r + 1] - 1, d + 1);          #
	  +-----+     +-----+          \ ---->8|e b b|        	         6|s h o r e +1|            for N = 2.                                          #                                                                             #
	                                \      +-----+        	          +--------------+          Observation 2. Huge number of small subarrays       # }                                                                           #
	                                 ---->9|f a d|        	         7|s u r e l y +1|          because of recursion.                               ###############################################################################
	                                     10|f e e|        	          +--------------+
	                                     11|f e d|        	
	                                       +-----+        	
	        	
	Cutoff to insertion sort												Summary of the performance of sorting algorithms							MSD string sort vs. quicksort for strings
	Solution. Cutoff to insertion sort for small subarrays.					+-------------------------------------------------------------------+		Disadvantages of MSD string sort.		
	・Insertion sort, but start at dth character.                            |algorithm | guarantee | random  |space  |stable?|operations on keys|        ・Extra space for aux[]. 
	・Implement less() so that it compares starting at dth character.        |insertion | ½N^2      | ¼N^2    |1      |yes    |compareTo()       |        ・Extra space for count[]. 
	###################################################################     |mergesort | NlgN      | NlgN    |N      |yes    |compareTo()       |       ・Inner loop has a lot of instructions.
	#public static void sort(String[] a, int lo, int hi, int d) {     #     |quicksort | 1.39NlgN* | 1.39NlgN|clgN   |no     |compareTo()       |       ・Accesses memory "randomly" (cache inefficient).
	#    for (int i = lo; i <= hi; i ++)                              #     |heapsort  | 2NlgN     | 2NlgN   |1      |no     |compareTo()       |		
	#        for (int j = i; j > lo && less(a[j], a[j - 1], d); j --) #     |LSD       | 2NW       | 2NW     |N+R    |yes    |charAt()          |		Disadvantage of quicksort.
	#            exch(a, j, j - 1);                                   #     |MSD       | 2NW       | NlogRN  |N+DR   |yes    |charAt()          |       ・Linearithmic number of string compares (not linear).
	#}                                                                #     |          |           |         |       |       |                  |       ・Has to rescan many characters in keys with long prefix matches.
	#private static boolean less(String v, String w, int d) {         #     +-------------------------------------------------------------------+
	#    return v.substring(d).compareTo(w.substring(d)) < 0;         #
    #}                                                                #
    ###################################################################


- 3-way Radix Quicksort
																											#################################################################					
	partition by		partition <s by		partition =s by		partition =e by		                        # private static void sort(String[] a) {                        #
	first char (s)		first char (b)		second char (e)		third char (a)                              #     sort(a, 0, a.length - 1, 0);                              #
	+----------+ 		+---------+			+-----------+		+-----------+		+-----------+           # }                                                             #
	|s|he      |        |b|y      | <s      |are        |		|are        |		|are        |           # private static void sort(String[] a, int lo, int hi, int d) { #
	|s|ells    |        |a|re     |         |by         |		|by         |		|by         |           #     if (hi <= lo)                                             #	3-way partitioning
	|s|eashells|        +---------+         +-----------+		+-----------+		+-----------+           #         return;                                               #	(using dth character)
	|b|y       |        |seashells| =s      |s|e|ashells|		|se|a|shells|=e		|sea|s|hells|=a         #     int lt = lo,                                              #
	|t|he      |        |she      |         |s|h|e      |		|se|l|ls    |		|sea| |     |           #     gt = hi;                                                  #
	|s|ea      |        |seashells|         |s|e|ashells|		|se|a|shells|		|sea|s|hells|           #     int v = charAt(a[lo], d);                                 #  <-- to handle variable-length strings
	|s|hore    |        |sea      |         |s|e|a      |		|se|a|      |		+-----------+           #     int i = lo + 1;                                           #
	|t|he      |        |shore    |         |s|h|ore    |		|se|l|ls    |		|sells      |>a         #     while (i <= gt) {                                         #
	|s|hells   |        |surely   |         |s|u|rely   |		+-----------+		|sells      |           #         int t = charAt(a[i], d);                              #  <-- to handle variable-length strings
	|s|he      |        |shells   |         |s|h|ells   |		|shells     |>e		+-----------+           #         if (t < v)                                            #
	|s|ells    |        |she      |         |s|h|e      |		|she        |		|shells     |           #             exch(a, lt ++, i ++);                             #
	|a|re      |        |sells    |         |s|e|lls    |		|surely     |		|she        |           #          else if (t > v)                                      #
	|s|urely   |        |sells    |         |s|e|lls    |		|shore      |		|surely     |           #             exch(a, i, gt --);                                #
	|s|eashells|        +---------+         +-----------+		|she        |		|shore      |           #          else                                                 #
	+----------+        |the      |>s       |the        |		+-----------+		|she        |           #             i ++;                                             #
	                    |the      |         |the        |		|the        |		+-----------+           #     }                                                         #
                        +---------+         +-----------+		|the        |		|the        |           #     sort(a, lo, lt - 1, d);                                   #
                                            					+-----------+		|the        |           #     if (v >= 0) sort(a, lt, gt, d + 1);                       #  <-- sort 3 subarrays recursively
                                            										+-----------+           #     sort(a, gt + 1, hi, d);                                   #
                                                                                                            # }                                                             #
                                                                                                            #################################################################
	3-way string quicksort vs. standard quicksort									3-way string quicksort vs. MSD string sort
    Standard quicksort.																MSD string sort.
	・Uses ~ 2N ln N string compares on average.	                                    ・Is cache-inefficient.
	・Costly for keys with long common prefixes (and this is a common case!)          ・Too much memory storing count[].                                                                                                
																					・Too much overhead reinitializing count[] and aux[]
	3-way string (radix) quicksort.                                  				
	・Uses ~ 2N ln N character compares on average for random strings.       		3-way string quicksort.         
    ・Avoids re-comparing long common prefixes.                                      ・Has a short inner loop.
                                                                                    ・Is cache-friendly.
                                                                                    ・Is in-place.   

	Summary of the performance of sorting algorithms					
    +-------------------------------------------------------------------+                    
    |algorithm | guarantee | random  |space  |stable?|operations on keys|
    |insertion | ½N^2      | ¼N^2    |1      |yes    |compareTo()       |
    |mergesort | NlgN      | NlgN    |N      |yes    |compareTo()       |
    |quicksort | 1.39NlgN* | 1.39NlgN|clgN   |no     |compareTo()       |
    |heapsort  | 2NlgN     | 2NlgN   |1      |no     |compareTo()       |                    
    |LSD       | 2NW       | 2NW     |N+R    |yes    |charAt()          |                    
    |MSD       | 2NW       | NlogRN  |N+DR   |yes    |charAt()          |                    
    |3way quick| 1.39WNlgR | 1.39NlgN|logN+W |no     |charAt()          |                    
    +-------------------------------------------------------------------+                    
                        
- suffix arrays
- Keyword-in-context search
	Given a text of N characters, preprocess it to enable fast substring search
	(find all occurrences of query string context).
	
	input string							form sufxes								sort sufxes to bring repeated substrings together
	+----------------------------------+    +--------------------------------+      +--------------------------------+		Algorithm					
	|i t w a s b e s t i t  w  a  s  w |    | 0 i t w a s b e s t i t w a s w|      | 3 a s b e s t                  |		・Preprocess: suffix sort the text.
	|0 1 2 3 4 5 6 7 8 9 10 11 12 13 14|    | 1 t w a s b e s t i t w a s w  |      |12 a s w                        |		・Query: binary search for query; scan until mismatch.
	+----------------------------------+    | 2 w a s b e s t i t w a s w    |      | 5 b e s t i t w a s w          |
	                                        | 3 a s b e s t i t w a s w      |      | 6 e s t i t w a s w            |
	                                        | 4 s b e s t i t w a s w        |      |  +---------+                   |
	                                        | 5 b e s t i t w a s w          |      | 0|i t w a s|b e s t i t w a s w|
	                                        | 6 e s t i t w a s w            |      | 9|i t w a s|w                  |
	                                        | 7 s t i t w a s w              |      |  +---------+                   |
	                                        | 8 t i t w a s w                |      | 4 s b e s t i t w a s w        |
	                                        | 9 i t w a s w                  |      | 7 s t i t w a s w              |
	                                        |10 t w a s w                    |      |13 s w                          |
	                                        |11 w a s w                      |      | 8 t i t w a s w                |
	                                        |12 a s w                        |      | 1 t w a s b e s t i t w a s w  |
	                                        |13 s w                          |      |10 t w a s w                    |
	                                        |14 w                            |      |14 w                            |
	                                        +--------------------------------+      | 2 w a s b e s t i t w a s w    |
	                                                                                |11 w a s w                      |
	                                                                                +--------------------------------+
	
- Longest repeated substring
	Given a string of N characters, find the longest repeated substring. 
	
	input string						 form sufxes						sort sufxes to bring repeated substrings together
	+----------------------------------+ +--------------------------------+ +--------------------------------+			#######################################################
	|a a c a a g t t t a c  a  a  g  c | | 0 a a c a a g t t t a c a a g c| | 0 a a c a a g t t t a c a a g c|          # public String lrs(String s) {                       #
	|0 1 2 3 4 5 6 7 8 9 10 11 12 13 14| | 1 a c a a g t t t a c a a g c  | |11 a a g c                      |          #     int N = s.length();                             #
	+----------------------------------+ | 2 c a a g t t t a c a a g c    | | 3 a a g t t t a c a a g c      |          #     String[] suffixes = new String[N];              #
	                                     | 3 a a g t t t a c a a g c      | |  +---------+                   |          #     for (int i = 0; i < N; i ++)                    #  <--create suffixes
	                                     | 4 a g t t t a c a a g c        | | 9|a c a a g|c                  |          #         suffixes[i] = s.substring(i, N);            #		(linear time and space)
	                                     | 5 g t t t a c a a g c          | | 1|a c a a g|t t t a c a a g c  |          #     Arrays.sort(suffixes);                          #  <--sort suffixes
	                                     | 6 t t t a c a a g c            | |  +---------+                   |          #     String lrs = "";                                #	    
	                                     | 7 t t a c a a g c              | |12 a g c                        |          #     for (int i = 0; i < N - 1; i ++) {              #  <--find LCP between
	                                     | 8 t a c a a g c                | | 4 a g t t t a c a a g c        |          #         int len = lcp(suffixes[i], suffixes[i + 1]);#		adjacent suffixes in
	                                     | 9 a c a a g c                  | |14 c                            |          #         if (len > lrs.length())                     #		sorted order
	                                     |10 c a a g c                    | |10 c a a g c                    |          #             lrs = suffixes[i].substring(0, len);    #
	                                     |11 a a g c                      | | 2 c a a g t t t a c a a g c    |          #     }                                               #
	                                     |12 a g c                        | |13 g c                          |          #     return lrs;                                     #
	                                     |13 g c                          | | 5 g t t t a c a a g c          |          # }                                                   #
	                                     +--------------------------------+ | 8 t a c a a g c                |          #######################################################
	                                                                        | 7 t t a c a a g c              |
	                                                                        +--------------------------------+
	Problem. Suffix sorting: worst-case input	
	Bad input: longest repeated substring very long.
	・Ex: same letter repeated N times.
	・Ex: two copies of the same Java codebase.
	+---------------------+		+---------------------+	LRS needs at least 1 + 2 + 3 + ... + D character compares,
	|0 t w i n s t w i n s|		|9|i n s|             | where D = length of longest match.
	|1 w i n s t w i n s  |		|8|i n s|t w i n s    |	Running time. Quadratic (or worse) in D for LRS (and also for sort).
	|2 i n s t w i n s    |		| +-----+             |
	|3 n s t w i n s      |		|7 n s                |
	|4 s t w i n s        |		|6 n s t w i n s      |
	|5 t w i n s          |		|5 s                  |
	|6 w i n s            |		|4 s t w i n s        |
	|7 i n s              |		| +---------+         |
	|8 n s                |		|3|t w i n s|         |
	|9 s                  |		|2|t w i n s|t w i n s|
	+---------------------+		| +---------+         |
								|1|w i n s|           |
								|0|w i n s|t w i n s  |
								+---------------------+

	Solution.
	Suffix sorting in linearithmic time
	Manber-Myers MSD algorithm overview.
	・Phase 0: sort on first character using key-indexed counting sort.
	・Phase i: given array of suffixes sorted on first 2i-1 characters,
	create array of suffixes sorted on first 2i
	characters.
	Worst-case running time. N lg N.
	・Finishes after lg N phases.
	・Can perform a phase in linear time. (!) [ahead]


###############
# week4
###############

###############
# week5
###############
###############
# week6
###############