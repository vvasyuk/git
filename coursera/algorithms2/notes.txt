###############
# week1
###############
- introduction
    Graph. Set of vertices connected pairwise by edges.
    Path. Sequence of vertices connected by edges.
    Cycle. Path whose first and last vertices are the same.
    
    graph             vertex                     edge
    communication     telephone, computer     fiber optic cable

- API
    compute the degree of v                                 compute maximum degree                                  compute average degree                                  count self - loops                                 
    ####################################################    ####################################################    ####################################################    ####################################################
    # public static int degree(Graph G, int v) {       #    # public static int maxDegree(Graph G) {           #    # public static double averageDegree(Graph G) {    #    # public static int numberOfSelfLoops(Graph G) {   #
    #     int degree = 0;                              #    #     int max = 0;                                 #    #     return 2.0 * G.E() / G.V();                  #    #     int count = 0;                               #
    #     for (int w : G.adj(v))                       #    #     for (int v = 0; v < G.V(); v ++)             #    # }                                                #    #     for (int v = 0; v < G.V(); v ++)             #
    #         degree ++;                               #    #         if (degree(G, v) > max)                  #    ####################################################    #         for (int w : G.adj(v))                   #
    #     return degree;                               #    #             max = degree(G, v);                  #                                                            #             if (v == w)                          #
    # }                                                #    #     return max;                                  #                                                            #                 count ++;                        #
    ####################################################    # }                                                #                                                            #     return count / 2; // each edge counted twice #
                                                            ####################################################                                                            # }                                                #
                                                                                                                                                                            ####################################################
    Adjacency-list graph representation
    ############################################    #############################################
    # +--------------------------------------+ #    # public class Graph {                      #
    # | 0| 1| 2| 3| 4| 5| 6| 7| 8| 9|10|11|12| #    #     private final int V;                  #
    # +--------------------------------------+ #    #     private Bag<Integer> [] adj;          #
    #   6  0  0  5  5  3  0  8  7 11  9  9 11  #    #     public Graph(int V) {                 #
    #   2        4  6  4  4       10    12  6  #    #         this.V = V;                       #
    #   7           3  0          12           #    #         adj = (Bag<Integer> [])new Bag[V];#
    #   5                                      #    #         for (int v = 0; v < V; v ++)      #
    ############################################    #             adj[v] = new Bag<Integer>();  #
                                                    #                                           #
                                                    #     }                                     #
                                                    #     public void addEdge(int v, int w) {   #
                                                    #         adj[v].add(w);                    #
                                                    #         adj[w].add(v);                    #
                                                    #     }                                     #
                                                    #     public Iterable<Integer> adj(int v) { #
                                                    #         return adj[v];                    #
                                                    #     }                                     #
                                                    # }                                         #
                                                    #############################################
    
- depth-first search
    
    Algorithm.                                                                                                                              ################################################
    ・Use recursion (ball of string).                                                                                                        # public class DepthFirstPaths {               # 
    ・Mark each visited vertex (and keep track of edge taken to visit it).                                                                   #     private boolean[] marked;                # 
    ・Return (retrace steps) when no unvisited options.                                                                                      #     private int[] edgeTo;                    # 
                                                                                                                                            #     private int s;                           #
    graph                            fin all vertices connected to s                                                                        #     public DepthFirstPaths(Graph G, int s) { #
    ##########################        v    marked[]    edgeTo[v]                                                                            #         //init data structures               #
    # +--------------------+ #        0    T            -           step1 - mark with T (check 6 2 1 5)                                     #         dfs(G, s);                           #
    # | 0| 1| 2| 3| 4| 5| 6| #        1    T            0           step7 - mark with T came from 0 (check 0)                               #     }                                        #
    # +--------------------+ #        2    T            0           step6 - mark with T came from 0 (check 0)                               #     private void dfs(Graph G, int v) {       #
    #   5  0  0  5  5  3  0  #        3    T            5           step5 - mark with T came from 5 (check 5 4)    both 5 4 already visited #         marked[v] = true;                    #
    #   1        4  6  4  4  #        4    T            6           step3 - mark with T came from 6 (check 5 6 3)                           #         for (int w : G.adj(v))               #
    #   2           3  0     #        5    T            4           step4 - mark with T came from 4 (check 3 4 0)                           #             if (!=marked[w]) {                #
    #   6                    #        6    T            0           step2 - mark with T came from 0 (check 0 4)                             #                 dfs(G, w);                   #
    ##########################        7    F            -                                                                                   #                 edgeTo[w] = v;               #
                                                                                                                                            #             }                                #
                                                                                                                                            #     }                                        #
                                                                                                                                            # }                                            #
                                                                                                                                            ################################################

- breadth-first search
    Algorithm                                                                                                                                           ####################################################
    Put s onto a FIFO queue, and mark s as visited.                                                                                                     # public class BreadthFirstPaths {                 #
    Repeat until the queue is empty:                                                                                                                    #     private boolean[] marked;                    #
     - remove the least recently added vertex v                                                                                                         #     private int[] edgeTo;                        #
     - add each of v's unvisited neighbors to the queue,and mark them as visited.                                                                       #     …                                            #
                                                                                                                                                        #     private void bfs(Graph G, int s) {           #
    graph                                                                                                                                               #         Queue<Integer> q = new Queue<Integer>(); #
    #######################     v    edgeTo[v]   distTo[]                                                                                               #         q.enqueue(s);                            #
    # +-----------------+ #     0    -           0           step1 - add 0 to queue (0), deque 0, add 0`s adj`s to queue that are not marked (2 1 5)    #         marked[s] = true;                        #
    # | 0| 1| 2| 3| 4| 5| #     1    0           1           step1                                                                                      #         while (<=q.isEmpty()) {                   #
    # +-----------------+ #     2    0           1           step1                                                                                      #             int v = q.dequeue();                 #
    #   5  0  0  5  2  3  #     3    2           2           step2 - deque 2, add 2`s adj`s to queue (1 5 3)                                            #             for (int w : G.adj(v)) {             #
    #   1     3  4  3  0  #     4    2           2           step1 - add 2`s adj`s to queue (1 5 3 4)                                                   #                 if (<=marked[w]) {                #
    #   2     4  2        #     5    0           1           step1                                                                                      #                     q.enqueue(w);                #
    #######################                                                                                                                             #                     marked[w] = true;            #
                                                                                                                                                        #                     edgeTo[w] = v;               #
    Depth-first search. Put unvisited vertices on a stack.                                                                                              #                 }                                #
    Breadth-first search. Put unvisited vertices on a queue                                                                                             #             }                                    #
                                                                                                                                                        #         }                                        #
                                                                                                                                                        #     }                                            #
                                                                                                                                                        # }                                                #
                                                                                                                                                        ####################################################

- connected components                                                                                          Finding connected components with DFS           Finding connected components with DFS
                                                                                                                ##############################################  ######################################
    Initialize all vertices v as unmarked.                                                                      # public class CC {                          #  # public int count() {               #
    For each unmarked vertex v, run DFS to identify all vertices discovered as part of the same component.      #     private boolean[] marked;              #  #     return count;                  #
                                                                                                                #     private int[] id;                      #  # }                                  #
    ##########################      v    marked[]    cc[]                                                       #     private int count;                     #  # public int id(int v) {             #
    #      +-+               #      0    T           0        1 visit0: check 6 2 1 5 (cc 0)                    #     public CC(Graph G) {                   #  #     return id[v];                  #
    #      |0|--\            #      1    T           0        7 visit1: check 0 (cc 0)                          #         marked = new boolean[G.V()];       #  # }                                  #
    #      +-+-\ ---\        #      2    T           0        6 visit2: check 0 (cc 0)                          #         id = new int[G.V()];               #  # private void dfs(Graph G, int v) { #
    #     / \   --\  ---\    #      3    T           0        5 visit3: check 5 4 (cc 0)                        #         for (int v = 0; v < G.V(); v ++) { #  #     marked[v] = true;              #
    #    |   +-+   +-+   +-+ #      4    T           0        3 visit4: check 5 6 3  (cc 0)                     #             if (!marked[v]) {              #  #     id[v] = count;                 #
    #    /   |1|   |2|   |6| #      5    T           0        4 visit5: check 3 4 0 (cc 0)                      #                 dfs(G, v);                 #  #     for (int w : G.adj(v))         #
    #   |    +-+   +-+   +-+ #      6    T           0        2 visit6: check 0 4 (cc 0)                        #                 count ++;                  #  #         if (<=marked[w])           #
    #   /                /   #                                                                                  #             }                              #  #             dfs(G, w);             #
    #  |      +-+     +-+    #        To visit a vertex v :                                                     #         }                                  #  #                                    #
    #  /    /-|3|-----|4|    #      -Mark vertex v as visited.                                                  #     }                                      #  #                                    # 
    # |   /-  +-+ /---+-+    #      -Recursively visit all unmarked vertices adjacent to v.                     #     public int count()                     #  # }                                  # 
    # +-+-  /-----           #                                                                                  #     public int id(int v)                   #  ######################################
    # |5|---                 #                                                                                  #     private void dfs(Graph G, int v)       #
    # +-+                    #                                                                                  # }                                          #
    ##########################                                                                                  ##############################################

        
- graph challenges
    P1 roblem. Is a graph bipartite?
    bipartite - whose vertices can be divided into two disjoint and independent sets U and V such that every edge connects a vertex in U to one in V.
    solution: dfs
    ##########################        2 Problem. Find cycle - use dfs (0 5 4 6 0)
    #                        #        3 Problem. Bridges of Konigsberg (cycle use every edge once).Yes if all vertices have even degree
    #      +-+               #        4 Find a (general) cycle that uses every edge exactly once.
    #     u|0|--\            #        5 Find a cycle that visits every vertex exactly once. Hamiltonian cycle. hard one
    #      +-+-\ ---\        #        6 Are two graphs identical except for vertex names? graph isomorphism is longstanding open problem. hard one
    #     / \   --\  ---\    #        7 Lay out a graph in the plane without crossing edges? linear-time DFS-based planarity algorithm discovered by Tarjan in 1970s. hard one
    #    |   +-+   +-+   +-+ #
    #    /  v|1|  v|2|  v|6| #
    #   |    +-+   +-+   +-+ #
    #   /      \   /  \  /   #
    #  |        +-+   +-+    #
    #  /       u|3|  u|4|    #
    # |         +-+   +-+    #
    # +-+           /---     #
    #v|5|     /-----         #
    # +-+ ----               #
    ##########################    

- directed graphs
    Digraph. Set of vertices connected pairwise by directed edges.
    
    #############################################    0->5            applications:                                                                              ############################################## 
    #      +-+<-------------      ----<----     #    0->1            Road network                    Vertex = intersection;      edge = one-way street.         # public class Diraph {                      #
    #      |0|<----\         \   /         \    #    0->5            Political blogosphere graph     Vertex = political blog;    edge = link                    #     private final int V;                   #
    #      +-+      +-+       +-+--->+-+    +-+ #    2->0            Overnight interbank loan graph  Vertex = bank;              edge = overnight loan.         #     private final Bag<Integer> [] adj;     #  <-- adj lists
    #     | | +-+   |2|       |6|    |8|    |7| #    2->3            Implication graph               Vertex = variable;          edge = logical implication.    #     public Diraph(int V) {                 #
    #     /  >|1|   +-+       +-+<---+-+    +-+ #    3->5            Combinational circuit           Vertex = logical gate;      edge = wire.                   #         this.V = V;                        #  <-- create empty Diraph with V vertices
    #    |    +-+  /> ^      /   \         /    #    3->2            WordNet graph                   Vertex = synset;            edge = hypernym relationship.  #         adj = (Bag<Integer> [])new Bag[V]; #
    #    /       < /  |     /     \       /     #    4->3            web                             web page                    hyperlink                      #         for (int v = 0; v < V; v ++)       #
    #   /     +-+ /   |    /       >    <-      #    5->4            scheduling                      task                        precedence constraint          #             adj[v] = new Bag<Integer>();   #
    #  |    /-|3|/    |   /         +-+    +--+ #    11->4           financial                       bank                        transaction                    #                                            #
    #  Y  /<  +-+   +-+  /          |9|--->|10| #    11->12          game                            board position              legal move                     #     }                                      #
    # +-+-          |4|<-           +-+<-\ +--+ #    12->9           citation                        journal article             citation                       #     public void addEdge(int v, int w) {    #  <-- add edge v-w
    # |5|>--------->+-+              Y    \   ^ #                    inheritance hierarchy           class                       inherits from                  #         adj[v].add(w);                     #
    # +-+                           +--+   +--| #                    control flow                    code block                  jump                           #                                            #
    #                               |11|---|12| #                                                                                                               #     }                                      #
    #                               +--+   +--+ #                                                                                                               #     public Iterable<Integer> adj(int v) {  #  <-- iterator for vertices adj to v
    #                                           #                                                                                                               #         return adj[v];                     #
    #############################################                                                                                                               #     }                                      #
                                                                                                                                                                # }                                          #
- Adjacency-lists digraph representation                                                                                                                        ##############################################
    #############################################
    # +--------------------------------------+  #
    # | 0| 1| 2| 3| 4| 5| 6| 7| 8| 9|10|11|12|  #
    # +--------------------------------------+  #
    #   5     0  5  3  4  9  6  6 11 12 12  9   #
    #   1     3  2  2     4  8    10            #
    #                     8                     #
    #                     0                     #
    #############################################
    
- digraph search
    Depth-first search in digraphs                                                                                                        Depth-first search in digraphs summary
    ##############################################    Mark v as visited.                                                                    DFS enables direct solution of simple digraph problems.
    # public class DirectedDFS {                 #    Recursively visit all unmarked vertices w pointing from v.                          -Reachability.
    #     private boolean[] marked;              #                                                                                      -Path finding.
    #     public DirectedDFS(Digraph G, int s) { #    Applications:                                                                       -Topological sort.
    #         marked = new boolean[G.V()];       #    Reachability application: program control-flow analysis:                            -Directed cycle detection.
    #         dfs(G, s);                         #        Every program is a digraph.                                                     Basis for solving difficult digraph problems.
    #     }                                      #      -Vertex = basic block of instructions (straight-line program).                   -2-satisfiability. 
    #     private void dfs(Digraph G, int v) {   #      -Edge = jump.                                                                    -Directed Euler path. 
    #         marked[v] = true;                  #                                                                                      -Strongly-connected components.
    #         for (int w : G.adj(v))             #    Reachability application: mark-sweep garbage collector
    #             if (!=marked[w])               #        Every data structure is a digraph.
    #                 dfs(G, w);                 #      -Vertex = object.
    #     }                                      #      -Edge = reference.
    #     public boolean visited(int v) {        #        Roots. Objects known to be directly accessible by program (e.g., stack).
    #         return marked[v];                  #        Reachable objects. Objects indirectly accessible by program
    #     }                                      #
    # }                                          #
    ##############################################

    Breadth-first search in digraphs                                BFS web crawler
    Same method as for undirected graphs.                           ################################################## 
    Put s onto a FIFO queue, and mark s as visited.                 # Queue<String> queue = new Queue<String>();     #  <-- queue of websites to crawl
        Repeat until the queue is empty:                            # SET<String> marked = new SET<String>();        #  <-- set of marked websites
         - remove the least recently added vertex v                 # String root = "http://www.princeton.edu";      #
         - for each unmarked vertex pointing from v:                # queue.enqueue(root);                           #  <-- start crawling from root website
         add to queue and mark as visited.                          # marked.add(root);                              #  
                                                                    # while (<=queue.isEmpty()) {                     #  
    Q. How to implement multi-source shortest paths algorithm?      #     String v = queue.dequeue();                #  <-- read in raw html from nextwebsite in queue
    A. Use BFS, but initialize by enqueuing all source vertices.    #     StdOut.println(v);                         #  
                                                                    #     In in = new In(v);                         #  
                                                                    #     String input = in.readAll();               #  
                                                                    #     String regexp = "http://(\\w+\\.)*(\\w+)"; #  <-- use regular expression to find all URLs in website of form http://xxx.yyy.zzz
                                                                    #     Pattern pattern = Pattern.compile(regexp); #  
                                                                    #     Matcher matcher = pattern.matcher(input);  #  
                                                                    #     while (matcher.find()) {                   #  
                                                                    #         String w = matcher.group();            #  
                                                                    #         if (<=marked.contains(w)) {             #  <-- if unmarked, mark it and put on the queue
                                                                    #             marked.add(w);                     #
                                                                    #             queue.enqueue(w);                  #
                                                                    #         }                                      #
                                                                    #     }                                          #
                                                                    # }                                              #
                                                                    ##################################################
    
- topological sort
    DAG. Directed acyclic graph.
    Topological sort. Redraw DAG so all edges point upwards.
    DAG                                            Topological sort. Redraw DAG so all edges point upwards         algorithm:                              step1  visit0: check 1 2 5     (mark 0)
    ##########################  0->5            ###################################################                -run dfs                                step2  visit1: check 4         (mark 1)
    #      +-+--------\      #  0->1            #             /-------------------------->\       #                -return vertices in reverse postorder   step3  visit4: done            (mark 4)    postorder 4
    #      |0|         \     #  3->5            #            /     /--------------->\      \      #                                                        step4  visit1: done                        postorder 4 1
    #    />+-+----\     \    #  5->2            #           /     //-------->\       \      \     #                                                        step5  visit2: done            (mark 2)    postorder 4 1 2
    #    |  \>     >     >   #  6->0            # +-+    +-+    +-+    +-+    +-+     +-+    +-+  #                                                        step6  visit5: done            (mark 5)    postorder 4 1 2 5
    #    |   +-+   +-+   +-+ #  1->4            # |3|--->|6|--->|0|--->|5|--->|2|     |1|--->|4|  #                                                        step7  visit0: done                        postorder 4 1 2 5 0
    #    /   |2|   |5|   |1| #  0->2            # +-+    +-+    +-+    +-+    +-+     +-+    +-+  #                                                        step8  visit3: check 6         (mark 3)
    #   |    +-+  >+-+   +-+ #  3->6            # \\\\->/             /      /              /     #                                                        step9  visit6: done            (mark 6)    postorder 4 1 2 5 0 6
    #   /     ^  /         | #  3->4            #  \\\-------------->/      /              /      #                                                        step10 visit3: done                        postorder 4 1 2 5 0 6 3
    #  |      +-+     +-+  / #  6->4            #   \\-------------------->/              /       #                                                     
    #  /     /|3|---->|4|</  #  3->2            #    \---------------------------------->/        #                                                     
    # |     / +-+     +-+    #                  #                                                 #
    # +-+<-/         ^       #                  ###################################################                                                     
    # |6|-----------/        #  
    # +-+                    #  
    ##########################  
    
    Depth-first search order
    ################################################    applications:
    # public class DepthFirstOrder {               #    Directed cycle detection application: precedence scheduling
    #     private boolean[] marked;                #    Directed cycle detection application: cyclic inheritance (The Java compiler does cycle detection.)
    #     private Stack<Integer> reversePost;      #    Directed cycle detection application: spreadsheet recalculation (Microsoft Excel does cycle detection (and has a circular reference toolbar<=))
    #     public DepthFirstOrder(Digraph G) {      #
    #         reversePost = new Stack<Integer>();  #
    #         marked = new boolean[G.V()];         #
    #         for (int v = 0; v < G.V(); v ++)     #
    #             if (!marked[v])                  #
    #                 dfs(G, v);                   #
    #     }                                        #
    #     private void dfs(Digraph G, int v) {     #
    #         marked[v] = true;                    #
    #         for (int w : G.adj(v))               #
    #             if (!marked[w])                  #
    #                 dfs(G, w);                   #
    #         reversePost.push(v);                 #
    #     }                                        #
    #     public Iterable<Integer> reversePost() { #
    #         return reversePost;                  #  <--returns all vertices in 
    #     }                                        #     “reverse DFS postorder”
    # }                                            #
    ################################################
    
- strong components
    Vertices v and w are strongly connected if there is both a directed path from v to w and a directed path from w to v.
    -If v is strongly connected to w, then w is strongly connected to v.
    -If v is strongly connected to w and w to x, then v is strongly connected to x.
    A strong component is a maximal subset of strongly-connected vertices.
    
    Kosaraju-Sharir algorithm: intuition                                Phase 1. Compute reverse postorder in GR.
    Reverse graph. Strong components in G are same as in GR.            Phase 2. Run DFS in G, visiting unmarked vertices in reverse postorder of GR.
    Kernel DAG. Contract each strong component into a single vertex.                                                                                             reverse 1 0 2 4 5 3 11 9 12 10 6 7 8
    Idea.                                                                phase1:                                                                                 phase2 (run dfs visiting reverse vertices)
    ・Compute topological order (reverse postorder) in kernel DAG.        step1  visit0:     check 6 2       (mark 0)                                             step1  visit1:     done          (scc 0)
    ・Run DFS, considering vertices in reverse topological order.         step2  visit6:     check 8 7       (mark 6)                                             step2  visit0:     check 5        (scc 1)
    #############################################                        step3  visit8:     done            (mark 8)    reverse 8                                step3  visit5:     check 4        (scc 1)
    #      +-+------->------      ---->----     #                        step4  visit6:     check 7                                                              step4  visit4:     check 3 2    (scc 1)
    #   /->|0|----\         \    /         \    #                        step5  visit7:     done            (mark 7)    reverse 7 8                              step5  visit3:    check 5 2    (scc 1)
    #  |   +-+     >+-+      >+-+--->+-+    +-+ #                        step5, visit6:     done                        reverse 6 7 8                            step6  visit2:     check 0        (scc 1)
    #  |    | +-+   |2|       |6|    |8|    |7| #                        step6  visit2:     check 4 3       (mark 2)                                             step6  visit2:     done
    #  |     <|1|   +-+     />+-+<---+-+  />+-+ #                        step7  visit4:     check 11 6 5    (mark 4)                                             step7  visit3:  done
    #  |      +-+  /> |    /     ^       /      #                        step8  visit11:    check 9         (mark 11)                                            step8  visit4:  done
    #  |         <//  |   /       \     /       #                        step9  visit9:     check 12 7 6    (mark 9)                                             step9  visit5:    done
    #  |      +-+ /   |  /         \   /        #                        step10 visit12:    check 10 11     (mark 12)                                            step10 visit0:  done
    #  |   /->|3|/    Y /           +-+    +--+ #                        step11 visit10:    done            (mark 10)    reverse 10 6 7 8                        step11 visit11:    check 4 12    (scc 2)
    #  |  /   +-+\->+-+/            |9|<---|10| #                        step12 visit12:    done                         reverse 12 10 6 7 8                     step12 visit12:    check 9        (scc 2)
    # +-+-          |4|             +-+\   +--+ #                        step13 visit9:     done                         reverse 9 12 10 6 7 8                   step13 visit9:     check 10 11    (scc 2)
    # |5|<--------- +-+\             ^  \     ^ #                        step14 visit11:    done                         reverse 11 9 12 10 6 7 8                step14 visit10:    check 12    (scc 2)
    # +-+               \           +--+ \>+--| #                        step15 visit4:     check 5                                                              step15 visit10:    done
    #                    \--------->|11|<--|12| #                        step16 visit5:     check 3 0       (mark 5)                                             step16 visit9:     done
    #                               +--+   +--+ #                        step17 visit3:     done            (mark 3)     reverse 3 11 9 12 10 6 7 8              step17 visit12: done
    #                                           #                        step18 visit5:     done                         reverse 5 3 11 9 12 10 6 7 8            step18 visit11: done
    #############################################                        step19 visit4:     done                         reverse 4 5 3 11 9 12 10 6 7 8          step19 visit6:     check 8        (scc 3)
                                                                         step20 visit2:     done                         reverse 2 4 5 3 11 9 12 10 6 7 8        step20 visit8:     check 6        (scc 3)
                                                                         step21 visit0:     done                         reverse 0 2 4 5 3 11 9 12 10 6 7 8      step21 visit8:     done
                                                                         step22 visit1:     done                         reverse 1 0 2 4 5 3 11 9 12 10 6 7 8    step22 visit6:     done
                                                                                                                                                                 step23 visit 7: done        (scc 4)
    Strong components in a digraph (with two DFSs)
    ####################################################################
    # public class KosarajuSharirSCC {                                 #
    #     private boolean marked[];                                    #
    #     private int[] id;                                            #
    #     private int count;                                           #
    #     public KosarajuSharirSCC(Digraph G) {                        #
    #         marked = new boolean[G.V()];                             #
    #         id = new int[G.V()];                                     #
    #         DepthFirstOrder dfs = new DepthFirstOrder(G.reverse());  #
    #         for (int v : dfs.reversePost()) {                        #
    #             if (!=marked[v]) {                                   #
    #                 dfs(G, v);                                       #
    #                 count ++;                                        #
    #             }                                                    #
    #         }                                                        #
    #     }                                                            #
    #     private void dfs(Digraph G, int v) {                         #
    #         marked[v] = true;                                        #
    #         id[v] = count;                                           #
    #         for (int w : G.adj(v))                                   #
    #             if (!=marked[w])                                     #
    #                 dfs(G, w);                                       #
    #     }                                                            #
    #     public boolean stronglyConnected(int v, int w) {             #
    #         return id[v] == id[w];                                   #
    #     }                                                            #
    # }                                                                #
    #                                                                  #
    ####################################################################
 
###############
# week2
###############

- MSTs
    A spanning tree of G is a subgraph T that is both a tree (connected and acyclic) 
    and spanning (includes all of the vertices).                                                    
    ###############################################################################        MST is fundamental problem with diverse applications.
    #                                          0.29                               #     -Dithering.                                  -Find road networks in satellite and aerial imagery.
    #                                  ┌·················┐                        #     -Cluster analysis.                           -Reducing data storage in sequencing amino acids in a protein. 
    #                                  :                 :                        #     -Max bottleneck paths.                       -Model locality of particle interactions in turbulent fluid flows. 
    #              ╔═══════╗  0.32   ╔═══════╗         ╔═══════╗                  #     -Real-time face verification.                -Autoconfig protocol for Ethernet bridging to avoid cycles in a network. 
    #           ┌─ ║   5   ║ ······· ║   1   ║ ·┐      ║   3   ║ ···············┐ #     -LDPC codes for error correction.            -Approximation algorithms for NP-hard problems (e.g., TSP, Steiner tree).
    #           │  ╚═══════╝         ╚═══════╝  :      ╚═══════╝                : #     -Image registration with Renyi entropy.      -Network design (communication, electrical, hydraulic, computer, road). 
    #           │    │                 │        :        │                      : #
    #           │    │ 0.28            │ 0.19   : 0.36   │ 0.17                 : #
    #           │    │                 │        :        │                      : #
    #           │    │      ╔═══════╗  │        :      ╔═══════╗                : #
    #           │    └───── ║       ║ ─┘        └····· ║       ║                : #
    #           │           ║       ║                  ║       ║                : #
    #           │           ║       ║          0.34    ║       ║                : #
    #           │           ║   7   ║ ················ ║   2   ║                : #
    #           │           ║       ║                  ║       ║                : #
    #           │           ║       ║          0.26    ║       ║                : #
    #  ┌········┼·········· ║       ║  ┌────────────── ║       ║ ──────┐        : #
    #  :        │           ╚═══════╝  │               ╚═══════╝       │        : #
    #  :        │             │      ╔═══════╗  0.58                   │        : #
    #  : 0.37   │             └───── ║   0   ║ ···················┐    │ 0.40   : #
    #  :        │                    ╚═══════╝                    :    │        : #
    #  :      ╔═══╗  0.93              :                        ╔═══╗  │        : #
    #  └····· ║ 4 ║ ···················┼······················· ║ 6 ║ ─┘        : #
    #         ╚═══╝                    :                        ╚═══╝           : #
    #           :   0.38               :                          :   0.52      : #
    #           └······················┘                          └·············┘ #
    #                                                                             #
    ###############################################################################


- Greedy algorithms
    Greedy MST                                                                          cut graph into 2 partition [0 1 4 5 7] and [2 3 6]                                  divide graph into 2 partition [5] and [1 7 4 ...]                                                    
    -Start with all edges colored gray.                                                 find cut between 2 partitions with min weight and paint it black                    find cut between 2 partitions with min weight and paint it black                                    
    -Find cut with no black crossing edges; color its min-weight edge black.            min cut is 0 2 among ([1 3],[0 2],[2 7],[1 2],[6 9],[6 4])                          min cut is 5 7 
    -Repeat until V - 1 edges are colored black.                                        MST 0 2,                                                                            MST [0 2], [5 7]
    ###############################################################################     ###############################################################################     ###############################################################################
    #                                          0.29                               #     #                                          0.29                               #     #                                          0.29                               #
    #                                  ┌·················┐                        #     #                                  ┌·················┐                        #     #                                  ┌·················┐                        #
    #                                  :                 :                        #     #                                  :                 :                        #     #                                  :                 :                        #
    #              ┌───────┐  0.32   ┌───────┐         ┌───────┐                  #     #              ╔═══════╗  0.32   ╔═══════╗         ┌───────┐                  #     #              ╔═══════╗  0.32   ┌───────┐         ┌───────┐                  #
    #           ┌· │   5   │ ······· │   1   │ ·┐      │   3   │ ···············┐ #     #           ┌· ║   5   ║ ······· ║   1   ║ ·┐      │   3   │ ···············┐ #     #           ┌· ║   5   ║ ······· │   1   │ ·┐      │   3   │ ···············┐ #
    #           :  └───────┘         └───────┘  :      └───────┘                : #     #           :  ╚═══════╝         ╚═══════╝  :      └───────┘                : #     #           :  ╚═══════╝         └───────┘  :      └───────┘                : #
    #           :    :                 :        :        :                      : #     #           :    :                 :        :        :                      : #     #           :    │                 :        :        :                      : #
    #           :    : 0.28            : 0.19   : 0.36   : 0.17                 : #     #           :    : 0.28            : 0.19   : 0.36   : 0.17                 : #     #           :    │ 0.28            : 0.19   : 0.36   : 0.17                 : #
    #           :    :                 :        :        :                      : #     #           :    :                 :        :        :                      : #     #           :    │                 :        :        :                      : #
    #           :    :      ┌───────┐  :        :      ┌───────┐                : #     #           :    :      ╔═══════╗  :        :      ┌───────┐                : #     #           :    │      ╔═══════╗  :        :      ╔═══════╗                : #
    #           :    └····· │       │ ·┘        └····· │       │                : #     #           :    └····· ║       ║ ·┘        └····· │       │                : #     #           :    └───── ║       ║ ·┘        └····· ║       ║                : #
    #           :           │       │                  │       │                : #     #           :           ║       ║                  │       │                : #     #           :           ║       ║                  ║       ║                : #
    #           :           │       │          0.34    │       │                : #     #           :           ║       ║          0.34    │       │                : #     #           :           ║       ║          0.34    ║       ║                : #
    #           :           │   7   │ ················ │   2   │                : #     #           :           ║   7   ║ ················ │   2   │                : #     #           :           ║   7   ║ ················ ║   2   ║                : #
    #           :           │       │                  │       │                : #     #           :           ║       ║                  │       │                : #     #           :           ║       ║                  ║       ║                : #
    #           :           │       │          0.26    │       │                : #     #           :           ║       ║          0.26    │       │                : #     #           :           ║       ║          0.26    ║       ║                : #
    #  ┌········┼·········· │       │  ┌·············· │       │ ······┐        : #     #  ┌········┼·········· ║       ║  ┌────────────── │       │ ······┐        : #     #  ┌········┼·········· ║       ║  ┌────────────── ║       ║ ······┐        : #
    #  :        :           └───────┘  :               └───────┘       :        : #     #  :        :           ╚═══════╝  │               └───────┘       :        : #     #  :        :           ╚═══════╝  │               ╚═══════╝       :        : #
    #  :        :             :      ┌───────┐  0.58                   :        : #     #  :        :             :      ╔═══════╗  0.58                   :        : #     #  :        :             :      ╔═══════╗  0.58                   :        : #
    #  : 0.37   :             └····· │   0   │ ···················┐    : 0.40   : #     #  : 0.37   :             └····· ║   0   ║ ···················┐    : 0.40   : #     #  : 0.37   :             └····· ║   0   ║ ···················┐    : 0.40   : #
    #  :        :                    └───────┘                    :    :        : #     #  :        :                    ╚═══════╝                    :    :        : #     #  :        :                    ╚═══════╝                    :    :        : #
    #  :      ┌───┐  0.93              :                        ┌───┐  :        : #     #  :      ╔═══╗  0.93              :                        ┌───┐  :        : #     #  :      ┌───┐  0.93              :                        ┌───┐  :        : #
    #  └····· │ 4 │ ···················┼······················· │ 6 │ ·┘        : #     #  └····· ║ 4 ║ ···················┼······················· │ 6 │ ·┘        : #     #  └····· │ 4 │ ···················┼······················· │ 6 │ ·┘        : #
    #         └───┘                    :                        └───┘           : #     #         ╚═══╝                    :                        └───┘           : #     #         └───┘                    :                        └───┘           : #
    #           :   0.38               :                          :   0.52      : #     #           :   0.38               :                          :   0.52      : #     #           :   0.38               :                          :   0.52      : #
    #           └······················┘                          └·············┘ #     #           └······················┘                          └·············┘ #     #           └······················┘                          └·············┘ #
    #                                                                             #     #                                                                             #     #                                                                             #
    ###############################################################################     ###############################################################################     ###############################################################################

    divide graph into 2 partition [6] and [3 2 0 4...]
    MST [0 2], [5 7], [6 2]
    divide graph into 2 partition [5 7 1 3] and [4 0 2 6]
    MST [0 2], [5 7], [6 2], [7 0]
    divide graph into 2 partition [5 7 0 2 6 4] and [1 3]
    MST [0 2], [5 7], [6 2], [7 0], [3 2]
    divide graph into 2 partition [5 7 0 2 6 3] and [1 4]
    MST [0 2], [5 7], [6 2], [7 0], [3 2], [1 7]
    divide graph into 2 partition [5 7 0 2 6 3 1] and [4]
    MST [0 2], [5 7], [6 2], [7 0], [3 2], [1 7], [4 5]    

- Edge-Weighed Graph API
    Add Edge class                                                                      Edge-weighted graph
    ####################################################   either            other      ###########################################
    # public class Edge implements Comparable<Edge> {  #    +-+    weight    +-+        # public class EdgeWeightedGraph {        #
    #     private final int v,                         #    |v|--------------|w|        #     private final int V;                #
    #     w;                                           #    +-+              +-+        #     private final Bag<Edge> [] adj;     #
    #     private final double weight;                 #                                #     public EdgeWeightedGraph(int V) {   #
    #     public Edge(int v, int w, double weight) {   #                                #         this.V = V;                     #
    #         this.v = v;                              #                                #         adj = (Bag<Edge> [])new Bag[V]; #
    #         this.w = w;                              #                                #         for (int v = 0; v < V; v ++)    #
    #         this.weight = weight;                    #                                #             adj[v] = new Bag<Edge>();   #
    #     }                                            #                                #     }                                   #
    #     public int either() {                        #                                #     public void addEdge(Edge e) {       #
    #         return v;                                #    <-- either endpoint         #         int v = e.either(),             #
    #     }                                            #                                #         w = e.other(v);                 #
    #     public int other(int vertex) {               #    <-- other endpoint          #         adj[v].add(e);                  #
    #         if (vertex == v)                         #                                #         adj[w].add(e);                  #
    #             return w;                            #                                #     }                                   #
    #          else                                    #                                #     public Iterable<Edge> adj(int v) {  #
    #             return v;                            #                                #         return adj[v];                  #
    #     }                                            #                                #     }                                   #
    #     public int compareTo(Edge that) {            #                                # }                                       #
    #         if (this.weight < that.weight)           #                                ###########################################
    #             return -1;                           #
    #          else if (this.weight > that.weight)     #
    #             return + 1;                          #
    #          else                                    #
    #             return 0;                            #
    #     }                                            #
    # }                                                #
    ####################################################
    
- Kruskal's Algorithm
    Consider edges in ascending order of weight.
    -Add next edge to tree T unless doing so would create a cycle.                        sorted wights                                                Kruskal's Algorithm
    ###############################################################################        0-7 0.16            step1  no cycle - add                   #############################################################
    #                                          0.29<=(6)                          #        2-3 0.17            step2  no cycle - add                   # public class KruskalMST {                                 #
    #                                  ┌·················┐                        #        1-7 0.19            step3  no cycle - add                   #     private Queue<Edge> mst = new Queue<Edge>();          #
    #                                  :                 :                        #        0-2 0.26            step4  no cycle - add                   #     public KruskalMST(EdgeWeightedGraph G) {              #
    #              ╔═══════╗0.32<=(7)╔═══════╗         ╔═══════╗                  #        5-7 0.28            step5  no cycle - add                   #         MinPQ<Edge> pq = new MinPQ<Edge>();               #  <-- build priority queue
    #           ┌─ ║   5   ║ ······· ║   1   ║ ·┐      ║   3   ║ ···············┐ #        1-3 0.29            step6  cycle - no add                   #         for (Edge e : G.edges())                          #
    #           │  ╚═══════╝         ╚═══════╝  :      ╚═══════╝                : #        1-5 0.32            step7  cycle - no add                   #             pq.insert(e);                                 #
    #           │    │                 │        :        │                      : #        2-7 0.34            step8  cycle - no add                   #                                                           #
    #           │    │0.28(4)          │0.19(3) :0.36<=10│ 0.17(2)              : #        4-5 0.35            step9  no cycle - add                   #         UF uf = new UF(G.V());                            #
    #           │    │                 │        :        │                      : #        1-2 0.36            step10 cycle - no add                   #         while (!pq.isEmpty() && mst.size() < G.V() - 1) { #
    #           │    │      ╔═══════╗  │        :      ╔═══════╗                : #        4-7 0.37            step11 cycle - no add                   #             Edge e = pq.delMin();                         #
    #           │    └───── ║       ║ ─┘        └····· ║       ║                : #        0-4 0.38            step12 cycle - no add                   #             int v = e.either(),                           #  <-- greedily add edges to MST
    #           │           ║       ║                  ║       ║                : #        6-2 0.40            step13 no cycle - add    MST is ready   #             w = e.other(v);                               #
    #           │0.35(9)    ║       ║      0.34<=(8)   ║       ║                : #        3-6 0.52                                                    #             if (!uf.connected(v, w)) {                    #  <-- edge v-w does not create a cycle
    #           │           ║   7   ║ ················ ║   2   ║                : #        6-0 0.58                                                    #                 uf.union(v, w);                           #  <-- merge sets
    #           │           ║       ║                  ║       ║                : #        6-4 0.93                                                    #                 mst.enqueue(e);                           #  <-- add edges to MST
    #           │           ║       ║       0.26(4)    ║       ║                : #                                                                    #             }                                             #
    #  ┌········┼·········· ║       ║  ┌────────────── ║       ║ ──────┐        : #                                                                    #         }                                                 #
    #  :        │           ╚═══════╝  │               ╚═══════╝       │        : #                                                                    #     }                                                     #
    #  :        │             │      ╔═══════╗  0.58                   │        : #                                                                    #     public Iterable<Edge> edges() {                       #
    #  :0.37<=11│             └───── ║   0   ║ ···················┐    │0.40(13): #                                                                    #         return mst;                                       #
    #  :        │            0.16(1) ╚═══════╝                    :    │        : #                                                                    #     }                                                     #
    #  :      ╔═══╗  0.93              :                        ╔═══╗  │        : #                                                                    # }                                                         #
    #  └····· ║ 4 ║ ···················┼······················· ║ 6 ║ ─┘        : #                                                                    #############################################################
    #         ╚═══╝                    :                        ╚═══╝           : #
    #           :   0.38<=12           :                          :   0.52      : #
    #           └······················┘                          └·············┘ #
    #                                                                             #
    ###############################################################################    
    
- Prim's Algorithm
    ・Start with vertex 0 and greedily grow tree T.
    ・Add to T the min weight edge with exactly one endpoint in T.
    ・Repeat until V - 1 edges.                                                                                      min-PQ        MST
    ###############################################################################     add edges of 0 to min PQ    0-7           0-7
    #                                          0.29                               #     add edges of 7 to min PQ    1-7           0-7 1-7
    #                                  ┌·················┐                        #     add edges of 1 to min PQ    0-2           0-7 1-7 0-2
    #                                  :                 :                        #     add edges of 2 to min PQ    2-3           0-7 1-7 0-2 2-3
    #              ╔═══════╗0.32     ╔═══════╗         ╔═══════╗                  #     add edges of 3 to min PQ    5-7           0-7 1-7 0-2 2-3 5-7
    #           ┌─ ║   5   ║ ······· ║   1   ║ ·┐      ║   3   ║ ···············┐ #     add edges of 5 to min PQ    5-4           0-7 1-7 0-2 2-3 5-7 5-4
    #           │  ╚═══════╝         ╚═══════╝  :      ╚═══════╝                : #     add edges of 4 to min PQ    6-2           0-7 1-7 0-2 2-3 5-7 5-4 6-2
    #           │    │                 │        :        │                      : #     
    #           │    │0.28(5)          │0.19(2) :0.36    │ 0.17(4)              : #     #############################################################
    #           │    │                 │        :        │                      : #     # public class LazyPrimMST {                                #
    #           │    │      ╔═══════╗  │        :      ╔═══════╗                : #     #     private boolean[] marked;     // MST vertices         #
    #           │    └───── ║       ║ ─┘        └····· ║       ║                : #     #     private Queue<Edge> mst;         // MST edges         #
    #           │           ║       ║                  ║       ║                : #     #     private MinPQ<Edge> pq;         // PQ of edges        #
    #           │0.35(6)    ║       ║      0.34        ║       ║                : #     #     public LazyPrimMST(WeightedGraph G) {                 #
    #           │           ║   7   ║ ················ ║   2   ║                : #     #         pq = new MinPQ<Edge>();                           #
    #           │           ║       ║                  ║       ║                : #     #         mst = new Queue<Edge>();                          #
    #           │           ║       ║       0.26(3)    ║       ║                : #     #         marked = new boolean[G.V()];                      #
    #  ┌········┼·········· ║       ║  ┌────────────── ║       ║ ──────┐        : #     #         visit(G, 0);                                      #  <-- assume G is connected
    #  :        │           ╚═══════╝  │               ╚═══════╝       │        : #     #         while (<=pq.isEmpty() && mst.size() < G.V() - 1) {#
    #  :        │             │      ╔═══════╗  0.58                   │        : #     #             Edge e = pq.delMin();                         #  <-- repeatedly delete the min weight edge e = v–w from PQ
    #  :0.37    │             └───── ║   0   ║ ···················┐    │0.40(7  : #     #             int v = e.either(),                           #
    #  :        │            0.16(1) ╚═══════╝                    :    │        : #     #             w = e.other(v);                               #
    #  :      ╔═══╗  0.93              :                        ╔═══╗  │        : #     #             if (marked[v] && marked[w]) continue;         #  <-- ignore if both endpoints in T
    #  └····· ║ 4 ║ ···················┼······················· ║ 6 ║ ─┘        : #     #                                                           #
    #         ╚═══╝                    :                        ╚═══╝           : #     #             mst.enqueue(e);                               #  <-- add edge e to tree
    #           :   0.38               :                          :   0.52      : #     #             if (<=marked[v]) visit(G, v);                 #  <-- add v or w to tree
    #           └······················┘                          └·············┘ #     #             if (<=marked[w]) visit(G, w);                 #
    #                                                                             #     #         }                                                 #
    ###############################################################################     #     }                                                     #
                                                                                        #     private void visit(WeightedGraph G, int v) {          #
                                                                                        #         marked[v] = true;                                 #  <-- add v to T
                                                                                        #         for (Edge e : G.adj(v))                           #
                                                                                        #             if (<=marked[e.other(v)])                     #
                                                                                        #                 pq.insert(e);                             #  <-- for each edge e = v–w, add to PQ if w not already in T
                                                                                        #     }                                                     #
                                                                                        #     public Iterable<Edge> mst() {return mst;}             #
                                                                                        # }                                                         #
                                                                                        #############################################################

- Prim's Algorithm (eager)
    step1: MST 0-7                  step2: MST 0-7 1-7          step3: MST 0-7 1-7 0-2
    add vertices 7 2 4 6 to PQ      add vertices 1 5 to PQ      add vertices 3 to PQ
    v     edgeTo[]     distTo[]     v     edgeTo[]     distTo[] v     edgeTo[]     distTo[]
    0     -             -           0     -            -        0     -            -
    7     0–7         0.16          *1    1–7          0.19     2     0–2          0.26
    2     0–2         0.26          2     0–2          0.26     5     5-7          0.28
    4     0–4         0.38          *5    5-7          0.28     3     1-3          0.29
    6     6–0         0.58          4     0–4          0.38     4     0–4          0.38
                                    6     6–0          0.58     6     6–0          0.58 
                                    not adding 7-4 7-2          not adding 3-6 3-2

- Shortest Paths APIs                                                                       DirectedEdge                                                    representation
    #################################################################################       ###########################################################     ###############################     ###################################################
    #  ┌·········································································┐  #       # public class DirectedEdge {                             #     # +-+    +--------++--------+ #     # public class EdgeWeightedDigraph {              #
    #  :                                                                         :  #       #     private final int v,                                #     # |0|--->|0-2 0.26||0-4 0.38| #     #     private final int V;                        #
    #  :            0.35    ┌───────┐  0.32   ┌───┐  0.29   ┌───┐  0.52          :  #       #     w;                                                  #     # +-+    +--------++--------+ #     #     private final Bag<DirectedEdge> [] adj;     #
    #  :        ┌··········>│   5   │ ······> │ 1 │ ······> │ 3 │ ··········┐    :  #       #     private final double weight;                        #     # |1|--->...                  #     #     public EdgeWeightedDigraph(int V) {         #
    #  :        :           └───────┘         └───┘         └───┘           :    :  #       #     public DirectedEdge(int v, int w, double weight) {  #     # +-+                         #     #         this.V = V;                             #
    #  : 0.93   :             ^                               ^             :    :  #       #         this.v = v;                                     #     # |2|--->...                  #     #         adj = (Bag<DirectedEdge> [])new Bag[V]; #
    #  :        :             : 0.28                          :             :    :  #       #         this.w = w;                                     #     # +-+                         #     #         for (int v = 0; v < V; v ++)            #
    #  :        v             v                               :             :    :  #       #         this.weight = weight;                           #     ###############################     #             adj[v] = new Bag<DirectedEdge>();   #
    #  :      ┌───┐  0.37   ┌───────┐  0.39                   :             :    :  #       #     }                                                   #                                         #     }                                           #
    #  └····> │ 4 │ ······> │   7   │ ························┘             :    :  #       #     public int from() {                                 #                                         #     public void addEdge(DirectedEdge e) {       #
    #         └───┘         └───────┘                                       :    :  #       #         return v;                                       #                                         #         int v = e.from();                       #  <-- add edgle e=b-w to
    #           ^             ^                                             :    :  #       #     }                                                   #                                         #         adj[v].add(e);                          #      only v`s adj list
    #           :             : 0.34                                        :    :  #       #     public int to() {                                   #                                         #     }                                           #
    #           :             :                                             v    :  #       #         return w;                                       #                                         #     public Iterable<DirectedEdge> adj(int v) {  #
    #           :           ┌───────┐                             0.40    ┌───┐  :  #       #     }                                                   #                                         #         return adj[v];                          #
    #           :           │   2   │ <·································· │ 6 │ ·┘  #       #     public int weight() {                               #                                         #     }                                           #
    #           :           └───────┘                                     └───┘     #       #         return weight;                                  #                                         # }                                               #
    #           :             ^                                             :       #       #     }                                                   #                                         ###################################################
    #           :             : 0.26                                        :       #       # }                                                       #
    #           :             :                                             :       #       ###########################################################
    #           :   0.38    ┌───────┐          0.58                         :       #
    #           └·········· │   0   │ <·····································┘       #
    #                       └───────┘                                               #
    #################################################################################
    
    Find the shortest path from s to every other vertex.               #########################################################################
     edgeTo[]    distTo[]                                              # public double distTo(int v) {                                         #
     0           null          0                                       #     return distTo[v];                                                 #
     1           5->1 0.32     1.05                                    # }                                                                     #
     2           0->2 0.26     0.26                                    # public Iterable<DirectedEdge> pathTo(int v) {                         #
     3           7->3 0.37     0.97                                    #     Stack<DirectedEdge> path = new Stack<DirectedEdge>();             #
     4           0->4 0.38     0.38                                    #     for (DirectedEdge e = edgeTo[v]; e <== null; e = edgeTo[e.from()])#
     5           4->5 0.35     0.73                                    #         path.push(e);                                                 #
     6           3->6 0.52     1.49                                    #     return path;                                                      #
     7           2->7 0.34     0.60                                    # }                                                                     #
                                                                       #########################################################################

    Edge relaxation
    Relax edge e = v→w.                                                                     #################################################
    - distTo[v] is length of shortest known path from s to v.                               # private void relax(DirectedEdge e) {          # 
    - distTo[w] is length of shortest known path from s to w.                               #     int v = e.from(),                         # 
    - edgeTo[w] is last edge on shortest known path from s to w.                            #     w = e.to();                               # 
    - If e = v→w gives shorter path to w through v, update both distTo[w] and edgeTo[w].    #     if (distTo[w] > distTo[v] + e.weight()) { # 
                                                                                            #         distTo[w] = distTo[v] + e.weight();   #
                                                                                            #         edgeTo[w] = e;                        #
                                                                                            #     }                                         #
                                                                                            # }                                             #
                                                                                            #################################################

    Optimality conditions
    distTo array represents shortest path distances from source if nelow 2 conditions hold
    -For each vertex v, distTo[v] is the length of some path from s to v.
    -For each edge e = v→w, distTo[w] ≤ distTo[v] + e.weight().
    Proof
    -Suppose that distTo[w] > distTo[v] + e.weight() for some edge e = v→w.
    -Then, e gives a path from s to w (through v) of length less than distTo[w].    

    Generic shortest-paths algorithm
    Generic algorithm (to compute SPT from s)
    Initialize distTo[s] = 0 and distTo[v] = ∞ for all other vertices.
    Repeat until optimality conditions are satisfied:
        - Relax any edge.


- Dijkstra's Algorithm
    -Consider vertices in increasing order of distance from s
    (non-tree vertex with the lowest distTo[] value).
    -Add vertex to tree and relax all edges pointing from that vertex.              SPT
    ############################################################################    ###########################################################################     ########################################################    #################################################
    #                         ╔════╗        15    ╔════╗                       #    #                         ╔════╗        15    ╔════╗                      #     #public class DijkstraSP {                             #    # private void relax(DirectedEdge e) {          #
    #                         ║    ║ ···········> ║ 3  ║ ········┐             #    #                         ║    ║ ···········> ║ 3  ║ ········┐            #     #    private DirectedEdge[] edgeTo;                    #    #     int v = e.from(),                         #
    #                         ║ 1  ║              ╚════╝         :             #    #                         ║ 1  ║              ╚════╝         :            #     #    private double[] distTo;                          #    #     w = e.to();                               #
    # ╔══════════╗       5    ║    ║  12            ^            :             #    # ╔══════════╗       5    ║    ║  12            ^            :            #     #    private IndexMinPQ<Double> pq;                    #    #     if (distTo[w] > distTo[v] + e.weight()) { #
    # ║    0     ║ ·········> ║    ║ ········┐      : 3          :             #    # ║    0     ║ ─────────> ║    ║ ········┐      │ 3          :            #     #    public DijkstraSP(EdgeWeightedDigraph G, int s) { #    #         distTo[w] = distTo[v] + e.weight();   #
    # ╚══════════╝            ╚════╝         :      :            :             #    # ╚══════════╝            ╚════╝         :      │            :            #     #        edgeTo = new DirectedEdge[G.V()];             #    #         edgeTo[w] = e;                        #
    #   :     :                 :            :    ╔════╗         :             #    #   │     │                 :            :    ╔════╗         :            #     #        distTo = new double[G.V()];                   #    #         if (pq.contains(w))                   #
    #   :     : 8               : 4          └··> ║    ║         :             #    #   │     │ 8               : 4          └··> ║    ║         :            #     #        pq = new IndexMinPQ<Double>(G.V());           #    #             pq.decreaseKey(w, distTo[w]);     #
    #   :     :                 v                 ║    ║         :             #    #   │     │                 v                 ║    ║         :            #     #        for (int v = 0; v < G.V(); v ++)              #    #          else                                 #
    #   :     :   ╔════════════════╗        7     ║    ║         :             #    #   │     │   ╔════════════════╗        7     ║    ║         :            #     #            distTo[v] = Double.POSITIVE_INFINITY;     #    #             pq.insert(w, distTo[w]);          #
    #   : 9   └·> ║                ║ ···········> ║ 2  ║         : 9           #    #   │ 9   └─> ║                ║ ···········> ║ 2  ║         : 9          #     #        distTo[s] = 0.0;                              #    #      }                                        #
    #   v         ║       7        ║              ║    ║         v             #    #   v         ║       7        ║              ║    ║         v            #     #        pq.insert(s, 0.0);                            #    # }                                             #
    # ╔════╗  5   ║                ║              ║    ║  11   ╔════════════╗  #    # ╔════╗  5   ║                ║              ║    ║  11   ╔════════════╗ #     #        while (<=pq.isEmpty()) {                      #    #################################################
    # ║    ║ ···> ║                ║              ║    ║ ····> ║     6      ║  #    # ║    ║ ···> ║                ║              ║    ║ ────> ║     6      ║ #     #            int v = pq.delMin();                      #
    # ║    ║      ╚════════════════╝              ╚════╝       ╚════════════╝  #    # ║    ║      ╚════════════════╝              ╚════╝       ╚════════════╝ #     #            for (DirectedEdge e : G.adj(v))           #
    # ║    ║        :                               ^            ^      ^      #    # ║    ║        :                               ^            ^      ^     #     #                relax(e);                             #
    # ║ 4  ║        : 6                             : 1          : 20   : 13   #    # ║ 4  ║        : 6                             │ 1          : 20   : 13  #     #        }                                             #
    # ║    ║        v                               :            :      :      #    # ║    ║        v                               │            :      :     #     #    }                                                 #
    # ║    ║  4   ╔════╗                            :            :      :      #    # ║    ║  4   ╔════╗                            │            :      :     #     #}                                                     #
    # ║    ║ ···> ║    ║ ···························┘            :      :      #    # ║    ║ ───> ║    ║ ───────────────────────────┘            :      :     #     ########################################################
    # ╚════╝      ║ 5  ║                                         :      :      #    # ╚════╝      ║ 5  ║                                         :      :     #
    #   :         ║    ║                                         :      :      #    #   :         ║    ║                                         :      :     #
    #   :         ║    ║ ········································┼······┘      #    #   :         ║    ║ ········································┼······┘     #
    #   :         ╚════╝                                         :             #    #   :         ╚════╝                                         :            #
    #   :                                                        :             #    #   :                                                        :            #
    #   └························································┘             #    #   └························································┘            #
    ############################################################################    ###########################################################################

    step1                        | step2                         | step3                         | step4                         | step5                         | step6                         | step7
    - add 0 to SPT as closest    | - add 1 to SPT as closest     | - add 7 to SPT as closest     | - add 4 to SPT as closest     | - add 5 to SPT as closest     | - add 2 to SPT as closest     | - add 3 to SPT as closest
    - relax all edges from 0     | - relax all edges from 1      | - relax all edges from 7      | - relax all edges from 4      | - relax all edges from 5      | - relax all edges from 2      | - relax all edges from 3
    v     distTo[]     edgeTo[]  | v     distTo[]    edgeTo[]    | v     distTo[]     edgeTo[]   | v     distTo[]    edgeTo[]    | v     distTo[]    edgeTo[]    | v     distTo[]    edgeTo[]    | v     distTo[]    edgeTo[]
    0#     0.0         -         | 0#    0.0         -           | 0#    0.0         -           | 0#     0.0         -          | 0#    0.0         -           | 0#    0.0         -           | 0#    0.0         -
    1*     5.0         0-1       | 1#    5.0         0-1         | 1#    5.0         0-1         | 1#     5.0         0-1        | 1#    5.0         0-1         | 1#    5.0         0-1         | 1#    5.0         0-1
    2                            | 2*    17.0        1-2         | 2*    15.0        7-2(change) | 2      15.0        7-2        | 2*    14.0        5-2(change) | 2#    14.0        5-2         | 2#    14.0        5-2
    3                            | 3*    20.0        1-3         | 3     20.0        1-3         | 3      20.0        1-3        | 3     20.0        1-3         | 3*    17.0        2-3(change) | 3#    17.0        2-3    
    4*     9.0         0-4       | 4     9.0         0-4         | 4     9.0         0-4         | 4#     9.0         0-4        | 4#    9.0         0-4         | 4#    9.0         0-4         | 4#    9.0         0-4
    5                            | 5                             | 5*    14.0        7-5         | 5*     13.0        4-5(change)| 5#    13.0        4-5         | 5#    13.0        4-5         | 5#    13.0        4-5
    6                            | 6                             | 6                             | 6*     29.0        4-6        | 6*    26.0        5-6(change) | 6*    25.0        2-6(change) | 6*    25.0        2-6(same)
    7*     8.0         0-7       | 7*    8.0         0-7 (same)  | 7#    8.0         0-7         | 7#*    8.0         0-7        | 7#    8.0         0-7         | 7#    8.0         0-7         | 7#    8.0         0-7


- Edge-Weighted DAGs
    It is easier to find shortest path in edge wighted graph without directed cycles then in general graph
    ・Consider vertices in topological order.
    ・Relax all edges pointing from that vertex.
    ############################################################################    Algorithm
    #                         ╔════╗        15    ╔════╗                       #    consider vertices in topologocal order
    #                         ║    ║ ···········> ║ 3  ║ ········┐             #    since there is no cycles - we know there is a topological ordering where we lay out the graph and all the edges pointing to vertices we have not seen yet
    #                         ║ 1  ║              ╚════╝         :             #    relax all edges point from each vertex taken in topologival order
    # ╔══════════╗       5    ║    ║  12            ^            :             #
    # ║    0     ║ ·········> ║    ║ ········┐      : 3          :             #    topological order 0 1 4 7 5 2 3 6
    # ╚══════════╝            ╚════╝         :      :            :             #    step1                        |step2                         |step3                         |step4                          ###########################################################################
    #   :     :                 :            :    ╔════╗         :             #    *                            |  *                           |    *                         |      *                        #                         ╔════╗        15    ╔════╗                      #
    #   :     : 8               : 4          └··> ║    ║         :             #    0 1 4 7 5 2 3 6              |0 1 4 7 5 2 3 6               |0 1 4 7 5 2 3 6               |0 1 4 7 5 2 3 6                #                         ║    ║ ···········> ║ 3  ║ ········┐            #
    #   :     :                 v                 ║    ║         :             #    relax all edges from 0       |relax all edges from 1        |relax all edges from 4        |relax all edges from 7         #                         ║ 1  ║              ╚════╝         :            #
    #   :     :   ╔════════════════╗        7     ║    ║         :             #    v     distTo[]    edgeTo[]   |v     distTo[]    edgeTo[]    |v     distTo[]    edgeTo[]    |v     distTo[]    edgeTo[]     # ╔══════════╗       5    ║    ║  12            ^            :            #
    #   : 9   └·> ║                ║ ···········> ║ 2  ║         : 9           #    0     0.0         -          |0     0           -           |0     0           -           |0     0           -            # ║    0     ║ ─────────> ║    ║ ········┐      │ 3          :            #
    #   v         ║       7        ║              ║    ║         v             #    1*    5.0         0-1        |1     5           0-1         |1     5           0-1         |1     5           0-1          # ╚══════════╝            ╚════╝         :      │            :            #
    # ╔════╗  5   ║                ║              ║    ║  11   ╔════════════╗  #    2                            |2*    17          1-2(change) |2     17          1-2         |2*    15          7-2(change)  #   │     │                 :            :    ╔════╗         :            #
    # ║    ║ ···> ║                ║              ║    ║ ····> ║     6      ║  #    3                            |3*    20          1-3(change) |3     20          1-3         |3     20          1-3          #   │     │ 8               : 4          └··> ║    ║         :            #
    # ║    ║      ╚════════════════╝              ╚════╝       ╚════════════╝  #    4*    9.0         0-4        |4     9           0-4         |4     9           0-4         |4     9           0-4          #   │     │                 v                 ║    ║         :            #
    # ║    ║        :                               ^            ^      ^      #    5                            |5                             |5*    13          4-5(change) |5*    13          4-5(same)    #   │     │   ╔════════════════╗        7     ║    ║         :            #
    # ║ 4  ║        : 6                             : 1          : 20   : 13   #    6                            |6                             |6*    29          4-6(change) |6     29          4-6          #   │ 9   └─> ║                ║ ···········> ║ 2  ║         : 9          #
    # ║    ║        v                               :            :      :      #    7*    8.0         0-7        |7*    8           0-7(same)   |7*    8           0-7(same)   |7     8           0-7          #   v         ║       7        ║              ║    ║         v            #
    # ║    ║  4   ╔════╗                            :            :      :      #                                                                                                                               # ╔════╗  5   ║                ║              ║    ║  11   ╔════════════╗ #
    # ║    ║ ···> ║    ║ ···························┘            :      :      #                                                                                                                               # ║    ║ ···> ║                ║              ║    ║ ────> ║     6      ║ #
    # ╚════╝      ║ 5  ║                                         :      :      #    |step5                       |step6                         |step7                            |step7                       # ║    ║      ╚════════════════╝              ╚════╝       ╚════════════╝ #
    #   :         ║    ║                                         :      :      #    |        *                   |          *                   |            *                  |              *               # ║    ║        :                               ^            ^      ^     #
    #   :         ║    ║ ········································┼······┘      #    |0 1 4 7 5 2 3 6             |0 1 4 7 5 2 3 6               |0 1 4 7 5 2 3 6                |0 1 4 7 5 2 3 6               # ║ 4  ║        : 6                             │ 1          : 20   : 13  #
    #   :         ╚════╝                                         :             #    |relax all edges from 5      |relax all edges from 2        |relax all edges from 3         |relax all edges from 6        # ║    ║        v                               │            :      :     #
    #   :                                                        :             #    |v    distTo[]    edgeTo[]   |v     distTo[]    edgeTo[]    |v     distTo[]    edgeTo[]     |v     distTo[]    edgeTo[]    # ║    ║  4   ╔════╗                            │            :      :     #
    #   └························································┘             #    |0    0           -          |0     0           -           |0     0           -            |0     0           -           # ║    ║ ───> ║    ║ ───────────────────────────┘            :      :     #
    ############################################################################    |1    5           0-1        |1     5           0-1         |1     5           0-1          |1     5           0-1         # ╚════╝      ║ 5  ║                                         :      :     #
                                                                                    |2*   14          5-2(change)|2     14          5-2         |2     14          5-2          |2     14          5-2         #   :         ║    ║                                         :      :     #
                                                                                    |3    20          1-3        |3*    17          2-3(change) |3     17          1-3          |3     17          1-3         #   :         ║    ║ ········································┼······┘     #
    #########################################################                       |4    9           0-4        |4     9           0-4         |4     9           0-4          |4     9           0-4         #   :         ╚════╝                                         :            #
    # public class AcyclicSP {                              #                       |5    13          4-5        |5     13          4-5         |5     13          4-5          |5     13          4-5         #   :                                                        :            #
    #     private DirectedEdge[] edgeTo;                    #                       |6*   26          5-6(change)|6*    25          2-6(change) |6*    25          5-6          |6     25          5-6         #   └························································┘            #
    #     private double[] distTo;                          #                       |7    8           0-7        |7     8           0-7         |7     8           0-7          |7     8           0-7         ###########################################################################
    #     public AcyclicSP(EdgeWeightedDigraph G, int s) {  #
    #         edgeTo = new DirectedEdge[G.V()];             #    
    #         distTo = new double[G.V()];                   #    
    #         for (int v = 0; v < G.V(); v ++)              #    
    #             distTo[v] = Double.POSITIVE_INFINITY;     #    
    #                                                       #    
    #         distTo[s] = 0.0;                              #
    #         Topological topological = new Topological(G); #
    #         for (int v : topological.order())             #
    #             for (DirectedEdge e : G.adj(v))           #
    #                 relax(e);                             #
    #     }                                                 #
    # }                                                     #
    #########################################################

    Applications:
    Seam carving - resize image (retargeted)
    
    Longest paths in edge-weighted DAGs - negate all weights and run shortyest paths (in acyclic):
        - Parallel job scheduling
        - get min completion time
                    must complete|                                                          ###################################################################################    Critical path method
    job    duration    before    |      #############################################       # +-+  41  +-+                  +-+    51     +-+                                 #    CPM. To solve a parallel job-scheduling problem, create edge-weighted DAG:
    0     41.0         1 7 9     |      #        +---------------+                  #       # |0|------|0|------------------|1|-----------|1|-----                            #     ・Source and sink vertices.
    1     51.0         2         |      #        |      1        |                  #       # +-+      +-+                  +-+           +-+     \   +-+  50   +-+           #     ・Two vertices (begin and end) for each job.
    2     50.0                   |      #        +-------------+-------+            #       #           |                                          ---|2|-------|2|-------    #     ・Three edges for each job.
    3     36.0                   |      #        |    7   |    |   3   |            #       #           |                +-+ 32  +-+   +-+ 32 +-+ /   +-+       +-+       \   #     – begin to end (weighted by duration)
    4     38.0                   |      # +------+-----+-------+------+-----------+ #       #           |----------------|7|-----|7|---|8|----|8|/                         |  #     – source to begin (0 weight)
    5     45.0                   |      # |  0   |  9  |   6   |  8   |     2     | #       #           |                +-+     +-+   +-+    +-+                          |  #     – end to sink (0 weight)
    6     21.0         3 8       |      # +------+-----+---+---+---+--+-----------+ #       #           |                                                                  |  #     ・One edge for each precedence constraint (0 weight).
    7     32.0         3 8       |      # |   5    |       |   4   |                #       #           |                +-+21+-+      +-+ 36 +-+                          |  #
    8     32.0         2         |      # +--------+       +-------+                #       #           |               -|6|--|6|------|3|----|3|------------------------- |  #    CPM. Use longest path from the source to schedule each job.
    9     29.0         4 6       |      # -------+-----+-------+------+-----------+ #       #           |              / +-+  +-+      +-+    +-+                         \|  #
                                        #       43    70      91    123         173 #       #           |             /                                                    |  #
                                        #############################################       #           |   +-+ 29 +-+                                                     |  #
                                                                                            #           |---|9|----|9|                                                     |  #
                                                                                            #               +-+    +-+                                                     |  #
                                                                                            #                         \                                                    |  #
                                                                                            #                          \ +-+  38   +-+                                    +-+ #
                                                                                            #                           -|4|-------|4|------------------------------------|e| #
                                                                                            #                            +-+       +-+                                    +-+ #
                                                                                            #                            +-+   45     +-+                                /    #
                                                                                            #                            |5|----------|5|--------------------------------     #
                                                                                            #                            +-+          +-+                                     #
                                                                                            ###################################################################################

- Negative Weights
                                                                                
    ###############     Dijkstra. Doesn’t work with negative edge weights.        
    # +-+  4  +-+ #     Dijkstra selects vertex 3 immediately after 0.            
    # |0|---->|1| #     But shortest path from 0 to 3 is 0→1→2→3.
    # +-+     +-+ #
    #  |2      |6 #     Topological sort wont work as here is a cycle
    #  v       v  #
    # +-+     +-+ #     Negative cycles
    # |3|<----|2| #     A negative cycle is a directed cycle whose sum of edge weights is negative.
    # +-+ -9  +-+ #     One can go around a negative cycle many times and get a shortest path which is wrong.
    ###############        If there is no negative cycles - then there is a shortest path tree
                        If there is a shortest path tree - then there is no negative cycles

    Bellman-Ford Algorithm
    Repeat V times: relax all E edges                                               PASS1: 0-1 0-4 0-7 1-2 1-3 1-7 2-3 2-6 3-6 4-5 4-6 4-7 5-2 5-6 7-5 7-2
    ############################################################################    step1                        |step2                        |step3                        |step4                       ###########################################################################
    #                         ╔════╗        15    ╔════╗                       #    relax edges from 0           |relax edges from 1           |relax edges from 2           |relax edges from 3          #                         ╔════╗        15    ╔════╗                      #
    #                         ║    ║ ···········> ║ 3  ║ ········┐             #    v     distTo[]     edgeTo[]  |v     distTo[]    edgeTo[]   |v     distTo[]    edgeTo[]   |v     distTo[]    edgeTo[]  #                         ║    ║ ···········> ║ 3  ║ ········┐            #
    #                         ║ 1  ║              ╚════╝         :             #    0     0.0          -         |0     0.0         -          |0     0.0         -          |0     0.0         -         #                         ║ 1  ║              ╚════╝         :            #
    # ╔══════════╗       5    ║    ║  12            ^            :             #    1*    5.0          0-1       |1     5.0         0-1        |1     5.0         0-1        |1     5.0         0-1       # ╔══════════╗       5    ║    ║  12            ^            :            #
    # ║    0     ║ ·········> ║    ║ ········┐      : 3          :             #    2                            |2*    17          1-2        |2     17          1-2        |2     17          1-2       # ║    0     ║ ─────────> ║    ║ ········┐      │ 3          :            #
    # ╚══════════╝            ╚════╝         :      :            :             #    3                            |3*    20          1-3        |3*    20          1-3        |3     20          1-3       # ╚══════════╝            ╚════╝         :      │            :            #
    #   :     :                 :            :    ╔════╗         :             #    4*    9.0          0-4       |4     9.0         0-4        |4     9.0         0-4        |4     9.0         0-4       #   │     │                 :            :    ╔════╗         :            #
    #   :     : 8               : 4          └··> ║    ║         :             #    5                            |5                            |5                            |5                           #   │     │ 8               : 4          └··> ║    ║         :            #
    #   :     :                 v                 ║    ║         :             #    6                            |6                            |6*    28          2-6        |6*    28          2-6       #   │     │                 v                 ║    ║         :            #
    #   :     :   ╔════════════════╗        7     ║    ║         :             #    7*    8.0          0-7       |7*    8.0         0-7        |7     8.0         0-7        |7     8.0         0-7       #   │     │   ╔════════════════╗        7     ║    ║         :            #
    #   : 9   └·> ║                ║ ···········> ║ 2  ║         : 9           #                                                                                                                          #   │ 9   └─> ║                ║ ···········> ║ 2  ║         : 9          #
    #   v         ║       7        ║              ║    ║         v             #                                                                                                                          #   v         ║       7        ║              ║    ║         v            #
    # ╔════╗  5   ║                ║              ║    ║  11   ╔════════════╗  #    step5                        |step6                        |step7                                                     # ╔════╗  5   ║                ║              ║    ║  11   ╔════════════╗ #
    # ║    ║ ···> ║                ║              ║    ║ ····> ║     6      ║  #    relax edges from 4           |relax edges from 5           |relax edges from 6                                        # ║    ║ ···> ║                ║              ║    ║ ────> ║     6      ║ #
    # ║    ║      ╚════════════════╝              ╚════╝       ╚════════════╝  #    v     distTo[]     edgeTo[]  |v     distTo[]    edgeTo[]   |v     distTo[]    edgeTo[]                                # ║    ║      ╚════════════════╝              ╚════╝       ╚════════════╝ #
    # ║    ║        :                               ^            ^      ^      #    0     0.0          -         |0     0.0         -          |0     0.0         -                                       # ║    ║        :                               ^            ^      ^     #
    # ║ 4  ║        : 6                             : 1          : 20   : 13   #    1     5.0          0-1       |1     5.0         0-1        |1     5.0         0-1                                     # ║ 4  ║        : 6                             │ 1          : 20   : 13  #
    # ║    ║        v                               :            :      :      #    2     17           1-2       |2*    14          5-2        |2*    14          5-2                                     # ║    ║        v                               │            :      :     #
    # ║    ║  4   ╔════╗                            :            :      :      #    3     20           1-3       |3     20          1-3        |3     20          1-3                                     # ║    ║  4   ╔════╗                            │            :      :     #
    # ║    ║ ···> ║    ║ ···························┘            :      :      #    4     9.0          0-4       |4     9.0         0-4        |4     9.0         0-4                                     # ║    ║ ───> ║    ║ ───────────────────────────┘            :      :     #
    # ╚════╝      ║ 5  ║                                         :      :      #    5*    13           4-5       |5     13          4-5        |5*    13          4-5                                     # ╚════╝      ║ 5  ║                                         :      :     #
    #   :         ║    ║                                         :      :      #    6*    28           2-6       |6*    26          5-6        |6     26          5-6                                     #   :         ║    ║                                         :      :     #
    #   :         ║    ║ ········································┼······┘      #    7*    8.0          0-7       |7     8.0         0-7        |7     8.0         0-7                                     #   :         ║    ║ ········································┼······┘     #
    #   :         ╚════╝                                         :             #                                                                                                                          #   :         ╚════╝                                         :            #
    #   :                                                        :             #    PASS2: 0-1 0-4 0-7 1-2 1-3 1-7 2-3 2-6 3-6 4-5 4-6 4-7 5-2 5-6 7-5 7-2                                                #   :                                                        :            #
    #   └························································┘             #    |step3                         2-3 successfully relaxed                                                               #   └························································┘            #
    ############################################################################    |relax edges from 2            in pass 1, but not pass 0                                                              ###########################################################################
                                                                                    |v     distTo[]    edgeTo[]    because in pass 0 path to 2 was longer
    ##############################################################################  |0     0.0         -      
    # algorithm      |restriction    |typical case   |worst case     |extra space#  |1     5.0         0-1         FIFO implementation. Maintain queue of vertices whose distTo[] changed.
    # topological    |no directed    |  E + V        |  E + V        |V          #  |2     14          5-2    
    # sort           |cycles         |               |               |           #  |3*    17          1-3    
    #                |               |               |               |           #  |4     9.0         0-4    
    # Dijkstra       |no negative    |  E log V      | E log V       |V          #  |5     13          4-5     
    # (binary heap)  |weights        |               |               |           #  |6     26          5-6    
    #                |               |               |               |           #  |7     8.0         0-7     
    # Bellman-Ford   |no negative    |  E V          | E V           |V          #  
    #                |cycles         |               |               |           #  
    #                |               |               |               |           #  
    # Bellman-Ford   |no negative    |  E + V        | E V           |V          #  
    # (queue-based)  |cycles         |               |               |           #  
    ##############################################################################  
                                                                                    
    Negative cycle application: arbitrage detection            Negative cycle application: arbitrage detection                    Model as a negative cycle detection problem by taking logs.                    
    #########################################                  Currency exchange graph.                                           ・Let weight of edge v→w be - ln (exchange rate from currency v to w).
    #        USD    EUR    GBP    CHF    CAD#                    ・Vertex = currency.                                              ・Multiplication turns to addition; > 1 turns to < 0. 
    # USD    1      0.7    0.6    1.0    1.0#                    ・Edge = transaction, with weight equal to exchange rate.         ・Find a directed cycle whose sum of edge weights is < 0 (negative cycle). 
    # EUR    1.3    1      0.8    1.4    1.3#                    ・Find a directed cycle whose product of edge weights is > 1.
    # GBP    1.5    1.1    1      1.6    1.5#                     >0.741    0.741 * 1.366 * .995 = 1.00714497
    # CHF    0.9    0.6    0.6    1      0.9#               +---+     +---+
    # CAD    0.9    0.7    0.6    1.0    1  #               |USD|<--->|EUR|              replace each weight with ln
    #########################################               +---+     +---+              -ln(.741) -ln(1.366) -ln(.995)     (ln(x) - time needed to grow to x with 100% continusos compund)
                                                             ^   ^   ^   ^ >1.366        .2998 - .3119 + .0050 = -.0071     e - constant 2.718
                                                             |    \ /    |                                                  e^3 is 20.08. After 3 units of time, we end up with 20.08 times what we started with.
                                                             |     /<0.99|                                                  log(x) tells you what power you must raise 10 to get x
                                                             |    / \    |                                                  ln(x) is log with base e 2.718
                                                             v   v   v   v                                                  ln(x) tells you what power you must raise e to get x
                                                            +---+     +---+
                                                            |CHF|<--->|CAD|
                                                            +---+     +---+
###############
# week3
###############

- MaxFlow
                                                                            Minimum st-cut (mincut) problem. Find a cut of minimum capacity.             Maximum st-flow (maxflow) problem. Find a flow of maximum value.
    ###################################################################        A st-cut (cut) is a partition of the vertices into two disjoint sets,        An st-flow (flow) is an assignment of values to the edges such that:
    #            10    ╔═════════╗        9     ╔═════╗               #        with s in one set A and t in the other set B.                               ・Capacity constraint: 0 ≤ edge's flow ≤ edge's capacity.
    #   ┌············> ║    1    ║ ···········> ║  2  ║ ········┐     #        Its capacity is the sum of the capacities of the edges from A to B.         ・Local equilibrium: inflow = outflow at every vertex (except s and t).
    #   :              ╚═════════╝              ╚═════╝         :     #        capacity in below cut is 30 ( s 1, s 3, s 5)                                The value of a flow is the inflow at t.
    #   :                :     :                  :             :     #     ###################################################################         ######################################################################################
    #   :                :     :                  : 15          :     #     #            10    ╔═════════╗        9     ╔═════╗               #         #            10/10    ╔════════════╗           5/9     ╔═══════╗                     #
    #   :                :     :                  v             :     #     #   ┌────────────> ║    1    ║ ···········> ║  2  ║ ········┐     #         #   ┌···············> ║     1      ║ ················> ║   2   ║ ···········┐        #
    #   :                :     :          15    ╔═════╗         :     #     #   │              ╚═════════╝              ╚═════╝         :     #         #   :                 ╚════════════╝                   ╚═══════╝            :        #
    #   :                : 4   └··············> ║     ║         : 10  #     #   │                :     :                  :             :     #         #   :                   :        │                       :                  :        #
    #   :                v                      ║  4  ║         v     #     #   │                :     :                  : 15          :     #         #   :                   :        │                       : 0/15             :        #
    # ╔═══╗      5     ╔═════════╗        8     ║     ║  10   ╔═════╗ #     #   │                :     :                  v             :     #         #   :                   :        │                       v                  :        #
    # ║ s ║ ·········> ║    3    ║ ···········> ║     ║ ····> ║  t  ║ #     #   │                :     :          15    ╔═════╗         :     #         #   :                   :        │             5/15    ╔═══════╗            :        #
    # ╚═══╝            ╚═════════╝              ╚═════╝       ╚═════╝ #     #   │                : 4   └··············> ║     ║         : 10  #         #   :                   : 5/15   └───────────────────> ║       ║            : 5/10   #
    #   :                :     :                  :             ^     #     #   │                v                      ║  4  ║         v     #         #   :                   v                              ║   4   ║            v        #
    #   :                :     :                  :             : 10  #     # ╔═══╗      5     ╔═════════╗        8     ║     ║  10   ╔═════╗ #         # ╔═══╗      5/5      ╔════════════╗           5/8     ║       ║  10/10   ╔════════╗ #
    #   :                :     :                  :             :     #     # ║ s ║ ─────────> ║    3    ║ ···········> ║     ║ ····> ║  t  ║ #         # ║ s ║ ············> ║     3      ║ ────────────────> ║       ║ ───────> ║   t    ║ #
    #   :                :     :   15             :             :     #     # ╚═══╝            ╚═════════╝              ╚═════╝       ╚═════╝ #         # ╚═══╝               ╚════════════╝                   ╚═══════╝          ╚════════╝ #
    #   :                : 4   └···········┐      : 15          :     #     #   │                :     :                  :             ^     #         #   :                   :        :                       :                  ^        #
    #   :                v                 v      v             :     #     #   │                :     :                  :             : 10  #         #   :                   :        :                       :                  : 10/10  #
    #   :        15    ╔═════════╗  16   ╔════════════╗         :     #     #   │                :     :                  :             :     #         #   :                   :        :                       :                  :        #
    #   └············> ║    5    ║ ····> ║     6      ║ ········┘     #     #   │                :     :   15             :             :     #         #   :                   :        :   0/6                 :                  :        #
    #                  ╚═════════╝       ╚════════════╝               #     #   │                : 4   └···········┐      : 15          :     #         #   :                   : 0/4    └··············┐        : 0/15             :        #
    ###################################################################     #   │                v                 v      v             :     #         #   :                   v                       v        v                  :        #
                                                                            #   │        15    ╔═════════╗  16   ╔════════════╗         :     #         #   :        10/15    ╔════════════╗  10/16   ╔════════════════╗            :        #
                                                                            #   └────────────> ║    5    ║ ····> ║     6      ║ ········┘     #         #   └···············> ║     5      ║ ·······> ║       6        ║ ···········┘        #
                                                                            #                  ╚═════════╝       ╚════════════╝               #         #                     ╚════════════╝          ╚════════════════╝                     #
                                                                            ###################################################################         ######################################################################################
    
- Ford-Fulkerson algorithm                                                   Augmenting path. Find an undirected path from s to t such that:
    Initialization. Start with 0 flow.                                       ・Can increase flow on forward edges (not full).
    ###################################################################      1st augmenting path  s-1-4-t (10 units)
    #          0/10    ╔═════════╗        0/9   ╔═════╗               #      2nd augmenting path  s-5-6-t (10 units)
    #   ┌············> ║    1    ║ ···········> ║  2  ║ ········┐     #      3rd augmenting path  s-3-4-1-2-t (add 5 in 3-4 and remove 5 in backward 4-1) total 25
    #   :              ╚═════════╝              ╚═════╝         :     #      4th augmenting path  s-5-6-3-4-1-2-t ( e more units as 3-4 had left capacity of 3) total 28       
    #   :                :     :                  :             :     #     ######################################################################################         Termination. All paths from s to t are blocked by either a   
    #   :                :     :                  : 0/15        :     #     #            10/10    ╔═══════════╗          8/9      ╔═══════╗                      #          ・Full forward edge.
    #   :                :     :                  v             :     #     #   ┌───────────────> ║     1     ║ ················> ║   2   ║ ···········┐         #          ・Empty backward edge.
    #   :                :     :        0/15    ╔═════╗         :     #     #   │                 ╚═══════════╝                   ╚═══════╝            :         #
    #   :                :0/4  └··············> ║     ║         :0/10 #     #   │                   :       │                       :                  :         #            Algorithm
    #   :                v                      ║  4  ║         v     #     #   │                   :       │                       : 0/15             :         #            Start with 0 flow.
    # ╔═══╗      0/5   ╔═════════╗        0/8   ║     ║  0/10 ╔═════╗ #     #   │                   :       │                       v                  :         #          While there exists an augmenting path:
    # ║ s ║ ·········> ║    3    ║ ···········> ║     ║ ····> ║  t  ║ #     #   │                   :       │            2/15     ╔═══════╗            :         #           - find an augmenting path
    # ╚═══╝            ╚═════════╝              ╚═════╝       ╚═════╝ #     #   │                   : 0/4   └───────────────────> ║       ║            : 8/10    #           - compute bottleneck capacity
    #   :                :     :                  :             ^     #     #   │                   v                             ║   4   ║            v         #           - increase flow on that path by bottleneck capacity
    #   :                :     :                  :             :0/10 #     # ╔═══╗      5/5      ╔═══════════╗          8/8      ║       ║  10/10   ╔═══════╗   #
    #   :                :     :                  :             :     #     # ║ s ║ ············> ║     3     ║ ················> ║       ║ ───────> ║   t   ║   #
    #   :                :     :   0/6            :             :     #     # ╚═══╝               ╚═══════════╝                   ╚═══════╝          ╚═══════╝   #
    #   :                :0/4  └···········┐      :0/15         :     #     #   :                   :       ^                       :                  ^         #
    #   :                v                 v      v             :     #     #   :                   :       :                       :                  : 10/10   #    
    #   :       0/15   ╔═════════╗  0/16 ╔════════════╗         :     #     #   :                   :       :                       :                  :         #
    #   └············> ║    5    ║ ····> ║     6      ║ ········┘     #     #   :                   :       :   3/6                 :                  :         #
    #                  ╚═════════╝       ╚════════════╝               #     #   :                   : 0/4   └·············┐         : 0/15             :         #
    ###################################################################     #   :                   v                     :         v                  :         #
                                                                            #   :        13/15    ╔═══════════╗  13/16  ╔═════════════════╗            :         #
                                                                            #   └···············> ║     5     ║ ······> ║        6        ║ ···········┘         #
                                                                            #                     ╚═══════════╝         ╚═════════════════╝                      #
                                                                            ######################################################################################

- maxflow-mincut theorem
    #####################################################################################    Computing a mincut from a maxflow
    #            10/10    ┌───────────┐          0/9     ┌───────┐                      #    ・Compute A = set of vertices connected to s by an undirected path
    #   ┌···············> │     1     │ ···············> │   2   │ ···········┐         #    with no full forward or empty backward edges.
    #   :                 └───────────┘                  └───────┘            :         #    in left example A is s-5-3-6
    #   :                   :       :                      :                  :         #
    #   :                   :       :                      : 0/15             :         #
    #   :                   :       :                      v                  :         #
    #   :                   :       :            2/15    ┌───────┐            :         #
    #   :                   : 0/4   └··················> │       │            : 10/10   #
    #   :                   v                            │   4   │            v         #
    # ╔═══╗      5/5      ╔═══════════╗          8/8     │       │  10/10   ┌────────┐  #
    # ║ s ║ ············> ║     3     ║ ···············> │       │ ·······> │   t    │  #
    # ╚═══╝               ╚═══════════╝                  └───────┘          └────────┘  #
    #   :                   :       :                      :                  ^         #
    #   :                   :       :                      :                  : 10/10   #
    #   :                   :       :                      :                  :         #
    #   :                   :       :   6/6                :                  :         #
    #   :                   : 3/4   └·············┐        : 0/15             :         #
    #   :                   v                     v        v                  :         #
    #   :        13/15    ╔═══════════╗  0/16   ╔════════════════╗            :         #
    #   └···············> ║     5     ║ ······> ║       6        ║ ···········┘         #
    #                     ╚═══════════╝         ╚════════════════╝                      #
    #####################################################################################


- implementation
    Flow edge data type. Associate flow fe and capacity ce with edge e = v→w.                                                   ######################################################################  #############################################################
    Flow network data type. Need to process edge e = v→w in either direction: Include e in both v and w's adjacency lists.      # public class FlowEdge {                                            #  # public double residualCapacityTo(int vertex) {            #
    Residual capacity.                                                                                                          #     private final int v,w; // from and to                          #  #     if (vertex == v) return flow;                         #  <-- backward edge
    ・Forward edge: residual capacity = ce - fe.                                                                                 #     private final double capacity; // capacity                     #  #      else if (vertex == w) return capacity - flow;        #  <-- forward edge 
    ・Backward edge: residual capacity = fe.                                                                                     #     private double flow; // flow                                   #  #      else throw new IllegalArgumentException();           # 
    Augment flow.                                                                                                               #     public FlowEdge(int v, int w, double capacity) {               #  #                                                           #
    ・Forward edge: add ∆.                                                                                                       #         this.v = v;                                                #  # }                                                         # 
    ・Backward edge: subtract ∆.                                                                                                 #         this.w = w;                                                #  # public void addResidualFlowTo(int vertex, double delta) { # 
    original network                        residual network:                                                                   #         this.capacity = capacity;                                  #  #     if (vertex == v) flow -= delta;                       #  <-- backward edge
    #####################################   same but:                   Augmenting path in original network is equivalent to    #     }                                                              #  #      else if (vertex == w) flow += delta;                 #  <-- forward edge
    #           +-+  9/9  +-+           #   s-1 = 1; 1-s = 9            directed path in residual network.                      #     public int from() {return v;}                                  #  #      else throw new IllegalArgumentException();           #
    #          >|1|------>|2|\          #   s-3 = 1; 3-s = 4                                                                    #     public int to() {return w;}                                    #  # }                                                         #
    #        -/ +-+       +-+ -\        #   1-3 = 4;                                                                            #     public double capacity() {return capacity;}                    #  #############################################################
    #   9/10/    ^ -\4/4   |    \9/10   #   s-3 = 1; 3-s = 4                                                                    #     public double flow() {return flow;}                            #
    #     -/  4/4|   --\   v     -\     #   2-1 = 9                                                                             #     public int other(int vertex) {                                 #
    # +-+/      +-+     ->+-+      >+-+ #   4-1 = 4                                                                             #         if (vertex == v) return w;                                 #
    # |s|------>|3|------>|4|------>|t| #   3-4 = 8 (cause was empty)                                                           #          else if (vertex == w) return v;                           #
    # +-+  4/5  +-+  0/8  +-+  4/10 +-+ #   2-4 = 15 (cause was empty)                                                          #          else throw new RuntimeException("Illegal endpoint");      #
    #####################################   4-t = 6; t-4 = 4                                                                    #                                                                    #
                                            2-t = 1; t-2 = 9                                                                    #     }                                                              #
                                                                                                                                #     public double residualCapacityTo(int vertex) {...}             #
                                                                                                                                #     public void addResidualFlowTo(int vertex, double delta) {...}  #
                                                                                                                                # }                                                                  #
                                                                                                                                ######################################################################

    ###############################################                                 Ford-Fulkerson: Java implementation
    # public class FlowNetwork {                  #                                 ###############################################################################                             #################################################################### 
    #     private final int V;                    #     same as EdgeWeightedGraph,  # public class FordFulkerson {                                                #                             # private boolean hasAugmentingPath(FlowNetwork G, int s, int t) { #
    #     private Bag<FlowEdge> [] adj;           #  <--but adjacency lists of      #     private boolean[] marked; // true if s->v path in residual network      #                             #     edgeTo = new FlowEdge[G.V()];                                #
    #                                             #     FlowEdges instead of Edges  #     private FlowEdge[] edgeTo; // last edge on s->v path                    #                             #     marked = new boolean[G.V()];                                 #
    #     public FlowNetwork(int V) {             #                                 #     private double value; // value of flow                                  #                             #     Queue<Integer> queue = new Queue<Integer>();                 #
    #         this.V = V;                         #                                 #     public FordFulkerson(FlowNetwork G, int s, int t) {                     #                             #     queue.enqueue(s);                                            #
    #         adj = (Bag<FlowEdge> [])new Bag[V]; #                                 #         value = 0.0;                                                        #                             #     marked[s] = true;                                            #
    #         for (int v = 0; v < V; v ++)        #                                 #         while (hasAugmentingPath(G, s, t)) {                                #                             #     while (<=queue.isEmpty()) {                                   #
    #             adj[v] = new Bag<FlowEdge>();   #                                 #             double bottle = Double.POSITIVE_INFINITY;                       #                             #         int v = queue.dequeue();                                 #
    #     }                                       #                                 #             for (int v = t; v <== s; v = edgeTo[v].other(v))                 #  <-- compute                #         for (FlowEdge e : G.adj(v)) {                            #
    #     public void addEdge(FlowEdge e) {       #                                 #                 bottle = Math.min(bottle, edgeTo[v].residualCapacityTo(v)); #      bottleneck capacity    #             int w = e.other(v);                                  #
    #         int v = e.from();                   #                                 #             for (int v = t; v <== s; v = edgeTo[v].other(v))                 #  <-- augment flow           #             if (e.residualCapacityTo(w) > 0 && <=marked[w]) {     #  <-- found path from s to win the residual network?
    #         int w = e.to();                     #                                 #                 edgeTo[v].addResidualFlowTo(v, bottle);                     #                             #                 edgeTo[w] = e;                                   #      save last edge on path to w;
    #         adj[v].add(e);                      #  <--add forward edge            #             value += bottle;                                                #                             #                 marked[w] = true;                                #  <-- mark w;
    #         adj[w].add(e);                      #  <--add backward edge           #         }                                                                   #                             #                 queue.enqueue(w);                                #      add w to the queue
    #     }                                       #                                 #     }                                                                       #                             #             }                                                    #
    #     public Iterable<FlowEdge> adj(int v) {  #                                 #     private boolean hasAugmentingPath(FlowNetwork G, int s, int t) {        #                             #         }                                                        #
    #         return adj[v];                      #                                 #         /* See next slide. */                                               #                             #     }                                                            #
    #     }                                       #                                 #     }                                                                       #                             #     return marked[t];                                            #
    # }                                           #                                 #     public double value() {return value;}                                   #                             # }                                                                #
    ###############################################                                 #     public boolean inCut(int v) {return marked[v];}                         #                             ####################################################################
                                                                                    # }                                                                           #
                                                                                    ###############################################################################

- applications
    Maxflow/mincut is a widely applicable problem-solving model.
    ・Data mining.
    ・Open-pit mining.
    ・Bipartite matching.
    ・Network reliability.
    ・Baseball elimination.
    ・Image segmentation.
    ・Network connectivity.
    ・Distributed computing.
    ・Security of statistical data.
    ・Egalitarian stable matching.
    ・Multi-camera scene reconstruction.
    ・Sensor placement for homeland security.
    ・Many, many, more.

- Strings
    How to efficiently reverse a string?                                    How to efficiently form array of suffixes?                          How long to compute length of longest common prefix?
    String                                                                  String
    ##################################################                      ###############################################                     #################################################
    # public static String reverse(String s) {       #                      # public static String[] suffixes(String s) { #                     # public static int lcp(String s, String t) {   #
    #     String rev = "";                           #                      #     int N = s.length();                     #                     #     int N = Math.min(s.length(), t.length()); #
    #     for (int i = s.length() - 1; i >= 0; i --) #                      #     String[] suffixes = new String[N];      #                     #     for (int i = 0; i < N; i ++)              #
    #         rev += s.charAt(i);                    #  <-- quadratic       #     for (int i = 0; i < N; i ++)            #  <-- linear         #         if (s.charAt(i) <== t.charAt(i))       #  <-- linear worse
    #                                                #                      #         suffixes[i] = s.substring(i, N);    #                     #             return i;                         #       sublinear typical
    #     return rev;                                #                      #                                             #                     #     return N;                                 #
    # }                                              #                      #     return suffixes;                        #                     # }                                             #
    ##################################################                      # }                                           #                     #################################################
    StringBuilder                                                           ###############################################
    ##################################################                      StringBuilder
    # public static String reverse(String s) {       #                      ###############################################
    #     StringBuilder rev = new StringBuilder();   #                      # public static String[] suffixes(String s) { #
    #     for (int i = s.length() - 1; i >= 0; i --) #                      #     int N = s.length();                     #
    #         rev.append(s.charAt(i));               #  <-- linear          #     StringBuilder sb = new StringBuilder(s);#  <-- quadratic
    #                                                #                      #     String[] suffixes = new String[N];      #
    #     return rev.toString();                     #                      #     for (int i = 0; i < N; i ++)            #
    # }                                              #                      #         suffixes[i] = sb.substring(i, N);   #
    ##################################################                      #                                             #
                                                                            #     return suffixes;                        #
                                                                            # }                                           #
                                                                            ###############################################

- key-indexed counting                            
    Keys used to sort are small integeres                          Applications:                                                  
                                                                  ・Sort string by first letter.                                 
    Goal. Sort an array a[] of N integers between 0 and R - 1.    ・Sort class roster by section.                                
    #################################                             ・Sort phone numbers by area code.                                             
    #     +-----------------------+ #                             ・Subroutine in a sorting algorithm.                           
    # a[i]|d|a|c|f|f|b|d|b|f|b|e|a| #                                                 
    #     +-----------------------+ #     count frquencies using key as index                                                 
    # i    0 1 2 3 4 5 6 7 8 9 1011 #     ###########################                                                 
    #################################     #           offset by 1   #                                                
                                          #         +-------------+ #                                                
    #################################     # count[r]|0|2|3|1|2|1|3| #                                                
    #int N = a.length;              #     #         +-/-/-/-/-/-/-+ #                                                
    #int[] count = new int[R + 1];  #     # r        a b c d e f    #                                                
    #for (int i = 0; i < N; i ++)   #  <--###########################                                                
    #    count[a[i] + 1]++;         #     compute cumulitives                                                                  
    #                               #     #         +--------------+#    go through count array and at each step                                                
    #for (int r = 0; r < R; r ++)   #  <--# count[r]|0|2|5|6|8|9|12|#   add current one to sum computed so far                                                                   
    #    count[r + 1] += count[r];  #     #         +-/-/-/-/-/-/--+#                                                
    #                               #     # r         a b c d e f   #
    #for (int i = 0; i < N; i ++)   #     ###################################    6 keys <d 8 keys <e so d`s go in a[6] and a[]7
    #    aux[count[a[i]]++] = a[i]; #  <--#       +-----------------------+ #    go through all array to be sorted and move each key where it has to go
    #                               #     # aux[i]|a|a|b|b|b|c|d|d|e|f|f|f| #    last step move back to original array
    #for (int i = 0; i < N; i ++)   #     #       +-----------------------+ #
    #    a[i] = aux[i];             #     # i      0 1 2 3 4 5 6 7 8 9 1011 #
    #################################     ###################################

- LSD radix sort
    Least-significant-digit-first string sort                                    good to sort one million 32-bit integers.
    LSD string (radix) sort.
    ・Consider characters from right to left.
    ・Stably sort using dth character as the key (using key-indexed counting)
                                                            LSD string sort: Java implementation
                    sort key    sort key    sort key        ########################################################
                    (d = 2)     (d = 1)     (d = 1)         # public class LSD {                                   #
    #################################################       #     public static void sort(String[] a, int W) {     #  <-- fixed-length W strings
    #                    *         *         *      #       #         int R = 256;                                 #  <-- radix R
    #   +-----+     +-----+     +-----+     +-----+ #       #         int N = a.length;                            #
    #  0|d a|b|    0|d a|b|    0|d|a|b|    0|a|c e| #       #         String[] aux = new String[N];                #      do key-indexed counting
    #  1|a d|d|    1|c a|b|    1|c|a|b|    1|a|d d| #       #         for (int d = W - 1; d >= 0; d --) {          #  <-- for each digit from right to left
    #  2|c a|b|    2|e b|b|    2|f|a|d|    2|b|a d| #       #             int[] count = new int[R + 1];            #
    #  3|f a|d|    3|a d|d|    3|b|a|d|    3|b|e d| #       #             for (int i = 0; i < N; i ++)             #
    #  4|f e|e|    4|f a|d|    4|d|a|d|    4|b|e e| #       #                 count[a[i].charAt(d) + 1]++;         #
    #  5|b a|d|    5|b a|d|    5|e|b|b|    5|c|a b| #       #             for (int r = 0; r < R; r ++)             #  <-- key-indexed counting
    #  6|d a|d|    6|d a|d|    6|a|c|e|    6|d|a b| #       #                 count[r + 1] += count[r];            #
    #  7|b e|e|    7|f e|d|    7|a|d|d|    7|d|a d| #       #             for (int i = 0; i < N; i ++)             #
    #  8|f e|d|    8|b e|d|    8|f|e|d|    8|e|b b| #       #                 aux[count[a[i].charAt(d)]++] = a[i]; #
    #  9|b e|d|    9|f e|e|    9|b|e|d|    9|f|a d| #       #                                                      #
    # 10|e b|b|   10|b e|e|   10|f|e|e|   10|f|e d| #       #             for (int i = 0; i < N; i ++)             #
    # 11|a c|e|   11|a c|e|   11|b|e|e|   11|f|e e| #       #                 a[i] = aux[i];                       #
    #   +-----+     +-----+     +-----+     +-----+ #       #         }                                            #
    #################################################       #     }                                                #
                                                            # }                                                    #
                                                            ########################################################
    
- MSD radix sort                                                                                                                                    MSD string sort: Java implementation
    MSD string (radix) sort.                                                                                                                        ###############################################################################
    ・Partition array into R pieces according to first character(use key-indexed counting).                                                          # public static void sort(String[] a) {                                       # 
    ・Recursively sort all strings that start with each character (key-indexed counts delineate subarrays to sort).                                  #     aux = new String[a.length];                                             # 
                                                                                                                                                    #     sort(a, aux, 0, a.length - 1, 0);                                       #
                                            sort subarrays            Variable-length strings                                                       # }                                                                           #
                  *        count[]          recursively               Treat strings as if they had an extra char at end (smaller than any char).    # private static void sort(String[] a, String[] aux, int lo, int hi, int d) { #
      +-----+     +-----+                  +-----+                      +--------+                ################################################  #     if (hi <= lo)                                                           #
     0|d a b|    0|a|d d|           ----->0|a d d|                     0|s e a +1|                # private static int charAt(String s, int d) { #  #         return;                                                             #
     1|a d d|    1|a|c e|          /      1|a c e|                      +--------------------+    #     if (d < s.length()) return s.charAt(d);  #  #     int[] count = new int[R + 2];                                           #
     2|c a b|    2|b|a d|         /        +-----+                     1|s e a s h e l l s +1|    #      else  return -1;                        #  #     for (int i = lo; i <= hi; i ++)                                         #
     3|f a d|    3|b|e e|    +--+/     -->2|b a d|                      +--------------------+    # }                                            #  #         count[charAt(a[i], d) + 2]++;                                       #
     4|f e e|    4|b|e d|   a|0 |     /   3|b e e|                     2|s e l l s +1|            ################################################  #     for (int r = 0; r < R + 1; r ++)                                        #
     5|b a d|    5|c|a b|   b|2 |-----    4|b e d|                      +------------+                                                              #         count[r + 1] += count[r];                                           #
     6|d a d|    6|d|a b|   c|5 |-----     +-----+                     3|s h e +1|                Observation 1.                                    #     for (int i = lo; i <= hi; i ++)                                         #
     7|b e e|    7|d|a d|   d|6 |---  \-->5|c a b|                      +--------+                Much too slow for small subarrays.                #         aux[count[charAt(a[i], d) + 1]++] = a[i];                           #
     8|f e d|    8|e|b b|   e|8 |-  \      +-----+                     4|s h e +1|                ・Each function call needs its own count[] array.  #     for (int i = lo; i <= hi; i ++)                                         #
     9|b e d|    9|f|a d|   f|9 | \  ---->6|d a b|                      +--------------+          ・ASCII (256 counts): 100x slower than copy pass   #         a[i] = aux[i - lo];                                                 #
    10|e b b|   10|f|e e|   ++12|\ \      7|d a d|                     5|s h e l l s +1|          for N = 2.                                        #     for (int r = 0; r < R; r ++)                                            #  <-- sort R subarrays recursively
    11|a c e|   11|f|e d|    +--+ \ \      +-----+                      +--------------+          ・Unicode (65,536 counts): 32,000x slower          #         sort(a, aux, lo + count[r], lo + count[r + 1] - 1, d + 1);          #
      +-----+     +-----+          \ ---->8|e b b|                     6|s h o r e +1|            for N = 2.                                        #                                                                             #
                                    \      +-----+                      +--------------+          Observation 2. Huge number of small subarrays     # }                                                                           #
                                     ---->9|f a d|                     7|s u r e l y +1|          because of recursion.                             ###############################################################################
                                         10|f e e|                      +--------------+
                                         11|f e d|            
                                           +-----+            
                
    Cutoff to insertion sort                                                Summary of the performance of sorting algorithms                            MSD string sort vs. quicksort for strings
    Solution. Cutoff to insertion sort for small subarrays.                 +-------------------------------------------------------------------+        Disadvantages of MSD string sort.        
    ・Insertion sort, but start at dth character.                            |algorithm | guarantee | random  |space  |stable?|operations on keys|        ・Extra space for aux[]. 
    ・Implement less() so that it compares starting at dth character.        |insertion | ½N^2      | ¼N^2    |1      |yes    |compareTo()       |        ・Extra space for count[]. 
    ###################################################################     |mergesort | NlgN      | NlgN    |N      |yes    |compareTo()       |       ・Inner loop has a lot of instructions.
    #public static void sort(String[] a, int lo, int hi, int d) {     #     |quicksort | 1.39NlgN* | 1.39NlgN|clgN   |no     |compareTo()       |       ・Accesses memory "randomly" (cache inefficient).
    #    for (int i = lo; i <= hi; i ++)                              #     |heapsort  | 2NlgN     | 2NlgN   |1      |no     |compareTo()       |        
    #        for (int j = i; j > lo && less(a[j], a[j - 1], d); j --) #     |LSD       | 2NW       | 2NW     |N+R    |yes    |charAt()          |        Disadvantage of quicksort.
    #            exch(a, j, j - 1);                                   #     |MSD       | 2NW       | NlogRN  |N+DR   |yes    |charAt()          |       ・Linearithmic number of string compares (not linear).
    #}                                                                #     |          |           |         |       |       |                  |       ・Has to rescan many characters in keys with long prefix matches.
    #private static boolean less(String v, String w, int d) {         #     +-------------------------------------------------------------------+
    #    return v.substring(d).compareTo(w.substring(d)) < 0;         #
    #}                                                                #
    ###################################################################


- 3-way Radix Quicksort
                                                                                                            #################################################################                    
    partition by        partition <s by     partition =s by      partition =e by                            # private static void sort(String[] a) {                        #
    first char (s)        first char (b)    second char (e)      third char (a)                             #     sort(a, 0, a.length - 1, 0);                              #
    +----------+        +---------+         +-----------+        +-----------+        +-----------+         # }                                                             #
    |s|he      |        |b|y      | <s      |are        |        |are        |        |are        |         # private static void sort(String[] a, int lo, int hi, int d) { #
    |s|ells    |        |a|re     |         |by         |        |by         |        |by         |         #     if (hi <= lo)                                             #  3-way partitioning
    |s|eashells|        +---------+         +-----------+        +-----------+        +-----------+         #         return;                                               #  (using dth character)
    |b|y       |        |seashells| =s      |s|e|ashells|        |se|a|shells|=e      |sea|s|hells|=a       #     int lt = lo,                                              #
    |t|he      |        |she      |         |s|h|e      |        |se|l|ls    |        |sea| |     |         #     gt = hi;                                                  #
    |s|ea      |        |seashells|         |s|e|ashells|        |se|a|shells|        |sea|s|hells|         #     int v = charAt(a[lo], d);                                 #  <-- to handle variable-length strings
    |s|hore    |        |sea      |         |s|e|a      |        |se|a|      |        +-----------+         #     int i = lo + 1;                                           #
    |t|he      |        |shore    |         |s|h|ore    |        |se|l|ls    |        |sells      |>a       #     while (i <= gt) {                                         #
    |s|hells   |        |surely   |         |s|u|rely   |        +-----------+        |sells      |         #         int t = charAt(a[i], d);                              #  <-- to handle variable-length strings
    |s|he      |        |shells   |         |s|h|ells   |        |shells     |>e      +-----------+         #         if (t < v)                                            #
    |s|ells    |        |she      |         |s|h|e      |        |she        |        |shells     |         #             exch(a, lt ++, i ++);                             #
    |a|re      |        |sells    |         |s|e|lls    |        |surely     |        |she        |         #          else if (t > v)                                      #
    |s|urely   |        |sells    |         |s|e|lls    |        |shore      |        |surely     |         #             exch(a, i, gt --);                                #
    |s|eashells|        +---------+         +-----------+        |she        |        |shore      |         #          else                                                 #
    +----------+        |the      |>s       |the        |        +-----------+        |she        |         #             i ++;                                             #
                        |the      |         |the        |        |the        |        +-----------+         #     }                                                         #
                        +---------+         +-----------+        |the        |        |the        |         #     sort(a, lo, lt - 1, d);                                   #
                                                                 +-----------+        |the        |         #     if (v >= 0) sort(a, lt, gt, d + 1);                       #  <-- sort 3 subarrays recursively
                                                                                      +-----------+         #     sort(a, gt + 1, hi, d);                                   #
                                                                                                            # }                                                             #
                                                                                                            #################################################################
    3-way string quicksort vs. standard quicksort                                    3-way string quicksort vs. MSD string sort
    Standard quicksort.                                                                MSD string sort.
    ・Uses ~ 2N ln N string compares on average.                                         ・Is cache-inefficient.
    ・Costly for keys with long common prefixes (and this is a common case<=)             ・Too much memory storing count[].                                                                                                
                                                                                        ・Too much overhead reinitializing count[] and aux[]
    3-way string (radix) quicksort.                                                  
    ・Uses ~ 2N ln N character compares on average for random strings.                3-way string quicksort.         
    ・Avoids re-comparing long common prefixes.                                        ・Has a short inner loop.
                                                                                      ・Is cache-friendly.
                                                                                      ・Is in-place.   

    Summary of the performance of sorting algorithms                    
    +-------------------------------------------------------------------+                    
    |algorithm | guarantee | random  |space  |stable?|operations on keys|
    |insertion | ½N^2      | ¼N^2    |1      |yes    |compareTo()       |
    |mergesort | NlgN      | NlgN    |N      |yes    |compareTo()       |
    |quicksort | 1.39NlgN* | 1.39NlgN|clgN   |no     |compareTo()       |
    |heapsort  | 2NlgN     | 2NlgN   |1      |no     |compareTo()       |                    
    |LSD       | 2NW       | 2NW     |N+R    |yes    |charAt()          |                    
    |MSD       | 2NW       | NlogRN  |N+DR   |yes    |charAt()          |                    
    |3way quick| 1.39WNlgR | 1.39NlgN|logN+W |no     |charAt()          |                    
    +-------------------------------------------------------------------+                    
                        
- suffix arrays
- Keyword-in-context search
    Given a text of N characters, preprocess it to enable fast substring search
    (find all occurrences of query string context).
    
    input string                            form sufxes                             sort sufxes to bring repeated substrings together
    +----------------------------------+    +--------------------------------+      +--------------------------------+        Algorithm                    
    |i t w a s b e s t i t  w  a  s  w |    | 0 i t w a s b e s t i t w a s w|      | 3 a s b e s t                  |        ・Preprocess: suffix sort the text.
    |0 1 2 3 4 5 6 7 8 9 10 11 12 13 14|    | 1 t w a s b e s t i t w a s w  |      |12 a s w                        |        ・Query: binary search for query; scan until mismatch.
    +----------------------------------+    | 2 w a s b e s t i t w a s w    |      | 5 b e s t i t w a s w          |
                                            | 3 a s b e s t i t w a s w      |      | 6 e s t i t w a s w            |
                                            | 4 s b e s t i t w a s w        |      |  +---------+                   |
                                            | 5 b e s t i t w a s w          |      | 0|i t w a s|b e s t i t w a s w|
                                            | 6 e s t i t w a s w            |      | 9|i t w a s|w                  |
                                            | 7 s t i t w a s w              |      |  +---------+                   |
                                            | 8 t i t w a s w                |      | 4 s b e s t i t w a s w        |
                                            | 9 i t w a s w                  |      | 7 s t i t w a s w              |
                                            |10 t w a s w                    |      |13 s w                          |
                                            |11 w a s w                      |      | 8 t i t w a s w                |
                                            |12 a s w                        |      | 1 t w a s b e s t i t w a s w  |
                                            |13 s w                          |      |10 t w a s w                    |
                                            |14 w                            |      |14 w                            |
                                            +--------------------------------+      | 2 w a s b e s t i t w a s w    |
                                                                                    |11 w a s w                      |
                                                                                    +--------------------------------+
    
- Longest repeated substring
    Given a string of N characters, find the longest repeated substring. 
    
    input string                         form sufxes                        sort sufxes to bring repeated substrings together
    +----------------------------------+ +--------------------------------+ +--------------------------------+          #######################################################
    |a a c a a g t t t a c  a  a  g  c | | 0 a a c a a g t t t a c a a g c| | 0 a a c a a g t t t a c a a g c|          # public String lrs(String s) {                       #
    |0 1 2 3 4 5 6 7 8 9 10 11 12 13 14| | 1 a c a a g t t t a c a a g c  | |11 a a g c                      |          #     int N = s.length();                             #
    +----------------------------------+ | 2 c a a g t t t a c a a g c    | | 3 a a g t t t a c a a g c      |          #     String[] suffixes = new String[N];              #
                                         | 3 a a g t t t a c a a g c      | |  +---------+                   |          #     for (int i = 0; i < N; i ++)                    #  <--create suffixes
                                         | 4 a g t t t a c a a g c        | | 9|a c a a g|c                  |          #         suffixes[i] = s.substring(i, N);            #     (linear time and space)
                                         | 5 g t t t a c a a g c          | | 1|a c a a g|t t t a c a a g c  |          #     Arrays.sort(suffixes);                          #  <--sort suffixes
                                         | 6 t t t a c a a g c            | |  +---------+                   |          #     String lrs = "";                                #        
                                         | 7 t t a c a a g c              | |12 a g c                        |          #     for (int i = 0; i < N - 1; i ++) {              #  <--find LCP between
                                         | 8 t a c a a g c                | | 4 a g t t t a c a a g c        |          #         int len = lcp(suffixes[i], suffixes[i + 1]);#     adjacent suffixes in
                                         | 9 a c a a g c                  | |14 c                            |          #         if (len > lrs.length())                     #     sorted order
                                         |10 c a a g c                    | |10 c a a g c                    |          #             lrs = suffixes[i].substring(0, len);    #
                                         |11 a a g c                      | | 2 c a a g t t t a c a a g c    |          #     }                                               #
                                         |12 a g c                        | |13 g c                          |          #     return lrs;                                     #
                                         |13 g c                          | | 5 g t t t a c a a g c          |          # }                                                   #
                                         +--------------------------------+ | 8 t a c a a g c                |          #######################################################
                                                                            | 7 t t a c a a g c              |
                                                                            +--------------------------------+
    Problem. Suffix sorting: worst-case input    
    Bad input: longest repeated substring very long.
    ・Ex: same letter repeated N times.
    ・Ex: two copies of the same Java codebase.
    +---------------------+        +---------------------+    LRS needs at least 1 + 2 + 3 + ... + D character compares,
    |0 t w i n s t w i n s|        |9|i n s|             |    where D = length of longest match.
    |1 w i n s t w i n s  |        |8|i n s|t w i n s    |    Running time. Quadratic (or worse) in D for LRS (and also for sort).
    |2 i n s t w i n s    |        | +-----+             |
    |3 n s t w i n s      |        |7 n s                |
    |4 s t w i n s        |        |6 n s t w i n s      |
    |5 t w i n s          |        |5 s                  |
    |6 w i n s            |        |4 s t w i n s        |
    |7 i n s              |        | +---------+         |
    |8 n s                |        |3|t w i n s|         |
    |9 s                  |        |2|t w i n s|t w i n s|
    +---------------------+        | +---------+         |
                                   |1|w i n s|           |
                                   |0|w i n s|t w i n s  |
                                   +---------------------+

    Solution.
    Suffix sorting in linearithmic time
    Manber-Myers MSD algorithm overview.
    ・Phase 0: sort on first character using key-indexed counting sort.
    ・Phase i: given array of suffixes sorted on first 2i-1 characters,
    create array of suffixes sorted on first 2i
    characters.
    Worst-case running time. N lg N.
    ・Finishes after lg N phases.
    ・Can perform a phase in linear time. (<=) [ahead]
    
    Linearithmic suffix sort example: 
                                                phase 0                                            phase 1                                        phase 2
    original sufxes                                key-indexed counting sort (first character)     index sort (first two characters)           index sort (first four characters)
    +--------------------------------------+    +--------------------------------------+        +------+-------------------------------+    +----------+---------------------------+
    | 0 b a b a a a a b c b a b a a a a a 0|    |17|0|                                 |        |17|0  |                               |    |17|0      |                           |
    | 1 a b a a a a b c b a b a a a a a 0  |    | 1|a|b a a a a b c b a b a a a a a 0  |        |16|a 0|                               |    |16|a 0    |                           |
    | 2 b a a a a b c b a b a a a a a 0    |    |16|a|0                                |        |12|a a|a a a 0                        |    |15|a a 0  |                           |
    | 3 a a a a b c b a b a a a a a 0      |    | 3|a|a a a b c b a b a a a a a 0      |        | 3|a a|a a b c b a b a a a a a 0      |    |14|a a a 0|                           |
    | 4 a a a b c b a b a a a a a 0        |    | 4|a|a a b c b a b a a a a a 0        |        | 4|a a|a b c b a b a a a a a 0        |    |  |       +---------------------------+
    | 5 a a b c b a b a a a a a 0          |    | 5|a|a b c b a b a a a a a 0          |        | 5|a a|b c b a b a a a a a 0          |    | 3|a a a a|b c b a b a a a a a 0      |
    | 6 a b c b a b a a a a a 0            |    | 6|a|b c b a b a a a a a 0            |        |13|a a|a a 0                          |    |12|a a a a|a 0                        |
    | 7 b c b a b a a a a a 0              |    |15|a|a 0                              |        |15|a a|0                              |    |13|a a a a|0                          |
    | 8 c b a b a a a a a 0                |    |14|a|a a 0                            |        |14|a a|a 0                            |    |  |       +---------------------------+
    | 9 b a b a a a a a 0                  |    |13|a|a a a 0                          |        |  |   +-------------------------------+    | 4|a a a b|c b a b a a a a a 0        |
    |10 a b a a a a a 0                    |    |12|a|a a a a 0                        |        | 6|a b|c b a b a a a a a 0            |    | 5|a a b c|b a b a a a a a 0          |
    |11 b a a a a a 0                      |    |10|a|b a a a a a 0                    |        | 1|a b|a a a a b c b a b a a a a a 0  |    |  |       +---------------------------+
    |12 a a a a a 0                        |    |  | +---------------------------------+        |10|a b|a a a a a 0                    |    | 1|a b a a|a a b c b a b a a a a a 0  |
    |13 a a a a 0                          |    | 0|b|a b a a a a b c b a b a a a a a 0|        |  |   +-------------------------------+    |10|a b a a|a a a 0                    |
    |14 a a a 0                            |    | 9|b|a b a a a a a 0                  |        | 0|b a|b a a a a b c b a b a a a a a 0|    |  |       +---------------------------+
    |15 a a 0                              |    |11|b|a a a a a 0                      |        | 9|b a|b a a a a a 0                  |    | 6|a b c b|a b a a a a a 0            |
    |16 a 0                                |    | 7|b|c b a b a a a a a 0              |        |11|b a|a a a a 0                      |    |  |       +---------------------------+
    |17 0                                  |    | 2|b|a a a a b c b a b a a a a a 0    |        | 2|b a|a a a b c b a b a a a a a 0    |    | 2|b a a a|a b c b a b a a a a a 0    |
    +--------------------------------------+    |  | +---------------------------------+        |  |   +-------------------------------+    |11|b a a a|a a 0                      |
                                                | 8|c|b a b a a a a a 0                |        | 7|b c|b a b a a a a a 0              |    |  |       +---------------------------+
                                                +--------------------------------------+        +--------------------------------------+    | 0|b a b a|a a a b c b a b a a a a a 0|
                                                                                                                                            | 9|b a b a|a a a a 0                  |
                                                                                                                                            |  |       +---------------------------+
                                                                                                                                            | 7|b c b a|b a a a a a 0              |
                                                                                                                                            | 8|c b a b|a a a a a 0                |
                                                                                                                                            +--------------------------------------+
                                                Constant-time string compare by indexing into inverse
    phase 3                                        index sort (first four characters)                                                inverse[]
    index sort (first eight characters)         +--------------------------------------+                                        +-----+
    +------------------+-------------------+    |17|0                                  |                                        | 0|14|
    |17|0              |                   |    |16|a 0                                |                                        | 1|9 |
    |16|a 0            |                   |    |15|a a 0                              |                                        | 2|12|
    |15|a a 0          |                   |    |14|a a a 0                            |                                        | 3|4 |
    |14|a a a 0        |                   |    | 3|a a a a b c b a b a a a a a 0      |                                        |  +--+
    |13|a a a a 0      |                   |    |12|a a a a a 0                        |                                        | 4|7 |
    |12|a a a a a 0    |                   |    |  |-------+                           |                                        |  +--+
    | 3|a a a a b c b a|b a a a a a 0      |    |13|a a a a|0                          |                                        | 5|8 |
    | 4|a a a b c b a b|a a a a a 0        |    |  |-------+                           |                                        | 6|11|
    | 5|a a b c b a b a|a a a a 0          |    | 4|a a a b|c b a b a a a a a 0        |                                        | 7|16|
    |10|a b a a a a a 0|                   |    |  |-------+                           |                                        | 8|17|
    | 1|a b a a a a b c|b a b a a a a a 0  |    | 5|a a b c b a b a a a a a 0          |                                        | 9|15|
    | 6|a b c b a b a a|a a a 0            |    | 1|a b a a a a b c b a b a a a a a 0  |                                        |10|10|
    |11|b a a a a a 0  |                   |    |10|a b a a a a a 0                    |                                        |11|13|
    | 2|b a a a a b c b|a b a a a a a 0    |    | 6|a b c b a b a a a a a 0            |                                        |12|5 |
    | 9|b a b a a a a a|0                  |    | 2|b a a a a b c b a b a a a a a 0    |                                        |  +--+
    | 0|b a b a a a a b|c b a b a a a a a 0|    |11|b a a a a a 0                      |                                        |13|6 |
    | 7|b c b a b a a a|a a 0              |    |  |       +-------+                   |                                        |  +--+
    | 8|c b a b a a a a|a 0                |    | 0|b a b a|a a a b|c b a b a a a a a 0|  <-- 0+4=4                             |14|3 |
    +--------------------------------------+    |  |       +-------+                   |                                        |15|2 |
    finished (no equal keys)                    | 9|b a b a|a a a a|0                  |  <-- 9+4=13                            |16|1 |
                                                |  |       +-------+                   |    suffixes4[13] ≤ suffixes4[4]        |17|0 |
                                                | 7|b c b a b a a a a a 0              |    (because inverse[13] < inverse[4])  +-----+
                                                | 8|c b a b a a a a a 0                |    so suffixes8[9] ≤ suffixes8[0]
                                                +--------------------------------------+

###############
# week4
###############

- R-way Tries
    Tries. [from retrieval, but pronounced "try"]
    ・Store characters in nodes (not keys).
    ・Each node has R children, one for each possible character.
    ・For now, we do not draw null links.

    ######################################  +------------+        Search in a trie                                                          #################################################################   ###########################################
    #                +-+root             #  |key   |value|         ・Search hit: node where search ends has a non-null value.                # public class TrieST<Value> {                                  #   # private static class Node {             #    characters are implicitly defined by link index 
    #      /---------| |---------\       #  |by    |4    |         ・Search miss: reach null link or node where search ends has null value.  #     private static final int R = 256;                         #   #     private Object value;               #    neither keys nor characters are explicitly stored 
    #     /          +++          \      #  |sea   |6    |                                                                                  #     private Node root = new Node();                           #   #     private Node[] next = new Node[R];  #    each node has an array of links and a value
    #    /            |            \     #  |sells |1    |        Insertion into a trie                                                     #     private static class Node { /* see previous slide */      #   # }                                       #
    # +-+            +++            +-+  #  |she   |0    |         ・Encounter a null link: create new node.                                 #     }                                                         #   ########################################### 
    # |b|          / |s| \          |t|  #  |shells|3    |         ・Encounter the last character of the key: set value in that node.        #     public void put(String key, Value val) {                  # 
    # +++         /  +-+  \         +++  #  |shore |7    |                                                                                  #         root = put(root, key, val, 0);                        #    Trie performance
    #  |       +-+         +-+       |   #  |the   |5    |        To delete a key-value pair:                                               #     }                                                         #     Search hit. Need to examine all L characters for equality.
    # +++      |e|         |h|      +++  #  +------------+         ・Find the node corresponding to key and set value to null.               #     private Node put(Node x, String key, Value val, int d) {  #     Search miss. 
    # |y|4     +-+         +-+      |h|  #                         ・If node has null value and all null links, remove that node (and recur).#         if (x == null) x = new Node();                        #      ・Could have mismatch on first character. 
    # +-+     /   \       /   \     +++  #                                                                                                  #                                                               #      ・Typical case: examine only a few characters (sublinear).
    #       +-+   +-+   +-+   +-+    |   #                                                                                                  #         if (d == key.length()) { x.val = val; return x;}      #     Space. R null links at each leaf.
    #       |a|2  |l|   |e|0  |o|   +++  #                                                                                                  #         char c = key.charAt(d);                               #     (but sublinear space possible if many short strings share common prefixes)
    #       +-+   +++   +++   +++   |e|5 #                                                                                                  #         x.next[c] = put(x.next[c], key, val, d + 1);          #
    #              |     |     |    +-+  #                                                                                                  #         return x;                                             #    Popular interview question
    #             +++   +++   +++        #                                                                                                  #     }                                                         #    Goal. Design a data structure to perform efficient spell checking.
    #             |l|   |l|   |r|        #                                                                                                  #     public boolean contains(String key) {                     #    Solution. Build a 26-way trie (key = word, value = bit).
    #             +++   +++   +++        #                                                                                                  #         return get(key) <== null;                              #
    #              |     |     |         #                                                                                                  #     }                                                         #
    #             +++   +++   +++        #                                                                                                  #     public Value get(String key) {                            #
    #             |s|1  |l|   |e|7       #                                                                                                  #         Node x = get(root, key, 0);                           #
    #             +-+   +++   +-+        #                                                                                                  #         if (x == null)                                        #
    #                    |               #                                                                                                  #             return null;                                      #
    #                   +++              #                                                                                                  #         return(Value)x.val;                                   #
    #                   |s|3             #                                                                                                  #     }                                                         #
    #                   +-+              #                                                                                                  #     private Node get(Node x, String key, int d) {             #
    #                                    #                                                                                                  #         if (x == null) return null;                           #
    ######################################                                                                                                  #         if (d == key.length())  return x;                     #
                                                                                                                                            #         char c = key.charAt(d);                               #
                                                                                                                                            #         return get(x.next[c], key, d + 1);                    #
                                                                                                                                            #     }                                                         #
                                                                                                                                            # }                                                             #
                                                                                                                                            #################################################################

- Ternary search tries
    ・Store characters and values in nodes (not keys).
    ・Each node has 3 children: smaller (left), equal (middle), larger (right).

    ############################    Search in a TST                                                           TST representation in Java     ##################################################################################
    #           +-+            #    Follow links corresponding to each character in the key.                   A TST node is five fields:    # public class TST<Value> {                                                      #
    #           |s|            #    ・If less, take left link; if greater, take right link.                     ・A value.                     #     private Node root;                                                         # 
    #        /--+-+--\         #    ・If equal, take the middle link and move to the next key character.        ・A character c.               #     private class Node { /* see previous slide */                              # 
    #    /---    |    ---\     #    Search hit. Node where search ends has a non-null value.                   ・A reference to a left TST.   #     }                                                                          # 
    # +-+       +|+       +-+  #    Search miss. Reach a null link or node where search ends has null value.   ・A reference to a middle TST. #     public void put(String key, Value val) {                                   # 
    # |b|       |h|       |t|  #                                                                               ・A reference to a right TST.  #         root = put(root, key, val, 0);                                         # 
    # +-+      /+-+       +-+  #    26-way trie vs. TST                                                                                      #     }                                                                          #
    #  |      /  |         |   #     26-way trie. 26 null links in each leaf.                    ###################################         #     private Node put(Node x, String key, Value val, int d) {                   #
    # +-+  +-+  +|+       +-+  #    TST. 3 null links in each leaf.                              # private class Node {            #         #         char c = key.charAt(d);                                                #
    # |y|4 |e|  |e|0      |h|  #                                                                 #     private Value val;          #         #         if (x == null) {                                                       #
    # +-+  +-+  +-+\      +-+  #    TST vs. hashing                                              #     private char c;             #         #             x = new Node();                                                    #
    #       |    |  \      |   #    Hashing.                                                     #     private Node left,mid,right;#         #             x.c = c;                                                           #
    #      +|+  +|+  +-+  +-+  #    ・Need to examine entire key.                                 # }                               #         #         }                                                                      #
    #      |l|  |l|  |o|  |e|5 #    ・Search hits and misses cost about the same.                 ###################################         #         if (c < x.c) x.left = put(x.left, key, val, d);                        #
    #     /+-+  +-+  +-+  +-+  #    ・Performance relies on hash function.                                                                    #          else if (c > x.c)    x.right = put(x.right, key, val, d);             #
    #    /  |    |    |        #    ・Does not support ordered symbol table operations.                                                       #          else if (d < key.length() - 1)  x.mid = put(x.mid, key, val, d + 1);  #
    # +-+  +|+  +|+  +|+       #    TSTs.                                                                                                    #          else  x.val = val;                                                    #
    # |a|  |l|  |l|  |r|       #    ・Works only for strings (or digital keys).                                                               #         return x;                                                              #
    # +-+  +-+  +-+  +-+       #    ・Only examines just enough key characters.                                                               #     }                                                                          #
    #       |    |    |        #    ・Search miss may involve only a few characters.                                                          #     public boolean contains(String key) {                                      #
    #      +|+  +|+  +|+       #    ・Supports ordered symbol table operations (plus others<=).                                                #         return get(key) <== null;                                               #
    #      |s|1 |s|3 |e|7      #    Bottom line. TSTs are:                                                                                   #     }                                                                          #
    #      +-+  +-+  +-+       #    ・Faster than hashing (especially for search misses).                                                     #     public Value get(String key) {                                             #
    ############################    ・More flexible than red-black BSTs. [stay tuned]                                                         #         Node x = get(root, key, 0);                                            #
                                                                                                                                             #         if (x == null)  return null;                                           #
    Ordered iteration                                                                                                                        #         return x.val;                                                          #
    To iterate through all keys in sorted order:                                                                                             #     }                                                                          #
      ・Do inorder traversal of trie; add keys encountered to a queue.                                                                        #     private Node get(Node x, String key, int d) {                              #
      ・Maintain sequence of characters on path from root to node.                                                                            #         if (x == null)  return null;                                           #
    ###################################################################                                                                      #         char c = key.charAt(d);                                                #
    # public Iterable<String> keys() {                                #                                                                      #         if (c < x.c)  return get(x.left, key, d);                              #
    #     Queue<String> queue = new Queue<String>();                  #                                                                      #         else if (c > x.c)  return get(x.right, key, d);                        #
    #     collect(root, "", queue);                                   #                                                                      #         else if (d < key.length() - 1)  return get(x.mid, key, d + 1);         #
    #     return queue;                                               #                                                                      #         else  return x;                                                        #
    # }                                                               #                                                                      #     }                                                                          #
    # private void collect(Node x, String prefix, Queue<String> q) {  #                                                                      # }                                                                              #
    #     if (x == null) return;                                      #                                                                      ##################################################################################
    #     if (x.val <== null) q.enqueue(prefix);                       #   
    #     for (char c = 0; c < R; c ++)                               #   
    #         collect(x.next[c], prefix + c, q);                      #   
    #                                                                 #   
    # }                                                               #   
    ###################################################################   

    ############################    Prefix matches in an R-way trie                                 Longest prefix
    #           +-+            #    ############################################################    Find longest key in symbol table that is a prefix of query string.
    #           |s|            #    # public Iterable<String> keysWithPrefix(String prefix) {  #    ・Search for query string.
    #        /--+-+--\         #    #     Queue<String> queue = new Queue<String>();           #    ・Keep track of longest key encountered.
    #    /---    |    ---\     #    #     Node x = get(root, prefix, 0);                       #    Find longest key in symbol table that is a prefix of query string.
    # +-+       +|+       +-+  #    #     collect(x, prefix, queue);                           #    ・Search for query string.
    # |b|       |h|       |t|  #    #     return queue;                                        #    ・Keep track of longest key encountered.
    # +-+      /+-+       +-+  #    # }                                                        #    ##################################################################
    #  |      /  |         |   #    ############################################################    # public String longestPrefixOf(String query) {                  #
    # +-+  +-+  +|+       +-+  #                                                                    #     int length = search(root, query, 0, 0);                    #
    # |y|4 |e|  |e|0      |h|  #    keysWithPrefix("sh")                                            #     return query.substring(0, length);                         #
    # +-+  +-+  +-+\      +-+  #    she shells shore                                                # }                                                              #
    #       |    |  \      |   #                                                                    # private int search(Node x, String query, int d, int length) {  #
    #      +|+  +|+  +-+  +-+  #                                                                    #     if (x == null)  return length;                             #
    #      |l|  |l|  |o|  |e|5 #                                                                    #                                                                #
    #     /+-+  +-+  +-+  +-+  #                                                                    #     if (x.val <== null) length = d;                             #
    #    /  |    |    |        #                                                                    #                                                                #
    # +-+  +|+  +|+  +|+       #                                                                    #     if (d == query.length()) return length;                    #
    # |a|  |l|  |l|  |r|       #                                                                    #                                                                #
    # +-+  +-+  +-+  +-+       #                                                                    #     char c = query.charAt(d);                                  #
    #       |    |    |        #                                                                    #     return search(x.next[c], query, d + 1, length);            #
    #      +|+  +|+  +|+       #                                                                    # }                                                              #
    #      |s|1 |s|3 |e|7      #                                                                    ##################################################################
    #      +-+  +-+  +-+       #
    ############################

- SUBSTRING SEARCH

    brute force
    #########################################################
    # public static int search(String pat, String txt) {    #
    #     int M = pat.length();                             #
    #     int N = txt.length();                             #
    #     for (int i = 0; i <= N - M; i ++) {               #
    #         int j;                                        #
    #         for (j = 0; j < M; j ++)                      #
    #             if (txt.charAt(i + j) != pat.charAt(j))   #
    #                 break;                                #      index in text where
    #         if (j == M)                                   #  <-- pattern starts
    #             return i;                                 #
    #     }                                                 #
    #     return N;                                         #  <-- not found
    # }                                                     #
    #########################################################

- Knuth-Morris-Pratt
    Intuition. Suppose we are searching in text for pattern BAAAAAAAAA.
    ・Suppose we match 5 chars in pattern, with mismatch on 6th char.
    ・We know previous 6 chars in text are BAAAAB.
    ・Don't need to back up text pointer<=

    Deterministic finite state automaton (DFA)                    Interpretation of Knuth-Morris-Pratt DFA
    DFA is abstract string-searching machine.                     Q. What is interpretation of DFA state after reading in txt[i]?
    ・Finite number of states (including start and halt).          A. State = number of characters in pattern that have been matched. <-- (length of longest prefix of pat[] that is a suffix of txt[0..i])
    ・Exactly one transition for each char in alphabet.            Ex. DFA is in state 3 after reading in txt[0..6].
    ・Accept if sequence of transitions leads to halt state.                       i
                                                                  +-----------------+           +-----------+
    internal representation                                       |0|1|2|3|4|5|6|7|8|           |0|1|2|3|4|5|
                j  0 1 2 3 4 5                                    +-----------------+           +-----------+
                --------------    If in state j reading char c:   |B|C|B|A|A|B|A|C|A|  <-- txt  |A|B|A|B|A|C|  <-- pat
    pat.charAt(j)  A B A B A C    if j is 6 halt and accept       +-----------------+           +-----------+
                |A 1 1 3 1 5 1    else move to state dfa[c][j]             * * *                 * * *
        dfa[][j]|B 0 2 0 4 0 4                                        suffix of txt[0..6]        prefix of pat
                |C 0 0 0 0 0 6    

    graphical representation                                      Knuth-Morris-Pratt substring search: Java implementation           Constructing the DFA for KMP substring search: Java implementation
    #########################################################     Key differences from brute-force implementation.                   For each state j:
    #                                   A                   #     ・Need to precompute dfa[][] from pattern.                           ・Copy dfa[][X] to dfa[][j] for mismatch case. 
    #                /<---------------------\               #     ・Text pointer i never decrements.                                   ・Set dfa[pat.charAt(j)][j] to j+1 for match case. 
    #  B C      A   /     A                  \              #                                                                         ・Update X.
    #  ---     --- /<--------\              B \             #    ##################################################                   ##############################################      How to build DFA from pattern?
    #  | |     | |/           \           /<--\\            #    # public int search(String txt) {                #                   # public KMP(String pat) {                   #      Mismatch transition. If in state j and next char c <== pat.charAt(j),
    #  v-+ A   v-+ B   +-+ A   +-+ B   +-+ A   +-+ C   +-+  #    #     int i,j,N = txt.length();                  #                   #     this.pat = pat;                        #      then the last j-1 characters of input are pat[1..j-1], followed by c.
    #  |0|---->|1|---->|2|---->|3|---->|4|---->|5|---->|6|  #    #     for (i = 0, j = 0; i < N && j < M; i ++)   #                   #     M = pat.length();                      #      
    #  +-+  C  +-+     +-+     +-+     +-+     +-+     +-+  #    #         j = dfa[txt.charAt(i)][j];             #  <-- no backup    #     dfa = new int[R][M];                   #      To compute dfa[c][j]: Simulate pat[1..j-1] on DFA and take transition c.
    #   \\\<--/  B C  /       /       /                     #    #     if (j == M) return i - M;                  #                   #     dfa[pat.charAt(0)][0] = 1;             #      Running time. Takes only constant time if we maintain state X.
    #    \\<---------/    C  /       /                      #    #      else return N;                            #                   #     for (int X = 0, j = 1; j < M; j ++) {  #      
    #     \\<---------------/  B C  /                       #    # }                                              #                   #         for (int c = 0; c < R; c ++)       #      Ex.  dfa['A'][5] = 1;      dfa['B'][5] = 4;      X'= 0                +-----------+
    #      \<----------------------/                        #    ##################################################                   #             dfa[c][j] = dfa[c][X];         #           from state X,         from state X,         from state X,        |0|1|2|3|4|5|
    #########################################################                                                                         #         dfa[pat.charAt(j)][j] = j + 1;     #           take transition 'A'   take transition 'B'   take transition 'C'  +-----------+
                                                                                                                                      #         X = dfa[pat.charAt(j)][X];         #           = dfa['A'][X]         = dfa['B'][X]         = dfa['C'][X]        |A|B|A|B|A|C|
                                                                                                                                      #     }                                      #                                                                            +-----------+
                                                                                                                                      # }                                          #                                                                               * * * *
                                                                                                                                      ############################################## 

    Constructing the DFA for KMP substring search for A B A B A C
                                                                               *                                                               *
                j  0 1 2 3 4 5                                              j  0 1 2 3 4 5                                               j  0 1 2 3 4 5
                --------------                                              --------------                                               --------------
    pat.charAt(j)  A B A B A C                                  pat.charAt(j)  A B A B A C                                   pat.charAt(j)  A B A B A C
                |A 1   3   5                                                |A 1   3   5                                                 |A 1 1 3   5  
        dfa[][j]|B   2   4                                          dfa[][j]|B 0 2   4                                           dfa[][j]|B 0 2   4    
                |C           6                                              |C 0         6                                               |C 0 0       6
    1. added match transitions                                  2. fill in zeros, X is inited to 0
    ########################################################    #########################################################    3.mismatches = what would happend if we found those chars in pos X: A->1, B->0
    #                                                      #    #  B C                                                  #    update X = where would it be if we matched B = 0
    # +-+ A   +-+ B   +-+ A   +-+ B   +-+ A   +-+ C   +-+  #    #  ---                                                  #    #########################################################
    # |0|---->|1|---->|2|---->|3|---->|4|---->|5|---->|6|  #    #  | |                                                  #    #  B C      A                                           #
    # +-+     +-+     +-+     +-+     +-+     +-+     +-+  #    #  v-+ A   +-+ B   +-+ A   +-+ B   +-+ A   +-+ C   +-+  #    #  ---     ---                                          #
    ########################################################    #  |0|---->|1|---->|2|---->|3|---->|4|---->|5|---->|6|  #    #  | |     | |                                          #
                                                                #  +-+     +-+     +-+     +-+     +-+     +-+     +-+  #    #  v-+ A   v-+ B   +-+ A   +-+ B   +-+ A   +-+ C   +-+  #
                                                                # X                                                     #    #  |0|---->|1|---->|2|---->|3|---->|4|---->|5|---->|6|  #
                                                                #########################################################    #  +-+  C  +-+     +-+     +-+     +-+     +-+     +-+  #
                                                                                                                             # X   \<--/                                             #
                                                                                                                             #########################################################
                       *                                                             *                                                              *                                                             *
                j  0 1 2 3 4 5                                              j  0 1 2 3 4 5                                               j  0 1 2 3 4 5                                              j  0 1 2 3 4 5
                --------------                                              --------------                                               --------------                                              --------------
    pat.charAt(j)  A B A B A C                                  pat.charAt(j)  A B A B A C                                   pat.charAt(j)  A B A B A C                                  pat.charAt(j)  A B A B A C
                |A 1 1 3   5                                                |A 1 1 3 1 5                                                 |A 1 1 3 1 5                                                |A 1 1 3 1 5 1
        dfa[][j]|B 0 2 0 4                                          dfa[][j]|B 0 2 0 4                                           dfa[][j]|B 0 2 0 4 0                                        dfa[][j]|B 0 2 0 4 0 4
                |C 0 0 0     6                                              |C 0 0 0 0   6                                               |C 0 0 0 0 0 6                                              |C 0 0 0 0 0 6
    4.mismatches = what would happend if we found those         5.mismatches = what would happend if we found those          6.mismatches = what would happend if we found those         6.mismatches = what would happend if we found those
    chars in pos X: B->0, C->0                                  chars in pos X: A->1, C->0                                   chars in pos X(2): B->0, C->0                               chars in pos X(3): A->0, B->0
    update X = where would it be if we matched A = 1            update X = where would it be if we matched B = 2             update X = where would it be if we matched A = 3            update X = where would it be if we matched C = 0
    ########################################################    ########################################################     ########################################################    #########################################################
    # B C      A                                           #    # B C      A         A                                 #     # B C      A         A                                 #    #                                   A                   #
    # ---     ---                                          #    # ---     --- /<--------\                              #     # ---     --- /<--------\                              #    #                /<---------------------\               #
    # | |     | |                                          #    # | |     | |/           \                             #     # | |     | |/           \                             #    #  B C      A   /     A                  \              #
    # v-+ A   v-+ B   +-+ A   +-+ B   +-+ A   +-+ C   +-+  #    # v-+ A   v-+ B   +-+ A   +-+ B   +-+ A   +-+ C   +-+  #     # v-+ A   v-+ B   +-+ A   +-+ B   +-+ A   +-+ C   +-+  #    #  ---     --- /<--------\              B \             #
    # |0|---->|1|---->|2|---->|3|---->|4|---->|5|---->|6|  #    # |0|---->|1|---->|2|---->|3|---->|4|---->|5|---->|6|  #     # |0|---->|1|---->|2|---->|3|---->|4|---->|5|---->|6|  #    #  | |     | |/           \           /<--\\            #
    # +-+  C  +-+X    +-+     +-+     +-+     +-+     +-+  #    # +-+  C  +-+     +-+X    +-+     +-+     +-+     +-+  #     # +-+  C  +-+     +-+     +-+X    +-+     +-+     +-+  #    #  v-+ A   v-+ B   +-+ A   +-+ B   +-+ A   +-+ C   +-+  #
    #   \\<--/  B C  /                                     #    #  \\\<--/  B C  /       /                             #     #  \\\<--/  B C  /       /       /                     #    #  |0|---->|1|---->|2|---->|3|---->|4|---->|5|---->|6|  #
    #    \<---------/                                      #    #   \\<---------/    C  /                              #     #   \\<---------/    C  /       /                      #    #  +-+  C  +-+     +-+     +-+     +-+     +-+     +-+  #
    ########################################################    #    \\<---------------/                               #     #    \\<---------------/  B C  /                       #    # X \\\<--/  B C  /       /       /                     #
                                                                ########################################################     #     \<----------------------/                        #    #    \\<---------/    C  /       /                      #
                                                                                                                             ########################################################    #     \\<---------------/  B C  /                       #
                                                                                                                                                                                         #      \<----------------------/                        #
                                                                                                                                                                                         #########################################################
    
- Boyer-Moore
    Intuition.                                                                                              Q. How much to skip?
    ・Scan characters in pattern from right to left.                                                         A. Precompute index of rightmost occurrence of character c in pattern (-1 if character not in pattern).
     ・Can skip as many as M text chars when finding one not in the pattern.                                 ##################################    ##################################    ######################################################################   
                                                                                                            #   +     N E E D L E            #    # right = new int[R];            #    # public int search(String txt) {                                    #
    How much to skip?                              How much to skip?                                        #  c|     0 1 2 3 4 5 right[c]   #    # for (int c = 0; c < R; c ++)   #    #     int N = txt.length();                                          #
    Mismatch character in pattern.                 Mismatch character in pattern (but heuristic no help).   # +---------------------------+  #    #     right[c] = -1;             #    #     int M = pat.length();                                          #
    mismatch character 'N' in pattern:             mismatch character 'E' in pattern:                       #  A| -1 -1-1-1-1-1-1 -1         #    #                                #    #     int skip;                                                      #
    align text 'N' with rightmost pattern 'N'      align text 'E' with rightmost pattern 'E' ?              #  B| -1 -1-1-1-1-1-1 -1         #    # for (int j = 0; j < M; j ++)   #    #     for (int i = 0; i <= N - M; i += skip) {                       #
                                                   mismatch character 'E' in pattern: increment i by 1      #  C| -1 -1-1-1-1-1-1 -1         #    #     right[pat.charAt(j)] = j;  #    #         skip = 0;                                                  #
    before       after                             before       after                                       #  D| -1 -1-1-1 3-1-1  3         #    ##################################    #         for (int j = M - 1; j >= 0; j --) {                        #
           *            *                                 *            *                                    #  E| -1 -1 1 2-1-1 5  5         #                                          #             if (pat.charAt(j) <== txt.charAt(i + j)) {              #
       +------+     +---------+                       +------+     +---------+                              #  .|                 -1         #    Boyer-Moore skip table computation    #                 skip = Math.max(1, j - right[txt.charAt(i + j)]);  #
    txt|...NLE|  txt|...NLE   |                    txt|...ELE|  txt|...ELE   |                              #  L| -1 -1-1-1-1 4 4  4         #                                          #                 break;                                             #
    pat|NEEDLE|  pat|   NEEDLE|                    pat|NEEDLE|  pat| NEEDLE  |                              #  M| -1 -1-1-1-1-1-1  0         #                                          #             }                                                      #
       +------+     +---------+                       +------+     +---------+                              #  N| -1  0-1-1-1-1-1 -1         #                                          #         }                                                          #
                                                                                                            #  .|                            #                                          #         if (skip == 0)                                             #
                                                                                                            #   +                            #                                          #             return i;                                              #
                                                                                                            ##################################                                          #     }                                                              #
                                                                                                                                                                                        #     return N;                                                      #
                                                                                                                                                                                        # }                                                                  #
                                                                                                                                                                                        ######################################################################

- Rabin-Karp
    Basic idea = modular hashing.                                    Efficiently computing the hash function
    ・Compute a hash of pattern characters 0 to M - 1.                Modular hash function. Using the notation ti for txt.charAt(i),we wish to compute
    ・For each i, compute a hash of text characters i to M + i - 1.   Intuition. M-digit, base-R integer, modulo Q.
    ・If pattern hash = text substring hash, check for a match.       Horner's method. Linear-time method to evaluate degree-M polynomial.

    ##############################################                   #################################################    #############################################
    #     pat.charAt(i)                          #                   # pat.charAt()                                  #    # // Compute hash for M-digit key           #
    #   i 0 1 2 3 4                              #                   # i 0 1 2 3 4                                   #    # private long hash(String key, int M) {    #
    # +------------+                             #                   #   2 6 5 3 5                                   #    #     long h = 0;                           #
    #     2 6 5 3 5 % 997 = 613                  #                   # 0 2 % 997 = 2                                 #    #     for (int j = 0; j < M; j ++)          #
    #                                            #                   # 1 2 6 % 997 = (2*10 + 6) % 997 = 26           #    #         h = (R * h + key.charAt(j)) % Q;  #
    #                                            #                   # 2 2 6 5 % 997 = (26*10 + 5) % 997 = 265       #    #     return h;                             #
    #                txt.charAt(i)               #                   # 3 2 6 5 3 % 997 = (265*10 + 3) % 997 = 659    #    # }                                         #
    #  i 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15   #                   # 4 2 6 5 3 5 % 997 = (659*10 + 5) % 997 = 613  #    #############################################
    # +---------------------------------------+  #                   #################################################
    #    3 1 4 1 5 9 2 6 5 3 5  8  9  7  9  3    #
    #  0 3 1 4 1 5 % 997 = 508                   #
    #  1   1 4 1 5 9 % 997 = 201                 #                   what is -30
    #  2     4 1 5 9 2 % 997 = 715               #                   ###############################################################################    #################################################################
    #  3       1 5 9 2 6 % 997 = 971             #                   #  i 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15                                    #    #               i ... 2 3 4 5 6 7 ...                           #
    #  4         5 9 2 6 5 % 997 = 442           #                   # +---------------------------------------+                                   #    #              +---------------------+                          #
    #  5           9 2 6 5 3 % 997 = 929         #                   #    3 1 4 1 5 9 2 6 5 3 5  8  9  7  9  3                                     #    # current ^alue     1 4 1 5 9 2 6 5                             #
    #  6             2 6 5 3 5 % 997 = 613       #                   #  0 3 % 997 = 3                                                              #    #     new value       4 1 5 9 2 6 5                             #
    ##############################################                   #  1 3 1 % 997 = (3*10 + 1) % 997 = 31                                        #    #                                                               #
                                                                     #  2 3 1 4 % 997 = (31*10 + 4) % 997 = 314                                    #    #                     4 1 5 9 2        current value            #
                                                                     #  3 3 1 4 1 % 997 = (314*10 + 1) % 997 = 150                                 #    #                   + 4 0 0 0 0                                 #
                                                                     #  4 3 1 4 1 5 % 997 = (150*10 + 5) % 997 = 508                               #    #                       1 5 9 2        substract leading digit  #
                                                                     #  5   1 4 1 5 9 % 997 = ((508 + 3*(997 - 30))*10 + 9) % 997 = 201            #    #                         * 1 0        multiply by radix        #
                                                                     #  6     4 1 5 9 2 % 997 = ((201 + 1*(997 - 30))*10 + 2) % 997 = 715          #    #                     1 5 9 2 0                                 #
                                                                     #  7       1 5 9 2 6 % 997 = ((715 + 4*(997 - 30))*10 + 6) % 997 = 971        #    #                           + 6        add new trailing digit   #
                                                                     #  8         5 9 2 6 5 % 997 = ((971 + 1*(997 - 30))*10 + 5) % 997 = 442      #    #                     1 5 9 2 6        new value                #
                                                                     #  9           9 2 6 5 3 % 997 = ((442 + 5*(997 - 30))*10 + 3) % 997 = 929    #    #################################################################
                                                                     # 10             2 6 5 3 5 % 997 = ((929 + 9*(997 - 30))*10 + 5) % 997 = 613  #
                                                                     ###############################################################################
    
    Rabin-Karp: Java implementation
    ##########################################################################
    # public class RabinKarp {                                               #
    #     private long patHash; // pattern hash value                        #
    #     private int M; // pattern length                                   #
    #     private long Q; // modulus                                         #
    #     private int R; // radix                                            #
    #     private long RM; // R^(M-1) % Q                                    #
    #     public RabinKarp(String pat) {                                     #
    #         M = pat.length();                                              #
    #         R = 256;                                                       #     a large prime
    #         Q = longRandomPrime();                                         #  <--(but avoid overflow)
    #         RM = 1;                                                        #
    #         for (int i = 1; i <= M - 1; i ++)                              #  <--precompute R^M – 1 (mod Q)
    #             RM = (R * RM) % Q;                                         #
    #                                                                        #
    #         patHash = hash(pat, M);                                        #
    #     }                                                                  #
    #     private long hash(String key, int M) { /* as before */}            #
    #     public int search(String txt) {                                    #  <--check for hash collision
    #         int N = txt.length();                                          #     using rolling hash function
    #         int txtHash = hash(txt, M);                                    #
    #         if (patHash == txtHash) return 0;                              #
    #         for (int i = M; i < N; i ++) {                                 #
    #             txtHash = (txtHash + Q - RM * txt.charAt(i - M) % Q) % Q;  #
    #             txtHash = (txtHash * R + txt.charAt(i)) % Q;               #
    #             if (patHash == txtHash)                                    #
    #                 return i - M + 1;                                      #
    #         }                                                              #
    #         return N;                                                      #
    #     }                                                                  #
    # }                                                                      #
    ##########################################################################
    
###############
# week5
###############

- REGULAR EXPRESSIONS
- NFAs
    Duality between REs and DFAs                                              Nondeterministic finite-state automata
    RE. Concise way to describe a set of strings.                             Regular-expression-matching NFA.
    DFA. Machine to recognize whether a given string is in a given set.       ・RE enclosed in parentheses.
	                                                                          ・One state per RE character (start = 0, accept = M).
    Kleene's theorem.                                                         ・Red ε-transition (change state, but don't scan text).
    ・For any DFA, there exists a RE that describes the same set of strings.    ・Black match transition (change state and scan to next text char). 
    ・For any RE, there exists a DFA that recognizes the same set of strings.	・Accept if any sequence of transitions ends in accept state.
                                                                              
                                                                              Nondeterminism.
                                                                              ・One view: machine can guess the proper sequence of state transitions.
                                                                              ・Another view: sequence is a proof that the machine accepts the text.
                                                                              
                                                                              ###########################################################################
                                                                              #                                                                         #
                                                                              #                 \                 /-----------\                         #
                                                                              #                / v               /             v                        #
                                                                              # +-+   +-+   +--   +-+   +-+   +--   +-+   +-+   +-+   +-+    +-+   +-+  #
                                                                              # |(|   |(|   |A|   |*|   |B|   |||   |A|   |C|   |)|   |D|    |)|   | |  #
                                                                              # +-+   +-+   +-+   --+   +-+   +-+   +-+   +-+   +-+   +-+    +-+   +-+  #
                                                                              #          \     ^ /                 ^                                    #
                                                                              #           \     \                 /                                     #
                                                                              #            \---------------------/                                      #
                                                                              #                 NFA corresponding to the pattern ( ( A * B | A C ) D )  #
                                                                              #                                                                         #
                                                                              ###########################################################################
    
- NFA representation
    State names. Integers from 0 to M(number of symbols in RE)
    Match-transitions. Keep regular expression in array re[].
    ε-transitions. Store in a digraph G.	
    0→1, 1→2, 1→6, 2→3, 3→2, 3→4, 5→8, 8→9, 10→11

    ###########################################################################    How to efficiently simulate an NFA?                        
    #                                                                         #    Maintain set of all possible states that NFA could be in   
    #                 \                 /-----------\                         #    after reading in the first i text characters               
    #                / v               /             v                        #                                                               
    # +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+    +-+   +-+  #    When no more input characters:                             
    # |(|-->|(|-->|A|-->|*|-->|B|-->|||-->|A|-->|C|-->|)|-->|D|--->|)|-->| |  #    ・Accept if any state reachable is an accept state.         
    # +-+   +-+   +-+   --+   +-+   +-+   +-+   +-+   +-+   +-+    +-+   +-+  #    ・Reject otherwise.                                         
    #          \     ^ /                 ^                                    #                                                               
    #           \     \                 /                                     #                                                               
    #            \---------------------/                                      #                                                               
    #                 NFA corresponding to the pattern ( ( A * B | A C ) D )  #                                                               
    #                                                                         #                                                               
    ###########################################################################                                                               
                                                                                                                                              
    ##########################################################    ###############################################################                                   ###############################################################
    # public class NFA {                                     #    # public boolean recognizes(String txt) {                     #                                   # private Digraph buildEpsilonTransitionDigraph() {           #                                                                                                       
	#     private char[] re; // match transitions            #    #     Bag<Integer> pc = new Bag<Integer>();                   #									#     Digraph G = new Digraph(M + 1);                         #																									  
	#     private Digraph G; // epsilon transition digraph   #    #     DirectedDFS dfs = new DirectedDFS(G, 0);                #     states reachable from			#     Stack<Integer> ops = new Stack<Integer>();              #																															  
	#     private int M; // number of states                 #    #     for (int v = 0; v < G.V(); v ++)                        #  <--start by ε-transitions		#     for (int i = 0; i < M; i ++) {                          #																																  
	#     public NFA(String regexp) {                        #    #         if (dfs.marked(v))                                  # 									#         int lp = i;                                         #																									  
	#         M = regexp.length();                           #    #             pc.add(v);                                      # 									#         if (re[i] == '(' || re[i] == '|')                   #  <--left parentheses and |																								  
	#         re = regexp.toCharArray();                     #    #     for (int i = 0; i < txt.length(); i ++) {               #  <--states reachable after 		#             ops.push(i);                                    #																																  
	#         G = buildEpsilonTransitionDigraph();           #    #         Bag<Integer> match = new Bag<Integer>();            #     scanning past txt.charAt(i)	#          else if (re[i] == ')') {                           #  <--2-way or																																	  
	#     }                                                  #    #         for (int v : pc) {                                  #									#             int or = ops.pop();                             #																									  
	#     public boolean recognizes(String txt) {            #    #             if (v == M) continue;                           #									#             if (re[or] == '|') {                            #																									  
	#     /* see next slide */                               #    #             if ((re[v] == txt.charAt(i)) || re[v] == '.')   #									#                 lp = ops.pop();                             #																									  
	#     }                                                  #    #                 match.add(v + 1);                           #									#                 G.addEdge(lp, or + 1);                      #																									  
	#     public Digraph buildEpsilonTransitionDigraph() {   #    #         }                                                   #									#                 G.addEdge(or, i);                           #																									  
	#     /* stay tuned */                                   #    #         dfs = new DirectedDFS(G, match);                    #  <--follow ε-transitions			#             } else                                          #																															  
	#     }                                                  #    #         pc = new Bag<Integer>();                            #									#                 lp = or;                                    #																									  
	# }                                                      #    #         for (int v = 0; v < G.V(); v ++)                    #									#         }                                                   #																									  
	##########################################################    #             if (dfs.marked(v))                              #									#         if (i < M - 1 && re[i + 1] == '*') {                #  <--closure																									  
	                                                              #                 pc.add(v);                                  #									#             G.addEdge(lp, i + 1);                           #	    (needs 1-character lookahead)																								  
	                                                              #     }                                                       #									#             G.addEdge(i + 1, lp);                           #																									  
	                                                              #     for (int v : pc)                                        #  <--accept if can end in state M	#         }                                                   #																																	  
	                                                              #         if (v == M) return true;                            #									#         if (re[i] == '(' || re[i] == '*' || re[i] == ')')   #  <--metasymbols																								  
	                                                              #     return false;                                           #									#             G.addEdge(i, i + 1);                            #																									  
	                                                              # }                                                           #									#     }                                                       #																									  
	                                                              #                                                             #									#     return G;                                               #																									  
	                                                              ###############################################################									# }                                                           #																									  
																																			                        ###############################################################
																																			  
    Goal. Write a program to build the ε-transition digraph
    Challenges. Remember left parentheses to implement closure and or; remember | to implement or.
    Solution. Maintain a stack.
    ・( symbol: push ( onto stack.
    ・| symbol: push | onto stack.
    ・) symbol: pop corresponding ( and any intervening |;
    add ε-transition edges for closure/or.

    NFA construction: ( ( A * B | A C ) D )
	Left paranthesis                                    Alphabet symbol                      Right paranthesis:
	-add e-transition to next state                     -Add match transition to next state  -add e-transition to next state
	-push index of state corresponding to ( onto stack  - do one-char lookahead:             -pop corresponding ( and possibly intervening |;
                                                        add e-transition if next char is *   add e-transition edges for it
                                                                                             - do one-char lookahead:          
                                                                                             add e-transition if next char is *
														              (added 5->8, 1->6)
    stack:0    stack:0 1                     stack:0 1 5              stack:0      stack:
                               \                 /------------------\ 
	 0          1           2 / v 3     4     5 /          6     7   v 8
	+-+        +-+         +-+   +-+   +-+ ` +-+          +-+   +-+   +-+   +-+    +-+   +-+  
    |(|-->     |(|-->      |A|-->|*|-->|B|-->|||-->       |A|-->|C|-->|)|-->|D|--->|)|-->| |
    +-+        +-+         +-+   --+   +-+   +-+          +-+   +-+   +-+   +-+    +-+   +-+
	              \           ^ /                        ^
	               \           \                        / 
                    \----------------------------------/  
                               
                               
    Abstract machines, languages, and nondeterminism.
    ・Basis of the theory of computation.
    ・Intensively studied since the 1930s.
    ・Basis of programming languages.
    
    Compiler. A program that translates a program to machine code.
    ・KMP string ⇒ DFA.
    ・grep RE ⇒ NFA.
    ・javac Java language ⇒ Java byte code.                               
                               
- DATA COMPRESSION
    Lossless compression and expansion                             Data representation: genomic code
    Message. Binary data B we want to compress.                    Genome. String over the alphabet { A, C, T, G }.
    Compress. Generates a "compressed" representation C(B).        Goal. Encode an N-character genome: ATAGATGCATAG ...
    Expand. Reconstructs original bitstream B.                     Standard ASCII encoding.    Two-bit encoding.
    Compression ratio. Bits in C(B) / bits in B.                   ・8 bits per char.            ・2 bits per char. 
    Ex. 50–75% or better compression ratio for natural language    ・8 N bits.                   ・2 N bits. 
                                                                   
                                                                   #####################    ################
                                                                   # char hex binary   #    # char binary  #
                                                                   # A    41 01000001  #    # A    00      #
                                                                   # C    43 01000011  #    # C    01      #
                                                                   # T    54 01010100  #    # T    10      #
                                                                   # G    47 01000111  #    # G    11      #
                                                                   #####################    ################
    
    Writing binary data                                                                             Three ints (BinaryStdOut)
    Date representation. Three different ways to represent 12/31/1999.                              BinaryStdOut.write(mobth);
    A character stream (StdOut)                                                                     BinaryStdOut.write(day);
    StdOut.print(month + "/" + day + "/" + year);                                                   BinaryStdOut.write(year);
    00110001001100100010111100110111001100010010111100110001001110010011100100111001  <-- 80 bits   000000000000000000000000000011000000000000000000000000000001111100000000000000000000011111001111  <-- 96 bits

    A 4-bit field, a 5-bit field, and a 12-bit field (BinaryStdOut)
    BinaryStdOut.write(month, 4);
    BinaryStdOut.write(day, 5);
    BinaryStdOut.write(year, 12);
    110011111011111001111000  <-- 21 bits ( + 3 bits for byte alignment at close)

- run-length coding
    Run-length encoding
    Simple type of redundancy in a bitstream. Long runs of repeated bits.
    0000000000000001111111000000011111111111  <-- 40 bits
    Representation. 4-bit counts to represent alternating runs of 0s and 1s:
    15 0s, then 7 1s, then 7 0s, then 11 1s  <-- 16 bits (instead of 40)

    Run-length encoding: Java implementation
    ####################################################                                            #############################################
    # public class RunLength {                         #                                            # public static void compress() {           #
    #     private final static int R = 256;            #  <--maximum run-length count               #     char cnt = 0;                         #
    #     private final static int lgR = 8;            #  <--number of bits per count               #     boolean b,                            #
    #     public static void compress() {              #                                            #     old = false;                          #
    #         /* see next pic */                       #                                            #     while (<=BinaryStdIn.isEmpty()) {      #
    #     }                                            #                                            #         b = BinaryStdIn.readBoolean();    #
    #     public static void expand() {                #                                            #         if (b <== old) {                   #
    #         boolean bit = false;                     #                                            #             BinaryStdOut.write(cnt);      #
    #         while (<=BinaryStdIn.isEmpty()) {         #                                            #             cnt = 0;                      #
    #             int run = BinaryStdIn.readInt(lgR);  #  <--read 8-bit count from standard input   #             old = <=old;                   #
    #             for (int i = 0; i < run; i ++)       #                                            #         } else {                          #
    #                 BinaryStdOut.write(bit);         #  <--write 1 bit to standard output         #             if (cnt == 255) {             #
    #                                                  #                                            #                 BinaryStdOut.write(cnt);  #
    #             bit = <=bit;                          #                                            #                 cnt = 0;                  #
    #         }                                        #                                            #                 BinaryStdOut.write(cnt);  #
    #         BinaryStdOut.close();                    #  <--pad 0s for byte alignment              #             }                             #
    #     }                                            #                                            #         }                                 #
    # }                                                #                                            #         cnt ++;                           #
    ####################################################                                            #     }                                     #
                                                                                                    #     BinaryStdOut.write(cnt);              #
                                                                                                    #     BinaryStdOut.close();                 #
                                                                                                    # }                                         #
                                                                                                    #############################################

- Huffman compression
    Variable-length codes
    in morse code  ...---... can be sos, v7, IAMIE, EEWNI
    Q. How do we avoid ambiguity?
    A. Ensure that no codeword is a prefix of another
                                            trie representation
    ###################################     #############################   Compression.
    # Codeword table                  #     #    +-+                    #   ・Method 1: start at leaf; follow path up to the root; print bits in reverse.
    # <=   101                         #     #    | |                    #   ・Method 2: create ST of key-value pairs
    # A   0                           #     #   0+-+1                   #   
    # B   1111                        #     # +-+   \                   #   Expansion.
    # C   110                         #     # |A|    +-+                #   ・Start at root.
    # D   100                         #     # +-+    | |                #   ・Go left if bit is 0; go right if 1.
    # R   1110                        #     #       0+-+1               #   ・If leaf node, print char and return to root
    #                                 #     #     +-+   \               #
    # Compressed bitstring            #     #     | |    \              #
    # 011111110011001000111111100101  #     #    0+-+1    \             #
    # A    B  RA  CA  DA    B RA   <=  #     #  +-+   +-+   \            #
    ###################################     #  |D|   |<=|    +-+         #
                                            #  +-+   +-+    | |         #
                                            #              0+-+1        #
                                            #            +-+   \        #
                                            #            |C|    +-+     #
                                            #            +-+    | |     #
                                            #                  0+-+1    #
                                            #                +-+   +-+  #
                                            #                |R|   |B|  #
                                            #                +-+   +-+  #
                                            #############################
    Huffman trie node data type
    ################################################################    #################################################                                   
    # private static class Node implements Comparable<Node> {      #    # public void expand() {                        #                                   
    #     private final char ch; // used only for leaf nodes       #    #     Node root = readTrie();                   #  <--read in encoding trie         
    #     private final int freq; // used only for compress        #    #     int N = BinaryStdIn.readInt();            #  <--read in number of chars       
    #     private final Node left,                                 #    #     for (int i = 0; i < N; i ++) {            #                                   
    #     right;                                                   #    #         Node x = root;                        #  <--expand codeword for ith char  
    #                                                              #    #         while (<=x.isLeaf()) {                 #                                   
    #     public Node(char ch, int freq, Node left, Node right) {  #    #             if (<=BinaryStdIn.readBoolean())   #                                   
    #         this.ch = ch;                                        #    #                 x = x.left;                   #                                   
    #         this.freq = freq;                                    #    #              else                             #                                   
    #         this.left = left;                                    #    #                 x = x.right;                  #                                   
    #         this.right = right;                                  #    #         }                                     #                                   
    #     }                                                        #    #         BinaryStdOut.write(x.ch, 8);          #                                   
    #                                                              #    #     }                                         #                                   
    #     public boolean isLeaf() {                                #    #     BinaryStdOut.close();                     #                                   
    #         return left == null && right == null;                #    # }                                             #                                   
    #     }                                                        #    #################################################                                   
    #                                                              #                                                                                        
    #     public int compareTo(Node that) {                        #                                                                                        
    #         return this.freq - that.freq;                        #  <--compare Nodes                                                                      
    #     }                                                        #     by frequency                                                                       
    # }                                                            #                                                                                        
    ################################################################
    
    Q. How to write the trie?                                         
    A. Write preorder traversal of trie;                Q. How to read in the trie?                         #############################   leaves                                                             
        mark leaf and internal nodes with a bit.        A. Reconstruct from preorder traversal of trie.     #    +-+                    #     |          |         |        |         |      
    ###############################################     ###############################################     #    |1|                    #     V       A  V       D V       <=V       C V       R       B                                         
    # private static void writeTrie(Node x) {     #     # private static Node readTrie() {            #     #    +-+                    #    01010000010010100010001000010101010000110101010010101000010
    #     if (x.isLeaf()) {                       #     #     if (BinaryStdIn.readBoolean()) {        #     # +-+   \                   #    1         23         4                  5   
    #         BinaryStdOut.write(true);           #     #         char c = BinaryStdIn.readChar(8);   #     # |A|    +-+                #                                           
    #         BinaryStdOut.write(x.ch, 8);        #     #         return new Node(c, 0, null, null);  #     # +-+    |2|                #   1. read 0 go to else                                          
    #         return;                             #     #     }                                       #     #        +-+                #   2. first go to x node 
    #     }                                       #     #     Node x = readTrie();                    #     #     +-+   \               #   3. into if read 8 chars(A) and put into node                                       
    #     BinaryStdOut.write(false);              #     #     Node y = readTrie();                    #     #     |3|    \              #   4. read 0 go to else...
    #     writeTrie(x.left);                      #     #     return new Node('\0', 0, x, y);         #     #  +-++-+     \             #                                          
    #     writeTrie(x.right);                     #     # }                                           #     #  |D|   \     \            #                                          
    # }                                           #     ###############################################     #  +-+    +-+   \           #                                          
    ###############################################                                                         #         |4|    \          #                                          
                                                                                                            #         +-+     \         #
                                                                                                            #      +-+   +-+   \        #
                                                                                                            #      |<=|   |C|    +-+     #
                                                                                                            #      +-+   +-+    |5|     #
                                                                                                            #                   +-+     #
                                                                                                            #                +-+   +-+  #
                                                                                                            #                |R|   |B|  #
                                                                                                            #                +-+   +-+  #
                                                                                                            #############################
    
    Huffman algorithm
    -count frequencies for each char
    input A B R A C A D A B R A <=
    ch  freq    encode
    A   5       
    B   2
    C   1
    D   1
    R   2
    <=   1
    
    -build one node for each char
    +-+     +-+     +-+     +-+     +-+     +-+
    |<=|1    |C|1    |D|1    |R|2    |B|2    |A|5
    +-+     +-+     +-+     +-+     +-+     +-+
    
    -merge into single trie with cumulative weight
    ################################################################################################################################    Q. How to find best prefix-free code?
    #     1)  +-+         2)      +-+             3)             +-+              4)       +-+                ch  freq    encode   #    Huffman algorithm:                                                                              
    #         | |2(sum)           | |3                           | |7                      | |12              A   5       0        #    ・Count frequency freq[i] for each char i in input.                                                                              
    #         +-+                 +-+                            +-+                       +-+                B   2       111      #    ・Start with one node corresponding to each char i (with weight freq[i]).                                                                              
    #       0/   \1             0/   \1                        0/   \1                   0/   \1              C   1       1011     #    ・Repeat until single trie formed:                                                                              
    #     +-+     +-+         +-+     +-+                      /     \                 +-+     +-+            D   1       100      #    – select two tries with min weight freq[i] and freq[j]                                                                              
    #     |<=|1    |C|1        |D|1    | |2                    /       \                |A|5    | |7           R   2       110      #    – merge into single trie with weight freq[i] + freq[j]                                                                                        
    #     +-+     +-+         +-+     +-+                    /         \               +-+     +-+            <=   1       1010     #                                                                                  
    #                               0/   \1               +-+           +-+                  0/   \1                               #                                                                                  
    #                             +-+     +-+             | |3          | |4                 /     \                               #                                                                                  
    #                             |<=|1    |C|1            +-+           +-+                 /       \                              #                                                                                  
    #                             +-+     +-+           0/   \1       0/   \1              /         \                             #                                                                                  
    #                                                 +-+     +-+   +-+     +-+         +-+           +-+                          #                                                                                  
    #                                                 |D|1    | |2  |R|2    |B|2        | |3          | |4                         #                                                                                  
    #                                                 +-+     +-+   +-+     +-+         +-+           +-+                          #                                                                                  
    #                                                       0/   \1                   0/   \1       0/   \1                        #                                                                                  
    #                                                     +-+     +-+               +-+     +-+   +-+     +-+                      #                                                                                  
    #                                                     |<=|1    |C|1              |D|1    | |2  |R|2    |B|2                     #                                                                                  
    #                                                     +-+     +-+               +-+     +-+   +-+     +-+                      #                                                                                  
    #                                                                                     0/   \1                                  #                          
    #                                                                                   +-+     +-+                                #               
    #                                                                                   |<=|1    |C|1                               #              
    #                                                                                   +-+     +-+                                #                
    ################################################################################################################################                
                 
    Constructing a Huffman encoding trie: Java implementation              
    #################################################################
    # private static Node buildTrie(int[] freq) {                   #
    #     MinPQ<Node> pq = new MinPQ<Node>();                       #  <--initialize PQ with
    #     for (char i = 0; i < R; i ++)                             #     singleton tries
    #         if (freq[i] > 0)                                      #
    #             pq.insert(new Node(i, freq[i], null, null));      #
    #     while (pq.size() > 1) {                                   #  <--merge two
    #         Node x = pq.delMin();                                 #     smallest tries
    #         Node y = pq.delMin();                                 #
    #         Node parent = new Node('\0', x.freq + y.freq, x, y);  #
    #         pq.insert(parent);                                    #
    #     }                                                         #
    #                                                               #
    #     return pq.delMin();                                       #
    # }                                                             #
    #################################################################                       

- LZW compression
    Statistical methods                                                         LZW compression example
    Static model. Same model for all texts.                                     #####################################################################
    -Fast.                                                                      # input:      A  B  R  A  C  A  D  A  B  R  A  B  R A   B  R  A     # 
    -Not optimal: different texts have different statistical properties.        # matches:    A  B  R  A  C  A  D  AB    RA    BR   ABR       A     # 
    -Ex: ASCII, Morse code.                                                     # value:      41 42 52 41 43 41 44 81    83    82   88        41 80 # 
    Dynamic model. Generate model based on text.                                #####################################################################
    -Preliminary pass needed to generate model.                                 codeword table 
    -Must transmit the model.                                                   ################################################################### 
    -Ex: Huffman code.                                                          # A  B  C  D  AB  BR  RA  AC  CA  AD  DA  ABR  RAB  BRA  ABRA     # 
    Adaptive model. Progressively learn and update model as you read text.      # 41 42 43 44 81  82  83  84  85  86  87  88   89   8A   8B       #
    -More accurate modeling produces better compression.                        ################################################################### 
    -Decoding must start from beginning.
    -Ex: LZW.


    LZW compression.                                                            ##############################################      LZW compression: Java implementation
    -Create ST associating W-bit codewords with string keys.                    #                   +-+                      #      ############################################################
    -Initialize ST with codewords for single-char keys.                         #                   | |                      #      # public static void compress() {                          #
    -Find longest string s in ST that is a prefix of unscanned part of input.   #        +----------+-+----+-----+-----+     #      #     String input = BinaryStdIn.readString();             #  <--read in input as a string
    -Write the W-bit codeword associated with s.                                #        |           |     |     |     |     #      #     TST<Integer> st = new TST<Integer>();                #     codewords for single
    -Add s + c to ST, where c is next char in the input.                        #        v           v     v     v     v     #      #     for (int i = 0; i < R; i ++)                         #  <--char, radix R keys
    Q. How to represent LZW compression code table?                             #       +-+         +-+   +-+   +-+   +-+    #      #         st.put("" + (                                    #
    A. A trie to support longest prefix match.                                  #       |A|41       |B|42 |C|43 |D|44 |R|52  #      #         char)i, i);                                      #
                                                                                #      /+-+\        +-+   +-+   +-+   +-+    #      #                                                          #
    LZW expansion                                                               #     /  v  \        v     v     v     v     #      #     int code = R + 1;                                    #
    LZW expansion.                                                              # +-+/  +-+  \+-+   +-+   +-+   +-+   +-+    #      #     while (input.length() > 0) {                         #
    -Create ST associating string values with W-bit keys.                       # |B|81 |C|84 |D|86 |R|82 |A|85 |A|87 |A|83  #      #         String s = st.longestPrefixOf(input);            #  <--find longest prefix match s
    -Initialize ST to contain single-char values.                               # +-+   +-+   +-+   +-+   +-+   +-+   +-+    #      #         BinaryStdOut.write(st.get(s), W);                #  <--write W-bit codeword for s
    -Read a W-bit key.                                                          #  v                 v                 v     #      #         int t = s.length();                              #
    -Find associated string value in ST and write it out.                       # +-+               +-+               +-+    #      #         if (t < input.length() && code < L)              #
    -Update ST.                                                                 # |R|88             |A|8A             |B|89  #      #             st.put(input.substring(0, t + 1), code ++);  #  <--add new codeword
    Q. How to represent LZW expansion code table?                               # +-+               +-+               +-+    #      #                                                          #  <--scan past s in input
    A. An array of size 2W.                                                     #  v                                         #      #         input = input.substring(t);                      #
                                                                                # +-+                                        #      #     }                                                    #     write "stop" codeword 
                                                                                # |A|8B                                      #      #     BinaryStdOut.write(R, W);                            #  <--and close input stream
                                                                                # +-+                                        #      #     BinaryStdOut.close();                                #
                                                                                ##############################################      # }                                                        #
                                                                                                                                    ############################################################

###############
# week6
###############
- Reduction
    Def. Problem X reduces to problem Y if you can use an algorithm that solves Y to help solve X.
    
    Ex 1. [finding the median reduces to sorting]       Ex 2. [element distinctness reduces to sorting]     Ex.
    To find the median of N items:                      To solve element distinctness on N items:           ・3-collinear reduces to sorting. [assignment]
    ・Sort N items.                                       ・Sort N items.                                      ・Finding the median reduces to sorting. 
    ・Return item in the middle.                          ・Check adjacent pairs for equality.                 ・Element distinctness reduces to sorting. 
    Cost of solving finding the median. N log N + 1 .   Cost of solving element distinctness. N log N + N.  ・CPM reduces to topological sort. [shortest paths lecture]
                                                                                                            ・Arbitrage reduces to shortest paths. [shortest paths lecture]
                                                                                                            ・Burrows-Wheeler transform reduces to suffix sort. [assignment]
                                                                                                            ・…
                                                                                                            Mentality. Since I know how to solve Y, can I use that algorithm to solve X ?
    
    Convex hull reduces to sorting
    Sorting. Given N distinct integers, rearrange them in ascending order.
    Convex hull. Given N points in the plane, identify the extreme points of the convex hull (in counterclockwise order)
    Proposition. Convex hull reduces to sorting
    Pf. Graham scan algorithm (see next slide).
    Graham scan.
    ・Choose point p with smallest (or largest) y-coordinate.
    ・Sort points by polar angle with p to get simple polygon.
    ・Consider points in order, and discard those that would create a clockwise turn. 
    
    Shortest paths on edge-weighted graphs and digraphs
    Proposition. Undirected shortest paths (with nonnegative weights) reduces to directed shortest path.
    Pf. Replace each undirected edge by two directed edges.
    Cost of undirected shortest paths. E log V + E.
    Caveat. Reduction is invalid for edge-weighted graphs with negative weights (even if no negative cycles).
    
    Linear-time reductions involving familiar problems
    sorting                 shortest paths in digraphs                                  maxflow
    -finding the median     =arbitrage (currency excahnge)                              -network reliability
    -SPT scheduling         -parallel scheduling (precedence-constrained)               -bipartite matching
    =element distinctness   -hortest paths in undirected graphs (no negative weights)   -product distribution
    -convex hull 

- LINEAR PROGRAMMING
    Small brewery produces ale and beer
    - Production limited by scarce resources: corn, hops, barley malt.      (corn: 480, hops: 160, malt: 1190)
    - Recipes for ale and beer require different proportions of resources.  (Ale: 5 corn, 4 hops, 35 malt; Beer: 15 corn, 4 hops, 20 malt)
    
    Price: Ale 13; Beer 23;                                                     
    Brewer’s problem: choose product mix to maximize profits.                   
    #####################################################                       
    # ale     beer    corn    hops    malt    profit    #                       
    # 34      0       179     136     1190    $442      # <-- 34x35malt=1190    
    # 0       32      480     128     640     $736      #                       
    # 19.5    20.5    405     160     1092.5  $725      #
    # 12      28      480     160     980     $800      #
    # ?       ?                               > $800 ?  #
    #####################################################
    
    Brewer’s problem: linear programming formulation 
    Linear programming formulation.
    -Let A be the number of barrels of ale.
    -Let B be the number of barrels of beer.
                      ale   beer
    ######################################
    # maximize        13A + 23B          #
    # subject         5A + 15B   <= 480  # corn(if one makes A barrels of beer and B barrels of beer he is a subject of this constrint)
    # to the          4A + 4B    <= 160  # hops
    # constraints     35A + 20B  <= 1190 # malt
    ######################################
    
    Standard form.
    -Add variable Z and equation corresponding to objective function.
    -Add slack variable to convert each inequality to an equality.
    -Now a 6-dimensional problem.
    ############################################
    # maximize        Z                        #
    #                 13A + 23B -Z= 0          #
    # subject         5A + 15B +Sc= 480        #  <-- add slack var if 5A+15B<=480 then its the same as 5A+15B+something positive=480
    # to the          4A + 4B  +Sh= 160        #
    # constraints     35A + 20B+Sm= 1190       #
    ############################################
    
- Simplex algorithm
    Generic algorithm.
    -Start at some extreme point.
    -Pivot from one extreme point to an adjacent one.
    -Repeat until optimal.
    
    
    ################################################    ############################################                                
    #     +(B,Sh,Sm)                               #    # maximize        Z                        #                                  
    #     |(0,32)                                  #    #                 13A + 23B -Z= 0          #                                
    #     X                                        #    # subject         5A + 15B +Sc= 480        #                                
    #     |                                        #    # to the          4A + 4B  +Sh= 160        #                                
    #     |         (A,B,Sm)basic feasible solution#    # constraints     35A + 20B+Sm= 1190       #                                
    #     |       X (12,28)                        #    ############################################                                
    #     |                                        #                                                                                
    #     |                                        #    Simplex algorithm: basis        
    #  ale|                                        #    A basis is a subset of m of the n variables.                                
    #     |                                        #    Basic feasible solution (BFS).                                              
    #     |                                        #    -Set n – m nonbasic variables to 0, solve for remaining m variables.        
    #     |                                        #    -Solve m equations in m unknowns.                                           
    #     |                           (A,B,Sc)     #    -If unique and feasible ⇒ BFS.
    #     |                         X (26,14)      #    -BFS ⇔ extreme point.
    #     |                                        #
    #     | (Sh,Sm,Sc)                             #    (B,Sh,Sm) - B, Sh,Sm in basis - then B=0 and A = 32
    #     | (0,0)                                  #
    # +---X-------------------------------X-----+  #
    #     |       beer                    (A,Sh,Sc)#
    #     |                               (34,0)   #
    #     +                                        #
    ################################################
    
    Simplex algorithm: initialization                                       Simplex algorithm: pivot 1 (15B)
    ############################################  basis = { SC, SH, SM }    5A + 15B +Sc= 480                                                                                                   Q. Why pivot on column 2 (corresponding to variable B)?
    # maximize        Z                        #  A = B = 0                 substitute B = (1/15) (480 – 5A – SC) and add B into the basis                                                      -Its objective function coefficient is positive.
    #                 13A + 23B -Z= 0          #  Z = 0                     (rewrite 2nd equation, eliminate B in 1st, 3rd, and 4th equations)                                                  (each unit increase in B from 0 increases objective value by $23)
    # subject         5A + 15B +Sc= 480        #  SC = 480                  ########################################################    basis = { B, SH, SM }                                   -Pivoting on column 1 (corresponding to A) also OK.
    # to the          4A + 4B  +Sh= 160        #  SH = 160                  # maximize        Z                                    #    A = SC = 0                                              Q. Why pivot on row 2?
    # constraints     35A + 20B+Sm= 1190       #  SM = 1190                 #                 (16/3)A     - (23/15)SC - Z   = -736 #    Z = 736 (A and SC are 0 so Z = (23*480)/15)=736         -Preserves feasibility by ensuring RHS ≥ 0.
    ############################################                            # subject         (1/3) A + B + (1/15)SC        = 32   #    B = 32  (A and SC are 0 so B = 32)                      -Minimum ratio rule: min { 480/15, 160/4, 1190/20 }.
                                                                            # to the          (8/3) A     - (4/15) SC + SH  = 32   #    SH = 32 (A and SC are 0 so SH = 32)
    Initial basic feasible solution.                                        # constraints     (85/3)A     - (4/3) SC + SM   = 550  #    SM = 550 (A and SC are 0 so SM = 1190=((20*480)/15)=550
    -Start with slack variables { SC , SH , SM } as the basis.              ########################################################
    -Set non-basic variables A and B to 0.
    -3 equations in 3 unknowns yields SC = 480, SH = 160, SM = 1190
                                                                            Simplex algorithm: pivot 2 (8/3)A                                                                                   Q. When to stop pivoting?
                                                                            substitute A = (3/8) (32 + (4/15) SC – SH ) and add A into the basis                                                A. When no objective function coefficient is positive.
                                                                            (rewrite 3rd equation, eliminate A in 1st, 2nd, and 4th equations)                                                  Q. Why is resulting solution optimal?
                                                                            ##############################################################  basis = { A, B, SM}                                 A. Any feasible solution satisfies current system of equations.
                                                                            # maximize        Z                                          #  SC=SH=0                                             -In particular: Z = 800 – SC – 2 SH
                                                                            #                               − SC − 2 SH − Z = -800       #  Z = 800 (SC=SH=0 so 13A+23B where a=12,b=28 is 800) -Thus, optimal objective value Z* ≤ 800 since SC , SH ≥ 0.
                                                                            # subject              B + (1/10) SC + (1/8) SH = 28         #  B = 28                                              -Current BFS has value 800 ⇒ optimal.
                                                                            # to the          A −      (1/10) SC + (3/8) SH = 12         #  SH = 12
                                                                            # constraints            − (25/6) SC − (85/8) SH + SM = 110  #  SM = 110
                                                                            ##############################################################
    
- implementations
    Simplex tableau
    Encode standard form LP in a single Java 2D array.  initial simplex tableaux    
    ########################################            +----------------+          +-------+
    # maximize    Z                        #            |5  15|1 0 0|480 |         m|A| I| b|
    #             13A + 23B   - Z   = 0    #            |4  4 |0 1 0|160 |          +-------+
    # subject     5A  + 15B   + SC  = 480  #            |35 20|0 0 1|1190|         i|c| 0| 0|
    # to the      4A  + 4B    + SH  = 160  #            +----------------+          +-------+
    # constraints 35A + 20B   + SM  = 1190 #            |13 23|0 0 0|0   |           n  m  1
    ########################################            +----------------+

    Simplex algorithm transforms initial 2D array into solution.    final simplex tableaux    
    ##############################################################  +---+-------------+----+    +-------------+
    # maximize    Z                                              #  |0 1|1/10  1/8   0|28  |    |    |    | x*|
    #                 − SC − 2 SH − Z =-800                      #  |   |             |    |    +-------------+
    # subject           B     + (1/10) SC + (1/8) SH = 28        #  |1 0|-1/10 3/8   0|12  |    |<=0 |<=0 |-Z*|
    # to the      A           − (1/10) SC + (3/8) SH = 12        #  |   |             |    |    +-------------+
    # constraints             − (25/6) SC − (85/8) SH + SM = 110 #  |0 0|-25/6 -85/8 1|110 |
    ##############################################################  +----------------------+
                                                                    |0 0|-1    -2    0|-800|
                                                                    +---+-------------+----+

    Construct the initial simplex tableau.
    ###############################################################  +-------+
    # public class Simplex {                                      # m|A| I| b|
    #     private double[][] a; // simplex tableaux               #  +-------+
    #     private int m, n; // M constraints, N variables         # i|c| 0| 0|
    #     public Simplex(double[][] A, double[] b, double[] c) {  #  +-------+
    #         m = b.length;                                       #   n  m  1
    #         n = c.length;                                       #
    #         a = new double[m + 1][m + n + 1];                   #
    #         for (int i = 0; i < m; i ++)                        #  <--put A[][] into tableau
    #             for (int j = 0; j < n; j ++)                    #
    #                 a[i][j] = A[i][j];                          #
    #         for (int j = n; j < m + n; j ++)                    #  <--put I[][] into tableau
    #             a[j - n][j] = 1.0;                              #
    #         for (int j = 0; j < n; j ++)                        #  <--put c[] into tableau
    #             a[m][j] = c[j];                                 #
    #         for (int i = 0; i < m; i ++)                        #  <--put b[] into tableau
    #             a[i][m + n] = b[i];                             #
    #     }                                                       #
    ###############################################################

    Simplex algorithm: Bland's rule                 
    Find entering column q using Bland's rule:      
    index of first column whose objective function  
    coefficient is positive.                                                         0 q   m+n
                                                                                     +-------+
    ##########################################                                      0| | | | |
    # private int bland() {                  #                                       +-------+
    #     for (int q = 0; q < m + n; q ++)   #     entering column q has positive   p| |+| | |
    #         if (a[M][q] > 0)               #  <--objective function coefficient    +-------+ 
    #             return q;                  #                                       | | | | |
    #     return -1;                         #  <--optimal                           +-------+
    # }                                      #                                      m| |+| | |
    ##########################################                                       +-+-+---+

    Find leaving row p using min ratio rule.
    (Bland's rule: if a tie, choose first such row)
    ######################################################################                           0 q   m+n
    # private int minRatioRule(int q) {                                  #                           +-------+
    #     int p = -1;                                                    #                          0| | | | |
    #     for (int i = 0; i < m; i ++) {                                 #  <--leaving row           +-------+
    #         if (a[i][q] <= 0)                                          #  <--consider only        p| |+| | |
    #             continue;                                              #     positive entries      +-------+
    #          else if (p == -1)                                         #                           | | | | |
    #             p = i;                                                 #                           +-------+
    #          else if (a[i][m + n] / a[i][q] < a[p][m + n] / a[p][q])   #                          m| |+| | |
    #             p = i;                                                 #  <--row p has min         +-+-+---+
    #     }                                                              #     ratio so far
    #     return p;                                                      #
    # }                                                                  #
    ######################################################################

    Pivot on element row p, column q.                                                                     Execute the simplex algorithm.
    ############################################################                             0 q   m+n    #####################################
    # public void pivot(int p, int q) {                        #                             +-------+    # public void solve() {             #
    #     for (int i = 0; i <= m; i ++)                        #                            0| | | | |    #     while (true) {                #
    #         for (int j = 0; j <= m + n; j ++)                #                             +-------+    #         int q = bland();          #  <--entering column q (optimal if -1)
    #             if (i <== p && j <== q)                        #  <--scale all entries but  p| |+| | |    #         if (q == -1)              #
    #                 a[i][j] -= a[p][j] * a[i][q] / a[p][q];  #     row p and column q      +-------+    #             break;                #
    #     for (int i = 0; i <= m; i ++)                        #                             | | | | |    #         int p = minRatioRule(q);  #  <--leaving row p (unbounded if -1)
    #         if (i <== p)                                      #                             +-------+    #         if (p == -1) ...          #
    #             a[i][q] = 0.0;                               #  <--zero out column q      m| |+| | |    #         pivot(p, q);              #  <--pivot on row p, column q
    #     for (int j = 0; j <= m + n; j ++)                    #                             +-+-+---+    #     }                             #
    #         if (j <== q)                                      #                                          # }                                 #
    #             a[p][j] /= a[p][q];                          #  <--scale row p                          #####################################
    #     a[p][q] = 1.0;                                       #
    # }                                                        #
    ############################################################

- Modeling
    Linear “programming” (1950s term) = reduction to LP (modern term).
    -Process of formulating an LP model for a problem.
    -Solution to LP for a specific problem gives solution to the problem.
    1. Identify variables.
    2. Define constraints (inequalities and equations).
    3. Define objective function.
    4. Convert to standard form.
    Examples.
    -Maxflow.
    -Shortest paths.
    -Bipartite matching.
    -Assignment problem.
    -2-person zero-sum games.
    
    Maxflow problem (revisited)                                     Modeling the maxflow problem as a linear program
    Input. Weighted digraph G, single source s and single sink t.   Variables. xvw = flow on edge v→w.
    Goal. Find maximum flow from s to t.                            Constraints. Capacity and flow conservation.
    maxfow problem                                                  Objective function. Net flow into t
    ################    0 1 2.0                                     0 <= x 01<=2    (from 0 to 1 cap is 2)
    #     +-+      #    0 2 3.0                                     0 <= x 02<=3
    #     |0|      #    1 3 3.0                                     0 <= x 13<=3
    #     +-+      #    1 4 1.0                                     0 <= x 14<=1    capacity constraints
    #   2/   \3    #    2 3 1.0                                     0 <= x 23<=1
    #   v     v    #    2 4 1.0                                     0 <= x 24<=1
    # +-+     +-+  #    3 5 2.0                                     0 <= x 35<=2
    # |1|     |2|  #    4 5 3.0                                     0 <= x 45<=3
    # +-+\   /+-+  #                                                x01=x13+x14     (input should = output 0-1 shoud = 1-3 + 1=4)
    #  |3 \1/1 |1  #                                                x02=x23+x24     flow conservation
    #  v   \   v   #                                                x13+x23=x35     constraints
    # +-+ / \ +-+  #                                                x14+x24=x4
    # |3|<   >|4|  #
    # +-+     +-+  #
    #    \2  /3    #
    #     v v      #
    #     +-+      #
    #     |5|      #
    #     +-+      #
    ################    
    
    



    
    
    
    
    
    
    
    
    
    
    
    
    








    
    
    
    


    







    
    








    
    
    