###############
# week1
###############
- introduction
	Graph. Set of vertices connected pairwise by edges.
	Path. Sequence of vertices connected by edges.
	Cycle. Path whose first and last vertices are the same.
	
	graph 			vertex 					edge
	communication 	telephone, computer 	fiber optic cable

- API
	compute the degree of v									compute maximum degree									compute average degree									count self - loops                                 
	####################################################    ####################################################    ####################################################    ####################################################
	# public static int degree(Graph G, int v) {       #    # public static int maxDegree(Graph G) {           #    # public static double averageDegree(Graph G) {    #    # public static int numberOfSelfLoops(Graph G) {   #
	#     int degree = 0;                              #    #     int max = 0;                                 #    #     return 2.0 * G.E() / G.V();                  #    #     int count = 0;                               #
	#     for (int w : G.adj(v))                       #    #     for (int v = 0; v < G.V(); v ++)             #    # }                                                #    #     for (int v = 0; v < G.V(); v ++)             #
	#         degree ++;                               #    #         if (degree(G, v) > max)                  #    ####################################################    #         for (int w : G.adj(v))                   #
	#     return degree;                               #    #             max = degree(G, v);                  #                                                            #             if (v == w)                          #
	# }                                                #    #     return max;                                  #                                                            #                 count ++;                        #
	####################################################    # }                                                #                                                            #     return count / 2; // each edge counted twice #
	                                                        ####################################################                                                            # }                                                #
	                                                                                                                                                                        ####################################################
	Adjacency-list graph representation
	############################################	#############################################
	# +--------------------------------------+ #    # public class Graph {                      #
	# | 0| 1| 2| 3| 4| 5| 6| 7| 8| 9|10|11|12| #    #     private final int V;                  #
	# +--------------------------------------+ #    #     private Bag<Integer> [] adj;          #
	#   6  0  0  5  5  3  0  8  7 11  9  9 11  #    #     public Graph(int V) {                 #
	#   2        4  6  4  4       10    12  6  #    #         this.V = V;                       #
	#   7           3  0          12           #    #         adj = (Bag<Integer> [])new Bag[V];#
	#   5                                      #    #         for (int v = 0; v < V; v ++)      #
	############################################    #             adj[v] = new Bag<Integer>();  #
	                                                #                                           #
	                                                #     }                                     #
	                                                #     public void addEdge(int v, int w) {   #
	                                                #         adj[v].add(w);                    #
	                                                #         adj[w].add(v);                    #
	                                                #     }                                     #
	                                                #     public Iterable<Integer> adj(int v) { #
	                                                #         return adj[v];                    #
	                                                #     }                                     #
	                                                # }                                         #
	                                                #############################################
	
- depth-first search
	
	Algorithm.																																################################################
	・Use recursion (ball of string).                                                                                                        # public class DepthFirstPaths {               # 
	・Mark each visited vertex (and keep track of edge taken to visit it).                                                                   #     private boolean[] marked;                # 
	・Return (retrace steps) when no unvisited options.                                                                                      #     private int[] edgeTo;                    # 
	                                                                                                                                        #     private int s;                           #
	graph							fin all vertices connected to s                                                                         #     public DepthFirstPaths(Graph G, int s) { #
	##########################		v	marked[]	edgeTo[v]                                                                               # 		//init data structures                 #
	# +--------------------+ #		0	T			-			step1 - mark with T (check 6 2 1 5)                                         #         dfs(G, s);                           #
	# | 0| 1| 2| 3| 4| 5| 6| #		1	T			0			step7 - mark with T came from 0 (check 0)                                   #     }                                        #
	# +--------------------+ #		2	T			0           step6 - mark with T came from 0 (check 0)                                   #     private void dfs(Graph G, int v) {       #
	#   5  0  0  5  5  3  0  #		3	T			5           step5 - mark with T came from 5 (check 5 4)	both 5 4 already visited        #         marked[v] = true;                    #
	#   1        4  6  4  4  #		4	T			6           step3 - mark with T came from 6 (check 5 6 3)                               #         for (int w : G.adj(v))               #
	#   2           3  0     #		5	T			4           step4 - mark with T came from 4 (check 3 4 0)                               #             if (!marked[w]) {                #
	#   6                    #		6	T			0           step2 - mark with T came from 0 (check 0 4)                                 #                 dfs(G, w);                   #
	##########################		7	F			-                                                                                       #                 edgeTo[w] = v;               #
	                                                                                                                                        #             }                                #
	                                                                                                                                        #     }                                        #
	                                                                                                                                        # }                                            #
	                                                                                                                                        ################################################

- breadth-first search
	Algorithm																																			####################################################
	Put s onto a FIFO queue, and mark s as visited.                                                                                                     # public class BreadthFirstPaths {                 #
	Repeat until the queue is empty:                                                                                                                    #     private boolean[] marked;                    #
 	- remove the least recently added vertex v                                                                                                          #     private int[] edgeTo;                        #
 	- add each of v's unvisited neighbors to the queue,and mark them as visited.                                                                        #     …                                            #
	                                                                                                                                                    #     private void bfs(Graph G, int s) {           #
	graph						                                                                                                                        #         Queue<Integer> q = new Queue<Integer>(); #
	#######################		v	edgeTo[v]	distTo[]                                                                                                #         q.enqueue(s);                            #
	# +-----------------+ # 	0	-			0			step1 - add 0 to queue (0), deque 0, add 0`s adj`s to queue that are not marked (2 1 5)     #         marked[s] = true;                        #
	# | 0| 1| 2| 3| 4| 5| # 	1	0		    1           step1                                                                                       #         while (!q.isEmpty()) {                   #
	# +-----------------+ # 	2	0           1           step1                                                                                       #             int v = q.dequeue();                 #
	#   5  0  0  5  2  3  # 	3	2           2           step2 - deque 2, add 2`s adj`s to queue (1 5 3)                                             #             for (int w : G.adj(v)) {             #
	#   1     3  4  3  0  # 	4	2           2           step1 - add 2`s adj`s to queue (1 5 3 4)                                                    #                 if (!marked[w]) {                #
	#   2     4  2        # 	5	0           1           step1                                                                                       #                     q.enqueue(w);                #
	####################### 	                                                                                                                        #                     marked[w] = true;            #
	                                                                                                                                                    #                     edgeTo[w] = v;               #
	Depth-first search. Put unvisited vertices on a stack.                                                                                              #                 }                                #
	Breadth-first search. Put unvisited vertices on a queue                                                                                             #             }                                    #
	                                                                                                                                                    #         }                                        #
                                                                                                                                                        #     }                                            #
                                                                                                                                                        # }                                                #
                                                                                                                                                        ####################################################

- connected components																							Finding connected components with DFS 			Finding connected components with DFS
																												##############################################	######################################
	Initialize all vertices v as unmarked.                                                                      # public class CC {                          #  # public int count() {               #
	For each unmarked vertex v, run DFS to identify all vertices discovered as part of the same component.      #     private boolean[] marked;              #  #     return count;                  #
                                                                                                                #     private int[] id;                      #  # }                                  #
	##########################		v	marked[]	cc[]											            #     private int count;                     #  # public int id(int v) {             #
	#      +-+               #      0	T			0		1 visit0: check 6 2 1 5 (cc 0)                      #     public CC(Graph G) {                   #  #     return id[v];                  #
	#      |0|--\            #      1	T		    0       7 visit1: check 0 (cc 0)                            #         marked = new boolean[G.V()];       #  # }                                  #
	#      +-+-\ ---\        #      2	T           0       6 visit2: check 0 (cc 0)                            #         id = new int[G.V()];               #  # private void dfs(Graph G, int v) { #
	#     / \   --\  ---\    #      3	T           0       5 visit3: check 5 4 (cc 0)                          #         for (int v = 0; v < G.V(); v ++) { #  #     marked[v] = true;              #
	#    |   +-+   +-+   +-+ #      4	T           0       3 visit4: check 5 6 3  (cc 0)                       #             if (!marked[v]) {              #  #     id[v] = count;                 #
	#    /   |1|   |2|   |6| #      5	T           0       4 visit5: check 3 4 0 (cc 0)                        #                 dfs(G, v);                 #  #     for (int w : G.adj(v))         #
	#   |    +-+   +-+   +-+ #		6   T           0		2 visit6: check 0 4 (cc 0)                          #                 count ++;                  #  #         if (!marked[w])            #
	#   /                /   #                                                                                  #             }                              #  #             dfs(G, w);             #
	#  |      +-+     +-+    #		To visit a vertex v :	                                                    #         }                                  #  #                                    #
	#  /    /-|3|-----|4|    #      ・Mark vertex v as visited.                                                  #     }                                      #  #                                    # 
	# |   /-  +-+ /---+-+    #      ・Recursively visit all unmarked vertices adjacent to v.                     #     public int count()                     #  # }                                  # 
	# +-+-  /-----           #                                                                                  #     public int id(int v)                   #  ######################################
	# |5|---                 #                                                                                  #     private void dfs(Graph G, int v)       #
	# +-+                    #                                                                                  # }                                          #
	##########################                                                                                  ##############################################

		
- graph challenges
	P1 roblem. Is a graph bipartite?
	bipartite - whose vertices can be divided into two disjoint and independent sets U and V such that every edge connects a vertex in U to one in V.
	solution: dfs
	##########################		2 Problem. Find cycle - use dfs (0 5 4 6 0)
	#                        #		3 Problem. Bridges of Konigsberg (cycle use every edge once).Yes if all vertices have even degree
	#      +-+               #		4 Find a (general) cycle that uses every edge exactly once.
	#     u|0|--\            #		5 Find a cycle that visits every vertex exactly once. Hamiltonian cycle. hard one
	#      +-+-\ ---\        #		6 Are two graphs identical except for vertex names? graph isomorphism is longstanding open problem. hard one
	#     / \   --\  ---\    #		7 Lay out a graph in the plane without crossing edges? linear-time DFS-based planarity algorithm discovered by Tarjan in 1970s. hard one
	#    |   +-+   +-+   +-+ #
	#    /  v|1|  v|2|  v|6| #
	#   |    +-+   +-+   +-+ #
	#   /      \   /  \  /   #
	#  |        +-+   +-+    #
	#  /       u|3|  u|4|    #
	# |         +-+   +-+    #
	# +-+           /---     #
	#v|5|     /-----         #
	# +-+ ----               #
	##########################	

- directed graphs
	Digraph. Set of vertices connected pairwise by directed edges.
	
	#############################################	0->5			applications:																				############################################## 
	#      +-+<-------------      ----<----     #	0->1			Road network					Vertex = intersection; 		edge = one-way street.          # public class Diraph {                      #
	#      |0|<----\         \   /         \    #	0->5			Political blogosphere graph		Vertex = political blog; 	edge = link                     #     private final int V;                   #
	#      +-+      +-+       +-+--->+-+    +-+ #	2->0			Overnight interbank loan graph	Vertex = bank; 				edge = overnight loan.          #     private final Bag<Integer> [] adj;     #	<-- adj lists
	#     | | +-+   |2|       |6|    |8|    |7| #	2->3			Implication graph				Vertex = variable; 			edge = logical implication.     #     public Diraph(int V) {                 #
	#     /  >|1|   +-+       +-+<---+-+    +-+ #	3->5			Combinational circuit			Vertex = logical gate; 		edge = wire.                    #         this.V = V;                        #  <-- create empty Diraph with V vertices
	#    |    +-+  /> ^      /   \         /    #	3->2			WordNet graph					Vertex = synset; 			edge = hypernym relationship.   #         adj = (Bag<Integer> [])new Bag[V]; #
	#    /       < /  |     /     \       /     #	4->3			web								web page					hyperlink                       #         for (int v = 0; v < V; v ++)       #
	#   /     +-+ /   |    /       >    <-      #	5->4			scheduling						task						precedence constraint           #             adj[v] = new Bag<Integer>();   #
	#  |    /-|3|/    |   /         +-+    +--+ #	11->4			financial						bank						transaction                     #                                            #
	#  Y  /<  +-+   +-+  /          |9|--->|10| #	11->12			game							board position 				legal move                      #     }                                      #
	# +-+-          |4|<-           +-+<-\ +--+ #	12->9			citation						journal article				citation                        #     public void addEdge(int v, int w) {    #	<-- add edge v-w
	# |5|>--------->+-+              Y    \   ^ #					inheritance hierarchy			class						inherits from                   #         adj[v].add(w);                     #
	# +-+                           +--+   +--| #					control flow					code block					jump                            #                                            #
	#                               |11|---|12| #			                                                                                                    #     }                                      #
	#                               +--+   +--+ #			                                                                                                    #     public Iterable<Integer> adj(int v) {  #	<-- iterator for vertices adj to v
	#                                           #			                                                                                                    #         return adj[v];                     #
	#############################################			                                                                                                    #     }                                      #
                                                                                                                                                                # }                                          #
- Adjacency-lists digraph representation                                                                                                                        ##############################################
	#############################################
	# +--------------------------------------+  #
	# | 0| 1| 2| 3| 4| 5| 6| 7| 8| 9|10|11|12|  #
	# +--------------------------------------+  #
	#   5     0  5  3  4  9  6  6 11 12 12  9   #
	#   1     3  2  2     4  8    10            #
	#                     8                     #
	#                     0                     #
	#############################################
	
- digraph search
	Depth-first search in digraphs																										Depth-first search in digraphs summary
	##############################################	Mark v as visited.																	DFS enables direct solution of simple digraph problems.
    # public class DirectedDFS {                 #	Recursively visit all unmarked vertices w pointing from v.                          ・Reachability.
    #     private boolean[] marked;              #                                                                                      ・Path finding.
    #     public DirectedDFS(Digraph G, int s) { #	Applications:                                                                       ・Topological sort.
    #         marked = new boolean[G.V()];       #	Reachability application: program control-flow analysis:                            ・Directed cycle detection.
    #         dfs(G, s);                         #		Every program is a digraph.                                                     Basis for solving difficult digraph problems.
    #     }                                      #  	・Vertex = basic block of instructions (straight-line program).                   ・2-satisfiability. 
    #     private void dfs(Digraph G, int v) {   #  	・Edge = jump.                                                                    ・Directed Euler path. 
    #         marked[v] = true;                  #                                                                                      ・Strongly-connected components.
    #         for (int w : G.adj(v))             #	Reachability application: mark-sweep garbage collector
    #             if (!marked[w])                #		Every data structure is a digraph.
    #                 dfs(G, w);                 #      ・Vertex = object.
    #     }                                      #      ・Edge = reference.
    #     public boolean visited(int v) {        #		Roots. Objects known to be directly accessible by program (e.g., stack).
    #         return marked[v];                  #		Reachable objects. Objects indirectly accessible by program
    #     }                                      #
	# }                                          #
	##############################################

	Breadth-first search in digraphs								BFS web crawler
	Same method as for undirected graphs.							################################################## 
	Put s onto a FIFO queue, and mark s as visited.                 # Queue<String> queue = new Queue<String>();     #	<-- queue of websites to crawl
		Repeat until the queue is empty:                            # SET<String> marked = new SET<String>();        #  <-- set of marked websites
 		- remove the least recently added vertex v                  # String root = "http://www.princeton.edu";      #
 		- for each unmarked vertex pointing from v:                 # queue.enqueue(root);                           #	<-- start crawling from root website
 		add to queue and mark as visited.                           # marked.add(root);                              #
		                                                            # while (!queue.isEmpty()) {                     #
	Q. How to implement multi-source shortest paths algorithm?      #     String v = queue.dequeue();                #	<-- read in raw html from nextwebsite in queue
	A. Use BFS, but initialize by enqueuing all source vertices.    #     StdOut.println(v);                         #
	                                                                #     In in = new In(v);                         #
	                                                                #     String input = in.readAll();               #
	                                                                #     String regexp = "http://(\\w+\\.)*(\\w+)"; #	<-- use regular expression to find all URLs in website of form http://xxx.yyy.zzz
	                                                                #     Pattern pattern = Pattern.compile(regexp); #
	                                                                #     Matcher matcher = pattern.matcher(input);  #
	                                                                #     while (matcher.find()) {                   #
	                                                                #         String w = matcher.group();            #
	                                                                #         if (!marked.contains(w)) {             #	<-- if unmarked, mark it and put on the queue
	                                                                #             marked.add(w);                     #
	                                                                #             queue.enqueue(w);                  #
	                                                                #         }                                      #
	                                                                #     }                                          #
	                                                                # }                                              #
	                                                                ##################################################
	
- topological sort
	DAG. Directed acyclic graph.
	Topological sort. Redraw DAG so all edges point upwards.
	DAG											Topological sort. Redraw DAG so all edges point upwards			algorithm:								step1  visit0: check 1 2 5 	(mark 0)
	##########################	0->5			###################################################				-run dfs                                step2  visit1: check 4 		(mark 1)
	#      +-+--------\      #	0->1            #             /-------------------------->\       #				-return vertices in reverse postorder   step3  visit4: done			(mark 4)	postorder 4
	#      |0|         \     #  3->5            #            /     /--------------->\      \      #                                                     step4  visit1: done						postorder 4 1
	#    />+-+----\     \    #  5->2            #           /     //-------->\       \      \     #                                                     step5  visit2: done			(mark 2)	postorder 4 1 2
	#    |  \>     >     >   #  6->0            # +-+    +-+    +-+    +-+    +-+     +-+    +-+  #                                                     step6  visit5: done			(mark 5)	postorder 4 1 2 5
	#    |   +-+   +-+   +-+ #  1->4            # |3|--->|6|--->|0|--->|5|--->|2|     |1|--->|4|  #                                                     step7  visit0: done						postorder 4 1 2 5 0
	#    /   |2|   |5|   |1| #  0->2            # +-+    +-+    +-+    +-+    +-+     +-+    +-+  #                                                     step8  visit3: check 6		(mark 3)
	#   |    +-+  >+-+   +-+ #  3->6            # \\\\->/             /      /              /     #                                                     step9  visit6: done			(mark 6)	postorder 4 1 2 5 0 6
	#   /     ^  /         | #  3->4            #  \\\-------------->/      /              /      #                                                     step10 visit3: done						postorder 4 1 2 5 0 6 3
	#  |      +-+     +-+  / #  6->4            #   \\-------------------->/              /       #                                                     
	#  /     /|3|---->|4|</  #  3->2            #    \---------------------------------->/        #                                                     
	# |     / +-+     +-+    #                  #	                                              #                                                     
	# +-+<-/         ^       #                  ###################################################                                                     
	# |6|-----------/        #  
	# +-+                    #  
	##########################  
	
	Depth-first search order
	################################################								applications:
	# public class DepthFirstOrder {               #                                Directed cycle detection application: precedence scheduling
	#     private boolean[] marked;                #                                Directed cycle detection application: cyclic inheritance (The Java compiler does cycle detection.)
	#     private Stack<Integer> reversePost;      #                                Directed cycle detection application: spreadsheet recalculation (Microsoft Excel does cycle detection (and has a circular reference toolbar!))
	#     public DepthFirstOrder(Digraph G) {      #
	#         reversePost = new Stack<Integer>();  #
	#         marked = new boolean[G.V()];         #
	#         for (int v = 0; v < G.V(); v ++)     #
	#             if (!marked[v])                  #
	#                 dfs(G, v);                   #
	#     }                                        #
	#     private void dfs(Digraph G, int v) {     #
	#         marked[v] = true;                    #
	#         for (int w : G.adj(v))               #
	#             if (!marked[w])                  #
	#                 dfs(G, w);                   #
	#         reversePost.push(v);                 #
	#     }                                        #
	#     public Iterable<Integer> reversePost() { #
	#         return reversePost;                  #	<--returns all vertices in 
	#     }                                        #	   “reverse DFS postorder”
	# }                                            #
	################################################
	
- strong components
	Vertices v and w are strongly connected if there is both a directed path from v to w and a directed path from w to v.
	・If v is strongly connected to w, then w is strongly connected to v.
	・If v is strongly connected to w and w to x, then v is strongly connected to x.
	A strong component is a maximal subset of strongly-connected vertices.
	
	Kosaraju-Sharir algorithm: intuition								Phase 1. Compute reverse postorder in GR.
	Reverse graph. Strong components in G are same as in GR.			Phase 2. Run DFS in G, visiting unmarked vertices in reverse postorder of GR.
	Kernel DAG. Contract each strong component into a single vertex.																					reverse 1 0 2 4 5 3 11 9 12 10 6 7 8
	Idea.																phase1:																			phase2 (run dfs visiting reverse vertices)
	・Compute topological order (reverse postorder) in kernel DAG.		step1  visit0: 	check 6 2  	(mark 0)                                            step1  visit1: 	done	  	(scc 0)
	・Run DFS, considering vertices in reverse topological order.       	step2  visit6: 	check 8 7	(mark 6)                                            step2  visit0: 	check 5		(scc 1)
	#############################################			            step3  visit8: 	done		(mark 8)	reverse 8                               step3  visit5: 	check 4		(scc 1)
	#      +-+------->------      ---->----     #			            step4  visit6: 	check 7                                                         step4  visit4: 	check 3 2	(scc 1)
	#   /->|0|----\         \    /         \    #			            step5  visit7: 	done		(mark 7)	reverse 7 8                             step5  visit3:	check 5 2	(scc 1)
	#  |   +-+     >+-+      >+-+--->+-+    +-+ #			            step5,5visit6: 	done					reverse 6 7 8                           step6  visit2: 	check 0		(scc 1)
	#  |    | +-+   |2|       |6|    |8|    |7| #			            step6  visit2: 	check 4 3	(mark 2)                                            step6  visit2: 	done
	#  |     <|1|   +-+     />+-+<---+-+  />+-+ #			            step7  visit4:  check 11 6 5(mark 4)                                            step7  visit3:  done
	#  |      +-+  /> |    /     ^       /      #			            step8  visit11: check 9		(mark 11)                                           step8  visit4:  done
	#  |         <//  |   /       \     /       #			            step9  visit9:	check 12 7 6(mark 9)                                            step9  visit5:	done
	#  |      +-+ /   |  /         \   /        #			            step10 visit12: check 10 11	(mark 12)                                           step10 visit0:  done
	#  |   /->|3|/    Y /           +-+    +--+ #			            step11 visit10:	done	  	(mark 10)	reverse 10 6 7 8                        step11 visit11:	check 4 12	(scc 2)
	#  |  /   +-+\->+-+/            |9|<---|10| #			            step12 visit12:	done					reverse 12 10 6 7 8                     step12 visit12:	check 9		(scc 2)
	# +-+-          |4|             +-+\   +--+ #			            step13 visit9: 	done					reverse 9 12 10 6 7 8                   step13 visit9: 	check 10 11	(scc 2)
	# |5|<--------- +-+\             ^  \     ^ #			            step14 visit11:	done					reverse 11 9 12 10 6 7 8                step14 visit10:	check 12	(scc 2)
	# +-+               \           +--+ \>+--| #			            step15 visit4:	check 5                                                         step15 visit10:	done
	#                    \--------->|11|<--|12| #			            step16 visit5: 	check 3 0	(mark 5)                                            step16 visit9: 	done
	#                               +--+   +--+ #			            step17 visit3: 	done		(mark 3)	reverse 3 11 9 12 10 6 7 8              step17 visit12: done
	#                                           #			            step18 visit5: 	done					reverse 5 3 11 9 12 10 6 7 8            step18 visit11: done
	#############################################			            step19 visit4: 	done					reverse 4 5 3 11 9 12 10 6 7 8          step19 visit6: 	check 8		(scc 3)
	                                                                    step20 visit2: 	done					reverse 2 4 5 3 11 9 12 10 6 7 8        step20 visit8: 	check 6		(scc 3)
																		step21 visit0: 	done					reverse 0 2 4 5 3 11 9 12 10 6 7 8      step21 visit8: 	done
																		step22 visit1: 	done					reverse 1 0 2 4 5 3 11 9 12 10 6 7 8    step22 visit6: 	done
																																						step23 visit 7: done		(scc 4)
	Strong components in a digraph (with two DFSs)
	####################################################################
	# public class KosarajuSharirSCC {                                 #
	#     private boolean marked[];                                    #
	#     private int[] id;                                            #
	#     private int count;                                           #
	#     public KosarajuSharirSCC(Digraph G) {                        #
	#         marked = new boolean[G.V()];                             #
	#         id = new int[G.V()];                                     #
	#         DepthFirstOrder dfs = new DepthFirstOrder(G.reverse());  #
	#         for (int v : dfs.reversePost()) {                        #
	#             if (!marked[v]) {                                    #
	#                 dfs(G, v);                                       #
	#                 count ++;                                        #
	#             }                                                    #
	#         }                                                        #
	#     }                                                            #
	#     private void dfs(Digraph G, int v) {                         #
	#         marked[v] = true;                                        #
	#         id[v] = count;                                           #
	#         for (int w : G.adj(v))                                   #
	#             if (!marked[w])                                      #
	#                 dfs(G, w);                                       #
	#     }                                                            #
	#     public boolean stronglyConnected(int v, int w) {             #
	#         return id[v] == id[w];                                   #
	#     }                                                            #
	# }                                                                #
	#                                                                  #
	####################################################################
	
	
	
	


###############
# week2
###############

- MSTs
	A spanning tree of G is a subgraph T that is both a tree (connected and acyclic) 
	and spanning (includes all of the vertices).													
	###############################################################################		MST is fundamental problem with diverse applications.
    #                                          0.29                               #     ・Dithering.									 ・Find road networks in satellite and aerial imagery.
    #                                  ┌·················┐                        #     ・Cluster analysis.                           ・Reducing data storage in sequencing amino acids in a protein. 
    #                                  :                 :                        #     ・Max bottleneck paths.                       ・Model locality of particle interactions in turbulent fluid flows. 
    #              ╔═══════╗  0.32   ╔═══════╗         ╔═══════╗                  #     ・Real-time face verification.                ・Autoconfig protocol for Ethernet bridging to avoid cycles in a network. 
    #           ┌─ ║   5   ║ ······· ║   1   ║ ·┐      ║   3   ║ ···············┐ #     ・LDPC codes for error correction.            ・Approximation algorithms for NP-hard problems (e.g., TSP, Steiner tree).
    #           │  ╚═══════╝         ╚═══════╝  :      ╚═══════╝                : #     ・Image registration with Renyi entropy.      ・Network design (communication, electrical, hydraulic, computer, road). 
    #           │    │                 │        :        │                      : #
    #           │    │ 0.28            │ 0.19   : 0.36   │ 0.17                 : #
    #           │    │                 │        :        │                      : #
    #           │    │      ╔═══════╗  │        :      ╔═══════╗                : #
    #           │    └───── ║       ║ ─┘        └····· ║       ║                : #
    #           │           ║       ║                  ║       ║                : #
    #           │           ║       ║          0.34    ║       ║                : #
    #           │           ║   7   ║ ················ ║   2   ║                : #
    #           │           ║       ║                  ║       ║                : #
    #           │           ║       ║          0.26    ║       ║                : #
    #  ┌········┼·········· ║       ║  ┌────────────── ║       ║ ──────┐        : #
    #  :        │           ╚═══════╝  │               ╚═══════╝       │        : #
    #  :        │             │      ╔═══════╗  0.58                   │        : #
    #  : 0.37   │             └───── ║   0   ║ ···················┐    │ 0.40   : #
    #  :        │                    ╚═══════╝                    :    │        : #
    #  :      ╔═══╗  0.93              :                        ╔═══╗  │        : #
    #  └····· ║ 4 ║ ···················┼······················· ║ 6 ║ ─┘        : #
    #         ╚═══╝                    :                        ╚═══╝           : #
    #           :   0.38               :                          :   0.52      : #
    #           └······················┘                          └·············┘ #
    #                                                                             #
    ###############################################################################


- Greedy algorithms
	Greedy MST																			cut graph into 2 partition [0 1 4 5 7] and [2 3 6]									divide graph into 2 partition [5] and [1 7 4 ...]													
	・Start with all edges colored gray.													find cut between 2 partitions with min weight and paint it black					find cut between 2 partitions with min weight and paint it black									
	・Find cut with no black crossing edges; color its min-weight edge black.			min cut is 0 2 among ([1 3],[0 2],[2 7],[1 2],[6 9],[6 4])							min cut is 5 7 
	・Repeat until V - 1 edges are colored black.										MST 0 2,														                    MST [0 2], [5 7]
	###############################################################################		###############################################################################		###############################################################################
    #                                          0.29                               #     #                                          0.29                               #     #                                          0.29                               #
    #                                  ┌·················┐                        #     #                                  ┌·················┐                        #     #                                  ┌·················┐                        #
    #                                  :                 :                        #     #                                  :                 :                        #     #                                  :                 :                        #
    #              ┌───────┐  0.32   ┌───────┐         ┌───────┐                  #     #              ╔═══════╗  0.32   ╔═══════╗         ┌───────┐                  #     #              ╔═══════╗  0.32   ┌───────┐         ┌───────┐                  #
    #           ┌· │   5   │ ······· │   1   │ ·┐      │   3   │ ···············┐ #     #           ┌· ║   5   ║ ······· ║   1   ║ ·┐      │   3   │ ···············┐ #     #           ┌· ║   5   ║ ······· │   1   │ ·┐      │   3   │ ···············┐ #
    #           :  └───────┘         └───────┘  :      └───────┘                : #     #           :  ╚═══════╝         ╚═══════╝  :      └───────┘                : #     #           :  ╚═══════╝         └───────┘  :      └───────┘                : #
    #           :    :                 :        :        :                      : #     #           :    :                 :        :        :                      : #     #           :    │                 :        :        :                      : #
    #           :    : 0.28            : 0.19   : 0.36   : 0.17                 : #     #           :    : 0.28            : 0.19   : 0.36   : 0.17                 : #     #           :    │ 0.28            : 0.19   : 0.36   : 0.17                 : #
    #           :    :                 :        :        :                      : #     #           :    :                 :        :        :                      : #     #           :    │                 :        :        :                      : #
    #           :    :      ┌───────┐  :        :      ┌───────┐                : #     #           :    :      ╔═══════╗  :        :      ┌───────┐                : #     #           :    │      ╔═══════╗  :        :      ╔═══════╗                : #
    #           :    └····· │       │ ·┘        └····· │       │                : #     #           :    └····· ║       ║ ·┘        └····· │       │                : #     #           :    └───── ║       ║ ·┘        └····· ║       ║                : #
    #           :           │       │                  │       │                : #     #           :           ║       ║                  │       │                : #     #           :           ║       ║                  ║       ║                : #
    #           :           │       │          0.34    │       │                : #     #           :           ║       ║          0.34    │       │                : #     #           :           ║       ║          0.34    ║       ║                : #
    #           :           │   7   │ ················ │   2   │                : #     #           :           ║   7   ║ ················ │   2   │                : #     #           :           ║   7   ║ ················ ║   2   ║                : #
    #           :           │       │                  │       │                : #     #           :           ║       ║                  │       │                : #     #           :           ║       ║                  ║       ║                : #
    #           :           │       │          0.26    │       │                : #     #           :           ║       ║          0.26    │       │                : #     #           :           ║       ║          0.26    ║       ║                : #
    #  ┌········┼·········· │       │  ┌·············· │       │ ······┐        : #     #  ┌········┼·········· ║       ║  ┌────────────── │       │ ······┐        : #     #  ┌········┼·········· ║       ║  ┌────────────── ║       ║ ······┐        : #
    #  :        :           └───────┘  :               └───────┘       :        : #     #  :        :           ╚═══════╝  │               └───────┘       :        : #     #  :        :           ╚═══════╝  │               ╚═══════╝       :        : #
    #  :        :             :      ┌───────┐  0.58                   :        : #     #  :        :             :      ╔═══════╗  0.58                   :        : #     #  :        :             :      ╔═══════╗  0.58                   :        : #
    #  : 0.37   :             └····· │   0   │ ···················┐    : 0.40   : #     #  : 0.37   :             └····· ║   0   ║ ···················┐    : 0.40   : #     #  : 0.37   :             └····· ║   0   ║ ···················┐    : 0.40   : #
    #  :        :                    └───────┘                    :    :        : #     #  :        :                    ╚═══════╝                    :    :        : #     #  :        :                    ╚═══════╝                    :    :        : #
    #  :      ┌───┐  0.93              :                        ┌───┐  :        : #     #  :      ╔═══╗  0.93              :                        ┌───┐  :        : #     #  :      ┌───┐  0.93              :                        ┌───┐  :        : #
    #  └····· │ 4 │ ···················┼······················· │ 6 │ ·┘        : #     #  └····· ║ 4 ║ ···················┼······················· │ 6 │ ·┘        : #     #  └····· │ 4 │ ···················┼······················· │ 6 │ ·┘        : #
    #         └───┘                    :                        └───┘           : #     #         ╚═══╝                    :                        └───┘           : #     #         └───┘                    :                        └───┘           : #
    #           :   0.38               :                          :   0.52      : #     #           :   0.38               :                          :   0.52      : #     #           :   0.38               :                          :   0.52      : #
    #           └······················┘                          └·············┘ #     #           └······················┘                          └·············┘ #     #           └······················┘                          └·············┘ #
    #                                                                             #     #                                                                             #     #                                                                             #
    ###############################################################################     ###############################################################################     ###############################################################################

	divide graph into 2 partition [6] and [3 2 0 4...]
	MST [0 2], [5 7], [6 2]
	divide graph into 2 partition [5 7 1 3] and [4 0 2 6]
	MST [0 2], [5 7], [6 2], [7 0]
	divide graph into 2 partition [5 7 0 2 6 4] and [1 3]
	MST [0 2], [5 7], [6 2], [7 0], [3 2]
	divide graph into 2 partition [5 7 0 2 6 3] and [1 4]
	MST [0 2], [5 7], [6 2], [7 0], [3 2], [1 7]
	divide graph into 2 partition [5 7 0 2 6 3 1] and [4]
	MST [0 2], [5 7], [6 2], [7 0], [3 2], [1 7], [4 5]	

- Edge-Weighed Graph API
	Add Edge class																		Edge-weighted graph
	####################################################   either			other		###########################################
	# public class Edge implements Comparable<Edge> {  #	+-+    weight    +-+        # public class EdgeWeightedGraph {        #
	#     private final int v,                         #    |v|--------------|w|        #     private final int V;                #
	#     w;                                           #    +-+              +-+        #     private final Bag<Edge> [] adj;     #
	#     private final double weight;                 #                                #     public EdgeWeightedGraph(int V) {   #
	#     public Edge(int v, int w, double weight) {   #                                #         this.V = V;                     #
	#         this.v = v;                              #                                #         adj = (Bag<Edge> [])new Bag[V]; #
	#         this.w = w;                              #                                #         for (int v = 0; v < V; v ++)    #
	#         this.weight = weight;                    #                                #             adj[v] = new Bag<Edge>();   #
	#     }                                            #                                #     }                                   #
	#     public int either() {                        #                                #     public void addEdge(Edge e) {       #
	#         return v;                                #	<-- either endpoint         #         int v = e.either(),             #
	#     }                                            #                                #         w = e.other(v);                 #
	#     public int other(int vertex) {               #	<-- other endpoint          #         adj[v].add(e);                  #
	#         if (vertex == v)                         #                                #         adj[w].add(e);                  #
	#             return w;                            #                                #     }                                   #
	#          else                                    #                                #     public Iterable<Edge> adj(int v) {  #
	#             return v;                            #                                #         return adj[v];                  #
	#     }                                            #                                #     }                                   #
	#     public int compareTo(Edge that) {            #                                # }                                       #
	#         if (this.weight < that.weight)           #                                ###########################################
	#             return -1;                           #
	#          else if (this.weight > that.weight)     #
	#             return + 1;                          #
	#          else                                    #
	#             return 0;                            #
	#     }                                            #
	# }                                                #
	####################################################
	
- Kruskal's Algorithm
	Consider edges in ascending order of weight.
	・Add next edge to tree T unless doing so would create a cycle.						sorted wights												Kruskal's Algorithm
	###############################################################################		0-7 0.16			step1  no cycle - add					#############################################################
	#                                          0.29!(6)                           #		2-3 0.17            step2  no cycle - add                   # public class KruskalMST {                                 #
	#                                  ┌·················┐                        #		1-7 0.19            step3  no cycle - add                   #     private Queue<Edge> mst = new Queue<Edge>();          #
	#                                  :                 :                        #		0-2 0.26            step4  no cycle - add                   #     public KruskalMST(EdgeWeightedGraph G) {              #
	#              ╔═══════╗0.32!(7) ╔═══════╗         ╔═══════╗                  #		5-7 0.28            step5  no cycle - add                   #         MinPQ<Edge> pq = new MinPQ<Edge>();               #  <-- build priority queue
	#           ┌─ ║   5   ║ ······· ║   1   ║ ·┐      ║   3   ║ ···············┐ #		1-3 0.29            step6  cycle - no add                   #         for (Edge e : G.edges())                          #
	#           │  ╚═══════╝         ╚═══════╝  :      ╚═══════╝                : #		1-5 0.32            step7  cycle - no add                   #             pq.insert(e);                                 #
	#           │    │                 │        :        │                      : #		2-7 0.34            step8  cycle - no add                   #                                                           #
	#           │    │0.28(4)          │0.19(3) :0.36!10 │ 0.17(2)              : #		4-5 0.35            step9  no cycle - add                   #         UF uf = new UF(G.V());                            #
	#           │    │                 │        :        │                      : #		1-2 0.36            step10 cycle - no add                   #         while (!pq.isEmpty() && mst.size() < G.V() - 1) { #
	#           │    │      ╔═══════╗  │        :      ╔═══════╗                : #		4-7 0.37            step11 cycle - no add                   #             Edge e = pq.delMin();                         #
	#           │    └───── ║       ║ ─┘        └····· ║       ║                : #		0-4 0.38            step12 cycle - no add                   #             int v = e.either(),                           #  <-- greedily add edges to MST
	#           │           ║       ║                  ║       ║                : #		6-2 0.40            step13 no cycle - add	MST is ready    #             w = e.other(v);                               #
	#           │0.35(9)    ║       ║      0.34!(8)    ║       ║                : #		3-6 0.52                                                    #             if (!uf.connected(v, w)) {                    #  <-- edge v-w does not create a cycle
	#           │           ║   7   ║ ················ ║   2   ║                : #		6-0 0.58                                                    #                 uf.union(v, w);                           #  <-- merge sets
	#           │           ║       ║                  ║       ║                : #		6-4 0.93                                                    #                 mst.enqueue(e);                           #  <-- add edges to MST
	#           │           ║       ║       0.26(4)    ║       ║                : #                                                                 #             }                                             #
	#  ┌········┼·········· ║       ║  ┌────────────── ║       ║ ──────┐        : #                                                                 #         }                                                 #
	#  :        │           ╚═══════╝  │               ╚═══════╝       │        : #                                                                 #     }                                                     #
	#  :        │             │      ╔═══════╗  0.58                   │        : #                                                                 #     public Iterable<Edge> edges() {                       #
	#  :0.37!11 │             └───── ║   0   ║ ···················┐    │0.40(13): #                                                                 #         return mst;                                       #
	#  :        │            0.16(1) ╚═══════╝                    :    │        : #                                                                 #     }                                                     #
	#  :      ╔═══╗  0.93              :                        ╔═══╗  │        : #                                                                 # }                                                         #
	#  └····· ║ 4 ║ ···················┼······················· ║ 6 ║ ─┘        : #                                                                 #############################################################
	#         ╚═══╝                    :                        ╚═══╝           : #
	#           :   0.38!12            :                          :   0.52      : #
	#           └······················┘                          └·············┘ #
	#                                                                             #
	###############################################################################	
	
- Prim's Algorithm
	・Start with vertex 0 and greedily grow tree T.
	・Add to T the min weight edge with exactly one endpoint in T.
	・Repeat until V - 1 edges.																						min-PQ		MST
	###############################################################################		add edges of 0 to min PQ	0-7			0-7
	#                                          0.29                               #     add edges of 7 to min PQ	1-7			0-7 1-7
	#                                  ┌·················┐                        #     add edges of 1 to min PQ	0-2			0-7 1-7 0-2
	#                                  :                 :                        #     add edges of 2 to min PQ	2-3			0-7 1-7 0-2 2-3
	#              ╔═══════╗0.32     ╔═══════╗         ╔═══════╗                  #     add edges of 3 to min PQ	5-7			0-7 1-7 0-2 2-3 5-7
	#           ┌─ ║   5   ║ ······· ║   1   ║ ·┐      ║   3   ║ ···············┐ #     add edges of 5 to min PQ	5-4			0-7 1-7 0-2 2-3 5-7 5-4
	#           │  ╚═══════╝         ╚═══════╝  :      ╚═══════╝                : #     add edges of 4 to min PQ	6-2			0-7 1-7 0-2 2-3 5-7 5-4 6-2
	#           │    │                 │        :        │                      : #     
	#           │    │0.28(5)          │0.19(2) :0.36    │ 0.17(4)              : #     #############################################################
	#           │    │                 │        :        │                      : #     # public class LazyPrimMST {                                #
	#           │    │      ╔═══════╗  │        :      ╔═══════╗                : #     #     private boolean[] marked; 	// MST vertices         #
	#           │    └───── ║       ║ ─┘        └····· ║       ║                : #     #     private Queue<Edge> mst; 		// MST edges            #
	#           │           ║       ║                  ║       ║                : #     #     private MinPQ<Edge> pq; 		// PQ of edges          #
	#           │0.35(6)    ║       ║      0.34        ║       ║                : #     #     public LazyPrimMST(WeightedGraph G) {                 #
	#           │           ║   7   ║ ················ ║   2   ║                : #     #         pq = new MinPQ<Edge>();                           #
	#           │           ║       ║                  ║       ║                : #     #         mst = new Queue<Edge>();                          #
	#           │           ║       ║       0.26(3)    ║       ║                : #     #         marked = new boolean[G.V()];                      #
	#  ┌········┼·········· ║       ║  ┌────────────── ║       ║ ──────┐        : #     #         visit(G, 0);                                      #  <-- assume G is connected
	#  :        │           ╚═══════╝  │               ╚═══════╝       │        : #     #         while (!pq.isEmpty() && mst.size() < G.V() - 1) { #
	#  :        │             │      ╔═══════╗  0.58                   │        : #     #             Edge e = pq.delMin();                         #  <-- repeatedly delete the min weight edge e = v–w from PQ
	#  :0.37    │             └───── ║   0   ║ ···················┐    │0.40(7  : #     #             int v = e.either(),                           #
	#  :        │            0.16(1) ╚═══════╝                    :    │        : #     #             w = e.other(v);                               #
	#  :      ╔═══╗  0.93              :                        ╔═══╗  │        : #     #             if (marked[v] && marked[w]) continue;         #  <-- ignore if both endpoints in T
	#  └····· ║ 4 ║ ···················┼······················· ║ 6 ║ ─┘        : #     #                                                           #
	#         ╚═══╝                    :                        ╚═══╝           : #     #             mst.enqueue(e);                               #  <-- add edge e to tree
	#           :   0.38               :                          :   0.52      : #     #             if (!marked[v]) visit(G, v);                  #  <-- add v or w to tree
	#           └······················┘                          └·············┘ #     #             if (!marked[w]) visit(G, w);                  #
	#                                                                             #     #         }                                                 #
	###############################################################################     #     }                                                     #
                                                                                        #     private void visit(WeightedGraph G, int v) {          #
                                                                                        #         marked[v] = true;                                 #  <-- add v to T
                                                                                        #         for (Edge e : G.adj(v))                           #
                                                                                        #             if (!marked[e.other(v)])                      #
                                                                                        #                 pq.insert(e);                             #  <-- for each edge e = v–w, add to PQ if w not already in T
                                                                                        #     }                                                     #
                                                                                        #     public Iterable<Edge> mst() {return mst;}             #
                                                                                        # }                                                         #
                                                                                        #############################################################

- Prim's Algorithm (eager)
	step1: MST 0-7					step2: MST 0-7 1-7			step3: MST 0-7 1-7 0-2
	add vertices 7 2 4 6 to PQ      add vertices 1 5 to PQ      add vertices 3 to PQ
	v 	edgeTo[] 	distTo[]        v 	edgeTo[] 	distTo[]    v 	edgeTo[] 	distTo[]
	0 	- 			-               0 	- 			-           0 	- 			-
	7 	0–7 		0.16            *1 	1–7 		0.19        2 	0–2 		0.26
	2 	0–2 		0.26            2 	0–2 		0.26        5	5-7			0.28
	4 	0–4 		0.38            *5	5-7			0.28        3	1-3			0.29
	6 	6–0 		0.58            4 	0–4 		0.38        4 	0–4 		0.38
                                    6 	6–0 		0.58        6 	6–0 		0.58 
                                    not adding 7-4 7-2          not adding 3-6 3-2

- Shortest Paths APIs																		DirectedEdge													representation
	#################################################################################		###########################################################		###############################		###################################################
	#  ┌·········································································┐  #       # public class DirectedEdge {                             #     # +-+    +--------++--------+ #     # public class EdgeWeightedDigraph {              #
	#  :                                                                         :  #       #     private final int v,                                #     # |0|--->|0-2 0.26||0-4 0.38| #     #     private final int V;                        #
	#  :            0.35    ┌───────┐  0.32   ┌───┐  0.29   ┌───┐  0.52          :  #       #     w;                                                  #     # +-+    +--------++--------+ #     #     private final Bag<DirectedEdge> [] adj;     #
	#  :        ┌··········>│   5   │ ······> │ 1 │ ······> │ 3 │ ··········┐    :  #       #     private final double weight;                        #     # |1|--->...                  #     #     public EdgeWeightedDigraph(int V) {         #
	#  :        :           └───────┘         └───┘         └───┘           :    :  #       #     public DirectedEdge(int v, int w, double weight) {  #     # +-+                         #     #         this.V = V;                             #
	#  : 0.93   :             ∧                         	  ∧         	:    :  #       #         this.v = v;                                     #     # |2|--->...                  #     #         adj = (Bag<DirectedEdge> [])new Bag[V]; #
	#  :        :             : 0.28                          :             :    :  #       #         this.w = w;                                     #     # +-+                         #     #         for (int v = 0; v < V; v ++)            #
	#  :        ∨       	  ∨                 	          :             :    :  #       #         this.weight = weight;                           #     ###############################     #             adj[v] = new Bag<DirectedEdge>();   #
	#  :      ┌───┐  0.37   ┌───────┐  0.39                   :             :    :  #       #     }                                                   #                                         #     }                                           #
	#  └····> │ 4 │ ······> │   7   │ ························┘             :    :  #       #     public int from() {                                 #                                         #     public void addEdge(DirectedEdge e) {       #
	#         └───┘         └───────┘                                       :    :  #       #         return v;                                       #                                         #         int v = e.from();                       #  <-- add edgle e=b-w to
    #           ∧          	  ∧                                        	    :    :  #       #     }                                                   #                                         #         adj[v].add(e);                          #      only v`s adj list
    #           :             : 0.34                                        :    :  #       #     public int to() {                                   #                                         #     }                                           #
    #           :             :                                             ∨	 :  #       #         return w;                                       #                                         #     public Iterable<DirectedEdge> adj(int v) {  #
    #           :           ┌───────┐                             0.40    ┌───┐  :  #       #     }                                                   #                                         #         return adj[v];                          #
    #           :           │   2   │ <·································· │ 6 │ ·┘  #       #     public int weight() {                               #                                         #     }                                           #
    #           :           └───────┘                                     └───┘     #       #         return weight;                                  #                                         # }                                               #
    #           :             ∧                                         	:       #       #     }                                                   #                                         ###################################################
    #           :             : 0.26                                        :       #       # }                                                       #
    #           :             :                                             :       #       ###########################################################
    #           :   0.38    ┌───────┐          0.58                         :       #
    #           └·········· │   0   │ <·····································┘       #
    #                       └───────┘                                               #
    #################################################################################
    
	Find the shortest path from s to every other vertex.	#########################################################################
		edgeTo[]	distTo[]                                # public double distTo(int v) {                                         #
     0 	null 		0                                       #     return distTo[v];                                                 #
     1 	5->1 0.32 	1.05                                    # }                                                                     #
     2 	0->2 0.26 	0.26                                    # public Iterable<DirectedEdge> pathTo(int v) {                         #
     3 	7->3 0.37 	0.97                                    #     Stack<DirectedEdge> path = new Stack<DirectedEdge>();             #
     4 	0->4 0.38 	0.38                                    #     for (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.from()]) #
     5 	4->5 0.35 	0.73                                    #         path.push(e);                                                 #
     6 	3->6 0.52 	1.49                                    #     return path;                                                      #
     7  2->7 0.34   0.60                                    # }                                                                     #
                                                            #########################################################################

	Edge relaxation
	Relax edge e = v→w.																		#################################################
	・ distTo[v] is length of shortest known path from s to v.                               # private void relax(DirectedEdge e) {          # 
	・ distTo[w] is length of shortest known path from s to w.                               #     int v = e.from(),                         # 
	・ edgeTo[w] is last edge on shortest known path from s to w.                            #     w = e.to();                               # 
	・If e = v→w gives shorter path to w through v, update both distTo[w] and edgeTo[w].     #     if (distTo[w] > distTo[v] + e.weight()) { # 
                                                                                            #         distTo[w] = distTo[v] + e.weight();   #
                                                                                            #         edgeTo[w] = e;                        #
                                                                                            #     }                                         #
                                                                                            # }                                             #
                                                                                            #################################################

	Optimality conditions
	distTo array represents shortest path distances from source if nelow 2 conditions hold
	・For each vertex v, distTo[v] is the length of some path from s to v.
	・For each edge e = v→w, distTo[w] ≤ distTo[v] + e.weight().
	Proof
	・Suppose that distTo[w] > distTo[v] + e.weight() for some edge e = v→w.
	・Then, e gives a path from s to w (through v) of length less than distTo[w].	

	Generic shortest-paths algorithm
	Generic algorithm (to compute SPT from s)
	Initialize distTo[s] = 0 and distTo[v] = ∞ for all other vertices.
	Repeat until optimality conditions are satisfied:
		- Relax any edge.


- Dijkstra's Algorithm
	・Consider vertices in increasing order of distance from s
	(non-tree vertex with the lowest distTo[] value).
	・Add vertex to tree and relax all edges pointing from that vertex.				SPT
	############################################################################	###########################################################################		########################################################	#################################################
    #  					      ╔════╗        15    ╔════╗                       #    #                         ╔════╗        15    ╔════╗                      #     #public class DijkstraSP {                             #    # private void relax(DirectedEdge e) {          #
    #                         ║    ║ ···········> ║ 3  ║ ········┐             #    #                         ║    ║ ···········> ║ 3  ║ ········┐            #     #    private DirectedEdge[] edgeTo;                    #    #     int v = e.from(),                         #
    #                         ║ 1  ║              ╚════╝         :             #    #                         ║ 1  ║              ╚════╝         :            #     #    private double[] distTo;                          #    #     w = e.to();                               #
    # ╔══════════╗       5    ║    ║  12            ∧        	 :             #    # ╔══════════╗       5    ║    ║  12            ∧            :            #     #    private IndexMinPQ<Double> pq;                    #    #     if (distTo[w] > distTo[v] + e.weight()) { #
    # ║    0     ║ ·········> ║    ║ ········┐      : 3          :             #    # ║    0     ║ ─────────> ║    ║ ········┐      │ 3          :            #     #    public DijkstraSP(EdgeWeightedDigraph G, int s) { #    #         distTo[w] = distTo[v] + e.weight();   #
    # ╚══════════╝            ╚════╝         :      :            :             #    # ╚══════════╝            ╚════╝         :      │            :            #     #        edgeTo = new DirectedEdge[G.V()];             #    #         edgeTo[w] = e;                        #
    #   :     :                 :            :    ╔════╗         :             #    #   │     │                 :            :    ╔════╗         :            #     #        distTo = new double[G.V()];                   #    #         if (pq.contains(w))                   #
    #   :     : 8               : 4          └··> ║    ║         :             #    #   │     │ 8               : 4          └··> ║    ║         :            #     #        pq = new IndexMinPQ<Double>(G.V());           #    #             pq.decreaseKey(w, distTo[w]);     #
    #   :     :                 ∨	              ║    ║         :             #    #   │     │                 ∨                 ║    ║         :            #     #        for (int v = 0; v < G.V(); v ++)              #    #          else                                 #
    #   :     :   ╔════════════════╗        7     ║    ║         :             #    #   │     │   ╔════════════════╗        7     ║    ║         :            #     #            distTo[v] = Double.POSITIVE_INFINITY;     #    #             pq.insert(w, distTo[w]);          #
    #   : 9   └·> ║                ║ ···········> ║ 2  ║         : 9           #    #   │ 9   └─> ║                ║ ···········> ║ 2  ║         : 9          #     #        distTo[s] = 0.0;                              #    #      }                                        #
    #   ∨     	  ║       7        ║              ║    ║         ∨         	   #    #   ∨         ║       7        ║              ║    ║         ∨            #     #        pq.insert(s, 0.0);                            #    # }                                             #
    # ╔════╗  5   ║                ║              ║    ║  11   ╔════════════╗  #    # ╔════╗  5   ║                ║              ║    ║  11   ╔════════════╗ #     #        while (!pq.isEmpty()) {                       #    #################################################
    # ║    ║ ···> ║                ║              ║    ║ ····> ║     6      ║  #    # ║    ║ ···> ║                ║              ║    ║ ────> ║     6      ║ #     #            int v = pq.delMin();                      #
    # ║    ║      ╚════════════════╝              ╚════╝       ╚════════════╝  #    # ║    ║      ╚════════════════╝              ╚════╝       ╚════════════╝ #     #            for (DirectedEdge e : G.adj(v))           #
    # ║    ║        :                               ∧        	 ∧      ∧  	   #    # ║    ║        :                               ∧            ∧      ∧     #     #                relax(e);                             #
    # ║ 4  ║        : 6                             : 1          : 20   : 13   #    # ║ 4  ║        : 6                             │ 1          : 20   : 13  #     #        }                                             #
    # ║    ║        ∨                            	:        	 :      :      #    # ║    ║        ∨                               │            :      :     #     #    }                                                 #
    # ║    ║  4   ╔════╗                            :            :      :      #    # ║    ║  4   ╔════╗                            │            :      :     #     #}                                                     #
    # ║    ║ ···> ║    ║ ···························┘            :      :      #    # ║    ║ ───> ║    ║ ───────────────────────────┘            :      :     #     ########################################################
    # ╚════╝      ║ 5  ║                                         :      :      #    # ╚════╝      ║ 5  ║                                         :      :     #
    #   :         ║    ║                                         :      :      #    #   :         ║    ║                                         :      :     #
    #   :         ║    ║ ········································┼······┘      #    #   :         ║    ║ ········································┼······┘     #
    #   :         ╚════╝                                         :             #    #   :         ╚════╝                                         :            #
    #   :                                                        :             #    #   :                                                        :            #
	#   └························································┘             #    #   └························································┘            #
    ############################################################################    ###########################################################################

	step1						| step2							| step3							| step4							| step5							| step6							| step7
	- add 0 to SPT as closest   | - add 1 to SPT as closest     | - add 7 to SPT as closest     | - add 4 to SPT as closest     | - add 5 to SPT as closest     | - add 2 to SPT as closest     | - add 3 to SPT as closest
	- relax all edges from 0    | - relax all edges from 1      | - relax all edges from 7      | - relax all edges from 4      | - relax all edges from 5      | - relax all edges from 2      | - relax all edges from 3
	v 	distTo[] 	edgeTo[]    | v 	distTo[] 	edgeTo[]    | v 	distTo[] 	edgeTo[]    | v 	distTo[] 	edgeTo[]    | v 	distTo[] 	edgeTo[]    | v 	distTo[] 	edgeTo[]    | v 	distTo[] 	edgeTo[]
	0# 	0.0 		-		    | 0# 	0.0 		-           | 0# 	0.0 		-           | 0# 	0.0 		-           | 0# 	0.0 		-           | 0# 	0.0 		-           | 0# 	0.0 		-
	1* 	5.0 		0-1         | 1# 	5.0 		0-1         | 1# 	5.0 		0-1         | 1# 	5.0 		0-1         | 1# 	5.0 		0-1         | 1# 	5.0 		0-1         | 1# 	5.0 		0-1
	2 	                        | 2*	17.0		1-2 	    | 2*	15.0		7-2(change) | 2		15.0		7-2	        | 2*	14.0		5-2(change) | 2#	14.0		5-2         | 2#	14.0		5-2
	3 	                        | 3*	20.0		1-3 	    | 3		20.0		1-3 	    | 3		20.0		1-3 	    | 3		20.0		1-3 	    | 3*	17.0		2-3(change) | 3#	17.0		2-3	
	4* 	9.0 		0-4         | 4 	9.0 		0-4         | 4 	9.0 		0-4         | 4# 	9.0 		0-4         | 4# 	9.0 		0-4         | 4# 	9.0 		0-4         | 4# 	9.0 		0-4
	5 	                        | 5 	                        | 5*	14.0		7-5 	    | 5*	13.0		4-5(change) | 5#	13.0		4-5         | 5#	13.0		4-5         | 5#	13.0		4-5
	6 	                        | 6 	                        | 6 	                        | 6*	29.0		4-6 	    | 6*	26.0		5-6(change)	| 6*	25.0		2-6(change) | 6*	25.0		2-6(same)
	7* 	8.0 		0-7         | 7* 	8.0 		0-7 (same)  | 7# 	8.0 		0-7         | 7#* 	8.0 		0-7         | 7# 	8.0 		0-7         | 7# 	8.0 		0-7         | 7# 	8.0 		0-7






###############
# week3
###############

###############
# week4
###############

###############
# week5
###############
###############
# week6
###############