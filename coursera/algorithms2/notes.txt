###############
# week1
###############
- introduction
	Graph. Set of vertices connected pairwise by edges.
	Path. Sequence of vertices connected by edges.
	Cycle. Path whose first and last vertices are the same.
	
	graph 			vertex 					edge
	communication 	telephone, computer 	fiber optic cable

- API
	compute the degree of v									compute maximum degree									compute average degree									count self - loops                                 
	####################################################    ####################################################    ####################################################    ####################################################
	# public static int degree(Graph G, int v) {       #    # public static int maxDegree(Graph G) {           #    # public static double averageDegree(Graph G) {    #    # public static int numberOfSelfLoops(Graph G) {   #
	#     int degree = 0;                              #    #     int max = 0;                                 #    #     return 2.0 * G.E() / G.V();                  #    #     int count = 0;                               #
	#     for (int w : G.adj(v))                       #    #     for (int v = 0; v < G.V(); v ++)             #    # }                                                #    #     for (int v = 0; v < G.V(); v ++)             #
	#         degree ++;                               #    #         if (degree(G, v) > max)                  #    ####################################################    #         for (int w : G.adj(v))                   #
	#     return degree;                               #    #             max = degree(G, v);                  #                                                            #             if (v == w)                          #
	# }                                                #    #     return max;                                  #                                                            #                 count ++;                        #
	####################################################    # }                                                #                                                            #     return count / 2; // each edge counted twice #
	                                                        ####################################################                                                            # }                                                #
	                                                                                                                                                                        ####################################################
	Adjacency-list graph representation
	############################################	#############################################
	# +--------------------------------------+ #    # public class Graph {                      #
	# | 0| 1| 2| 3| 4| 5| 6| 7| 8| 9|10|11|12| #    #     private final int V;                  #
	# +--------------------------------------+ #    #     private Bag<Integer> [] adj;          #
	#   6  0  0  5  5  3  0  8  7 11  9  9 11  #    #     public Graph(int V) {                 #
	#   2        4  6  4  4       10    12  6  #    #         this.V = V;                       #
	#   7           3  0          12           #    #         adj = (Bag<Integer> [])new Bag[V];#
	#   5                                      #    #         for (int v = 0; v < V; v ++)      #
	############################################    #             adj[v] = new Bag<Integer>();  #
	                                                #                                           #
	                                                #     }                                     #
	                                                #     public void addEdge(int v, int w) {   #
	                                                #         adj[v].add(w);                    #
	                                                #         adj[w].add(v);                    #
	                                                #     }                                     #
	                                                #     public Iterable<Integer> adj(int v) { #
	                                                #         return adj[v];                    #
	                                                #     }                                     #
	                                                # }                                         #
	                                                #############################################
	
- depth-first search
	
	Algorithm.																																################################################
	・Use recursion (ball of string).                                                                                                        # public class DepthFirstPaths {               # 
	・Mark each visited vertex (and keep track of edge taken to visit it).                                                                   #     private boolean[] marked;                # 
	・Return (retrace steps) when no unvisited options.                                                                                      #     private int[] edgeTo;                    # 
	                                                                                                                                        #     private int s;                           #
	graph							fin all vertices connected to s                                                                         #     public DepthFirstPaths(Graph G, int s) { #
	##########################		v	marked[]	edgeTo[v]                                                                               # 		//init data structures                 #
	# +--------------------+ #		0	T			-			step1 - mark with T (check 6 2 1 5)                                         #         dfs(G, s);                           #
	# | 0| 1| 2| 3| 4| 5| 6| #		1	T			0			step7 - mark with T came from 0 (check 0)                                   #     }                                        #
	# +--------------------+ #		2	T			0           step6 - mark with T came from 0 (check 0)                                   #     private void dfs(Graph G, int v) {       #
	#   5  0  0  5  5  3  0  #		3	T			5           step5 - mark with T came from 5 (check 5 4)	both 5 4 already visited        #         marked[v] = true;                    #
	#   1        4  6  4  4  #		4	T			6           step3 - mark with T came from 6 (check 5 6 3)                               #         for (int w : G.adj(v))               #
	#   2           3  0     #		5	T			4           step4 - mark with T came from 4 (check 3 4 0)                               #             if (!marked[w]) {                #
	#   6                    #		6	T			0           step2 - mark with T came from 0 (check 0 4)                                 #                 dfs(G, w);                   #
	##########################		7	F			-                                                                                       #                 edgeTo[w] = v;               #
	                                                                                                                                        #             }                                #
	                                                                                                                                        #     }                                        #
	                                                                                                                                        # }                                            #
	                                                                                                                                        ################################################

- breadth-first search
	Algorithm																																			####################################################
	Put s onto a FIFO queue, and mark s as visited.                                                                                                     # public class BreadthFirstPaths {                 #
	Repeat until the queue is empty:                                                                                                                    #     private boolean[] marked;                    #
 	- remove the least recently added vertex v                                                                                                          #     private int[] edgeTo;                        #
 	- add each of v's unvisited neighbors to the queue,and mark them as visited.                                                                        #     …                                            #
	                                                                                                                                                    #     private void bfs(Graph G, int s) {           #
	graph						                                                                                                                        #         Queue<Integer> q = new Queue<Integer>(); #
	#######################		v	edgeTo[v]	distTo[]                                                                                                #         q.enqueue(s);                            #
	# +-----------------+ # 	0	-			0			step1 - add 0 to queue (0), deque 0, add 0`s adj`s to queue that are not marked (2 1 5)     #         marked[s] = true;                        #
	# | 0| 1| 2| 3| 4| 5| # 	1	0		    1           step1                                                                                       #         while (!q.isEmpty()) {                   #
	# +-----------------+ # 	2	0           1           step1                                                                                       #             int v = q.dequeue();                 #
	#   5  0  0  5  2  3  # 	3	2           2           step2 - deque 2, add 2`s adj`s to queue (1 5 3)                                             #             for (int w : G.adj(v)) {             #
	#   1     3  4  3  0  # 	4	2           2           step1 - add 2`s adj`s to queue (1 5 3 4)                                                    #                 if (!marked[w]) {                #
	#   2     4  2        # 	5	0           1           step1                                                                                       #                     q.enqueue(w);                #
	####################### 	                                                                                                                        #                     marked[w] = true;            #
	                                                                                                                                                    #                     edgeTo[w] = v;               #
	Depth-first search. Put unvisited vertices on a stack.                                                                                              #                 }                                #
	Breadth-first search. Put unvisited vertices on a queue                                                                                             #             }                                    #
	                                                                                                                                                    #         }                                        #
                                                                                                                                                        #     }                                            #
                                                                                                                                                        # }                                                #
                                                                                                                                                        ####################################################

- connected components																							Finding connected components with DFS 			Finding connected components with DFS
																												##############################################	######################################
	Initialize all vertices v as unmarked.                                                                      # public class CC {                          #  # public int count() {               #
	For each unmarked vertex v, run DFS to identify all vertices discovered as part of the same component.      #     private boolean[] marked;              #  #     return count;                  #
                                                                                                                #     private int[] id;                      #  # }                                  #
	##########################		v	marked[]	cc[]											            #     private int count;                     #  # public int id(int v) {             #
	#      +-+               #      0	T			0		1 visit0: check 6 2 1 5 (cc 0)                      #     public CC(Graph G) {                   #  #     return id[v];                  #
	#      |0|--\            #      1	T		    0       7 visit1: check 0 (cc 0)                            #         marked = new boolean[G.V()];       #  # }                                  #
	#      +-+-\ ---\        #      2	T           0       6 visit2: check 0 (cc 0)                            #         id = new int[G.V()];               #  # private void dfs(Graph G, int v) { #
	#     / \   --\  ---\    #      3	T           0       5 visit3: check 5 4 (cc 0)                          #         for (int v = 0; v < G.V(); v ++) { #  #     marked[v] = true;              #
	#    |   +-+   +-+   +-+ #      4	T           0       3 visit4: check 5 6 3  (cc 0)                       #             if (!marked[v]) {              #  #     id[v] = count;                 #
	#    /   |1|   |2|   |6| #      5	T           0       4 visit5: check 3 4 0 (cc 0)                        #                 dfs(G, v);                 #  #     for (int w : G.adj(v))         #
	#   |    +-+   +-+   +-+ #		6   T           0		2 visit6: check 0 4 (cc 0)                          #                 count ++;                  #  #         if (!marked[w])            #
	#   /                /   #                                                                                  #             }                              #  #             dfs(G, w);             #
	#  |      +-+     +-+    #		To visit a vertex v :	                                                    #         }                                  #  #                                    #
	#  /    /-|3|-----|4|    #      ・Mark vertex v as visited.                                                  #     }                                      #  #                                    # 
	# |   /-  +-+ /---+-+    #      ・Recursively visit all unmarked vertices adjacent to v.                     #     public int count()                     #  # }                                  # 
	# +-+-  /-----           #                                                                                  #     public int id(int v)                   #  ######################################
	# |5|---                 #                                                                                  #     private void dfs(Graph G, int v)       #
	# +-+                    #                                                                                  # }                                          #
	##########################                                                                                  ##############################################

		
- graph challenges
	P1 roblem. Is a graph bipartite?
	bipartite - whose vertices can be divided into two disjoint and independent sets U and V such that every edge connects a vertex in U to one in V.
	solution: dfs
	##########################		2 Problem. Find cycle - use dfs (0 5 4 6 0)
	#                        #		3 Problem. Bridges of Konigsberg (cycle use every edge once).Yes if all vertices have even degree
	#      +-+               #		4 Find a (general) cycle that uses every edge exactly once.
	#     u|0|--\            #		5 Find a cycle that visits every vertex exactly once. Hamiltonian cycle. hard one
	#      +-+-\ ---\        #		6 Are two graphs identical except for vertex names? graph isomorphism is longstanding open problem. hard one
	#     / \   --\  ---\    #		7 Lay out a graph in the plane without crossing edges? linear-time DFS-based planarity algorithm discovered by Tarjan in 1970s. hard one
	#    |   +-+   +-+   +-+ #
	#    /  v|1|  v|2|  v|6| #
	#   |    +-+   +-+   +-+ #
	#   /      \   /  \  /   #
	#  |        +-+   +-+    #
	#  /       u|3|  u|4|    #
	# |         +-+   +-+    #
	# +-+           /---     #
	#v|5|     /-----         #
	# +-+ ----               #
	##########################	



###############
# week2
###############

###############
# week3
###############

###############
# week4
###############

###############
# week5
###############
###############
# week6
###############