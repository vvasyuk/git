###############
# week1
###############
- introduction
	Graph. Set of vertices connected pairwise by edges.
	Path. Sequence of vertices connected by edges.
	Cycle. Path whose first and last vertices are the same.
	
	graph 			vertex 					edge
	communication 	telephone, computer 	fiber optic cable

- API
	compute the degree of v									compute maximum degree									compute average degree									count self - loops                                 
	####################################################    ####################################################    ####################################################    ####################################################
	# public static int degree(Graph G, int v) {       #    # public static int maxDegree(Graph G) {           #    # public static double averageDegree(Graph G) {    #    # public static int numberOfSelfLoops(Graph G) {   #
	#     int degree = 0;                              #    #     int max = 0;                                 #    #     return 2.0 * G.E() / G.V();                  #    #     int count = 0;                               #
	#     for (int w : G.adj(v))                       #    #     for (int v = 0; v < G.V(); v ++)             #    # }                                                #    #     for (int v = 0; v < G.V(); v ++)             #
	#         degree ++;                               #    #         if (degree(G, v) > max)                  #    ####################################################    #         for (int w : G.adj(v))                   #
	#     return degree;                               #    #             max = degree(G, v);                  #                                                            #             if (v == w)                          #
	# }                                                #    #     return max;                                  #                                                            #                 count ++;                        #
	####################################################    # }                                                #                                                            #     return count / 2; // each edge counted twice #
	                                                        ####################################################                                                            # }                                                #
	                                                                                                                                                                        ####################################################
	Adjacency-list graph representation
	############################################	#############################################
	# +--------------------------------------+ #    # public class Graph {                      #
	# | 0| 1| 2| 3| 4| 5| 6| 7| 8| 9|10|11|12| #    #     private final int V;                  #
	# +--------------------------------------+ #    #     private Bag<Integer> [] adj;          #
	#   6  0  0  5  5  3  0  8  7 11  9  9 11  #    #     public Graph(int V) {                 #
	#   2        4  6  4  4       10    12  6  #    #         this.V = V;                       #
	#   7           3  0          12           #    #         adj = (Bag<Integer> [])new Bag[V];#
	#   5                                      #    #         for (int v = 0; v < V; v ++)      #
	############################################    #             adj[v] = new Bag<Integer>();  #
	                                                #                                           #
	                                                #     }                                     #
	                                                #     public void addEdge(int v, int w) {   #
	                                                #         adj[v].add(w);                    #
	                                                #         adj[w].add(v);                    #
	                                                #     }                                     #
	                                                #     public Iterable<Integer> adj(int v) { #
	                                                #         return adj[v];                    #
	                                                #     }                                     #
	                                                # }                                         #
	                                                #############################################
	
- depth-first search
	
	Algorithm.																																################################################
	・Use recursion (ball of string).                                                                                                        # public class DepthFirstPaths {               # 
	・Mark each visited vertex (and keep track of edge taken to visit it).                                                                   #     private boolean[] marked;                # 
	・Return (retrace steps) when no unvisited options.                                                                                      #     private int[] edgeTo;                    # 
	                                                                                                                                        #     private int s;                           #
	graph							fin all vertices connected to s                                                                         #     public DepthFirstPaths(Graph G, int s) { #
	##########################		v	marked[]	edgeTo[v]                                                                               # 		//init data structures                 #
	# +--------------------+ #		0	T			-			step1 - mark with T (check 6 2 1 5)                                         #         dfs(G, s);                           #
	# | 0| 1| 2| 3| 4| 5| 6| #		1	T			0			step7 - mark with T came from 0 (check 0)                                   #     }                                        #
	# +--------------------+ #		2	T			0           step6 - mark with T came from 0 (check 0)                                   #     private void dfs(Graph G, int v) {       #
	#   5  0  0  5  5  3  0  #		3	T			5           step5 - mark with T came from 5 (check 5 4)	both 5 4 already visited        #         marked[v] = true;                    #
	#   1        4  6  4  4  #		4	T			6           step3 - mark with T came from 6 (check 5 6 3)                               #         for (int w : G.adj(v))               #
	#   2           3  0     #		5	T			4           step4 - mark with T came from 4 (check 3 4 0)                               #             if (!marked[w]) {                #
	#   6                    #		6	T			0           step2 - mark with T came from 0 (check 0 4)                                 #                 dfs(G, w);                   #
	##########################		7	F			-                                                                                       #                 edgeTo[w] = v;               #
	                                                                                                                                        #             }                                #
	                                                                                                                                        #     }                                        #
	                                                                                                                                        # }                                            #
	                                                                                                                                        ################################################

- breadth-first search
	Algorithm																																			####################################################
	Put s onto a FIFO queue, and mark s as visited.                                                                                                     # public class BreadthFirstPaths {                 #
	Repeat until the queue is empty:                                                                                                                    #     private boolean[] marked;                    #
 	- remove the least recently added vertex v                                                                                                          #     private int[] edgeTo;                        #
 	- add each of v's unvisited neighbors to the queue,and mark them as visited.                                                                        #     …                                            #
	                                                                                                                                                    #     private void bfs(Graph G, int s) {           #
	graph						                                                                                                                        #         Queue<Integer> q = new Queue<Integer>(); #
	#######################		v	edgeTo[v]	distTo[]                                                                                                #         q.enqueue(s);                            #
	# +-----------------+ # 	0	-			0			step1 - add 0 to queue (0), deque 0, add 0`s adj`s to queue that are not marked (2 1 5)     #         marked[s] = true;                        #
	# | 0| 1| 2| 3| 4| 5| # 	1	0		    1           step1                                                                                       #         while (!q.isEmpty()) {                   #
	# +-----------------+ # 	2	0           1           step1                                                                                       #             int v = q.dequeue();                 #
	#   5  0  0  5  2  3  # 	3	2           2           step2 - deque 2, add 2`s adj`s to queue (1 5 3)                                             #             for (int w : G.adj(v)) {             #
	#   1     3  4  3  0  # 	4	2           2           step1 - add 2`s adj`s to queue (1 5 3 4)                                                    #                 if (!marked[w]) {                #
	#   2     4  2        # 	5	0           1           step1                                                                                       #                     q.enqueue(w);                #
	####################### 	                                                                                                                        #                     marked[w] = true;            #
	                                                                                                                                                    #                     edgeTo[w] = v;               #
	Depth-first search. Put unvisited vertices on a stack.                                                                                              #                 }                                #
	Breadth-first search. Put unvisited vertices on a queue                                                                                             #             }                                    #
	                                                                                                                                                    #         }                                        #
                                                                                                                                                        #     }                                            #
                                                                                                                                                        # }                                                #
                                                                                                                                                        ####################################################

- connected components																							Finding connected components with DFS 			Finding connected components with DFS
																												##############################################	######################################
	Initialize all vertices v as unmarked.                                                                      # public class CC {                          #  # public int count() {               #
	For each unmarked vertex v, run DFS to identify all vertices discovered as part of the same component.      #     private boolean[] marked;              #  #     return count;                  #
                                                                                                                #     private int[] id;                      #  # }                                  #
	##########################		v	marked[]	cc[]											            #     private int count;                     #  # public int id(int v) {             #
	#      +-+               #      0	T			0		1 visit0: check 6 2 1 5 (cc 0)                      #     public CC(Graph G) {                   #  #     return id[v];                  #
	#      |0|--\            #      1	T		    0       7 visit1: check 0 (cc 0)                            #         marked = new boolean[G.V()];       #  # }                                  #
	#      +-+-\ ---\        #      2	T           0       6 visit2: check 0 (cc 0)                            #         id = new int[G.V()];               #  # private void dfs(Graph G, int v) { #
	#     / \   --\  ---\    #      3	T           0       5 visit3: check 5 4 (cc 0)                          #         for (int v = 0; v < G.V(); v ++) { #  #     marked[v] = true;              #
	#    |   +-+   +-+   +-+ #      4	T           0       3 visit4: check 5 6 3  (cc 0)                       #             if (!marked[v]) {              #  #     id[v] = count;                 #
	#    /   |1|   |2|   |6| #      5	T           0       4 visit5: check 3 4 0 (cc 0)                        #                 dfs(G, v);                 #  #     for (int w : G.adj(v))         #
	#   |    +-+   +-+   +-+ #		6   T           0		2 visit6: check 0 4 (cc 0)                          #                 count ++;                  #  #         if (!marked[w])            #
	#   /                /   #                                                                                  #             }                              #  #             dfs(G, w);             #
	#  |      +-+     +-+    #		To visit a vertex v :	                                                    #         }                                  #  #                                    #
	#  /    /-|3|-----|4|    #      ・Mark vertex v as visited.                                                  #     }                                      #  #                                    # 
	# |   /-  +-+ /---+-+    #      ・Recursively visit all unmarked vertices adjacent to v.                     #     public int count()                     #  # }                                  # 
	# +-+-  /-----           #                                                                                  #     public int id(int v)                   #  ######################################
	# |5|---                 #                                                                                  #     private void dfs(Graph G, int v)       #
	# +-+                    #                                                                                  # }                                          #
	##########################                                                                                  ##############################################

		
- graph challenges
	P1 roblem. Is a graph bipartite?
	bipartite - whose vertices can be divided into two disjoint and independent sets U and V such that every edge connects a vertex in U to one in V.
	solution: dfs
	##########################		2 Problem. Find cycle - use dfs (0 5 4 6 0)
	#                        #		3 Problem. Bridges of Konigsberg (cycle use every edge once).Yes if all vertices have even degree
	#      +-+               #		4 Find a (general) cycle that uses every edge exactly once.
	#     u|0|--\            #		5 Find a cycle that visits every vertex exactly once. Hamiltonian cycle. hard one
	#      +-+-\ ---\        #		6 Are two graphs identical except for vertex names? graph isomorphism is longstanding open problem. hard one
	#     / \   --\  ---\    #		7 Lay out a graph in the plane without crossing edges? linear-time DFS-based planarity algorithm discovered by Tarjan in 1970s. hard one
	#    |   +-+   +-+   +-+ #
	#    /  v|1|  v|2|  v|6| #
	#   |    +-+   +-+   +-+ #
	#   /      \   /  \  /   #
	#  |        +-+   +-+    #
	#  /       u|3|  u|4|    #
	# |         +-+   +-+    #
	# +-+           /---     #
	#v|5|     /-----         #
	# +-+ ----               #
	##########################	

- directed graphs
	Digraph. Set of vertices connected pairwise by directed edges.
	
	#############################################	0->5			applications:																				############################################## 
	#      +-+<-------------      ----<----     #	0->1			Road network					Vertex = intersection; 		edge = one-way street.          # public class Diraph {                      #
	#      |0|<----\         \   /         \    #	0->5			Political blogosphere graph		Vertex = political blog; 	edge = link                     #     private final int V;                   #
	#      +-+      +-+       +-+--->+-+    +-+ #	2->0			Overnight interbank loan graph	Vertex = bank; 				edge = overnight loan.          #     private final Bag<Integer> [] adj;     #	<-- adj lists
	#     | | +-+   |2|       |6|    |8|    |7| #	2->3			Implication graph				Vertex = variable; 			edge = logical implication.     #     public Diraph(int V) {                 #
	#     /  >|1|   +-+       +-+<---+-+    +-+ #	3->5			Combinational circuit			Vertex = logical gate; 		edge = wire.                    #         this.V = V;                        #  <-- create empty Diraph with V vertices
	#    |    +-+  /> ^      /   \         /    #	3->2			WordNet graph					Vertex = synset; 			edge = hypernym relationship.   #         adj = (Bag<Integer> [])new Bag[V]; #
	#    /       < /  |     /     \       /     #	4->3			web								web page					hyperlink                       #         for (int v = 0; v < V; v ++)       #
	#   /     +-+ /   |    /       >    <-      #	5->4			scheduling						task						precedence constraint           #             adj[v] = new Bag<Integer>();   #
	#  |    /-|3|/    |   /         +-+    +--+ #	11->4			financial						bank						transaction                     #                                            #
	#  Y  /<  +-+   +-+  /          |9|--->|10| #	11->12			game							board position 				legal move                      #     }                                      #
	# +-+-          |4|<-           +-+<-\ +--+ #	12->9			citation						journal article				citation                        #     public void addEdge(int v, int w) {    #	<-- add edge v-w
	# |5|>--------->+-+              Y    \   ^ #					inheritance hierarchy			class						inherits from                   #         adj[v].add(w);                     #
	# +-+                           +--+   +--| #					control flow					code block					jump                            #                                            #
	#                               |11|---|12| #			                                                                                                    #     }                                      #
	#                               +--+   +--+ #			                                                                                                    #     public Iterable<Integer> adj(int v) {  #	<-- iterator for vertices adj to v
	#                                           #			                                                                                                    #         return adj[v];                     #
	#############################################			                                                                                                    #     }                                      #
                                                                                                                                                                # }                                          #
- Adjacency-lists digraph representation                                                                                                                        ##############################################
	#############################################
	# +--------------------------------------+  #
	# | 0| 1| 2| 3| 4| 5| 6| 7| 8| 9|10|11|12|  #
	# +--------------------------------------+  #
	#   5     0  5  3  4  9  6  6 11 12 12  9   #
	#   1     3  2  2     4  8    10            #
	#                     8                     #
	#                     0                     #
	#############################################
	
- digraph search
	Depth-first search in digraphs																										Depth-first search in digraphs summary
	##############################################	Mark v as visited.																	DFS enables direct solution of simple digraph problems.
    # public class DirectedDFS {                 #	Recursively visit all unmarked vertices w pointing from v.                          ・Reachability.
    #     private boolean[] marked;              #                                                                                      ・Path finding.
    #     public DirectedDFS(Digraph G, int s) { #	Applications:                                                                       ・Topological sort.
    #         marked = new boolean[G.V()];       #	Reachability application: program control-flow analysis:                            ・Directed cycle detection.
    #         dfs(G, s);                         #		Every program is a digraph.                                                     Basis for solving difficult digraph problems.
    #     }                                      #  	・Vertex = basic block of instructions (straight-line program).                   ・2-satisfiability. 
    #     private void dfs(Digraph G, int v) {   #  	・Edge = jump.                                                                    ・Directed Euler path. 
    #         marked[v] = true;                  #                                                                                      ・Strongly-connected components.
    #         for (int w : G.adj(v))             #	Reachability application: mark-sweep garbage collector
    #             if (!marked[w])                #		Every data structure is a digraph.
    #                 dfs(G, w);                 #      ・Vertex = object.
    #     }                                      #      ・Edge = reference.
    #     public boolean visited(int v) {        #		Roots. Objects known to be directly accessible by program (e.g., stack).
    #         return marked[v];                  #		Reachable objects. Objects indirectly accessible by program
    #     }                                      #
	# }                                          #
	##############################################

	Breadth-first search in digraphs								BFS web crawler
	Same method as for undirected graphs.							################################################## 
	Put s onto a FIFO queue, and mark s as visited.                 # Queue<String> queue = new Queue<String>();     #	<-- queue of websites to crawl
		Repeat until the queue is empty:                            # SET<String> marked = new SET<String>();        #  <-- set of marked websites
 		- remove the least recently added vertex v                  # String root = "http://www.princeton.edu";      #
 		- for each unmarked vertex pointing from v:                 # queue.enqueue(root);                           #	<-- start crawling from root website
 		add to queue and mark as visited.                           # marked.add(root);                              #
		                                                            # while (!queue.isEmpty()) {                     #
	Q. How to implement multi-source shortest paths algorithm?      #     String v = queue.dequeue();                #	<-- read in raw html from nextwebsite in queue
	A. Use BFS, but initialize by enqueuing all source vertices.    #     StdOut.println(v);                         #
	                                                                #     In in = new In(v);                         #
	                                                                #     String input = in.readAll();               #
	                                                                #     String regexp = "http://(\\w+\\.)*(\\w+)"; #	<-- use regular expression to find all URLs in website of form http://xxx.yyy.zzz
	                                                                #     Pattern pattern = Pattern.compile(regexp); #
	                                                                #     Matcher matcher = pattern.matcher(input);  #
	                                                                #     while (matcher.find()) {                   #
	                                                                #         String w = matcher.group();            #
	                                                                #         if (!marked.contains(w)) {             #	<-- if unmarked, mark it and put on the queue
	                                                                #             marked.add(w);                     #
	                                                                #             queue.enqueue(w);                  #
	                                                                #         }                                      #
	                                                                #     }                                          #
	                                                                # }                                              #
	                                                                ##################################################
	
	
	
	
	


###############
# week2
###############

###############
# week3
###############

###############
# week4
###############

###############
# week5
###############
###############
# week6
###############