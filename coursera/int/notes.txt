###############
# Algs
###############
    - selection (n^2)                               // or
    +-------------------------------------------+   +------------------------------------------+    +----------------------------------+
    | def maxSort(a:Array[Double]):Unit = {     |   | def selectionSort(arr):                  |    | def findSmallest(arr):           |
    |   for (i <- (0 until a.length).reverse) { |   |     newArr = []                          |    |     smallest = arr[0]            |    // Stores the smallest value
    |     var max = i                           |   |     for i in range(len(arr)):            |    |     smallest_index = 0           |    // Stores the index of the smallest value
    |     for (j <- (0 until i).reverse) {      |   |         smallest = findSmallest(arr)     |    |     for i in range(1, len(arr)): |
    |       if (a(j) > a(max)) max = j          |   |         newArr.append(arr.pop(smallest)) |    |         if arr[i] < smallest:    |
    |     }                                     |   |     return newArr                        |    |             smallest = arr[i]    |
    |     val tmp = a(i)                        |   +------------------------------------------+    |             smallest_index = i   |
    |     a(i) = a(max)                         |                                                   |     return smallest_index        |
    |     a(max) = tmp                          |                                                   +----------------------------------+
    |   }                                       |
    | }                                         |
    +-------------------------------------------+

    - recursion                             // base case
    +------------------------------------+  +------------------------+  +------------------------------+
    | def look_for_key(box):             |  | def countdown(i):      |  | def fact(x):                 |
    |     for item in box:               |  |     print i            |  |     if x == 1:               |
    |         if item.is_a_box():        |  |     if i <= 0:         |  |         return 1             |
    |             look_for_key(item)     |  |         return         |  |     else:                    |
    |         elif item.is_a_key():      |  |     else:              |  |         return x * fact(x-1) |
    |             print "found the key!" |  |         countdown(i-1) |  +------------------------------+
    +------------------------------------+  +------------------------+





    - insertionSort (n^2)
    +---------------------------------------------------------+
    | def insertionSort(input: List[Int]): List[Int] = {      |
    |   input.foldLeft(List[Int]())( (acc, element) => {      |
    |     val (firstHalf, secondHalf) = acc.span(_ < element) |
    |     //inserting the element at the right place          |
    |     firstHalf ::: element :: secondHalf                 |
    |   })                                                    |
    | }                                                       |
    +---------------------------------------------------------+

    - heap sort (n log n)
    // values in parent leaves are greater then in childs   
    +------------------------------------------------------------------------------------+  |   /**Pushes an illegally located element down the heap to restore heap property.*/ |
    | object HeapSort {                                                                  |  |   @annotation.tailrec                                                              |
    |   def main(args: Array[String]): Unit = {                                          |  |   def heapify(a: Array[Int], loc: Int, lastLeaf: Int): Unit = {                    |
    |     var mess = Array(3, 9, 8, 13, 2, 5, 4);                                        |  |     val l = left(loc)                                                              |
    |                                                                                    |  |     val r = right(loc)                                                             |
    |     sort(mess)                                                                     |  |                                                                                    |
    |    // buildHeap(mess, mess.length-1)                                               |  |     var max = loc                                                                  |
    |                                                                                    |  |                                                                                    |
    |     mess.foreach( println )                                                        |  |     if(l <= lastLeaf && a(l) > a(max)) max = l                                     |
    |   }                                                                                |  |     if(r <= lastLeaf && a(r) > a(max)) max = r                                     |
    |                                                                                    |  |                                                                                    |
    |   def sort(a: Array[Int]): Unit = {                                                |  |     if(max != loc) {                                                               |
    |     var m = a.length - 1                                                           |  |       swap(a, max, loc)                                                            |
    |     buildHeap(a, m)                                                                |  |       heapify(a, max, lastLeaf)                                                    |
    |     while (m >= 1) {                                                               |  |     }                                                                              |
    |       swap(a, 0, m)                                                                |  |   }                                                                                |
    |       m-=1                                                                         |  |                                                                                    |
    |       heapify(a, 0, m)                                                             |  |   /**Returns position of left child (possibly empty). */                           |
    |     }                                                                              |  |   def left(loc: Int): Int = {                                                      |
    |   }                                                                                |  |     return 2*loc                                                                   |
    |                                                                                    |  |   }                                                                                |
    |   def buildHeap(a: Array[Int], m: Int): Unit = {                                   |  |                                                                                    |
    |     for (i <- m/2 to 0 by -1) {                                                    |  |   /**Returns position of right child (possibly empty). */                          |
    |       heapify(a, i, m)                                                             |  |   def right(loc: Int): Int = {                                                     |
    |     }                                                                              |  |     return 2*loc+1                                                                 |
    |   }                                                                                |  |   }                                                                                |
    |                                                                                    |  |                                                                                    |
                                                                                            |   def swap(a: Array[Int], i: Int, j:Int): Unit = {                                 |
                                                                                            |     val staging = a(i)                                                             |
                                                                                            |     a(i) = a(j)                                                                    |
                                                                                            |     a(j) = staging                                                                 |
                                                                                            |   }                                                                                |
                                                                                            | }                                                                                  |
                                                                                            +------------------------------------------------------------------------------------+

    - merge sort (n log n)
    +---------------------------------------------------------------------------+
    | def msort[T](less: (T, T) => Boolean)(xs: List[T]): List[T] =             |
    |   def merge(xs: List[T], ys: List[T]): List[T] =                          |
    |    (xs, ys) match                                                         |
    |       case (Nil, _) => ys                                                 |
    |       case (_, Nil) => xs                                                 |
    |       case (x :: xs1, y :: ys1) => if less(x, y) then x :: merge(xs1, ys) |
    |                                    else y :: merge(xs, ys1)               |
    |   val n = xs.length / 2                                                   |
    |   if n == 0 then xs                                                       |
    |   else                                                                    |
    |     val (ys, zs) = xs.splitAt(n)                                          |
    |     merge(msort(less)(ys), msort(less)(zs))                               |
    +---------------------------------------------------------------------------+

    - quicksort (n log n)
    +---------------------------------------------------------------------------------+ +---------------------------------------------------------------+
    | object QuickSortFP extends App {                                                | | def quicksort(array):                                         |
    |     val r = scala.util.Random                                                   | |     if len(array) < 2:                                        |
    |     val randomArray = (for (i <- 1 to 10000000) yield r.nextInt(10000)).toArray | |         return array                                          |
    |     val sortedArray = quickSort(randomArray)                                    | |     else:                                                     |
    |                                                                                 | |         pivot = array[0] Recursive case                       |
    |     def quickSort(xs: Array[Int]): Array[Int] = {                               | |         less = [i for i in array[1:] if i <= pivot]           |
    |         if (xs.length <= 1) xs                                                  | |         greater = [i for i in array[1:] if i > pivot]         |
    |         else {                                                                  | |         return quicksort(less) + [pivot] + quicksort(greater) |
    |             val pivot = xs(xs.length / 2)                                       | +---------------------------------------------------------------+
    |             Array.concat(                                                       |
    |                 quickSort(xs filter (pivot > _),                                |
    |                 xs filter (pivot == _),                                         |
    |                 quickSort(xs filter (pivot < _))                                |
    |         }                                                                       |
    |     }                                                                           |
    | }                                                                               |
    +---------------------------------------------------------------------------------+

    - hash tables
    // collisions
    ┌─┐ ┌──────┬────┐ ┌──────┬────┐
    │ │►│apples│0.67│►│avokad│1.49│
    ├─┤ └──────┴────┘ └──────┴────┘
    │ │
    ├─┤
    │ │
    └─┘    

    - BFS

###############
# DB
###############
    - ACID
        Atomicity
            Transactions are often composed of multiple statements. Atomicity guarantees that each transaction is treated as a single "unit" which either succeeds completely, or fails completely

        Consistency
            Consistency ensures that a transaction can only bring the database from one valid state to another
            data written to the database must be valid according to all defined rules, including constraints, cascades, triggers, and any combination thereof

        Isolation
            multiple transactions reading and writing to a table at the same time
            Isolation ensures that concurrent execution of transactions leaves the database in the same state that would have been obtained if the transactions were executed sequentially

        Durability
            Durability guarantees that once a transaction has been committed, it will remain committed even in the case of a system failure

    - CAP theorem
        Cheap, Fast, and Good: Pick Two
        distributed system can deliver only two of three desired characteristics: consistency, availability, and partition tolerance (the ‘C,’ ‘A’ and ‘P’ in CAP).

        - Consistency
            every node in a distributed cluster returns the same, most recent, successful write
            all clients see the same data at the same time no matter which node they connect to
            For this to happen, whenever data is written to one node, it must be instantly forwarded or replicated to all the other nodes in the system before the write is deemed ‘successful.’

        - Availability
            every non-failing node returns a response for all read and write requests in a reasonable amount of time
            any client making a request for data gets a response even if one or more nodes are down
            all working nodes in the distributed system return a valid response for any request, without exception

        - Partition tolerance
                the system continues to function and upholds its consistency guarantees in spite of network partitions
                partition is a communications break within a distributed system - a lost or temporarily delayed connection between two nodes.
                Partition tolerance means that the cluster must continue to work despite any number of communication breakdowns between nodes in the system            

        cp (consistent and partition tolerant) - availability is sacrificed only in the case of a network partition
        ca (consistent and available) - ca systems are consistent and available systems in the absence of any network partition. often a single node's db servers are categorized as ca systems. single node db
        ap (available and partition tolerant) - these are systems that are available and partition tolerant but cannot guarantee consistency.

    - SQL/ NoSQL
        Unlike vertically scalable SQL (relational) counterparts, NoSQL databases are horizontally scalable and distributed by design—they can rapidly scale across a growing network consisting of multiple interconnected nodes
        NoSQL databases:
            CP database: consistency and partition tolerance at the expense of availability. When a partition occurs between any two nodes, the system has to shut down the non-consistent node (i.e., make it unavailable) until the partition is resolved.
            AP database: delivers availability and partition tolerance at the expense of consistency. When a partition occurs, all nodes remain available but those at the wrong end of a partition might return an older version of data than others
            CA database: CA database delivers consistency and availability across all nodes. It can’t do this if there is a partition between any two nodes in the system, however, and therefore can’t deliver fault tolerance

        MongoDB = CP - stores data as json doc. Resolves network partitions by maintaining consistency, while compromising on availability.
                       MongoDB is a single-master system. Each replica set can have only one primary node that receives all the write operations. other nodes in the same replica set are secondary nodes that replicate the primary node's operation log and apply it to their own data set
                       When the primary node becomes unavailable, the secondary node with the most recent operation log will be elected as the new primary node
        Cassandra - AP - has a masterless architecture, and as a result, it has multiple points of failure, rather than a single one
                         delivers availability and partition tolerance but can't deliver consistency all the time
                         no master node, all the nodes must be available continuously
                         provides eventual consistency by allowing clients to write to any nodes at any time and reconciling inconsistencies as quickly as possible                       
        Ignite = CP or AP - In TRANSACTIONAL atomicity mode, you get an CP system with the option of fully ACID compliant transactions
                            In ATOMIC atomicity mode, you gain the speed and uptime guarantees of AP system

###############
# Java basics
###############
    - Primitive types:
        Integers:
         byte    (8 bits)  127
         char    (16 bits) char c = 'A'; char c = 65;
         short   (16 bits) 32,767
         int     (32 bits) 2,147,483,647
         long    (64 bits) long l = 65L
        Floating 
         float   (32 bits) float f = 65f
         double  (64 bits) double d = 65.55;
        Other
         boolean (1 bits)
    - static block
        executed once class is loaded into memory
    - base class, its methods
        Object methods: equals, hashCode, getClass, clone, toString, notify, wait, finalize
    - contract between equals, hashcode
        if object are equal - hashcodes are equal; if hashes are equal - objects are not 100% equal
    - access modifies
        protected vs default: protected is visible from other packages classes if derived from it
    - volatile
        threads gang bang - can modify var in memory directly and its visible to other threads
        transient - not put into serialized
    - StringBuilder vs StringBuffer
        StringBuffer is syncronized; StringBuilder is not
    - mutable/immutable
        immutable - cannot be changed after construction (String), are thread safe, good map keys
        how to make class immutable: class final, no setters, all fields are private and final, collections unmodifiable, return new Date(mutableField.getTime())
    - overload/override
        overload - same methods in class with diff params
        overriding - methods with same signature in parent/ child
    = how to replace multi inheritance
        extend multiple times, implement one time
    - can interface inherit from another interface
        yes
    -what is marker interface
        without methods or fields
    -regular vs static initialization block
        static - when class is loaded 

###############
# Memory and GC
###############
    -how is virtual heap space divided
        Young generation:
        Eden space: pool from which memory is allocated for objects
        Survivour space: contains objects which survived gc collection of eden
        Tenured space(old generation): pool containing objects that have existed for some time in survivour space
        Permanent: classes, methods
    -how to force gc
        System.gc()

###############
# Exceptions
###############
                +-----------+
                | Throwable |
                +-----------+
                      |
                +---------------+
                |               |
            +-------+   +-----------+
        VM->| Error |   | Exception |
            +-------+   +-----------+
                            |
            +---------------+---------------+
            |               |               |
    +-------------++---------------++------------------+
    | IOException || ClassNotFound || RuntimeException |
    +-------------++---------------++------------------+
    - Exceptions - checked except for Runtime,Error
    - diff between Error and UncheckedExceptions
        Unchecked - error should not be cought; Error - fatal and out of control of program
    - could we have try, and finally without catch
        yes
    - when finally is not executed
        System.exit(), JVM crashes, endless loop in try
    - NoClassDefFoundError vs ClassNotFoundException
        - NoClassDefFoundError: class is present at compile time, but was missing at runtime
        - ClassNotFoundException - class not found in classpath

###############
# Exceptions
###############
                    +----------+                        +-----+
                    | Iterable |                        | Map |
                    +----------+                        +-----+
                        |                               -HashMap
        +---------------+---------------+               -LinkedHashMap
        |               |               |               -TreeMap
    +------+        +-------+       +-----+             
    | List |        | Queue |       | Set |
    +------+        +-------+       +-----+
    -ArrayList      -PriorityQueue  -HashSet
    -LinkedList     -Dequeu         -LinkedHashSet
    -Vector                         -TreeSet

    - java 8 hashmap implementation - '>8 nodes' -> red-black tree; '<8 nodes' -> linkedList
    - diff between ArrayList and LinkedList
        - delete: A-shift all; L-change links of neighbors;
        - L uses more memory cause of links
        - L is better when lots of inserts, deletes
        - A - search is better
    - Stack bs Queue
        stack - LIFO
        queue - fifo
    - TreeMap
        uses red-black tree, softs by key; logn access


###############
# Multithreading
###############
    - run vs start
        Thread implements Runnable, run does nothing
        +------------------------------+
        | HelloThread extends Thread() |
        | new HelloThread().start()    |
        +------------------------------+
    -threadlocal
        allows to store data that will be accessed only by specific thread
    - thread lifecycle

    +-----+                                 +------------+
    | New |                                 | Terminated |
    +-----+                                 +------------+
           \ admitted     interrupted     / exit
            +----------+ <------------- +---------+
            | Runnable | schedule       | Running |
            +----------+ -------------->+---------+
                notify()\  dispatcher  / wait()
                        +--------------+
                        | Non-Runnable |
                        +--------------+
    - CAS
        you can think of i++ as a single operation but its a read nad write
        basically CAS says - maybe value in address V is A - if true - set it to B
        +--------------------------------------------------------------------------+
        | public final int incrementAndGet() {                                     |
        |     for (;;) {                                                           |
        |         int current = get();                                             |    // read value from memory
        |         int next = current + 1;                                          |    
        |         if (compareAndSet(current, next)) return next;                   |    // compare expected with fact if true - update
        |         }                                                                |
        | }                                                                        |
        | public final boolean compareAndSet(int expect, int update) {             |
        |     return unsafe.compareAndSwapInt(this, valueOffset, expect, update);  |
        | }                                                                        |
        +--------------------------------------------------------------------------+


###############
# CS basics
###############
    - complexity algs
        1<logn<n<nlogn<n^2<n^3<2^n
    - merge sort is stable, quick sort is not stable
    -ways to traverse graph
        - BFS
        - DFS

###############
# swap example
###############
    +--------------------------------+                  - variable in lambda should be final
    | Dog aDog = new Dog("Max")      |                  +----------------------------------------+
    | foo(aDog)                      |                  | int a = 0                              |
    | aDog.getName().equals("Max")   |  // false        | IntStream.range(0,10).forEach(x->a+x;) |
    | public static void foo(Dog d){ |                  +----------------------------------------+
    |     d = new Dog("Bob")         |              
    | }                              |              
    +--------------------------------+              

###############
# design patterns
###############
    -Structual
        Facade: hides complexity, provides interface to client
        Proxy: class represents functionality of other class. Proxy used to get real class when needed
        Decorator: adds functionality to existing object without changing it. Wraps original class, providing additional functionality
        Strategy: class behaviour can be changed at runtime
        +---------------------------------+ +----------------------------------+    +-----------------------------+ +--------------------------------------+
        | interface Strategy{             | | class Add implements Strategy{   |    | class Context{              | | new Context(new Add()).executeS(1,2) |
        |     int operation(int a, int b) | |     int operation(int a, int b){ |    |     Strategy s              | +--------------------------------------+
        | }                               | |         a+b                      |    |     executeS(int a, int b){ |
        +---------------------------------+ |     }                            |    |         s.operation(a,b)    |
                                            | }                                |    |     }                       |
                                            +----------------------------------+    | }                           |
                                                                                    +-----------------------------+
    -Behaviour
        Observer: if one obj.notified -> all related should be notified
        +--------------------------+    +---------------------+
        | Subject                  |    | Observer            |
        | -has list of subscribers |    | - implements update |
        | -calls observers update  |    +---------------------+
        +--------------------------+
        
    -Factory: such object creates instances of classes based on some conditions
    -Singleton: makes sure only one instance of class will be created
        +-----------------------+
        | private static fields |
        | private constructor   |
        | factory method        |
        | or                    |
        | Enum                  |
        +-----------------------+
  
        


###############
# OOP
###############
    - inheritance vs composition
        inheritance: class Apple extends Fruit
        composition: class Apple{ Fruit f = new Fruit();}
    - coupling & cohesion
        low cohesion: class does a lot of diff work; high cohesion: class does one thing
        losely coupling: changing something in one class should not affect the other





###############
# CS basics
###############


###########
#
###########

###########
#Bit operations:
###########
 A   B   A|B A&B A^B ~A
 0   0   0   0   0   1
 1   0   1   0   1   0
 0   1   1   0   1   1
 1   1   1   1   0   0
 64<<1=128
 32>>1=16

###########
#Passing arguments:
###########
 pass by value - value is copied to formal parameter not affecting argument
 pass by refference - parameter gets a ref to argument, changes to the ref object will affect argument

 java uses pass by value (result depends if we pass primitive or ref)
 void modify(int i){i++}
 a=10; modify(a);        // initial a will not be affected, cause argument was copied by value
 void modify(Test o){o.i++}
 modify(test);           // ref to test is copied and passeed as perameter

###########
#Exceptions
###########
 Throwable:
  Error(stackOverfllow)(unchecked)
  Exception
   RuntimeExceptiom(unchecked)
    NullPointerException
    ArrayIndexOutofBound
    IllegalArgumentException
    ArithmeticException(/0)
   Other exceptions
    IOException
    ClassNotFound
 
 Checked exception - compile-time (SQLException, IOException, ClassNotFoundException)
 Unchecked exception - occur during the execution (RuntimeExceptiom)

###########
#Functions
###########
 public interface MyIF {
     int getNumЬer();
     default String getString () {
         return "bla";
     }
 }

###########
#Multithreading
###########
#states
 blocked         not running waits to get the lock (runnable<->blocked)
 new             not picked up by cpu yet (new->runnable)
 runnable        running by cpu
 terminated      ended (runnable->terminated)
 timed_waiting   sleep, wait, join (runnable<->timed_waiting)
 waiting         wait, join without time specified (runnable<->waiting)
#create
 class NewThread extends Thread {
     NewThread() {
         suреr("Демонстрационный поток");
         start(); 11 запустить поток на исполнение
     }
     public void run() {
         try {
             for(int i = 5; i > О; i--) {
             Thread.sleep(500);
         catch (InterruptedException е) {...}
             }
         }
     }
 }
#join()
 NewThread оbj1 = new NewThread ( "One" );
#wait till thread is over
 obj1.join();

#consumer producer
 public class Q {
     int n;
     boolean valueSet = false;
     synchronized int get(){
         while (!valueSet){                     // wait if value is not set
             try {wait();}
             catch(InterruptedException е) {System.out.println("interrupted");}
         }
         System.out.println("Received: " + n); //get message if value is set
         valueSet = false;
         notify ();
         return n;
     }
     synchronized void put(int n){
         while(valueSet){                    // if value is set - wait
             try {wait();}
             catch(InterruptedException е){ System.out.println("interrupted");}
             this.n = n;
         }
         valueSet = true;
         System.out.println("Sent: " + n);   // set value and send a message
         notify ();
     }
     static class Producer implements Runnable {
         Q q;
         Producer(Q q){
             this.q = q;
             new Thread(this, "Поставщик").start();
         }
         public void run(){
             int i = 0;
             while(true){
                 q.put (i++); }}}
     static class Consumer implements Runnable {
         Q q;
         Consumer (Q q) {
             this.q = q;
             new Thread(this, "Потребитель").start(); }
         public void run(){
             while(true)
                 q.get (); }}
     static class QTester {
         public static void main(String[] args) {
             Q q = new Q();
             new Producer(q);
             new Consumer(q); }}}

#Blocking vs Non-Blocking
- Blocking
  one thread at given time holds monitor, others wait for lock to free;
  Synchronized ArrayList or HashMap, ArrayBlockingQueue or 
  LinkedBlockingQueue
- Non-Blocking
  Compare-And-Swap - read-modify-write kind of instruction:
  1. A memory location M on which to operate
  2. Expected old value OV
  3. New value NV
  CAS match expected OV to the value stored in memory location M, if both 
  match then only CAS will update the memory location M to the new value NV, 
  otherwise nothing;
  Thread that looses can: try again, do nothing, or something else;
  Example: M=5, 1 thread expects OV as 5 and NV as 6. At same time 2 thread
  tries to change value M passing 6 as OV and 7 as NV.
  1 thread will succeed M = 6, 2 thread will report failure
  AtomicInteger, AtomicLong, ConcurrentLinkedQueue
  
#Context Switch:
  When CPU switches from one thread to another = CPU needs to save local  
  data, program pointer etc. of the current thread, and load the local data,
  program pointer etc. of another thread 
  
#Concurrency Models:
Parallel Workers
  If your jobs are naturally parallel, independent and with no shared state
  necessary
Assembly Line (Aktors, channels)
  jobs are not naturally parallel and independent though
Functional Parallelism

#Creating and Starting Threads
  public class T extends Thread {public void run(){...}}
  public class T implements Runnable {public void run(){...}}
  Runnable t =new Runnable(){public void run(){...}}
  Runnable t =() -> { ...; };
  
#Race Conditions
 occurs if code executed by multiple threads and result is different depending  
 on sequence
  public class Counter {
    protected long count = 0;
    public void add(long value){
        this.count = this.count + value;} }
  add code is not atomic - will be executed like this:
 -read this.count
 -add value to register
 -write register to memory
 if A wants to add 2 and B 3:
 1.A reads 0 and B reads 0
 2.A adds 2 and writes 2 to memory (res:2)
 3.B adds 3 and writes 3 to memory (res:3)
 To prevent - one can synchronize code
 public void add(int val1, int val2){
     synchronized(this){
         this.sum1 += val1;   
         this.sum2 += val2;} }
 or
 private Integer sum1Lock = new Integer(1);
 private Integer sum2Lock = new Integer(2); 
 public void add(int val1, int val2){
     synchronized(this.sum1Lock){
         this.sum1 += val1;   }
     synchronized(this.sum2Lock){
         this.sum2 += val2;} }
         
#Thread safety
 Local Variables are stored in each thread stack (never shared)
 Local Object Refs: if obj created locally, not leaked - its safe
 public void someMethod(){
  LocalObject localObject = new LocalObject();
  localObject.callMethod();
  method2(localObject); }
 public void method2(LocalObject localObject){
   localObject.setValue("value"); }
 Object Member Variables not safe
 public class NotThreadSafe{
    StringBuilder builder = new StringBuilder();
    public add(String text){
        this.builder.append(text);} }
 The Thread Control Escape Rule:
 If a resource is created, used and disposed within
 the control of the same thread,
 and never escapes the control of this thread,
 the use of that resource is thread safe.
 
#Thread Safety and Immutability
 if objects are not updated - they are safe
 
#Java Memory Model
 Is how threads can see values written to shared variables by other threads
 -memory divided between thread stacks and heap
 Thread stack contains methods(with local vars) that were called
 primitive local vars fully stored in thread stack
 one thread can send a copy of promitive var to another thread, but not var itself
 Heap contains all objs created, includes Byte, Integer,etc
 obj`s memeber vars stored on heap even if var is primitive
 Static class vars stored on heap
 If 2 threads call method on same obj - they will have access to its vars, but 
 each will have own copy of local vars
 Hardware architecture: CPU & CPU registers, CPU mem cache, RAM
 Access speed: CPU registers > CPU mem cache > RAM
 To read - cpu copies from RAM to cache or registers
 To write - flush registers -> cache -> RAM
 cache -> RAM happens when cpu needs to reuse cache for smth else
 Java Memory Model and Hardware architecture:
 On hardware both: thread stack, heap located in RAM
 Visibility of Shared Objects
 if threads share obj(not volatile or synchronized) - updates by 1 not seen by 
 2 thread 1 reads obj value to cpu cache, updates it, before flush it is not visible to thread 2
 with volatile - changes applied to RAM directly
 Race Conditions
 if both threads read obj value to diff cpu caches and increment it - value will 
 be 1 instead of 2 if threads were run in sequence
 to fix this use synchronized block 
 Out of order execution
 a=3;
 b=2;
 a=a+1;
 these operations can be reordered to:
 load a -> set to 3, set to 4 -> store a
 load b -> set to 2 -> store b
 Field visibility
 Run below two threads
 public class FiedVisibility{
    int x = 0;  // if int x is volatile - below will be fixed
    public void writerThread(){ x=1; }          //runs on core1, cpu cache will have x=1, possible that will never be flushed to RAM
    public void readerThread(){ int r2 = x; }   //runs on core2, cpu cache will have x=0
 }
 Happens before relationship
 public class VolatileFieldVisibility{
    // Lock lock = new ReentrantLock();
    int a=0, b=0, c=0;
    volatile x = 0;
    public void writerThread(){
        a=1;
        b=1;
        c=1;
        x=1;    //flush of x, all fields written before x are flushed as well
        // also works with synchrinized,locks,join,start
        // synchronized (this){ x=1; }
        // lock.lock();
        // a=1;
        // b=1;
        // c=1;
        // x=1;
        // lock.unlock();
    }
    public void readerThread(){
        int r2=x;   //read of x, all other fields are visible as well
        // synchronized (this){ int r2 = x; }
        int d1=a;
        int d2=b;
        int d3=c;
    }
 }
 
#The Java synchronized Keyword
 Synchronized Instance Methods
 public synchronized void add(int value){
    this.count += value;}
 is synched on object owning method
 each instance has diff synched obj - one thread per instance
 Synchronized Blocks in Instance Methods
 public void add(int value){
   synchronized(this){
     this.count += value;}}
 this - is called monitor obj
 Java Synchronized Example
 public class Counter{
    long count = 0;
    public synchronized void add(long value){
      this.count += value;}} 
 public class CounterThread extends Thread{
    protected Counter counter = null;
    public CounterThread(Counter counter){
       this.counter = counter;}
    public void run() {
       for(int i=0; i<10; i++){
          counter.add(i);}}}
 Thread  threadA = new CounterThread(counter);
 Thread  threadB = new CounterThread(counter);
 threadA.start();
 threadB.start();
 
#Java Volatile Keyword
 volatile var is stored in RAM
 Variable Visibility Problems:
 guarantees visibility of changes across threads
 Problem whrn var is not volatile:
 Thread A runs on CPU1 (reads and updates counter)
 Thread B runs on CPU2 (reads counter)
 Thread A may copy counter to CPU1 cache and update
 Thread B wont see these changes from CPU2
 When is volatile Enough?
 if two threads read/write = volatile is not enough
 in those cases use synchronized or Atomic
 volatile is enough if 1 thread reads/writes and others read
 reading/writing directly to RAm is expensive
 
#Java ThreadLocal
 each thread see only its threadLocal
 ThreadLocal tl = new ThreadLocal();
 tl.set("A thread local value");
 String v = (String) tl.get();
 or generic
 ThreadLocal<String> tl = new ThreadLocal();
 
#Thread Signaling
 thread B may wait for signal from thread A saying data ready
 A and B may use shared obj for signals
 public class MySignal{
  protected boolean hasData = false;
  public synchronized boolean get(){
    return this.hasData;}
  public synchronized void set(boolean b){
    this.hasData = b;  }
 }
 Busy Wait(ineffective)
 B is waiting for signal from A
 MySignal sharedSignal = ...
 while(!sharedSignal.get()){
  //do nothing... busy waiting
 }
 wait(), notify() and notifyAll()
 waiting thread sleeps until receives a signal
 thread that calls wait() on any obj becomes inactive
 until another thread calls notify() on that obj
 in order to call wait/notify - thread should have a lock on that obj
 once a thread calls wait() it releases the lock
 public class MonitorObject{}
 public class MyWaitNotify{
  MonitorObject m = new MonitorObject();
  public void doWait(){
   synchronized(m){
    try{m.wait();
    } catch(InterruptedException e){...}}
  }
  public void doNotify(){
   synchronized(m){m.notify();}}
 }
 wakened thread must reobtain lock on monitor obj before it can exit the 
 wait() call
 If multiple threads awakened by notifyAll() - one awakened thread at a time 
 can exit the wait() method
 Missed Signals
 if a thread calls notify() before the thread to signal has called wait(), the 
 signal will be missed
 to fix - check before wait if(!wasSignalled){...wait...}
 MonitorObject myMonitorObject = new MonitorObject();
 boolean wasSignalled = false;
 Spurious Wakeups
 threads can wake up without notify()
 to fix - while(!wasSignalled){...wait...}
 Don't call wait() on constant String's or global objects
 because string refs point to same obj
 
#Deadlock
 thread 1 locks A, and tries to lock B, and thread 2 has already locked B, and 
 tries to lock A
Deadlock Prevention
 Lock Ordering
 Deadlock occurs when multiple threads need the same locks but obtain 
 them in different order.
 if locks always taken in same order by any thread, deadlocks cannot occur.
 Lock Timeout
 thread trying to obtain a lock will only try for so long before giving up
 Deadlock Detection
 when thread takes a lock it is noted in map
 when thread requests a lock it is noted in map
 When thread requests a lock but is denied it traverse the lock graph to check 
 for deadlocks
 
 
 
 

###########
#Enum
###########
enum Apple {
    Jonathan(10), GoldenDel(9), RedDel, Winesap(15), Cortland(8);
    private int price;
    Apple ( int р) { price = р; }
    Apple() { price = -1;}
    int getPrice () { return price;}
}
Apple ар = Apple.GoldenDel;
Arrays.stream(Apple.values()).forEach(x-> System.out.println(x + ":" + x.getPrice()));
System.out.println(Apple.valueOf("Winesap"));


###########
#Generics
###########
class Gen<T> {
    Т оЬ;
    Gen (Т о) {оЬ = о;}
    Т getob() {return оЬ;}
    void showТype (){System.out.println(ob.getClass().getName());}}
class GenDemo {
    puЬlic static void main(String args[])
    Gen<Integer> iOb = new Gen<Integer>(88);
    iOb.showТype();
    int v = iOb.getob();}
class NonGen {
    NonGen(Object о) {оЬ = о;}
    Obj ect getob () {return оЬ;}}
class NonGenDemo {
    puЬlic static void main(String args[])
    NonGen iOb = new NonGen(88);
    int v =(Integer) iOb.getob(); // can be issues
}
#unknown type
class Stats<T extends NumЬer> {
    Т[] nums; // array of Number subclasses
    Stats(T[] о){nums = о;}
    double average() {
        double sum = 0.0;
        for(int i=0; i < nums.length; i++){sum += nums[i].douЬleValue();}
        return sum / nums.length;}
    boolean sameAvg(Stats<?> оb){   // ?(unknown type) can accept Stats<Integer>, Stats<Double>
        if(average() == ob.average()) return true;
        return false;}}
#bounded unknown type        
class TwoD {
    int х, у;
    TwoD(int а, int b) {х = а;у = b;}}
class ThreeD extends TwoD {
    int z;
    ThreeD(int а, int b, int c) {super(a,b);z = c;}}
class Coords<T extends TwoD> {  //array of coordinates
    Т[] coords;
    Coords (Т[] o) {coords = о;}}
class BoundedWildcard {
    static void showXY(Coords<?> с) {   //TwoD and ThreeD have x and y
        for(int i=0; i < c.coords.length; i++){
            System.out.println(c.coords[i].х + " " + c.coords[i].у);
        }}
    static void showXYZ(Coords<? extends ThreeD> с) { //only ThreeD has z
        for(int i=O; i < c.coords.length; i++){
            Systern.out.println(c.coords[i].х + c.coords[i].у + с.coords[i].z) ;
        }}}
#generic method
class GenMethDemo {
    static <Т extends ComparaЬle<T>, V extends Т> boolean isIn(T х, V[] у) {
        for(int i=O; i < y.length; i++){
            if(x.equals(y[i] )) return true;}
        return false;}}
usage:
    isIn(2,nums)
   
#type erasure
type constraints enforced during compile time
this one is replace after compilation
public class Stack<E> {         --> Stack
    private E[] stackContent;   --> Object[] stackContent;
    public void push(E data){}  --> push(Object data)
    public E pop(){}            --> Object pop()
}
#cannot create instance from generic type
T ob = new T(); // not working

###########
#Lambda
###########
() -> 123.45
(n) -> (n % 2)==0
interface MyNumЬer {double getValue();}
MyNumЬer myNum = () -> 123.45; // class instance created myNum.getValue()
#with param
interface NumericTest {boolean test(int n);}
NumericTest isEven = (n) -> (n % 2)==0; // sEven.test(9);
#generic functional interface
interf ace SomeFunc<T> {т f(T t);}
SomeFunc<String> foo = (str) -> {return "1:"+ str;};    // foo.f("one")
#lambda as argument
interface StringFunc {String func(String n);}
static String stringOp(StringFunc sf, String s){return sf.func(s);} // stringOp((str) -> str.toUpperCase(), "test");
#method reference
class MyStringOps {
static String strUp(String str){return str.toUpperCase();} // stringOp(MyStringOps::strUp, "test");