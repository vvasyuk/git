###############
# Classes and Objects
###############
                                                     -A Scala application                                    -The App trait
    +---------------------------------------------+ +--------------------------------------------------+    +----------------------------------------------------+
    | class ChecksumAccumulator {                 | | import ChecksumAccumulator.calculate             |    | import ChecksumAccumulator.calculate               |
    |     private var sum = 0                     | | object Summer {                                  |    | object FallWinterSpringSummer extends App {        |
    |     def add(b: Byte): Unit = { sum += b }   | |     def main(args: Array[String]) = {            |    |     for (season <List("fall", "winter", "spring")) |
    |     def checksum(): Int = ~(sum & 0xFF) + 1 | |         for (arg <args)                          |    |         println(season + ": " + calculate(season)) |
    | }                                           | |             println(arg + ": " + calculate(arg)) |    | }                                                  |
    +---------------------------------------------+ |     }                                            |    +----------------------------------------------------+
                                                    | }                                                |
    -Singleton objects                              +--------------------------------------------------+
    +--------------------------------------------------------+
    | import scala.collection.mutable                        |
    | object ChecksumAccumulator {                           |
    |     private val cache = mutable.Map.empty[String, Int] |
    |     def calculate(s: String): Int =                    |
    |         if (cache.contains(s))                         |
    |             cache(s)                                   |
    |         else {                                         |
    |             val acc = new ChecksumAccumulator          |
    |             for (c <s)                                 |
    |             acc.add(c.toByte)                          |
    |             val cs = acc.checksum()                    |
    |             cache += (s >                              |
    |             cs)                                        |
    |             cs                                         |
    |         }                                              |
    | }                                                      |
    +--------------------------------------------------------+


###############
# Basic Types and Operations
###############
    -Basic types                                        -Character literals
    +------------------------------------------------+  +---------------------------------------+
    | Byte    8-bit (-2^7 to 2^7)                    |  |val hex = 0x5       // hex: Int = 5    |
    | Short   16-bit (-2^15 to 2^15)                 |  |val hex2 = 0x00FF   // hex: Int = 255  |
    | Int     32-bit (-2^31 to 2^31)                 |  |val a = 'A'         // a: Char = A     |
    | Long    64-bit (-2^63 to 2^63)                 |  |val d = '\u0041'    // d: Char = A     |
    | Char    16-bit (-2^15 to 2^15)                 |  |val f = '\u0044'    // f: Char = D     |
    | String  seq of chars                           |  |val B\u0041\u0044 = 1   //BAD: Int = 1 |
    | Float   32-bit IEEE 754 single-precision float |  +---------------------------------------+
    | Double  63-bit IEEE 754 single-precision float |
    | Boolean true or false                          |
    +------------------------------------------------+

    -String interpolation
    +-----------------------------------------------------------------+
    | val name = "reader"         // println(s"Hello, $name!")        |
    | s"The answer is ${6 * 7}."  // res0: String = The answer is 42. |
    +-----------------------------------------------------------------+

    infix operator                  // method between the object and the parameter ("7 + 2")
    prefix operator (only +,-,!,~)  // method before the object on which you are invoking the method (-7, !found). "-2.0" transformed into (2.0).unary_-
    postfix operator                // method after the object ("7 toLong")

    -Bitwise operations
    +--------------------------------------------------------------------------------------------------------------------+
    | 1 & 2   // 1 (0001) and 2 (0010) = 0 (0000)                                                                        |
    | 1 | 2   // 1 (0001) and 2 (0010) = 3 (0011)                                                                        |
    | 1 ˆ 3   // 1 (0001) and 3 (0011) = 2 (0010)                                                                        |
    | ~1      // inverts each bit in 1 (0001), yielding -2, which in binary looks like 11111111111111111111111111111110. |
    | 1 << 2  // 4                                                                                                       |
    +--------------------------------------------------------------------------------------------------------------------+


    -Operator precedence and associativity  - any method that ends in a ‘:’ character is invoked on its right operand, passing in the left operand
    +----------------------------+          +--------------------+
    | * / %                      |          | a * b   //a.*(b)   |
    | + :                        |          | a:::b   //b.:::(a) |
    | = !                        |          +--------------------+
    | < >                        |
    | &                          |
    | ˆ                          |
    | |                          |
    | (all letters)              |
    | (all assignment operators) |
    +----------------------------+

    -Equality
    in Java == compares: Primitives->value, ReferenceTypes->reference equality
    in Java == compares check the left side for null. If it is not null, call the equals method. Since equals is a method, the precise comparison you get depends on the type of the left-hand argument


###############
# Functional Objects
###############
    +------------------------------------------------------+
    | class Rational(n: Int, d: Int, val visible = 0) {    |    // class body code will be added to primary constructor (precondition of the primary constructor that d must be non-zero)
    |     require(d != 0)                                  |    // n, d not visible, cause they are constructor params
    |     private val g = gcd(n.abs, d.abs)                |    // need to prefix them with val or add fields as here
    |     val numer = n / g                                |    
    |     val denom = d / g                                |    // simply that.d will not work because d is not accessible outside object where they invoked, so we added numer, denum fields
    |     def this(n: Int) = this(n, 1)                    |    // auxiliary constructors invokes the primary constructor
    |     def + (that: Rational): Rational =               |    
    |         new Rational(numer * that.denom +            |
    |         that.numer * denom,denom * that.denom)       |
    |     def + (i: Int): Rational =                       |
    |         new Rational(numer + i * denom, denom)       |
    |     def - (that: Rational): Rational =               |
    |       new Rational(                                  |
    |         numer * that.denom - that.numer * denom,     |
    |         denom * that.denom                           |
    |       )                                              |
    |     def - (i: Int): Rational =                       |
    |       new Rational(numer - i * denom, denom)         |
    |     def * (that: Rational): Rational =               |
    |         new Rational(numer * that.numer, denom *     |
    |         that.denom)                                  |
    |     def * (i: Int): Rational =                       |
    |         new Rational(numer * i, denom)               |
    |     def / (that: Rational): Rational =               |
    |         new Rational(numer * that.denom, denom *     |
    |         that.numer)                                  |
    |     def / (i: Int): Rational =                       |
    |         new Rational(numer, denom * i)               |
    |     override def toString = numer + "/" + denom      |    // override default override
    |     private def gcd(a: Int, b: Int): Int =           |
    |         if (b == 0) a else gcd(b, a % b)             |
    | }                                                    |
    +------------------------------------------------------+

    -Implicit conversions
    r * 2   // works
    2 * r   // does not work, 2 is Int - not method that takes Rational argument
    implicit def intToRational(x: Int) = new Rational(x)


###############
# Built-in Control Structures
###############
    -If expressions
    +--------------------------------------------------------------+
    | val filename = if (!args.isEmpty) args(0) else "default.txt" |
    +--------------------------------------------------------------+

    -While loops                                - this doesn't work! (line = readLine()) retunrs Unit
    +-----------------------------------------+ +--------------------------------------+
    | def gcdLoop(x: Long, y: Long): Long = { | | while ((line = readLine()) != "")    |
    |     var a = x                           | |     println("Read: " + line)         |
    |     var b = y                           | +--------------------------------------+
    |     while (a != 0) {                    |
    |         val temp = a                    |
    |         a = b % a                       |
    |         b = temp                        |
    |     }                                   |
    |     b                                   |
    | }                                       |
    +-----------------------------------------+

    -For expressions
    // for file in filesHere                                                        -Filtering
    +--------------------------------------+    +-------------------------------+   +----------------------------------------+
    | for (file <- filesHere)              |    | for (i <- 1 to 4)             |   | for (                                  |
    |     println(file)                    |    |     println("Iteration " + i) |   |     file <- filesHere                  |
    +--------------------------------------+    +-------------------------------+   |     if file.isFile                     |
                                                                                    |     if file.getName.endsWith(".scala") |
                                                                                    | ) println(file)                        |
                                                                                    +----------------------------------------+

    -Nested iteration                                           -Producing a new collection
    +------------------------------------------------------+    // type of the resulting collection is based on the kind of collections processed in the iteration clauses
    | def fileLines(file: java.io.File) =                  |    // In this case the result is an Array[File], because filesHere is an array and the type of the yielded expression is File
    |     scala.io.Source.fromFile(file).getLines().toList |    +--------------------------------------------+
    | def grep(pattern: String) =                          |    | def scalaFiles =                           |
    |     for (                                            |    |     for {                                  |
    |         file <- filesHere                            |    |         file <- filesHere                  |
    |         if file.getName.endsWith(".scala");          |    |         if file.getName.endsWith(".scala") |
    |         line <- fileLines(file)                      |    |     } yield file                           |
    |         if line.trim.matches(pattern)                |    +--------------------------------------------+
    |     ) println(file + ": " + line.trim)               |
    | grep(".*gcd.*")                                      |
    +------------------------------------------------------+
    -Exception handling with try expressions                    -Catching exception                                                 -The finally clause
    // One branch of an if computes a value, while the other    +--------------------------------------------------------------+    +-----------------------------------------------+
    throws an exception and computes Nothing                    | try {                                                        |    | val file = new FileReader("input.txt")        |
    // If n is not even, an exception will be thrown before     |     val f = new FileReader("input.txt")                      |    | try {                                         |
    half can be initialized to anything at all                  |     // Use and close file                                    |    |     // Use the file                           |
    +-------------------------------------------------------+   | } catch {                                                    |    | } finally {                                   |
    | val half =                                            |   |     case ex: FileNotFoundException => // Handle missing file |    |     file.close() // Be sure to close the file |
    |     if (n % 2 == 0)                                   |   |     case ex: IOException => // Handle other I/O error        |    | }                                             |
    |         n / 2                                         |   | }                                                            |    +-----------------------------------------------+
    |     else                                              |   +--------------------------------------------------------------+
    |         throw new RuntimeException("n must be even")  |
    +-------------------------------------------------------+

    -Yielding a value
    +--------------------------------------------------------------------------------------------------------+
    | def urlFor(path: String) =                                                                             |
    |     try {                                                                                              |
    |         new URL(path)                                                                                  |
    |     } catch {                                                                                          |
    |         case e: MalformedURLException =>                                                               |
    |         new URL("http://www.scalalang.org") // this one is returned if eexception is thrown and cought |
    |     }                                                                                                  |
    +--------------------------------------------------------------------------------------------------------+

    -Match expressions                                      -Living without break and continue          -get ird of vars
    +---------------------------------------------------+   +-----------------------------------------+ +--------------------------------------------------------+
    | val firstArg = if (!args.isEmpty) args(0) else "" |   | var i = 0                               | | def searchFrom(i: Int): Int =                          |
    | val friend = firstArg match {                     |   | var foundIt = false                     | |     if (i >= args.length) 1                            |
    |     case "salt" => "pepper"                       |   | while (i < args.length && !foundIt) {   | |     else if (args(i).startsWith("")) searchFrom(i + 1) |
    |     case "chips" => "salsa"                       |   |     if (!args(i).startsWith("")){       | |     else if (args(i).endsWith(".scala")) i             |
    |     case "eggs" => "bacon"                        |   |         if (args(i).endsWith(".scala")) | |     else searchFrom(i + 1)                             |
    |     case _ => "huh?"                              |   |             foundIt = true              | | val i = searchFrom(0)                                  |
    | }                                                 |   |         }                               | +--------------------------------------------------------+
    | println(friend)                                   |   |     i = i + 1                           |
    +---------------------------------------------------+   | }                                       |
                                                            +-----------------------------------------+


###############
# Functions and Closures
###############
    -Methods
    +----------------------------------------------------------------------------+  +-----------------------------------------------+
    | object LongLines {                                                         |  | object FindLongLines {                        |
    |     def processFile(filename: String, width: Int) = {                      |  |     def main(args: Array[String]) = {         |
    |         val source = Source.fromFile(filename)                             |  |         val width = args(0).toInt             |
    |         for (line <- source.getLines())                                    |  |         for (arg <args.drop(1))               |
    |             processLine(filename, width, line)                             |  |             LongLines.processFile(arg, width) |
    |     }                                                                      |  |     }                                         |
    |     private def processLine(filename: String,width: Int, line: String) = { |  | }                                             |
    |         if (line.length > width)                                           |  +-----------------------------------------------+
    |             println(filename + ": " + line.trim)                           |
    |     }                                                                      |
    | }                                                                          |
    +----------------------------------------------------------------------------+

    -Local functions
    +-------------------------------------------------------+
    | object LongLines {                                    |
    |     def processFile(filename: String, width: Int) = { |
    |         def processLine(line: String) = {             |
    |             if (line.length > width)                  |   // local functions can access the parameters of their enclosing function
    |                 println(filename + ": " + line.trim)  |
    |         }                                             |
    |         val source = Source.fromFile(filename)        |
    |         for (line <-source.getLines())                |
    |             processLine(line)                         |
    |     }                                                 |
    | }                                                     |
    +-------------------------------------------------------+

    -First-class functions
    // A function literal is compiled into a class that when instantiated at runtime is a function value
    // function literals exist in the source code
    // function values exist as objects at runtime
    // Every function value is an instance of some class that extends one of several FunctionN traits in package scala

    +--------------------------------------+
    | (x: Int) => x + 1                    |    // function literal
    | var increase = (x: Int) => x + 1     |    // Function values are objects, so you can store them in variables
    | increase(10)                         |    // you can call them
    +--------------------------------------+

    -Short forms of function literals   -Placeholder syntax
    +--------------------------------+  +-----------------------------------------------------------------------+
    | someNumbers.filter(x => x > 0) |  | someNumbers.filter(_ > 0)                                             |
    +--------------------------------+  | val f = (_: Int) + (_: Int)     // f: (Int, Int) => Int = <function2> |
                                        | f(5, 10)                                                              |
                                        +-----------------------------------------------------------------------+

    -Partially applied functions
    // Although the previous examples substitute underscores in place of individual parameters, you can also replace an entire parameter list with an underscore
    // when you invoke a function, passing in any needed arguments, you apply that function to the arguments
    // given, you could apply the function sum to the arguments 1, 2, and 3 like this
    +---------------------------------------------+
    | def sum(a: Int, b: Int, c: Int) = a + b + c |
    | sum(1, 2, 3)                                |
    +---------------------------------------------+
    // partially applied function is an expression in which you don’t supply all of the arguments needed by the function. Instead, you supply some, or none
    +---------------+
    | val a = sum _ |   // partially applied function expression involving sum, in which you supply none of the three required args
    | a(1, 2, 3)    |   // Scala compiler translates the expression a(1, 2, 3) into an invocation of the function value’s apply method, passing in the three arguments 1, 2, and 3.
    +---------------+

    +---------------------------+
    | val b = sum(1, _: Int, 3) |   // you can also express a partially applied function by supplying only some of the required arguments
    | b(2)                      |   // res13: Int = 6
    +---------------------------+
    -Closures
    +------------------------------------+
    | (x: Int) => x + more               |  // A function object that captures free variables, and is said to be "closed" over the variables visible at the time it is created.
    | var more = 1                       |
    | val addMore = (x: Int) => x + more |  // addMore: Int => Int = <function1>
    | addMore(10)                        |  // res16: Int = 11
    | more = 9999                        |  // What happens if more changes after the closure is created? In Scala, the answer is that the closure sees the change
    | addMore(10)                        |  // res17: Int = 10009
    +------------------------------------+

    +------------------------------------------+
    | val someNumbers = List(11,10,5,0, 5, 10) |
    | var sum = 0                              |
    | someNumbers.foreach(sum += _)            |    // sum = 11
    +------------------------------------------+

    -Special function call forms
    -Repeated parameters
    +----------------------------------------------------------+
    | def echo(args: String*) = for (arg <args) println(arg)   |    // echo("hello", "world!")
    | echo(Array("What's", "up", "doc?"))                      |    // error: type mismatch found : Array[String] required: String. fix: echo(arr: _*)
    +----------------------------------------------------------+
    // This notation tells the compiler to pass each element of arr as its own argument to echo, rather than all of it as a single argument.

    -Named arguments
    +------------------------------------------------------------------+
    | def speed(distance: Float, time: Float): Float = distance / time |    // speed(distance = 100, time = 10)
    +------------------------------------------------------------------+
    
    -Default parameter values
    +----------------------------------------------------------------------------+
    | def printTime2(out: java.io.PrintStream = Console.out, divisor: Int = 1) = |
    |     out.println("time = " + System.currentTimeMillis()/divisor)            |
    +----------------------------------------------------------------------------+

    -Tail recursion
    // Functions like approximate, which call themselves as their last action, are called tail recursive. The Scala compiler detects tail recursion and replaces it with a jump back to the beginning of the function, after updating the function parameters with the new values.
    +------------------------------------------+
    | def approximate(guess: Double): Double = |
    |     if (isGoodEnough(guess)) guess       |
    |     else approximate(improve(guess))     |
    +------------------------------------------+


###############
# Control Abstraction
###############
    -Reducing code duplication
    // function works just like filesEnding only difference is that this        // While you cannot pass around a method name as a value, you can get the same 
    function uses contains instead of endsWith                                  effect by passing around a function value
    +----------------------------------------------------------------------+    +----------------------------------------------------------------------------------+
    | object FileMatcher {                                                 |    | def filesMatching(query: String, matcher: (String, String) => Boolean) = {       |    // uses matcher to check the file name against the query
    |     private def filesHere = (new java.io.File(".")).listFiles        |    |     for (file <-filesHere; if matcher(file.getName, query))                      |
    |                                                                      |    |         yield file                                                               |
    |     def filesEnding(query: String) =                                 |    | }                                                                                |
    |         for (file <-filesHere; if file.getName.endsWith(query))      |    | def filesEnding(query: String) = filesMatching(query, _.endsWith(_))             |
    |             yield file                                               |    +----------------------------------------------------------------------------------+
    |                                                                      |
    |     def filesContaining(query: String) =                             |
    |         for (file <-filesHere; if file.getName.contains(query))      |
    |         yield file                                                   |
    |     }                                                                |
    +----------------------------------------------------------------------+

    // full simplified version                                                      -Simplifying client code
    +---------------------------------------------------------------------------+   +------------------------------------------------------------+
    | object FileMatcher {                                                      |   | def containsNeg(nums: List[Int]) = nums.exists(_ < 0)      |
    |     private def filesHere = (new java.io.File(".")).listFiles             |   | def containsOdd(nums: List[Int]) = nums.exists(_ % 2 == 1) |
    |     private def filesMatching(matcher: String => Boolean) =               |   +------------------------------------------------------------+
    |         for (file <-filesHere; if matcher(file.getName))                  |
    |             yield file                                                    |
    |     def filesEnding(query: String) = filesMatching(_.endsWith(query))     |
    |     def filesContaining(query: String) = filesMatching(_.contains(query)) |
    |     def filesRegex(query: String) = filesMatching(_.matches(query))       |
    | }                                                                         |
    +---------------------------------------------------------------------------+

    -Currying
    +----------------------------------------+
    | def curriedSum(x: Int)(y: Int) = x + y |  // curriedSum: (x: Int)(y: Int)Int
    | curriedSum(1)(2)                       |  // res5: Int = 3; two traditional function invocations back to back; The first function invocation takes a single Int parameter named x, and returns a function value for the second function
    | val onePlus = curriedSum(1)_           |  // placeholder for the second parameter list
    | onePlus(2)                             |  // res7: Int = 3
    +----------------------------------------+                             

    -Writing new control structures
    +--------------------------------------------------------+
    | def twice(op: Double => Double, x: Double) = op(op(x)) |
    | twice(_ + 1, 5)                                        |  // res9: Double = 7.0
    +--------------------------------------------------------+
                            
    // Any time you find a control pattern repeated in multiple parts of your code, you should think about implementing it as a new control structure
    // Consider now a more widely used coding pattern: open a resource, operate on it, and then close the resource
    // loan pattern: (because a control-abstraction function, such as withPrintWriter, opens a resource and “loans” it to a function)
    +-------------------------------------------------------------------------------------+
    | def withPrintWriter(file: File, op: PrintWriter => Unit) = {                        |
    |     val writer = new PrintWriter(file)                                              |
    |     try {                                                                           |
    |         op(writer)                                                                  |
    |     } finally {                                                                     |
    |         writer.close()                                                              | // impossible to forget to close the file
    |     }                                                                               |
    | }                                                                                   |
    | withPrintWriter(new File("date.txt"), writer => writer.println(new java.util.Date)) |
    +-------------------------------------------------------------------------------------+

    -By-name parameters
    // you want to implement an assertion construct     // By-name parameters exist precisely so you can remove () => part
    called myAssert                                     // function value will be created whose apply method will evaluate 5 > 3, and this function value will be passed to byNameAssert
    +--------------------------------------------+      +-------------------------------------------+      
    | var assertionsEnabled = true               |      | def byNameAssert(predicate: => Boolean) = |
    | def myAssert(predicate: () => Boolean) =   |      |     if (assertionsEnabled && !predicate)  |
    |     if (assertionsEnabled && !predicate()) |      |         throw new AssertionError          |
    |         throw new AssertionError           |      | byNameAssert(5 > 3)                       |
    | myAssert(() => 5 > 3)                      |      +-------------------------------------------+
    +--------------------------------------------+


###############
# Composition and Inheritance
###############
    -A two-dimensional layout library
    // library for building and rendering two-dimensional layout elements
    +-----------------------------------------------+   +-----------+
    | val column1 = elem("hello") above elem("***") |   | result:   |
    | val column2 = elem("***") above elem("world") |   | hello *** |
    | column1 beside column2                        |   | *** world |
    +-----------------------------------------------+   +-----------+

    -Abstract classes
    // no abstract modifier, method abstract 
    if no implementation
    +---------------------------------+
    | abstract class Element {        |
    |     def contents: Array[String] |
    | }                               |
    +---------------------------------+

    -Defining parameterless methods
    // if function has no params - use no braces (if only this function does no side-effect)
    // notice no braces
    +----------------------------------------------------------------------+
    | abstract class Element {                                             |
    |     def contents: Array[String]                                      |
    |     def height: Int = contents.length                                |
    |     def width: Int = if (height == 0) 0 else contents(0).length      |
    | }                                                                    |
    +----------------------------------------------------------------------+

    -Extending classes
    // inherit all non-private members from class Element
    // private members of the superclass are not inherited in a subclass
    +----------------------------------------------------------------------+    +----------------------------------------------------------------------+
    | class ArrayElement(conts: Array[String]) extends Element {           |    | val ae = new ArrayElement(Array("hello", "world"))                   |
    |     def contents: Array[String] = conts                              |    | ae.width                                            // res0: Int = 5 |
    | }                                                                    |    | val e: Element = new ArrayElement(Array("hello"))                    |
    +----------------------------------------------------------------------+    +----------------------------------------------------------------------+
    // hieararchy is next ArrayElement<-Element<-AnyRef

    -Overriding methods and fields                                      -Defining parametric fields
    // fields and methods belong to the same namespace -                // can remove const param by combining the parameter and the field
     possible for a field to override a parameterless method            in a single parametric field definition
    // val here overrides def in abstract                               // val defines at the same time a parameter and field with the same name (with var it can be reassignable)
    +--------------------------------------------------------------+    +-----------------------------------------------------------------+    
    | class ArrayElement(conts: Array[String]) extends Element {   |    | class ArrayElement(val contents: Array[String]) extends Element |
    |     val contents: Array[String] = conts                      |    +-----------------------------------------------------------------+
    | }                                                            |    
    +--------------------------------------------------------------+

    -Invoking superclass constructors                                               -Using composition and inheritance
    // element consisting of a single line given by a string                        // previous version, LineElement had an inheritance relationship with ArrayElement, from which it inherited contents
    // Array(s) passed to primary constructor of a parent class (like in java)      // It now has a composition relationship with Array: it holds a reference to an array
    +--------------------------------------------------------------------------+    +------------------------------------------------+
    | class LineElement(s: String) extends ArrayElement(Array(s)) {            |    | class LineElement(s: String) extends Element { |
    |     override def width = s.length                                        |    |     val contents = Array(s)                    |
    |     override def height = 1                                              |    |     override def width = s.length              |
    | }                                                                        |    |     override def height = 1                    |
    +--------------------------------------------------------------------------+    | }                                              |
                                                                                    +------------------------------------------------+

    -Using override modifiers
    // Scala requires override modifier for all members that override a concrete member in a parent class
    // if client created a hidden method (no override) and later you added hidden in superclass - code wont copile saying override keyword is needed

    -Polymorphism and dynamic binding
    // method invocations on variables and expressions are dynamically bound (determined at run time based on the class of the object)
    +---------------------------------------------------------------------------------------------------+
    | class UniformElement(ch: Char,override val width: Int,override val height: Int) extends Element { |
    |     private val line = ch.toString * width                                                        |
    |     def contents = Array.fill(height)(line)                                                       |
    | }                                                                                                 |
    | val e1: Element = new ArrayElement(Array("hello", "world"))                                       |
    | val ae: ArrayElement = new LineElement("hello")                                                   |
    | val e2: Element = ae                                                                              |
    | val e3: Element = new UniformElement('x', 2, 3)                                                   |
    +---------------------------------------------------------------------------------------------------+

    -Declaring final members
    // final on method - method cannot be overriden
    // fnal on class - entire class not be subclassed

    // beside                                                               -Implementing above, beside, and toString
    // this.contents and that.contents, are transformed into an array of    // above first version
    pairs (as Tuple2s are called) using the zip operator                    +------------------------------------------------------+
    +------------------------------------------------------------------+    | def above(that: Element): Element =                  |
    | def beside(that: Element): Element = new ArrayElement(           |    |     new ArrayElement(this.contents ++ that.contents) |
    |     for (                                                        |    +------------------------------------------------------+
    |         (line1, line2) <- this.contents zip that.contents        |    // toString
    |     ) yield line1 + line2                                        |    +------------------------------------------------+
    | )                                                                |    | override def toString = contents mkString "\n" |
    +------------------------------------------------------------------+    +------------------------------------------------+

    -Defining a factory object
    // A straightforward solution is to create a companion object of class Element and make this the factory object for layout elements
    +----------------------------------------------------------------------------------------------------+
    | object Element {                                                                                   |
    |     def elem(contents: Array[String]): Element = new ArrayElement(contents)                        |
    |     def elem(chr: Char, width: Int, height: Int): Element = new UniformElement(chr, width, height) |
    |     def elem(line: String): Element = new LineElement(line)                                        |
    | }                                                                                                  |
    +----------------------------------------------------------------------------------------------------+

    -Heighten and widen                                                          -Putting it all together
    +-----------------------------------------------------------------------+    +------------------------------------------------------------------------------------------+
    | import Element.elem                                                   |    | import Element.elem                                                                      |
    | abstract class Element {                                              |    | object Spiral {                                                                          |
    |     def contents: Array[String]                                       |    |     val space = elem(" ")                                                                |
    |     def width: Int = contents(0).length                               |    |     val corner = elem("+")                                                               |
    |     def height: Int = contents.length                                 |    |     def spiral(nEdges: Int, direction: Int): Element = {                                 |
    |     def above(that: Element): Element = {                             |    |         if (nEdges == 1)                                                                 |
    |         val this1 = this widen that.width                             |    |             elem("+")                                                                    |
    |         val that1 = that widen this.width                             |    |         else {                                                                           |
    |         elem(this1.contents ++ that1.contents)                        |    |             val sp = spiral(nEdges - 1, (direction + 3) % 4)                             |
    |     }                                                                 |    |             def verticalBar = elem('|', 1, sp.height)                                    |
    |     def beside(that: Element): Element = {                            |    |             def horizontalBar = elem('-', sp.width, 1)                                   |
    |         val this1 = this heighten that.height                         |    |             if (direction == 0)                                         // bottom to up  |
    |         val that1 = that heighten this.height                         |    |                 (corner beside horizontalBar) above (sp beside space)                    |
    |         elem(                                                         |    |             else if (direction == 1)                                    // right to left |
    |             for ((line1, line2) <- this1.contents zip that1.contents) |    |                 (sp above space) beside (corner above verticalBar)                       |
    |                 yield line1 + line2)                                  |    |             else if (direction == 2)                                    // top to bottom |
    |     }                                                                 |    |                 (space beside sp) above (horizontalBar beside corner)                    |
    |     def widen(w: Int): Element =                                      |    |             else                                                        // right to left |
    |         if (w <= width) this                                          |    |                 (verticalBar above corner) beside (space above sp)                       |
    |         else {                                                        |    |         }                                                                                |
    |         val left = elem(' ', (w - width) / 2, height)                 |    |     }                                                                                    |
    |         val right = elem(' ', w - width - left.width, height)         |    |     def main(args: Array[String]) = {                                                    |
    |         left beside this beside right                                 |    |         val nSides = args(0).toInt                                                       |
    |         }                                                             |    |         println(spiral(nSides, 0))                                                       |
    |     def heighten(h: Int): Element =                                   |    |     }                                                                                    |
    |     if (h <= height) this                                             |    | }                                                                                        |
    |     else {                                                            |    +------------------------------------------------------------------------------------------+
    |         val top = elem(' ', width, (h - height) / 2)                  |
    |         val bot = elem(' ', width, h - height - top.height)           |
    |         top above this above bot                                      |
    |     }                                                                 |
    |     override def toString = contents mkString "\n"                    |
    | }                                                                     |
    +-----------------------------------------------------------------------+


###############
# Traits
###############
    // traits encapsulate field and method definition which can be reused by mixin them into classes
    // when you write super.tostring in class you know exactly what method will be called
    // when you write super.tostring in trait - method implementation to invoke is defined by mixed in (stackable modification)
    -How traits work
    // default superclass of AnyRef
    +------------------------------------------------------------+  +-------------------------------------+
    | trait Philosophical:                                       |  | class Frog extends Philosophical:   |
    |     def philosophize = "I consume memory, therefore I am!" |  |     override def toString = "green" |
    +------------------------------------------------------------+  +-------------------------------------+

    +--------------------------------------------------------+  +--------------------------------------------------------+
    | val frog = new Frog                                    |  | val phil: Philosophical = frog                         |
    | frog.philosophize // I consume memory, therefore I am! |  | phil.philosophize // I consume memory, therefore I am! |
    +--------------------------------------------------------+  +--------------------------------------------------------+

    +---------------------------------------------------------------+
    | class Animal                                                  |
    | class Frog extends Animal with Philosophical:                 |
    |     override def toString = "green"                           |
    |     override def philosophize = s"It ain't easy being $this!" |
    | val phrog: Philosophical = new Frog                           |
    | phrog.philosophize // It ain't easy being green!              |
    +---------------------------------------------------------------+
                                       
    -Thin versus rich interfaces
    // One major use of traits is to automatically add methods to a class
    // rich interface has many metods, adding concrete method to trait makes it rich interface

    // rich interface example (note 3 methods defined in terms of <)    -fix
    +---------------------------------------------------------------+   +---------------------------------------------------------------+
    | class Rational(n: Int, d: Int):                               |   | class Rational(n: Int, d: Int) extends Ordered[Rational]:     |
    | // ...                                                        |   | // ...                                                        |
    |     def < (that: Rational) =                                  |   |     def compare(that: Rational) =                             |   +--------------------------------+
    |         this.numer * that.denom < that.numer * this.denom     |   |         (this.numer * that.denom) - (that.numer * this.denom) |   | val half = new Rational(1, 2)  |
    |     def > (that: Rational) = that < this                      |   +---------------------------------------------------------------+   | val third = new Rational(1, 3) |
    |     def <= (that: Rational) = (this < that) || (this == that) |   0           - same                                                  | half < third // false          |
    |     def >= (that: Rational) = (this > that) || (this == that) |   negative    - receiver less than argument                           | half > third // true           |
    +---------------------------------------------------------------+   positive    - receiver is greater than argument                     +--------------------------------+

    - Traits as stackable modifications
    // traits allow you to stack modifications with each other

    // basic queue
    +-------------------------------+   +----------------------------------------------+    +---------------------------+
    | val queue = new BasicIntQueue |   | import scala.collection.mutable.ArrayBuffer  |    | abstract class IntQueue:  |
    | queue.put(10)                 |   | class BasicIntQueue extends IntQueue:        |    |     def get(): Int        |
    | queue.put(20)                 |   |     private val buf = ArrayBuffer.empty[Int] |    |     def put(x: Int): Unit |
    | queue.get() // 10             |   |     def get() = buf.remove(0)                |    +---------------------------+
    | queue.get() // 20             |   |     def put(x: Int) = buf += x               |    
    +-------------------------------+   +----------------------------------------------+    
    // stacking
    // when you extend IntQueue - you can only be mixed in a class that also extends IntQueues
    // trait Doubling makes a super call for method in abstract class (classes cannot do that)
    // super call in trait are dynamically bound
    // super call in trait will work because trait will be mixed in after another trait or concrete class method implementation
    +-----------------------------------------------------------------------+   +---------------------------------------------------+   +---------------------------------------------+
    | trait Doubling extends IntQueue:                                      |   | class MyQueue extends BasicIntQueue with Doubling |   | val queue = new BasicIntQueue with Doubling |
    |     abstract override def put(x: Int) = super.put(2 * x)              |   | val queue = new MyQueue                           |   | queue.put(10)                               |
    | trait Incrementing extends IntQueue:                                  |   | queue.put(10)                                     |   | queue.get() // 20                           |
    |     abstract override def put(x: Int) = super.put(x + 1)              |   | queue.get() // 20                                 |   +---------------------------------------------+
    | trait Filtering extends IntQueue:                                     |   +---------------------------------------------------+
    |     abstract override def put(x: Int) = if x >= 0 then super.put(x)   |
    +-----------------------------------------------------------------------+
    // order of mixins is important - traits further to the right take effect first
    +------------------------------------+  +------------------------------------+
    | val queue = new BasicIntQueue with |  | val queue = new BasicIntQueue with |
    |   Incrementing with Filtering      |  |     Filtering with Incrementing    |
    | queue.put(-1)                      |  | queue.put(-1)                      |
    | queue.put(0)                       |  | queue.put(0)                       |
    | queue.put(1)                       |  | queue.put(1)                       |
    | queue.get() // 1                   |  | queue.get() // 0                   |
    | queue.get() // 2                   |  | queue.get() // 1                   |
    +------------------------------------+  | queue.get() // 2                   |
                                            +------------------------------------+

    - why not multiple inheritence
    // if you define put method in two traits which version will be called? but in scala - they are stacked
    // When you instantiate a class with new, Scala takes the class, and all of its inherited classes and traits, and puts them in a single, linear order.
    // Then, whenever you call super inside one of those classes, the invoked method is the next one up the chain. If all of the methods but the last call super, the net result is stackable behavior.

    - Trait parameters
    +---------------------------------------+   +-----------------------------------------------+
    | trait Philosophical(message: String): |   | class Frog extends Animal with                |
    |     def philosophize = message        |   |     Philosophical("I croak, therefore I am!") |
    +---------------------------------------+   | class Duck extends Animal with                |
                                                |     Philosophical("I quack, therefore I am!") |
                                                |                                               |
                                                | val frog = new Frog                           |
                                                | frog.philosophize // I croak, therefore I am! |
                                                | val duck = new Duck                           |
                                                | duck.philosophize // I quack, therefore I am! |
                                                +-----------------------------------------------+

    -To trait or not to trait?
    // If the behavior will not be reused, then make it a concrete class.
    // If it might be reused in multiple, unrelated classes, make it a trait
    // If you want to inherit from it in Java code, use an abstract class
    // If you plan to distribute it in compiled form, and you expect outside groups to write classes inheriting from it, you might lean towards using an abstract class
    // If you still do not know, after considering the above, then start by making it as a trait


###############
# Packages and Imports
###############
    -Putting code in packages
    +----------------------------------+
    | package bobsrockets.navigation   |
    | class Navigator                  |
    | // C# style                      |
    | package bobsrockets.navigation { |
    |     class Navigator              |
    | }                                |
    +----------------------------------+

    -Concise access to related code
    // Multiple packages in the same file                   // Concise access to classes and packages.                      // Accessing hidden package names
    +-----------------------------------------------------+ +------------------------------------------------------------+  +------------------------------------------------------------+
    | package bobsrockets:                                | | package bobsrockets:                                       |  | // In file launch.scala                                    |
    |     package navigation:                             | |     package navigation:                                    |  | package launch:                                            |
    |         // In package bobsrockets.navigation        | |         class Navigator:                                   |  |     class Booster3                                         |
    |         class Navigator                             | |         // No need to say bobsrockets.navigation.StarMap   |  | // In file bobsrockets.scala                               |
    |     package launch:                                 | |         val map = new StarMap                              |  | package bobsrockets:                                       |
    |         // In package bobsrockets.navigation.launch | |         class StarMap                                      |  |     package launch:                                        |
    |         class Booster                               | |     class Ship:                                            |  |         class Booster2                                     |
    +-----------------------------------------------------+ |         // No need to say bobsrockets.navigation.Navigator |  |     package navigation:                                    |
    //Symbols in enclosing packages not automatically       |         val nav = new navigation.Navigator                 |  |         package launch:                                    |
      available                                             |     package fleets:                                        |  |             class Booster1                                 |
    +-----------------------------------------------+       |         class Fleet:                                       |  |         class MissionControl:                              |
    | package bobsrockets:                          |       |             // No need to say bobsrockets.Ship             |  |             val booster1 = new launch.Booster1             |
    |     class Ship                                |       |             def addShip = new Ship                         |  |             val booster2 = new bobsrockets.launch.Booster2 |
    | package bobsrockets.fleets:                   |       +------------------------------------------------------------+  |             val booster3 = new _root_.launch.Booster3      |
    |     class Fleet:                              |                                                                       +------------------------------------------------------------+
    |     // Doesn't compile! Ship is not in scope. |
    |     def addShip = new Ship                    |                                                       
    +-----------------------------------------------+

    -Imports
    +-----------------------------------------------------+ +-----------------------------------------------------------------------------------------------+
    | package bobsdelights                                | | import bobsdelights.Fruit                       // easy access to Fruit                       |
    | abstract class Fruit(                               | | import bobsdelights._                           // easy access to all members of bobsdelights |
    |     val name: String,                               | | import bobsdelights.Fruits._                    // easy access to all members of Fruits       |
    |     val color: String                               | | import Fruits.{Apple, Orange}                   // selective                                  |
    | )                                                   | | import Fruits.{Apple => McIntosh, Orange}       // Apple object is renamed to McIntosh        |
    | object Fruits {                                     | | import Fruits.{Pear => _, _}                    // except pear                                |
    |     object Apple extends Fruit("apple", "red")      | +-----------------------------------------------------------------------------------------------+
    |     object Orange extends Fruit("orange", "orange") |
    |     object Pear extends Fruit("pear", "yellowish")  |
    |     val menu = List(Apple, Orange, Pear)            |
    | }                                                   |
    +-----------------------------------------------------+

    -Implicit imports
    //  added to the top of every source file with extension ".scala"
    import java.lang._      // everything in the java.lang package
    import scala._          // everything in the scala package
    import Predef._         // everything in the Predef object

    -Access modifiers
    // Private members - visible only inside the class  // Protected members - accessible from subclasses of the 
     or object that contains the member definition       class in which the member is defined (not packge as in java)
    (Outter class sees no private memeber of inner)     +-----------------------------------------------------+
    +---------------------------------------------+     | package p:                                          |
    | class Outer:                                |     |     class Super:                                    |
    |     class Inner:                            |     |         protected def f = "f"                       |
    |     private def f = "f"                     |     |     class Sub extends Super:                        |
    |     class InnerMost:                        |     |         f                                           |
    |         f // OK                             |     |     class Other:                                    |
    | (new Inner).f // error: f is not accessible |     |         (new Super).f // error: f is not accessible |
    +---------------------------------------------+     +-----------------------------------------------------+
    // Public members - default - accessed from anywhere

    - Scope of protection
    +-------------------------------------------------------+
    | package bobsrockets                                   |
    | package navigation:                                   |
    |     private[bobsrockets] class Navigator:             |   no access               modifier public access
    |         protected[navigation] def useStarChart() = {} |   private[bobsrockets]    access within outer package
    |         class LegOfJourney:                           |   private[navigation]     same as package visibility in Java
    |             private[Navigator] val distance = 100     |   private[Navigator]      same as private in Java
    | package launch:                                       |   private[LegOfJourney]   same as private in Scala
    |     import navigation.*                               |
    |     object Vehicle:                                   |
    |         private[launch] val guide = new Navigator     |
    +-------------------------------------------------------+

    - Visibility and companion objects
    // Accessing private members of companion classes and objects
    +--------------------------------------------+
    | class Rocket:                              |
    |     import Rocket.fuel                     |
    |     private def canGoHomeAgain = fuel > 20 |
    | object Rocket:                             |
    |     private def fuel = 10                  |
    |     def chooseStrategy(rocket: Rocket) =   |
    |         if rocket.canGoHomeAgain then      |
    |             goHome()                       |
    |         else                               |
    |             pickAStar()                    |
    |         def goHome() = {}                  |
    |         def pickAStar() = {}               |
    +--------------------------------------------+

    -Package objects
    // Any kind of definition that you can put inside a class can also be at the top level of a package (method you’d like to be in scope for an entire package)
    // Each package is allowed to have one package object. Any definitions placed in a package object are considered members of the package itself.
    // In file bobsdelights/package.scala           // In file PrintMenu.scala
    +------------------------------------------+    +---------------------------------------+
    | package object bobsdelights {            |    | package printmenu                     |
    |     def showFruit(fruit: Fruit) = {      |    | import bobsdelights.Fruits            |
    |         import fruit._                   |    | import bobsdelights.showFruit         |
    |         println(name + "s are " + color) |    | object PrintMenu {                    |
    |     }                                    |    |     def main(args: Array[String]) = { |
    | }                                        |    |         for (fruit <- Fruits.menu) {  |
    +------------------------------------------+    |             showFruit(fruit)          |
                                                    |         }                             |
                                                    |     }                                 |
                                                    | }                                     |
                                                    +---------------------------------------+


###############
# Case Classes and Pattern Matching
###############
    -need to write a library that manipulates arithmetic expressions
    //Defining case classes
    +--------------------------------------------------------------------------+
    | trait Expr                                                               |
    | case class Var(name: String) extends Expr                                |    // case modifier makes the Scala compiler add some syntactic conveniences to your class
    | case class Num(number: Double) extends Expr                              |    // 1. adds a factory method with the name of the class (new not needed)
    | case class UnOp(operator: String, arg: Expr) extends Expr                |    // 2. arguments in the parameter list of a case class implicitly get a val prefix, so they are maintained as fields
    | case class BinOp(operator: String, left: Expr, right: Expr) extends Expr |    // 3. you get methods toString, hashCode,  equals, copy to your class
    +--------------------------------------------------------------------------+

    -Pattern matching
    // The simplifyTop function, which does a pattern match.
    +-----------------------------------------------------------+
    | def simplifyTop(expr: Expr): Expr =                       |   // A match expression is evaluated by trying each of the patterns in the order they 
    |   expr match                                              |   // constructor pattern looks like UnOp("-", e). This pattern matches all values of type UnOp whose first argument matches "-" and whose second argument matches e
    |     case UnOp("-", UnOp("-", e)) => e // Double negation  |
    |     case BinOp("+", e, Num(0)) => e // Adding zero        |   // e - a variable that is bound within the associated pattern
    |     case BinOp("*", e, Num(1)) => e // Multiplying by one |   // wildcard pattern (_) also matches every value
    |     case _ => expr                                        |
    +-----------------------------------------------------------+
    
    -match compared to switch
    // match is an expression in Scala (i.e., it always results in a value)
    // Scala’s alternative expressions never “fall through” into the next case
    // Third, if none of the patterns match, an exception named MatchError is thrown

    -Kinds of patterns
    -Constant patterns                          -Wildcard patterns                                              -Variable patterns
    +--------------------------------------+    // dont care about elements of binary operation                 // somethingElse - default case for all other values
    | def describe(x: Any) =               |    // handle the default case                                      +------------------------------------------------------+
    |     x match                          |    +-----------------------------------------------------------+   | expr match                                           |
    |         case 5 => "five"             |    | expr match                                                |   |     case 0 => "zero"                                 |
    |         case true => "truth"         |    |     case BinOp(_, _, _) => s" is a binary operation"      |   |     case somethingElse => s"not zero "               |
    |         case "hello" => "hi!"        |    |     case _ => "It's something else"                       |   +------------------------------------------------------+
    |         case Nil => "the empty list" |    +-----------------------------------------------------------+
    |         case _ => "something else"   |
    +--------------------------------------+

    -Variable patterns                                          // E does not match Pi                                                                                  
    // somethingElse - default case for all other values        // how does scala know that Pi is constant imported and not
    +------------------------------------------------------+    // variable that stands for selector value itself?
    | expr match                                           |    // if name starts with lower case - its pattern var, others are constants                                                   // `pi` interpreted as a constant, not as a variable
    |     case 0 => "zero"                                 |    +-------------------------------------------------------+   +---------------------------------------------------------+     +--------------------------------------------+
    |     case somethingElse => s"not zero $somethingElse" |    | import math.{E, Pi} // E (2.71828. . . ),Pi (3.14159) |   | val pi = math.Pi                                        |     | E match                                    |
    +------------------------------------------------------+    | E match                                               |   | E match                                                 |     |     case `pi` => s"strange math? Pi = " |
                                                                |     case Pi => s"strange math? Pi = "                 |   |     case pi => s"strange math? Pi = "                   |     |     case _ => "OK"                         |
                                                                |     case _ => "OK"                                    |   | val res1: String = strange math? Pi = 2.718281828459045 |     | res4: String = OK                          |
                                                                | val res0: String = OK                                 |   +---------------------------------------------------------+     +--------------------------------------------+
                                                                +-------------------------------------------------------+

    -Constructor patterns                                   -Sequence patterns                                              -Tuple patterns                                 -Typed patterns
    // if BinOp is case class - first check if object is    // three-element list starting with zero                        // matches an arbitrary 3-tuple                 +-------------------------------------+
     of case class, then check constructor params match     // matches 1 and any number of elements within a sequence       +-----------------------------------------+     | def generalSize(x: Any) =           |
    +--------------------------------------------------+    // _* matches 1 and any number of elements within a sequence    | def tupleDemo(obj: Any) = obj match     |     |     x match                         |
    | expr match                                       |    +---------------------------------------------+                 |     case (a, b, c) => s"matched "       |     |         case s: String => s.length  |
    |     case BinOp("+", e, Num(0)) => "a deep match" |    | xs match                                    |                 |     case _ => ""                        |     |         case m: Map[_, _] => m.size |
    |     case _ => ""                                 |    |     case List(0, _, _) => "found it"        |                 +-----------------------------------------+     |         case _ => -1                |
    +--------------------------------------------------+    |     case List(1, _*) => println("found it") |                                                                 +-------------------------------------+
                                                            |     case _ => ""                            |
                                                            +---------------------------------------------+

    -Type erasure
    // wont work                                // will owrk with Arrays
    // no information about type arguments is   // element type of an array is stored with the array value, so you can pattern match on it
    maintained at runtime                       +-------------------------------------+ +--------------------------------------------------------+
    // no way to determine at runtime whether   | def isStringArray(x: Any) = x match | | isStringArray(Array("abc"))     // res21: String = yes |
    given Map has  two Int arguments            |     case a: Array[String] => "yes"  | | isStringArray(Array(1, 2, 3))   // res22: String = no  |
    +-----------------------------------+       |     case _ => "no"                  | +--------------------------------------------------------+
    | def isIntIntMap(x: Any) = x match |       +-------------------------------------+
    |     case m: Map[Int, Int] => true |       
    |     case _ => false               |       
    +-----------------------------------+       

    -Variable binding
    // variable-binding pattern with e as the variable and UnOp("abs", _) as the pattern
    // If the entire pattern match succeeds, then the portion that matched the UnOp("abs", _) part is made available as variable e
    +--------------------------------------------------+
    | expr match                                       |
    |     case UnOp("abs", e @ UnOp("abs", _)) => e    |    // looks for the absolute value operation being applied twice in a row
    |     case _ =>                                    |
    +--------------------------------------------------+

    -Pattern guards
    // pattern variable may only appear once in a pattern           // A match expression with a pattern guard.
    // error: x is already defined as value x                       +--------------------------------------------------------------+    +----------------------------------------------------+
    +----------------------------------------------------------+    | def simplifyAdd(e: Expr) = e match                           |    | // match only positive integers                    |
    | def simplifyAdd(e: Expr) = e match                       |    |     case BinOp("+", x, y) if x == y => BinOp("*", x, Num(2)) |    | case n: Int if 0 < n => ...                        |
    |     case BinOp("+", x, x) => BinOp("*", x, Number(2))    |    |     case _ => e                                              |    | // match only strings starting with the letter ‘a' |
    |     case _ => e                                          |    +--------------------------------------------------------------+    | case s: String if s(0) == 'a' => ...               |
    +----------------------------------------------------------+                                                                        +----------------------------------------------------+

    -Pattern overlaps
    // If you wrote them in the other order, then the catch-all case would be run in favor of the more specific rules
    +------------------------------------------------------------------------------------------+
    | def simplifyAll(expr: Expr): Expr = expr match                                           |
    |     case UnOp("-",UnOp("-",e))      =>simplifyAll(e) // '-'is its own inverse            |
    |     case BinOp("+", e, Number(0))   =>simplifyAll(e) // '0' is a neutral element for ‘+' |
    |     case BinOp("*", e, Number(1))   =>simplifyAll(e) // '1' is a neutral element for ‘*' |
    |     case UnOp(op, e)                =>UnOp(op, simplifyAll(e))                           |
    |     case BinOp(op, l, r)            =>BinOp(op, simplifyAll(l), simplifyAll(r))          |
    |     case _ => expr                                                                       |
    +------------------------------------------------------------------------------------------+

    -Sealed classes
    // How can you ever feel safe that you covered all the cases in pattern matching?           +----------------------------------------------------------------------------------+
    // A sealed class cannot have any new subclasses added except the ones in the same file     |     def describe(e: Expr): String = e match // warning: match is not exhaustive! |
    // you only need to worry about the subclasses you already know about                       |         case Number(_) => "a number"        // missing combination UnOp          |
    +-------------------------------------------------------------------------+                 |         case Var(_) => "a variable"         // missing combination BinOp         |
    | sealed trait Expr                                                       |                 +----------------------------------------------------------------------------------+
    | case class Var(name: String) extends Expr                               | // no warning                                                       // or this
    | case class Num(number: Double) extends Expr                             | +---------------------------------------------------------------+   +-------------------------------------------------------+
    | case class UnOp(operator: String, arg: Expr) extends Expr               | | def describe(e: Expr): String = e match                       |   | def describe(e: Expr): String = (e: @unchecked) match |
    | case class BinOp(operator: String,left: Expr, right: Expr) extends Expr | |     case Num(_) => "a number"                                 |   |     case Number(_) => "a number"                      |
    +-------------------------------------------------------------------------+ |     case Var(_) => "a variable"                               |   |     case Var(_) => "a variable"                       |
                                                                                |     case _ => throw new RuntimeException // Should not happen |   +-------------------------------------------------------+
                                                                                +---------------------------------------------------------------+

    -Pattern matching Options
    +-------------------------------------------------------------+ +---------------------------------------+   +----------------------------------------------+
    | val capitals = Map("France" -> "Paris", "Japan" -> "Tokyo") | | def show(x: Option[String]) = x match |   | show(capitals.get("Japan"))         // Tokyo |
    | capitals.get("France")      // Some(Paris)                  | |     case Some(s) => s                 |   | show(capitals.get("France"))        // Paris |
    | capitals.get("North Pole")  // None                         | |     case None => "?"                  |   | show(capitals.get("North Pole"))    // ?     |
    +-------------------------------------------------------------+ +---------------------------------------+   +----------------------------------------------+
      
    -Patterns everywhere
    -Patterns in variable definitions
    +------------------------------------------------+
    | val myTuple = (123, "abc")                     |
    | val (number, string) = myTuple                 |  // number: Int = 123; string: String = abc
    | val exp = new BinOp("*", Number(5), Number(1)) |
    | val BinOp(op, left, right) = exp               |  // op: String = *; left: Expr = Number(5.0); right: Expr = Number(1.0)
    +------------------------------------------------+

    -Case sequences as partial functions
    // A sequence of cases (i.e., alternatives) in curly braces can be used anywhere a      // Akka actors receive method to be defined as a series of cases
     function literal can be used                                                           +---------------------------------------------------------------------+
    // case sequence is a function literal, only more general                               | var sum = 0                                                         |
    // each case is an entry point to the function, and the parameters are specified        | def receive =                                                       |
     with the pattern the body of each entry point is the right-hand side of the case       |     case Data(byte) => sum += byte                                  |
    +---------------------------------------+                                               |     case GetChecksum(requester) => val checksum = ~(sum & 0xFF) + 1 |
    | val withDefault: Option[Int] => Int = |   // withDefault(Some(10))    // 10           |     requester ! checksum                                            |
    |     case Some(x) => x                 |   // withDefault(None)        // 0            +---------------------------------------------------------------------+
    |     case None => 0                    |
    +---------------------------------------+

    - a sequence of cases gives you a partial function
    // partial f that returns 2nd element of list                   // second try with partial type (no warn)                                       // literal { case x :: y :: _ => y }
    // warn that the match is not exhaustive                        +------------------------------------------------------------------------+      +--------------------------------------+
    // (List[Int] => Int) - includes all functions (and partial)    | val second: PartialFunction[List[Int],Int] = case x :: y :: _ => y     |      | new PartialFunction[List[Int], Int]: |
    +------------------------------------------------------+        +------------------------------------------------------------------------+      |     def apply(xs: List[Int]) =       |
    | val second: List[Int] => Int = case x :: y :: _ => y |        // partial function has isDefined method                                        |         xs match                     |
    +------------------------------------------------------+        second.isDefinedAt(List(5,6,7))     // true                                     |             case x :: y :: _ => y    |
                                                                    second.isDefinedAt(List())          // false                                    |     def isDefinedAt(xs: List[Int]) = |
                                                                                                                                                    |         xs match                     |
    -Patterns in for expressions                                                                                                                    |             case x :: y :: _ => true |
    // for expression retrieves all key/value pairs from the capitals map                                                                           |             case _ => false          |
    +----------------------------------------+                                                                                                      +--------------------------------------+
    | for (country, city) <- capitals yield  |
    |     "The capital of  is "              |
    +----------------------------------------+
    // the second element None in the results list does not match the pattern Some(fruit); therefore it does not show up in the output.
    +---------------------------------------------------------+
    | val results = List(Some("apple"), None, Some("orange")) |
    | for (Some(fruit) <results)                              |
    |     println(fruit)              // apple, orange        |
    +---------------------------------------------------------+
    
    -A larger example
    +-------------------------+
    |                      x  |
    | x/(x+1)     -->     --- |
    |                     x+1 |
    +-------------------------+
    // concentrate on horizontal layout
    +----------------------------------------------------------------------+
    | BinOp("+",                                                           |
    |     BinOp("*",                                                       |
    |         BinOp("+", Var("x"), Var("y")),                              |
    |         Var("z")),                                                   |
    |     Number(1))                                                       |
    | // code needs to know about the relative precedence of each operator |
    | Map( "|" > 0, "||" > 0, "&" > 1, "&&" > 1, ... )                     |
    +----------------------------------------------------------------------+

    +--------------------------------------------------------------------------+    +--------------------------------------------------------------+    // A mapping from operators to their precedence
    | package org.stairwaybook.expr                                            |    | class ExprFormatter {                                        |    +------------------------------------------+
    | import org.stairwaybook.layout.Element.elem                              |    |     // Contains operators in groups of increasing precedence |    | private val precedence = {               |
    | sealed abstract class Expr                                               |    |     private val opGroups =                                   |    |     val assocs =                         |
    | case class Var(name: String) extends Expr                                |    |         Array(                                               |    |         for                              |
    | case class Number(num: Double) extends Expr                              |    |             Set("|", "||"),                                  |    |             i <- 0 until opGroups.length |
    | case class UnOp(operator: String, arg: Expr) extends Expr                |    |             Set("&", "&&"),                                  |    |             op <- opGroups(i)            |
    | case class BinOp(operator: String, left: Expr, right: Expr) extends Expr |    |             Set("ˆ"),                                        |    |         yield op -> i                    |
    +--------------------------------------------------------------------------+    |             Set("==", "!="),                                 |    |     assocs.toMap                         |
                                                                                    |             Set("<", "<=", ">", ">="),                       |    | }                                        |
                                                                                    |             Set("+", ""),                                    |    +------------------------------------------+
                                                                                    |             Set("*", "%")                                    |
                                                                                    |         )                                                    |
                                                                                    +--------------------------------------------------------------+

    +---------------------------------------------------------------------------------------+
    | private val unaryPrecedence = opGroups.length                                         |
    | private val fractionPrecedence = 1                                                    |
    | import org.stairwaybook.layout.Element                                                |
    |     private def format(e: Expr, enclPrec: Int): Element =                             |
    |         e match {                                                                     |
    |             case Var(name) => elem(name)                                              |   // 1.If the expression is a variable, the result is an element formed from the variable’s name.
    |             case Number(num) =>                                                       |
    |                 def stripDot(s: String) =                                             |   // 2.cleans up the display of a floating-point number by stripping any ".0" suffix from a string
    |                     if (s endsWith ".0") s.substring(0, s.length 2)                   |
    |                     else s                                                            |
    |                 elem(stripDot(num.toString))                                          |
    |             case UnOp(op, arg) => elem(op) beside format(arg, unaryPrecedence)        |   // 3.if arg is a binary operation (but not a fraction) it will always be displayed in parentheses
    |             case BinOp("/", left, right) =>                                           |   // 4.If the expression is a fraction, an intermediate result frac is formed by placing the formatted
    |                 val top = format(left, fractionPrecedence)                            |   // operands left and right on top of each other, separated by an horizontal line element
    |                 val bot = format(right, fractionPrecedence)                           |
    |                 val line = elem('',top.width max bot.width, 1)                        |
    |                 val frac = top above line above bot                                   |
    |                 if (enclPrec != fractionPrecedence) frac                              |
    |                 else elem(" ") beside frac beside elem(" ")                           |
    |             case BinOp(op, left, right) =>                                            |   // applies for all other binary operations
    |                 val opPrec = precedence(op)                                           |   +-------------------------------------------------------------------------------------------+
    |                 val l = format(left, opPrec)                                          |   | import org.stairwaybook.expr._                                                            |
    |                 val r = format(right, opPrec + 1)                                     |   | object Express extends App {                                                              |         1
    |                 val oper = l beside elem(" " + op + " ") beside r                     |   |     val f = new ExprFormatter                                                             | -->     - * (x + 1)
    |                 if (enclPrec <= opPrec) oper                                          |   |     val e1 = BinOp("*", BinOp("/", Number(1), Number(2)),BinOp("+", Var("x"), Number(1))) |         2
    |                 else elem("(") beside oper beside elem(")")                           |   |     println(f.format(e1)+ "\n\n")                                                         |
    |         }                                                                             |   | }                                                                                         |
    |     def format(e: Expr): Element = format(e, 0)                                       |   +-------------------------------------------------------------------------------------------+
    | }                                                                                     |
    +---------------------------------------------------------------------------------------+


###############
# Enums
###############
    // type that’s restricted to a finite set of named values                           +---------------------------------------------+
    // values are called the cases of the EDT                                           | import Direction.{North, South, East, West} | // invert(North) // South
    +-----------------------------------+                                               | def invert(dir: Direction): Direction =     |
    | enum Direction:                   |   // generate a sealed class named Direction  |   dir match                                 |
    |     case North, East, South, West |   // and a companion object with 4 vals       |     case North => South                     |
    +-----------------------------------+                                               |     case East => West                       |
                                                                                        |     case South => North                     |
    // enumarated because assosiates Int with each case                                 |     case West => East                       |
    +----------------------+                                                            +---------------------------------------------+
    | North.ordinal   // 0 |    // also in companion object values method generated         // valueOf in companion object - converts string to instance of enum type
    | East.ordinal    // 1 |    +-----------------------------------------------------+     +-------------------------------------+
    | South.ordinal   // 2 |    | Direction.values // Array(North, East, South, West) |     | Direction.valueOf("North") // North |
    | West.ordinal    // 3 |    +-----------------------------------------------------+     +-------------------------------------+
    +----------------------+
    -EDT value parameters
    +----------------------------------------+  +----------------------+
    | enum Direction(val degrees: Int):      |  | import Direction.*   |
    |     case North extends Direction(0)    |  | North.degrees // 0   |
    |     case East extends Direction(90)    |  | South.degrees // 180 |
    |     case South extends Direction(180)  |  +----------------------+
    |     case West extends Direction(270)   |
    +----------------------------------------+
    -Define own methods in EDT                                          // if define companion object - scala will still
    +-------------------------------------+                                provide values, valueOf methods if not provided in object
    | enum Direction(val degrees: Int):   | // North.invert // South    +--------------------------------------------------+    +----------------------------------------------------+
    | def invert: Direction =             | // East.invert // West      | object Direction:                                |    | def allButNearest(degrees: Int): List[Direction] = |
    |   this match                        |                             | def nearestTo(degrees: Int): Direction =         |    |   val nearest = Direction.nearestTo(degrees)       |
    |     case North => South             |                             |   val rem = degrees % 360                        |    |   Direction.values.toList.filter(_ != nearest)     |
    |     case East => West               |                             |   val angle = if rem < 0 then rem + 360 else rem |    | allButNearest(42) // List(East, South, West)       |
    |     case South => North             |                             |   val (ne, se, sw, nw) = (45, 135, 225, 315)     |    +----------------------------------------------------+
    |     case West => East               |                             |   angle match                                    |
    |     case North extends Direction(0) |                             |     case a if a > nw || a <= ne => North         |
    | case East extends Direction(90)     |                             |     case a if a > ne && a <= se => East          |
    | case South extends Direction(180)   |                             |     case a if a > se && a <= sw => South         |
    | case West extends Direction(270)    |                             |     case a if a > sw && a <= nw => West          |
    +-------------------------------------+                             +--------------------------------------------------+
    // cannot define methods for the individual cases

    -Algebraic data types                       - ADT with method                                   // for each ADT case with params - compiler 
    // (ADT) is a data type composed of         +------------------------------------------------+  // will generate case class in companion object
       a finite set of cases                    | enum Eastwood[+G, +B]:                         |  +-------------------------------------------------------------------+
    // sealed family of case classes forms      |     def map[G2](f: G => G2): Eastwood[G2, B] = |  | // Generated sealed trait (the "enum type")                       |
       an ADT so long as at least one of        |       this match                               |  | sealed trait Eastwood[+G, +B]                                     |
       the cases takes parameters.              |         case Good(g) => Good(f(g))             |  | object Eastwood: // Generated companion object                    |
    +----------------------------+              |         case Bad(b) => Bad(b)                  |  |     // Generated case classes                                     |
    | enum Eastwood[+G, +B]:     |              |         case Ugly(ex) => Ugly(ex)              |  |     case class Good[+G, +B](g: G) extends Eastwood[G, B]          |
    |   case Good(g: G)          |              |     case Good(g: G)                            |  |     case class Bad[+G, +B](b: B) extends Eastwood[G, B]           |
    |   case Bad(b: B)           |              |     case Bad(b: B)                             |  |     case class Ugly[+G, +B](ex: Throwable) extends Eastwood[G, B] |
    |   case Ugly(ex: Throwable) |              |     case Ugly(ex: Throwable)                   |  +-------------------------------------------------------------------+
    +----------------------------+              +------------------------------------------------+  // Good(42)
                                                // val eastWood = Good(41)                          // val res0: Eastwood[Int, Nothing] = Good(42)
                                                // eastWood.map(n => n + 1) // Good(42)      
    - linked list type whose empty list object is named Nada and whose cons cell class is named Yada                                                       
    +----------------------------------------------------------+
    | enum Seinfeld[+E]:                                       |
    |     def ::[E2 >: E](o: E2): Seinfeld[E2] = Yada(o, this) |    // val xs = 1 :: 2 :: 3 :: Nada
    |     case Yada(head: E, tail: Seinfeld[E])                |    // val xs: Seinfeld[Int] = Yada(1,Yada(2,Yada(3,Nada)))
    |     case Nada                                            |
    +----------------------------------------------------------+

    -Generalized ADTs
    // (GADTs) are ADTs in which the sealed trait takes a type parameter that is filled in by the cases
    +--------------------------------------------------------------+    +---------------------------------------------+
    | enum Literal[T]:                                             |    | import Literal.*                            | // valueOfLiteral(BooleanLit(true)) // true: Boolean
    |     case IntLit(value: Int) extends Literal[Int]             |    | def valueOfLiteral[T](lit: Literal[T]): T = | // valueOfLiteral(IntLit(42)) // 42: Int
    |     case LongLit(value: Long) extends Literal[Long]          |    |     lit match                               |
    |     case CharLit(value: Char) extends Literal[Char]          |    |         case IntLit(n) => n                 |
    |     case FloatLit(value: Float) extends Literal[Float]       |    |         case LongLit(m) => m                |
    |     case DoubleLit(value: Double) extends Literal[Double]    |    |         case CharLit(c) => c                |
    |     case BooleanLit(value: Boolean) extends Literal[Boolean] |    |         case FloatLit(f) => f               |
    |     case StringLit(value: String) extends Literal[String]    |    |         case DoubleLit(d) => d              |
    +--------------------------------------------------------------+    |         case BooleanLit(b) => b             |
                                                                        |         case StringLit(s) => s              |
                                                                        +---------------------------------------------+
    - What makes ADTs algebraic
    // "algebraic" because they embody the algebraic laws of addition and multiplication
    // Boolean has two possible values, true and false
    // two inhabitants of type Boolean, cardinality of Boolean, therefore, is 2

    // TrafficLight cardinality is 3    
    +-----------------------------+     // Byte cardinality - 256 (2^8)
    | enum TrafficLight:          |     // Int cardinality - 42949672962 (2^32)
    |     case Red, Yellow, Green |     // String cardinalitt - infinite
    +-----------------------------+

    // Sum type                                                                         // product type
    // can combine types into new composite ones, its called Sum type                   +-----------------------------------+
    +---------------------+ // cardinality of Glad[T] is equal to cardinality of T      | case class Both[A, B](a: A, b: B) |
    | enum Hope[+T]:      | // Hope[Byte] - 256 + 1(Sad)                                +-----------------------------------+
    |     case Glad(o: T) | // Hope[Boolean] - 2 + 1(Sad)                               // Both type allows you to gather together two values of types A and B
    |     case Sad        |                                                             // How many inhabitants does Both[A, B] have? 
    +---------------------+                                                             // product of the cardinalities of its constituent types, A and B
                                                                                        // Both[TrafficLight, Boolean] is 3 * 2, or 6


###############
# Working with Lists 
###############
    -List literals
    // lists are immutable, lists have a recursive structure, whereas arrays are flat
    +------------------------------------------------+
    | val fruit = List("apples", "oranges", "pears") |
    | val nums = List(1, 2, 3, 4)                    |
    | val empty = List()                             |
    +------------------------------------------------+

    -The List type
    // The list type in Scala is covariant
    // if S is a subtype of T, then List[S] is a subtype of List[T]
    // List[String] is a subtype of List[Object]
    +--------------------------------------------------------------+
    | val fruit: List[String] = List("apples", "oranges", "pears") |
    | val nums: List[Int] = List(1, 2, 3, 4)                       |
    | val empty: List[Nothing] = List()                            |    // Because lists are covariant, it follows that List[Nothing] is a subtype of List[T]
    | val xs: List[String] = List()                                |    // List() is also of type List[String]!
    +--------------------------------------------------------------+

    -Constructing lists
    // lists are built from two fundamental building blocks, Nil and :: (pronounced "cons")
    // x :: xs represents a list whose first element is x, followed by (the elements of) list xs
    +---------------------------------------------------------+
    | val fruit = "apples" :: ("oranges" :: ("pears" :: Nil)) |
    | val nums = 1 :: 2 :: 3 :: 4 :: Nil                      |
    +---------------------------------------------------------+

    -Basic operations on lists
    head    // returns the first element of a list
    tail    // returns a list consisting of all elements except the first
    isEmpty // returns true if the list is empty
    // insertion sort - sort a non-empty list x :: xs, sort the remainder xs and insert the first element x at the right position in the result
    +------------------------------------------------+
    | def isort(xs: List[Int]): List[Int] =          |
    |     if (xs.isEmpty) Nil                        |
    |     else insert(xs.head, isort(xs.tail))       |
    | def insert(x: Int, xs: List[Int]): List[Int] = |
    |     if (xs.isEmpty || x <= xs.head) x :: xs    |
    |     else xs.head :: insert(x, xs.tail)         |
    +------------------------------------------------+

    -List patterns
    val List(a, b, c) = fruit       // match on all elements of a list (a: String = apples ,b: String = oranges ,c: String = pears)
    val a :: b :: rest = fruit      // (a: String = apples, b: String = oranges, rest: List[String] = List(pears))
    // sorting
    +--------------------------------------------------+
    | def isort(xs: List[Int]): List[Int] =            |
    |   xs match                                       |
    |     case List() => List()                        |
    |     case x :: xs1 => insert(x, isort(xs1))       |
    |   def insert(x: Int, xs: List[Int]): List[Int] = |
    |     xs match                                     |
    |       case List() => List(x)                     |
    |       case y :: ys => if x <= y then x :: xs     |
    |                       else y :: insert(x, ys)    |
    +--------------------------------------------------+


    -First-order methods on class List
    // A method is first-order if it does not take any functions as arguments

    -Concatenating two lists    
    +------------------------------+
    | List(1, 2) ::: List(3, 4, 5) |    // res0: List[Int] = List(1, 2, 3, 4, 5)
    +------------------------------+

    -The Divide and Conquer principle
    // implementing concatenation
    +----------------------------------------------------+
    | def append[T](xs: List[T], ys: List[T]): List[T] = |
    |   xs match                                         |
    |     case List() => ys                              |
    |     case x :: xs1 => x :: append(xs1, ys)          |
    +----------------------------------------------------+

    -Taking the length of a list: length
    +----------------------+
    | List(1, 2, 3).length |    // res3: Int = 3 (needs to traverse the whole list)
    +----------------------+
    
    -Accessing the end of a list: init and last
    +-------------------------------------------+
    | val abcde = List('a', 'b', 'c', 'd', 'e') |
    | abcde.last                                |   // res4: Char = e   (need to traverse the whole list to compute their result)
    | abcde.init                                |   // res5: List[Char] = List(a, b, c, d)  (need to traverse the whole list to compute their result)
    +-------------------------------------------+
                      
    -Reversing lists: reverse
    abcde.reverse
    // Reverse could be implemented using concatenation (:::)
    // complexity is quadratic, compared to the standard reversal of a mutable, linked list, which has linear complexity
    +-----------------------------------------------+
    | def rev[T](xs: List[T]): List[T] =            |
    |     xs match                                  |
    |         case List() => xs                     |
    |         case x :: xs1 => rev(xs1) ::: List(x) |
    +-----------------------------------------------+

    -Prefixes and suffixes: drop, take, and splitAt
    +-----------------+
    | abcde take 2    | // res8: List[Char] = List(a, b)
    | abcde drop 2    | // res9: List[Char] = List(c, d, e)
    | abcde splitAt 2 | // res10: (List[Char], List[Char]) = (List(a, b),List(c, d, e))
    +-----------------+
    
    -Element selection: apply and indices
    +---------------+
    | abcde apply 2 |   // res11: Char = c (rare in Scala)
    | abcde(2)      |   // res12: Char = c (rare in Scala)
    | abcde.indices |   // res13: scala.collection.immutable.Range = Range(0, 1, 2, 3, 4)
    +---------------+

    -Flattening a list of lists: flatten
    +-------------------------------------------------------+
    | List(List(1, 2), List(3), List(), List(4, 5)).flatten |   // res14: List[Int] = List(1, 2, 3, 4, 5)
    | fruit.map(_.toCharArray).flatten                      |   // res15: List[Char] = List(a, p, p, l, e, s, o, r, a, n, g, e,s, p, e, a, r, s)
    +-------------------------------------------------------+
                 
    -Zipping lists: zip and unzip
    // takes two lists and forms a list of pairs
    +---------------------------------------+
    | abcde.indices zip abcde               |   // res17: scala.collection.immutable.IndexedSeq[(Int, Char)] = Vector((0,a), (1,b), (2,c), (3,d), (4,e))
    | val zipped = abcde zip List(1, 2, 3)  |   // zipped: List[(Char, Int)] = List((a,1), (b,2), (c,3))
    | abcde.zipWithIndex                    |   // res18: List[(Char, Int)] = List((a,0), (b,1), (c,2), (d,3), (e,4))
    | zipped.unzip                          |   // res19: (List[Char], List[Int]) = (List(a, b, c),List(1, 2, 3))
    +---------------------------------------+

    -Displaying lists: toString and mkString
    +--------------------------------------+
    | abcde.toString                       |    // res20: String = List(a, b, c, d, e)
    | abcde mkString ("[", ",", "]")       |    // res21: String = [a,b,c,d,e]
    | abcde mkString ""                    |    // res22: String = abcde
    | abcde.mkString                       |    // res23: String = abcde
    | abcde mkString                       |    // ("List(", ", ", ")")  res24: String = List(a, b, c, d, e)
    | val buf = new StringBuilder          |    
    | abcde addString (buf, "(", ";", ")") |    // res25: StringBuilder = (a;b;c;d;e)
    +--------------------------------------+

    -Converting lists: iterator, toArray, copyToArray
    +-------------------------------------+
    | val arr = abcde.toArray             | // arr: Array[Char] = Array(a, b, c, d, e)
    | arr.toList                          | // res26: List[Char] = List(a, b, c, d, e)
    | val arr2 = new Array[Int](10)       | // arr2: Array[Int] = Array(0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    | List(1, 2, 3) copyToArray (arr2, 3) | 
    | arr2                                | // res28: Array[Int] = Array(0, 0, 0, 1, 2, 3, 0, 0, 0, 0)
    | val it = abcde.iterator             | 
    | it.next                             | // res30: Char = b
    | it.next                             | // res29: Char = a
    +-------------------------------------+

    -Example: Merge sort
    +---------------------------------------------------------------------------+   +----------------------------------------------------------+
    | def msort[T](less: (T, T) => Boolean)(xs: List[T]): List[T] =             |   | msort((x: Int, y: Int) => x < y)(List(5, 7, 1, 3))       |    // res31: List[Int] = List(1, 3, 5, 7)
    |   def merge(xs: List[T], ys: List[T]): List[T] =                          |   | val intSort = msort((x: Int, y: Int) => x < y) _         |
    |    (xs, ys) match                                                         |   | val reverseIntSort = msort((x: Int, y: Int) => x > y) _  |
    |       case (Nil, _) => ys                                                 |   | val mixedInts = List(4, 1, 9, 0, 5, 8, 3, 6, 2, 7)       |
    |       case (_, Nil) => xs                                                 |   | intSort(mixedInts)                                       |    // res0: List[Int] = List(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
    |       case (x :: xs1, y :: ys1) => if less(x, y) then x :: merge(xs1, ys) |   | reverseIntSort(mixedInts)                                |    // res1: List[Int] = List(9, 8, 7, 6, 5, 4, 3, 2, 1, 0)
    |                                    else y :: merge(xs, ys1)               |   +----------------------------------------------------------+
    |   val n = xs.length / 2                                                   |
    |   if n == 0 then xs                                                       |
    |   else                                                                    |
    |     val (ys, zs) = xs.splitAt(n)                                          |
    |     merge(msort(less)(ys), msort(less)(zs))                               |
    +---------------------------------------------------------------------------+

    -Higher-order methods on class List
    -Mapping over lists: map, flatMap and foreach
    +--------------------------------------------------+
    | List(1, 2, 3) map (_ + 1)                        |    // res32: List[Int] = List(2, 3, 4)
    | val words = List("the", "quick", "brown", "fox") |    // words: List[String] = List(the, quick, brown, fox)
    | words map (_.length)                             |    // res33: List[Int] = List(3, 5, 5, 3)
    | words map (_.toList.reverse.mkString)            |    // res34: List[String] = List(eht, kciuq, nworb, xof)
    | words map (_.toList)                             |    // res35: List[List[Char]] = List(List(t, h, e), List(q, u, i, c, k), List(b, r, o, w, n), List(f, o, x))
    | words flatMap (_.toList)                         |    // res36: List[Char] = List(t, h, e, q, u, i, c, k, b, r, o, w, n, f, o, x)
    +--------------------------------------------------+
    // 1. generate a list of integers from 1 (including) until 5 (excluding),
    // 2. a second time to generate a list of integers from 1 until i, for each value of i taken from the first list
    // 3. The map in this expression generates a list of tuples (i; j)
    +--------------------------------------------------------------------+
    | List.range(1, 5) flatMap (i => List.range(1, i) map (j => (i, j))) |  // res37: List[(Int, Int)] = List((2,1), (3,1), (3,2), (4,1),(4,2), (4,3))
    | var sum = 0                                                        |
    | List(1, 2, 3, 4, 5) foreach (sum += _)                             |
    | sum                                                                |  // res39: Int = 15
    +--------------------------------------------------------------------+

    -Filtering lists: filter, partition, find, takeWhile, dropWhile, and span
    +--------------------------------------------------------------------------+
    | List(1, 2, 3, 4, 5) filter (_ % 2 == 0)                                  |    // res40: List[Int] = List(2, 4)
    | words filter (_.length == 3)                                             |    // res41: List[String] = List(the, fox)
    |                                                                          |
    | // partition method is like filter but returns                           |
    | // a pair of lists (for true,false)                                      |
    | List(1, 2, 3, 4, 5) partition (_ % 2 == 0)                               |    // res42: (List[Int], List[Int]) = (List(2, 4),List(1, 3, 5))
    |                                                                          |
    | // find method is also similar to filter, but                            |
    | // it returns the first element satisfying a given predicate             |
    | List(1, 2, 3, 4, 5) find (_ % 2 == 0)                                    |    // res43: Option[Int] = Some(2)
    | scala> List(1, 2, 3, 4, 5) find (_ <= 0)                                 |    // res44: Option[Int] = None
    |                                                                          |
    | // takeWhile and dropWhile operators also take                           |
    | // a predicate - takes/drops longest prefix                              |
    | List(1, 2, 3, -4, 5) takeWhile (_ > 0)                                   |    // res45: List[Int] = List(1, 2, 3)
    | words dropWhile (_ startsWith "t")                                       |    // res46: List[String] = List(quick, brown, fox)
    |                                                                          |
    | // span method combines takeWhile and dropWhile in one                   |
    | // operation, just like splitAt combines take and drop                   |
    | List(1, 2, 3, -4, 5) span (_ > 0)                                        |    // res47: (List[Int], List[Int]) = (List(1, 2, 3),List(4, 5))
    +--------------------------------------------------------------------------+
                        
    -Predicates over lists: forall and exists
    // forall p takes as arguments a list xs and a predicate p. Its result is true if all elements in the list satisfy p
    +-------------------------------------------+
    | def hasZeroRow(m: List[List[Int]]) =      |
    |     m exists (row => row forall (_ == 0)) |
    | hasZeroRow(diag3)                         |   // res48: Boolean = false
    +-------------------------------------------+
               
    -Folding lists: /: and :\
    // fold left operation "xs.foldLeft(z)(op)" involves three objects: a start value z, a list xs, and a binary operation op
    // List(a, b, c).foldLeft(z)(op) equals op(op(op(z, a), b), c)
    +------------+  +--------------------------------------------------------------+    +----------------------------------+
    |       op   |  | def foldLeft[A, B](xs: Seq[A], z: B)(op: (B, A) => B): B = { |    | List(1, 2, 3).foldLeft(0)(_ + _) |
    |      /  \  |  |   def f(xs: Seq[A], acc: B): B = xs match {                  |    |  ((0 + 1) + 2) + 3               |
    |     op   c |  |     case Seq()   => acc                                      |    |  = 6                             |
    |    /  \    |  |     case x +: xs => f(xs, op(acc, x))                        |    +----------------------------------+
    |   op   b   |  |   }                                                          |
    |  /  \      |  |   f(xs, z)                                                   |
    | z    a     |  | }                                                            |
    +------------+  +--------------------------------------------------------------+

    // List(a, b, c).foldRight(z)(op) equals op(a, op(b, op(c, z)))
    +------------+  +----------------------------------------------------------------+    +-----------------------------------+
    |   op       |  | final def foldRight[B](z: B)(f: (A, B) => B): B = this match { |    | List(1, 2, 3).foldRight(0)(_ + _) |
    |  /  \      |  |   case Nil => z                                                |    |  1 + (2 + (3 + 0))                |
    | a   op     |  |   case Cons(head, tail) => f(head, tail.foldRight(z)(f))       |    |  = 6                              |
    |    /  \    |  | }                                                              |    +-----------------------------------+
    |   b   op   |  +----------------------------------------------------------------+
    |      /  \  |
    |     c    z |
    +------------+
    // concatenates all elements in a list of lists
    +------------------------------------------------------------------------+
    | def flattenLeft[T](xss: List[List[T]]) = (List[T]() /: xss) (_ ::: _)  |
    | def flattenRight[T](xss: List[List[T]]) = (xss :\ List[T]()) (_ ::: _) |  // more efficient, because flattenLeft(xss) copies the first element list xss.head n􀀀1 times, where n is the length of the list xss
    +------------------------------------------------------------------------+

    -Example: List reversal using fold
    +---------------------------------------------------------------------------------+
    | def reverseLeft[T](xs: List[T]) = xs.foldLeft(List[T]()) { (ys, y) => y :: ys } |
    +---------------------------------------------------------------------------------+

    -Sorting lists: sortWith
    +--------------------------------------+
    | List(1, 3, 4, 2, 6) sortWith (_ < _) |    // res51: List[Int] = List(3, 1, 2, 4, 6)
    | words sortWith (_.length > _.length) |    // res52: List[String] = List(quick, brown, the, fox)
    +--------------------------------------+

    -Methods of the List object                                         -Creating a range of numbers: List.range
    -Creating lists from their elements: List.apply                     +---------------------+
    +----------------------+                                            | List.range(1, 5)    | // res54: List[Int] = List(1, 2, 3, 4)
    | List.apply(1, 2, 3)  |    // res53: List[Int] = List(1, 2, 3)     | List.range(1, 9, 2) | // res55: List[Int] = List(1, 3, 5, 7)
    +----------------------+                                            | List.range(9, 1, 3) | // res56: List[Int] = List(9, 6, 3)    
                                                                        +---------------------+

    -Creating uniform lists: List.fill
    +---------------------------+
    | List.fill(5)('a')         |   // res57: List[Char] = List(a, a, a, a, a)
    | List.fill(3)("hello")     |   // res58: List[String] = List(hello, hello, hello)
    | // multidimensional lists |
    | List.fill(2, 3)('b')      |   // res59: List[List[Char]] = List(List(b, b, b), List(b, b, b))
    +---------------------------+

    -Tabulating a function: List.tabulate
    // tabulate method creates a list whose elements are computed according to a supplied function
    +--------------------------------------------+
    | val squares = List.tabulate(5)(n => n * n) |  // squares: List[Int] = List(0, 1, 4, 9, 16)
    +--------------------------------------------+
    
    -Concatenating multiple lists: List.concat
    +-------------------------------------------+
    | List.concat(List('a', 'b'), List('c'))    |   // res60: List[Char] = List(a, b, c)
    | List.concat(List(), List('b'), List('c')) |   // res61: List[Char] = List(b, c)
    | List.concat()                             |   // res62: List[Nothing] = List()
    +-------------------------------------------+

    -Processing multiple lists together
    +--------------------------------------------------------------+
    | (List(10, 20), List(3, 4, 5)).zipped.map(_ * _)              |    // res63: List[Int] = List(30, 80)
    | (List("abc", "de"), List(3, 2)).zipped.forall(_.length == _) |    // res64: Boolean = true
    | (List("abc", "de"), List(3, 2)).zipped.exists(_.length != _) |    // res65: Boolean = false
    +--------------------------------------------------------------+

    -Understanding Scala’s type inference algorithm
    +-------------------------------------------+       +----------------------------------------------+
    | msort((x: Char, y: Char) => x > y)(abcde) |   vs  | abcde.sortWith(_ > _) // List(e, d, c, b, a) |
    +-------------------------------------------+       +----------------------------------------------+
    // wont work                // scala type inference is flow based
    +---------------------+     // in m(args) first check to see if m has known type
    | msort(_ > _)(abcde) |     // in abcde.sortWith(_ > _) - type of abcde is List[Char], sorWith can work with that, so param types are known no need in explicit
    +---------------------+     // msort(_ > _)(abcde) - takes argument of type (T,T) => Boolean where T is as yet unknown. Type inference here first checks method argument to determine proper instance type of method
                                   when it type checks function _ > _ it fails
                                // solutions
                                // 1. msort[Char](_ > _)(abcde)
                                // 2. def msortSwapped[T](xs: List[T])(less: (T, T) => Boolean): List[T] =
                                // msortSwapped(abcde)(_ > _)
    

###############
# Working with Other Collections
###############
    -Sequences
    // Lists, Arrays, List buffers, Array buffers, StringOps
    -Lists                                                  -Arrays
    // fast add to start of list (prepended)                // efficiently access/update an element at an arbitrary position
    // not fast access to arbitrary indexes                 +--------------------------------------+
    // because will need to iterate the list linearly       | val fiveInts = new Array[Int](5)     |    // fiveInts: Array[Int] = Array(0, 0, 0, 0, 0)
    +-------------------------------------------+           | val fiveToOne = Array(5, 4, 3, 2, 1) |    // fiveToOne: Array[Int] = Array(5, 4, 3, 2, 1)
    | val colors = List("red", "blue", "green") |           | fiveInts(0) = fiveToOne(4)           |
    | colors.head   // res0: String = red       |           | fiveInts                             |    // res3: Array[Int] = Array(1, 0, 0, 0, 0)
    | colors.tail   // res1: List(blue, green)  |           +--------------------------------------+
    +-------------------------------------------+                           

    -List buffers                                           -Array buffers
    // mutable, more efficiently when you need to append    // like an array, except that you can additionally add and
    // += append    (constant)                              // remove elements from the beginning and end of the sequence
    // +=: prepand  (constant)                              +------------------------------------------------------+
    +--------------------------------------------------+    | import scala.collection.mutable.ArrayBuffer          |
    | import scala.collection.mutable.ListBuffer       |    | val buf = new ArrayBuffer[Int]()                     |
    | import scala.collection.mutable.ListBuffer       |    | buf += 12   // res9: buf.type = ArrayBuffer(12)      |
    | val buf = new ListBuffer[Int]                    |    | buf += 15   // res10: buf.type = ArrayBuffer(12, 15) |
    | buf += 1    // res: buf.type = ListBuffer(1)     |    | buf.length  // res12: Int = 2                        |
    | buf += 2    // res: buf.type = ListBuffer(1,2)   |    | buf(0)      // res13: Int = 12                       |
    | 3 +=: buf   // res: buf.type = ListBuffer(3,1,2) |    +------------------------------------------------------+
    | buf.toList                                       |    
    +--------------------------------------------------+    -Sets and maps  
                                                            // when say Map or Set - these types are taken from Predef immutable map/set
    -Strings (via StringOps)                                +------------------------------------------------------+
    // because String has no exists method, StringOps will  | object Predef {                                      |
       be used                                              |     type Map[A, +B] = collection.immutable.Map[A, B] |
    +---------------------------------------------------+   |     type Set[A] = collection.immutable.Set[A]        |
    | def hasUpperCase(s: String) = s.exists(_.isUpper) |   |     val Map = collection.immutable.Map               |
    | hasUpperCase("Robert Frost")  // res14: = true    |   |     val Set = collection.immutable.Set               |
    | hasUpperCase("e e cummings")  // res15: = false   |   | }                                                    |
    +---------------------------------------------------+   +------------------------------------------------------+

    -Using sets
    +--------------------------------------------+
    | val text = "See Spot run. Run, Spot. Run!" |
    | val wordsArray = text.split("[ !,.]+")     |  // wordsArray: Array[String] = Array(See, Spot, run, Run, Spot, Run)
    | val words = mutable.Set.empty[String]      |  // words: scala.collection.mutable.Set[String] = Set()
    |                                            |
    | for word <- wordsArray do                  |
    |     words += word.toLowerCase              |
    | words                                      |  // res17: scala.collection.mutable.Set[String] = Set(see, run, spot)
    |                                            |
    | val nums = Set(1, 2, 3)                    |  // Creates an immutable set (nums.toString returns Set(1, 2, 3))
    | nums + 5                                   |  // Adds an element (returns Set(1, 2, 3, 5))
    | nums - 3                                   |  // Removes an element (returns Set(1, 2))
    | nums ++ List(5, 6)                         |  // Adds multiple elements (returns Set(1, 2, 3, 5, 6))
    | nums -- List(1, 2)                         |  // Removes multiple elements (returns Set(3))
    | nums & Set(1, 3, 5, 7)                     |  // Takes the intersection of two sets (returns Set(1, 3))
    | nums.size                                  |  // Returns the size of the set (returns 3)
    | nums.contains(3)                           |  // Checks for inclusion (returns true)
    | import scala.collection.mutable            |  // Makes the mutable collections easy to access
    | val words = mutable.Set.empty[String]      |  // Creates an empty, mutable set (words.toString returns Set())
    | words += "the"                             |  // Adds an element (words.toString returns Set(the))
    | words -= "the"                             |  // Removes an element, if it exists (words.toString returns Set())
    | words ++= List("do", "re", "mi")           |  // Adds multiple elements (words.toString returns Set(do, re, mi))
    | words --= List("do", "re")                 |  // Removes multiple elements (words.toString returns Set(mi))
    | words.clear                                |  // Removes all elements (words.toString returns Set())
    +--------------------------------------------+

    -Using maps                                           // Putting it all together, here is a method that counts the
    +--------------------------------------------------+     number of times each word occurs in a string
    | val map = mutable.Map.empty[String, Int]         |  +--------------------------------------------------------+
    | map("hello") = 1                                 |  | def countWords(text: String) =                         |
    | map("there") = 2                                 |  |     val counts = mutable.Map.empty[String, Int]        |
    | map               // Map(hello -> 1, there -> 2) |  |     for rawWord <- text.split("[ ,!.]+") do            |
    | map("hello")      // res21: Int = 1              |  |         val word = rawWord.toLowerCase                 |
    +--------------------------------------------------+  |         val oldCount =                                 |
                                                          |             if counts.contains(word) then counts(word) |
                                                          |             else 0                                     |
                                                          |         counts += (word -> (oldCount + 1))             |
                                                          |     counts                                             |
                                                          | countWords("See Spot run! Run, Spot. Run!")            |
                                                          | // res22: mutable.Map(spot -> 2, see -> 1, run -> 3)   |
                                                          +--------------------------------------------------------+

    +------------------------------------------------------+
    | val nums = Map("i" -> 1, "ii" ->2)                   |    // Creates an immutable map (nums.toString returns Map(i -> 1, ii -> 2))
    | nums + ("vi" -> 6)                                   |    // Adds an entry (returns Map(i -> 1, ii -> 2, vi -> 6))
    | nums - "ii"                                          |    // Removes an entry (returns Map(i ->1))
    | nums ++ List("iii" -> 3, "v" -> 5)                   |    // Adds multiple entries (returns Map(i -> 1, ii -> 2, iii -> 3, v -> 5))
    | nums -- List("i", "ii")                              |    // Removes multiple entries (returns Map())
    | nums.size                                            |    // Returns the size of the map (returns 2)
    | nums.contains("ii")                                  |    // Checks for inclusion (returns true)
    | nums("ii")                                           |    // Retrieves the value at a specified key (returns 2)
    | nums.keys                                            |    // Returns the keys (returns an Iterable over the strings "i" and "ii")
    | nums.keySet                                          |    // Returns the keys as a set (returns Set(i, ii))
    | nums.values                                          |    // Returns the values (returns an Iterable over the integers 1 and 2)
    | nums.isEmpty                                         |    // Indicates whether the map is empty
    | (returns false)                                      |
    | import scala.collection.mutable                      |    // Makes the mutable collections easy to access
    | val words = mutable.Map.empty[String, Int]           |    // Creates an empty, mutable map
    | words += ("one" -> 1)                                |    // Adds a map entry from "one" to 1 (words.toString returns Map(one -> 1))
    | words -= "one"                                       |    // Removes a map entry, if it exists (words.toString returns Map())
    | words ++= List("one" -> 1, "two" -> 2, "three" -> 3) |    // Adds multiple map entries (words.toString returns Map(one -> 1, two -> 2, three -> 3))
    | words --= List("one", "two")                         |    // Removes multiple objects (words.toString returns Map(three -> 3))
    +------------------------------------------------------+

    -Default sets and maps
    // mutable Set/Map use HashSet/HashMap
    // immutable Set use Set1,2,3,4,HashSet(when more then 5 elements) - uses uses hash tries
    // immutable Map use Map1,2,3,4,HashMap(when more then 5 elements) - uses uses hash tries

    -Sorted sets and maps
    // These traits are implemented by classes TreeSet and TreeMap, which use a red-black tree to keep elements (in the case of TreeSet) or keys (in the case of TreeMap) in order
    +------------------------------------------------+
    | import scala.collection.immutable.TreeSet      |
    | val ts = TreeSet(9, 3, 1, 8, 0, 2, 7, 4, 6, 5) |  // ts: scala.collection.immutable.TreeSet[Int] = TreeSet(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
    | val cs = TreeSet('f', 'u', 'n')                |  // cs: scala.collection.immutable.TreeSet[Char] = TreeSet(f, n, u)
    | import scala.collection.immutable.TreeMap      |  
    | var tm = TreeMap(3 -> 'x', 1 -> 'x', 4 -> 'x') |  // tm: scala.collection.immutable.TreeMap[Int,Char] = Map(1 ->x, 3 ->x, 4 ->x)
    | tm += (2 ->'x')                                |  
    | tm                                             |  // res30: scala.collection.immutable.TreeMap[Int,Char] = Map(1 ->x, 2 ->x, 3 ->x, 4 ->x)
    +------------------------------------------------+

    -Selecting mutable versus immutable collections
    // immutable sets do not support a += operator
    // <console>:14: error: value += is not a member of
    +-----------------------------------+
    | val people = Set("Nancy", "Jane") |
    | people += "Bob"                   |
    +-----------------------------------+
    // if you declare people as a var, instead of a val, then the collection can be “updated” with a += operation
    // a new collection will be created, and then people will be reassigned to refer to the new collection
    +--------------------------------------------------------------+
    | var people = Set("Nancy", "Jane")                            |
    | people += "Bob"                                              |
    | people                                                       |    // res34: scala.collection.immutable.Set[String] = Set(Nancy, Jane, Bob)
    | people -= "Jane"                                             |
    | people ++= List("Tom", "Harry")                              |
    | people                                                       |    // res37: scala.collection.immutable.Set[String] = Set(Nancy, Bob, Tom, Harry)
    | var capital = Map("US" -> "Washington", "France" -> "Paris") |
    | capital += ("Japan" -> "Tokyo")                              |
    | println(capital("France"))                                   |
    | import scala.collection.mutable.Map                          |    // only change needed!
    +--------------------------------------------------------------+
             
    -Initializing collections                                   -Converting to array or list
    +-----------------------------------------------------+     +-----------------+
    | List(1, 2, 3)                                       |     | treeSet.toList  |// res50: List[String] = List(blue, green, red, yellow)
    | Set('a', 'b', 'c')                                  |     | treeSet.toArray |// res51: Array[String] = Array(blue, green, red, yellow)
    | import scala.collection.mutable                     |     +-----------------+
    | mutable.Map("hi" -> 2, "there" ->5)                 |     
    | Array(1.0, 2.0, 3.0)                                |
    | import scala.collection.mutable                     |
    | val stuff = mutable.Set(42)                         |
    | stuff += "abracadabra"                              | // <console>:16: error: type mismatch;
    | val stuff = mutable.Set[Any](42)                    | // stuff: scala.collection.mutable.Set[Any] = Set(42)
    | // have a list, but you want a TreeSet              |
    | val colors = List("blue", "yellow", "red", "green") |
    | import scala.collection.immutable.TreeSet           |
    | val treeSet = TreeSet(colors)                       | // error: No implicit Ordering defined for List[String]
    | val treeSet = TreeSet[String]() ++ colors           | // treeSet: scala.collection.immutable.TreeSet[String] = TreeSet(blue, green, red, yellow)
    +-----------------------------------------------------+

    -Converting between mutable and immutable sets and maps
    +---------------------------------------------+
    | import scala.collection.mutable             |
    | treeSet                                     | // res52: scala.collection.immutable.TreeSet[String] = TreeSet(blue, green, red, yellow)
    | val mutaSet = mutable.Set.empty ++= treeSet | // mutaSet: scala.collection.mutable.Set[String] = Set(red, blue, green, yellow)
    | val immutaSet = Set.empty ++ mutaSet        | // immutaSet: scala.collection.immutable.Set[String] = Set(red, blue, green, yellow)
    | // same for maps                            | 
    | val muta = mutable.Map("i" -> 1, "ii" -> 2) | 
    | val immu = Map.empty ++ muta                | // immu: scala.collection.immutable.Map[String,Int] = Map(ii -> 2, i -> 1)
    +---------------------------------------------+

    -Tuples
    // can hold objects with different types
    (1, "hello", Console)
    // method that finds the longest word in a collection and also returns its index
    +--------------------------------------------------------+  +-------------------------------------------------------------+
    | def longestWord(words: Array[String]): (String, Int) = |  | val longest = longestWord("The quick brown fox".split(" ")) |// longest: (String, Int) = (quick,1)
    |     var word = words(0)                                |  | longest._1                                                  |// res53: String = quick
    |     var idx = 0                                        |  | longest._2                                                  |// res54: Int = 1
    |     for i <- 1 until words.length do                   |  | val (word, idx) = longest                                   |// word: String = quick;  idx: Int = 1
    |         if words(i).length > word.length then          |  +-------------------------------------------------------------+
    |             word = words(i)                            |
    |             idx = i                                    |
    |     (word, idx)                                        |
    +--------------------------------------------------------+


###############
# Mutable Objects
###############
    -What makes an object mutable                       - var not always indicates that object is mutable
    +----------------------------------------------+    // caching example
    | class BankAccount:                           |    +-----------------------------------------------------------+
    |     private var bal: Int = 0                 |    | class Keyed:                                              |
    |     def balance: Int = bal                   |    |     def computeKey: Int = ... // this will take some time |
    |     def deposit(amount: Int): Unit =         |    |                                                           |
    |         require(amount > 0)                  |    | class MemoKeyed extends Keyed:                            |
    |         bal += amount                        |    |     private var keyCache: Option[Int] = None              |
    |     def withdraw(amount: Int): Boolean =     |    |     override def computeKey: Int =                        |
    |         if amount > bal then false           |    |         if !keyCache.isDefined then                       |
    |         else                                 |    |             keyCache = Some(super.computeKey)             |
    |             bal -= amount                    |    |         keyCache.get                                      |
    |             true                             |    +-----------------------------------------------------------+
    |                                              |
    | val account = new BankAccount                |
    | account deposit 100                          |
    | account withdraw 80 // res1: Boolean = true  |
    | account withdraw 80 // res2: Boolean = false |
    +----------------------------------------------+

    -Reassignable variables and properties
    // in scala every var that is a non-private member of some object implicitly defines a getter and a setter method with it.
    // getter of a var x is just named "x", while its setter is named "x_="
    +---------------+
    | var hour = 12 |   // generates a getter, “hour”, and setter, “hour_=”, in addition to a reassignable field
    +---------------+
    // below is rewritten to   \                                        // can modify methods
    +--------------------+      +----------------------------------+    +-----------------------------------+
    | class Time:        |      | class Time:                      |    | class Time:                       |
    |     var hour = 12  |  ->  |     private var h = 12           |    |     private var h = 12            |
    |     var minute = 0 |      |     private var m = 0            |    |     private var m = 0             |
    +--------------------+      |     def hour: Int = h            |    |     def hour: Int = h             |
                                |     def hour_=(x: Int) = h = x   |    |     def hour_=(x: Int) =          |   // when you call t.hour=25 - "hour_" will be cassed
                                |     def minute: Int = m          |    |         require(0 <= x && x < 24) |
                                |     def minute_=(x: Int) = m = x |    |         h = x                     |
                                +----------------------------------+    |     def minute = m                |
                                                                        |     def minute_=(x: Int) =        |
                                                                        |         require(0 <= x && x < 60) |
                                                                        |         m = x                     |
                                                                        +-----------------------------------+
    // Defining a getter and setter without an associated field
    +-----------------------------------------------------------+                                                   +-------------------------+
    | import scala.compiletime.uninitialized                    |                                                   | val t = new Thermometer |
    | class Thermometer:                                        |                                                   | t // 32.0F/0.0C         |
    |     var celsius: Float = uninitialized                    |   // uninitialized - sets to default (0) value    | t.celsius = 100         |
    |     def fahrenheit = celsius * 9 / 5 + 32                 |   // convert from celsius                         | t // 212.0F/100.0C      |
    |     def fahrenheit_=(f: Float) =                          |   // convert to celsius                           | t.fahrenheit = -40      |
    |         celsius = (f - 32) * 5 / 9                        |                                                   | t // -40.0F/-40.0C      |
    |     override def toString = s"${fahrenheit}F/${celsius}C" |                                                   +-------------------------+
    +-----------------------------------------------------------+                                                   

    -Case study: Discrete event simulation
    -A language for digital circuits
    -The Simulation API
    -Circuit Simulation

    -A language for digital circuits
    // digital circuit is built from wires and function boxes               // basic function boxes (or gates):
    // wires carry signals, which are transformed by function boxes          - inverter, which negates its signal
    // function boxes. Signals are represented by booleans: true for         - and-gate, which sets its output to the conjunction of its inputs
       signal-on and false for signal-off                                    - or-gate, which sets its output to the disjunction of its inputs

    +-----------------------------------------------------+
    | val a, b, c = new Wire                              |
    | def inverter(input: Wire, output: Wire): Unit       | // construct the gates as a side effect
    | def andGate(a1: Wire, a2: Wire, output: Wire): Unit | // instead of returning the constructed gates as a result
    | def orGate(o1: Wire, o2: Wire, output: Wire): Unit  |
    +-----------------------------------------------------+

    // The halfAdder method                                     // The fullAdder (one-bit) method
    +-----------------------------------------------------+     +---------------------------------------------------------------------+
    | def halfAdder(a: Wire, b: Wire, s: Wire, c: Wire) = |     | def fullAdder(a: Wire, b: Wire, cin: Wire, sum: Wire, cout: Wire) = | // cin - carry in
    |     val d, e = new Wire                             |     |     val s, c1, c2 = new Wire                                        |
    |     orGate(a, b, d)                                 |     |     halfAdder(a, cin, s, c1)                                        |
    |     andGate(a, b, c)                                |     |     halfAdder(b, s, sum, c2)                                        |
    |     inverter(c, e)                                  |     |     orGate(c1, c2, cout)                                            |
    |     andGate(d, e, s)                                |     +---------------------------------------------------------------------+
    +-----------------------------------------------------+

    -The Simulation API
    // The Simulation class
    +------------------------------------------------------------------------------+
    | abstract class Simulation:                                                   |
    |     type Action = () => Unit                                                 |    // think of it as a more readable name for type () => Unit
    |     case class WorkItem(time: Int, action: Action)                           |
    |     private var curtime = 0                                                  |
    |     def currentTime: Int = curtime                                           |    // public accessor method
    |     private var agenda: List[WorkItem] = List()                              |    // keeps an agenda of all remaining work items
    |                                                                              |
    |     private def insert(ag: List[WorkItem], item: WorkItem): List[WorkItem] = |    // updates agenda
    |         if ag.isEmpty || item.time < ag.head.time then item :: ag            |
    |         else ag.head :: insert(ag.tail, item)                                |
    |                                                                              |
    |     def afterDelay(delay: Int)(block: => Unit) =                             |    // only way to add a work item to the agenda
    |         val item = WorkItem(currentTime + delay, () => block)                |    // curried function, currying can be used to make method calls look more like built-in syntax
    |         agenda = insert(agenda, item)                                        |
    |                                                                              |
    |     private def next() =                                                     |
    |         (agenda: @unchecked) match                                           |
    |             case item :: rest =>                                             |    // removes the front item from the current agenda, 
    |                 agenda = rest                                                |    // sets the simulated time curtime to the work item’s time, and executes the work item’s action
    |                 curtime = item.time                                          |
    |                 item.action()                                                |
    |     def run() =                                                              |    // repeatedly takes the first item in the agenda, removes it from the agenda and executes it
    |         afterDelay(0) {                                                      |
    |             println("*** simulation started, time = " +                      |
    |             currentTime + " ***")                                            |
    |         }                                                                    |
    |         while !agenda.isEmpty do next()                                      |
    +------------------------------------------------------------------------------+

    +----------------------------------+    // by-name parameters are not evaluated when passed to a method
    | afterDelay(delay) { count += 1 } |    // would be incremented only when the simulation framework calls the action stored in the work item
    +----------------------------------+

    -Circuit Simulation
    // wire class
    +-----------------------------------------------------------+
    | package org.stairwaybook.simulation                       |
    | abstract class BasicCircuitSimulation extends Simulation: |
    |     def InverterDelay: Int                                |
    |     def AndGateDelay: Int                                 |
    |     def OrGateDelay: Int                                  |
    |                                                           |
    |     class Wire:                                           |
    |         private var sigVal = false                        |   // state of wire, current signal
    |         private var actions: List[Action] = List.empty    |   // state of wire, actions attached to wire
    |         def getSignal = sigVal                            |
    |         def setSignal(s: Boolean) =                       |
    |             if s != sigVal then                           |   // new value stored when signal changes
    |                 sigVal = s                                |   // all actions attached are executed
    |                 actions.foreach(_())                      |   // applies function _() to each element of actions 
    |         def addAction(a: Action) =                        |   // _() short for f => f() - takes a function, applies it to empty param list
    |             actions = a :: actions                        |
    |             a()                                           |
    |                                                           |
    |     def inverter(input: Wire, output: Wire) =             |   // action is installed on its input wire
    |         def invertAction() =                              |   // action is invoked once at the time the action is installed, and thereafter every time the signal on the input changes
    |             val inputSig = input.getSignal                |   // value of the inverter’s output value is set (via setSignal) to the inverse of its input value
    |             afterDelay(InverterDelay) {                   |   // effect of inverter method - add invertAction to the input wire, when invoked, gets the input signal and installs another action that inverts the output signal into the simulation agenda
    |                 output setSignal !inputSig                |   // This other action is to be executed after InverterDelay units of simulated time
    |             }                                             |
    |         input addAction invertAction                      |
    |                                                           |
    |     def andGate(a1: Wire, a2: Wire, output: Wire) =       |   // effect of the andGate method is to add andAction to both of its input wires a1 and a2
    |         def andAction() =                                 |   // This action, when invoked, gets both input signals and installs another action that sets the output signal to the conjunction of both input signals
    |             val a1Sig = a1.getSignal                      |   // This other action is to be executed after AndGateDelay units of simulated time
    |             val a2Sig = a2.getSignal                      |
    |             afterDelay(AndGateDelay) {                    |
    |                 output setSignal (a1Sig & a2Sig)          |
    |             }                                             |
    |         a1 addAction andAction                            |
    |         a2 addAction andAction                            |
    |                                                           |
    | def orGate(o1: Wire, o2: Wire, output: Wire) =            |
    |     def orAction() =                                      |
    |         val o1Sig = o1.getSignal                          |
    |         val o2Sig = o2.getSignal                          |
    |         afterDelay(OrGateDelay) {                         |
    |             output setSignal (o1Sig | o2Sig)              |
    |         }                                                 |
    |     o1 addAction orAction                                 |
    |     o2 addAction orAction                                 |
    |                                                           |
    | def probe(name: String, wire: Wire) =                     |   // effect of the probe procedure is to install a probeAction on a given wire
    |     def probeAction() =                                   |   // installed action is executed every time the wire’s signal changes
    |         println(name + " " + currentTime +                |   // simply prints the name of the wire (which is passed as first parameter to probe), as well as the current simulated time and the wire’s new value
    |         " new-value = " + wire.getSignal)                 |
    |     wire addAction probeAction                            |
    +-----------------------------------------------------------+

    // Running the simulator
    +------------------------------------------------+  +-------------------------------------------------------------------------+ +-------------------------------------------+
    | import org.stairwaybook.simulation.*           |  | package org.stairwaybook.simulation                                     | | import MySimulation.*                     |
    | object MySimulation extends CircuitSimulation: |  | abstract class CircuitSimulation extends BasicCircuitSimulation:        | | val input1, input2, sum, carry = new Wire |
    |     def InverterDelay = 1                      |  |     def halfAdder(a: Wire, b: Wire, s: Wire, c: Wire) =                 | | probe("sum", sum)                         |
    |     def AndGateDelay = 3                       |  |         val d, e = new Wire                                             | | //sum 0 new-value = false                 |
    |     def OrGateDelay = 5                        |  |         orGate(a, b, d)                                                 | | probe("carry", carry)                     |
    +------------------------------------------------+  |         andGate(a, b, c)                                                | | //carry 0 new-value = false               |
                                                        |         inverter(c, e)                                                  | | halfAdder(input1, input2, sum, carry)     |
                                                        |         andGate(d, e, s)                                                | | input1 setSignal true                     |
                                                        |     def fullAdder(a: Wire, b: Wire, cin: Wire, sum: Wire, cout: Wire) = | | scala> run()                              |
                                                        |         val s, c1, c2 = new Wire                                        | | *** simulation started, time = 0 ***      |
                                                        |         halfAdder(a, cin, s, c1)                                        | | sum 8 new-value = true                    |
                                                        |         halfAdder(b, s, sum, c2)                                        | | scala> input2 setSignal true              |
                                                        |         orGate(c1, c2, cout)                                            | | scala> run()                              |
                                                        +-------------------------------------------------------------------------+ | *** simulation started, time = 8 ***      |
                                                                                                                                    | carry 11 new-value = true                 |
                                                                                                                                    | sum 15 new-value = false                  |
                                                                                                                                    +-------------------------------------------+


###############
# Scala’s Hierarchy
###############
    -Scala’s class hierarchy
    //top of the hierarchy is class Any, methods:
    +--------------------------------------+
    | final def ==(that: Any): Boolean     |    // cannot be overriden by subclasses
    | final def !=(that: Any): Boolean     |
    | def equals(that: Any): Boolean       |    // behaviour of == can be changed by overring equals
    | def ##: Int                          |
    | def hashCode: Int                    |
    | def toString: String                 |
    +--------------------------------------+

    // methods min, max, until, to, and abs are all defined in a class scala.runtime.RichInt, and there is an implicit conversion from class Int to RichInt. 
    //The conversion is applied whenever a method is invoked on an Int that is undefined in Int but defined in RichInt.
    #########################################################################################################
    #+---+                                                                                                  #
    #|any|                                                                                                  #
    #+---+                                                                                                  #
    #|    +------+                                                                                  +------+#   // one can define his own value classes
    #+----+anyVal+-+--------+--------+--------+--------+--------+--------+--------+--------+<-------+Nothng|#   // Int has methods named + and *, and Boolean has methods named || and &&
    #|    +------+ |        |        |        |        |        |        |        |        |        +------+#   // Value classes also inherit all methods from class Any
    #|             +------+ +------+ +------+ +------+ +------+ +------+ +------+ +------+ +------+     |   #   // 42.toString // 42
    #|             |Double| |Float | |Long  | |Int   | |Short | |Byte  | |Char  | |Bolean| |Unit  |     |   #
    #|             +------+ +------+ +------+ +------+ +------+ +------+ +------+ +------+ +------+     |   #   // nothing signals abnormal termination
    #|                                                                                                  |   #
    #|                                                                                                  |   #
    #|    +------+                                     +------+                                         |   #
    #+----+anyRef+-+--------+--------+--------+<-------+Null  |<----------------------------------------+   #   // AnyRef is in fact just an alias for class java.lang.Object
    #     +------+ |        |        |        |        +------+                                             #   // null not compatible with alue classes (cannot assign null to Int)
    #              +------+ +------+ +------+ +------+                                                      #
    #              |Itrble+<+Seq   +<+List  | |Option|                                                      #
    #              +------+ +------+ +------+ +------+                                                      #
    #########################################################################################################

    -How primitives are implemented
    // class AnyRef defines an additional eq method, which cannot be overridden and is implemented as reference equality (i.e., it behaves like == in Java for reference types).
    +---------------------------+   // equality operation == in Scala is designed to be transparent with respect to the type’s representation
    | val x = new String("abc") |   // For value types, it is the natural (numeric or boolean) equality
    | val y = new String("abc") |   // For reference types == is treated as an alias of the equals method inherited from Object
    | x == y                    |   // res13: Boolean = true
    | x eq y                    |   // res14: Boolean = false (eq checks for reference equality)
    | x ne y                    |   // res15: Boolean = true
    +---------------------------+

    -Bottom types                                       // Because Nothing is a subtype of Int, the type of the whole conditional is Int, as required.
    // Null is a subclass of every reference class      +-----------------------------------------+
    // Nothing is a subtype of every other type         | def divide(x: Int, y: Int): Int =       |
    // error: an expression of type Null is ineligible  |     if (y != 0) x / y                   |
    for implicit conversion                             |     else error("can't divide by zero")  |
    // return type of error is Nothing                  +-----------------------------------------+
    +------------------------------------------+        
    | val i: Int = null     // wond work       |
    | def error(message: String): Nothing =    |
    |     throw new RuntimeException(message)  |    
    +------------------------------------------+

    -Defining your own value classes
    // must have exactly one parameter and it must have nothing inside it except defs   +----------------------------------------------------+
    // money: Dollars = $1000000; money.amount  -> res16: Int = 1000000                 | class SwissFrancs(val amount: Int) extends AnyVal: |
    +------------------------------------------------+                                  |     override def toString = s" CHF"                |  // Even though both Dollars and SwissFrancs are represented as integers at run time, 
    | class Dollars(val amount: Int) extends AnyVal: |                                  | val dollars: Dollars = new SwissFrancs(1000)       |  // they are distinct types at compile time
    |     override def toString = "$" + amount       |                                  | // compile error                                   |
    +------------------------------------------------+                                  +----------------------------------------------------+

    - Avoiding a types monoculture
    // try to define a new class for each domain concept
    // Even if such a class is a so-called tiny type with no methods or fields
    +-----------------------------------------------------------------------------+
    | class Anchor(val value: String) extends AnyVal                              |
    | class Style(val value: String) extends AnyVal                               |
    | class Text(val value: String) extends AnyVal                                |
    | class Html(val value: String) extends AnyVal                                |
    | def title(text: Text, anchor: Anchor, style: Style): Html =                 |
    |     new Html(s"<a id='${anchor.value}'>" +                                  |
    |         s"<h1 class='${style.value}'>" +                                    |
    |         text.value +                                                        |
    | )                                                                           |
    | title(new Anchor("chap:vcls"), new Style("bold"),new Text("Value Classes")) | // wrong order wont work
    +-----------------------------------------------------------------------------+

    - Intersection types
    // can join two or more types with ampersand (&) characters to form an 
       intersection type, such as Incrementing & Filtering
    +------------------------------------------------------------+
    | val q = new BasicIntQueue with Incrementing with Filtering |  // q is initialized with an instance of an anonymous class that extends BasicIntQueue and mixes in Incrementing followed by Filtering
    | // val q: BasicIntQueue & Incrementing & Filtering = anon$ |  // Its inferred type, BasicIntQueue & Incrementing & Filtering
    +------------------------------------------------------------+  // , is an intersection type that indicates the object to which q refers is an instance of all three mentioned types: BasicIntQueue, Incrementing, and Filtering

    +--------------------------------------------------+
    | // Compiles because B & I & F <: I & F           |    // type B & I & F is a subtype of B, I, F, B & I, B & F, I & F, and reflexively, of B & I & F itself
    | val q2: Incrementing & Filtering = q             |    // order does not matter: type I & F, for example, is equivalent to type F & I
    | // Compiles because I & F is equivalent to F & I |
    | val q3: Filtering & Incrementing = q2            |
    +--------------------------------------------------+

    - Union types
    +---------------------------------------+    // Scala offers a dual to intersection types called union types, which consist of two or more types joined by pipe (|) characters, such as Plum | Apricot
    | trait Fruit                           |    // union type indicates that an object is an instance of at least one mentioned type
    | trait Plum extends Fruit              |    // object of type Plum | Apricot is either an instance of Plum, an instance of Apricot, or both
    | trait Apricot extends Fruit           |    // Plum | Apricot is a supertype of both Plum and Apricot
    | trait Pluot extends Plum with Apricot |    // In Scala 3, the least upper bound of any two types is their union; the greatest lower bound is their intersection
    +---------------------------------------+
                                // Fruit is a supertype to both Plum and Apricot, but it is not the nearest common supertype
    +-------+                   // On an instance of Plum | Apricot, therefore, you can access the members of Fruit (including members it inherits from AnyRef and Any), but you cannot access any members added ineither Plum or Apricot
    | Fruit |                   +---------------------------------------------------------+
    +-------+                   | def errorMessage(msg: Int | String): String = msg match | // You could, therefore, directly invoke on msg only methods declared on Any, the sole common supertype of Int and String
        ^                       |     case n: Int => s"Error number: ${n.abs}"            |
        |                       |     case s: String => s + "!"                           |
    +----------------+          +---------------------------------------------------------+
    | Plum | Apricot |          // union type Plum | Apricot is the nearest common supertype, or least upper bound, of Plum and Apricot
    +----------------+          // Plum | Apricot union type is a subtype of Fruit
        ^           ^           +-------------------------------------------------+
        |           |           | val plumOrApricot: Plum | Apricot = new Plum {} |
    +------+    +---------+     | val fruit: Fruit = plumOrApricot                | // because Plum | Apricot <: Fruit
    | Plum |    | Apricot |     | val doesNotCompile: Plum | Apricot = fruit      | // cannot use Fruit where Plum | Apricot is needed
    +------+    +---------+     +-------------------------------------------------+
        ^           ^
        |           |           +--------------------------------------------+
    +----------------+          | val pluot: Pluot = new Pluot {}            |
    | Plum & Apricot |          | val plumAndApricot: Plum & Apricot = pluot |  // because Pluot <: Plum & Apricot
    +----------------+          | val doesNotCompile: Pluot = plumAndApricot |  // cannot use a Plum & Apricot where Pluot is needed
        ^                       +--------------------------------------------+
        |                       // On an instance of Plum & Apricot, for example, you can invoke any methods defined in either Plum or Apricot
    +-------+
    | Pluot |   // Pluot is a subtype to both Plum and Apricot, but it is not the nearest common subtype
    +-------+   //intersection type Plum & Apricot is the nearest common subtype, or greatest lower bound, of Plum and Apricot


###############
# Type Parameterization
###############
    // Type parameterization allows you to write generic classes and traits
    // example Set[T] - can be Set[String], Set[Int], but it must be Set of something
    // Variance defines inheritance relationships of parameterized types - whether Set[String] is a subtype of Set[AnyRef]

    -Functional queues
    +----------------------------------------------+    // A functional queue is a data structure with three operations:
    | val q = Queue(1, 2, 3)  // Queue(1, 2, 3)    |    // head     returns the first element of the queue
    | val q1 = q.enqueue(4)   // Queue(1, 2, 3, 4) |    // tail     returns a queue without its first element
    | q                       // Queue(1, 2, 3)    |    // enqueue  returns a new queue with a given element appended at the end
    +----------------------------------------------+

    // Not efficient implementation
    +------------------------------------------------------------+
    | class SlowAppendQueue[T](elems: List[T]): // Not efficient |
    |     def head = elems.head                                  |
    |     def tail = new SlowAppendQueue(elems.tail)             |
    |     def enqueue(x: T) = SlowAppendQueue(elems ::: List(x)) |  // takes time proportional to the number of elements stored in the queue
    +------------------------------------------------------------+

    // Not efficient as well
    +----------------------------------------------------------+
    | class SlowHeadQueue[T](smele: List[T]): // Not efficient |
    |     // smele is elems reversed                           |
    |     def head = smele.last                                |    // takes time proportional to the number of elements stored in the queue
    |     def tail = new SlowHeadQueue(smele.init)             |    // takes time proportional to the number of elements stored in the queue
    |     def enqueue(x: T) = SlowHeadQueue(x :: smele)        |    // takes constant time
    +----------------------------------------------------------+

    // mixed approach
    +-------------------------------------------------------------------------------+   // represent a queue by two lists, called leading and trailing
    | class Queue[T]( private val leading: List[T], private val trailing: List[T]): |   // leading list contains elements towards the front, whereas the trailing list contains elements towards the back of the queue in reversed order
    |                                                                               |   // contents of the whole queue are at each instant equal to "leading ::: trailing.reverse"
    |     private def mirror =                                                      |    
    |         if leading.isEmpty then                                               |   // before first head/tail operation called on empty leading list, the whole trailing list is copied to leading, reversing the order of the elements
    |             new Queue(trailing.reverse, Nil)                                  |   // mirror operation might take time proportional to the number of queue elements, but only if list leading is empty
    |         else                                                                  |   // Because head and tail call mirror, their complexity might be linear in the size of the queue, too. However, the longer the queue gets, the less often mirror is called
    |             this                                                              |
    |     def head = mirror.leading.head                                            |
    |     def tail =                                                                |
    |         val q = mirror                                                        |
    |         new Queue(q.leading.tail, q.trailing)                                 |
    |     def enqueue(x: T) = new Queue(leading, x :: trailing)                     |   // constant time - cons it to the trailing list using the :: operator
    +-------------------------------------------------------------------------------+   // when initially empty queue is constructed from successive enqueue ops - trailing list will grow whereas leading list will stay empty

    - Information hiding
    // Queue constructor, takes two lists as parameters. Need to hide this constructor




    -Private constructors and factory methods
    // In Java, you can hide a constructor by making it private
    // possible to hide the primary constructor by adding a private modifier in front of the class parameter list
    +-----------------------------------+
    | class Queue[T] private (          |   // private modifier between the class name and its parameters indicates that the constructor of Queue is private (accessed only from class or companion object)
    |     private val leading: List[T], |   // primary constructor
    |     private val trailing: List[T] |   // primary constructor
    | )                                 |   // new Queue(List(1, 2), List(3))   // error: constructor Queue in class Queue cannot be accessed in object $iw
    +-----------------------------------+

    // auxiliary constructor                                                        -An alternative: private classes
    +-----------------------------------------------+                               // hide the class itself and only export a trait that reveals the public interface of the class
    | def this() = this(Nil, Nil)                   |   // build empty queue        +---------------------------------------------------------------------------------------------------------------+
    | def this(elems: T*) = this(elems.toList, Nil) |   // T* - repeated params     | trait Queue[T]:                                                                                               |
    +-----------------------------------------------+                               |     def head: T                                                                                               |
                                                                                    |     def tail: Queue[T]                                                                                        |
    // companion object of the class                                                |     def enqueue(x: T): Queue[T]                                                                               |
    // xs: T* - constructs a queue with initial elements ‘xs'                       | object Queue:                                                                                                 |
    +---------------------------------------------------------+                     |     def apply[T](xs: T*): Queue[T] = QueueImpl[T](xs.toList, Nil)                                             |
    | object Queue:                                           |                     |     private class QueueImpl[T](private val leading: List[T],private val trailing: List[T] ) extends Queue[T]: |
    |     def apply[T](xs: T*) = new Queue[T](xs.toList, Nil) |                     |         def mirror =                                                                                          |
    | Queue(1, 2, 3)                                          |                     |             if leading.isEmpty then                                                                           |
    +---------------------------------------------------------+                     |                 QueueImpl(trailing.reverse, Nil)                                                              |
                                                                                    |             else                                                                                              |
                                                                                    |                 this                                                                                          |
                                                                                    |         def head: T = mirror.leading.head                                                                     |
                                                                                    |         def tail: QueueImpl[T] =                                                                              |
                                                                                    |             val q = mirror                                                                                    |
                                                                                    |             QueueImpl(q.leading.tail, q.trailing)                                                             |
                                                                                    |         def enqueue(x: T) = QueueImpl(leading, x :: trailing)                                                 |
                                                                                    +---------------------------------------------------------------------------------------------------------------+

    -Variance annotations
    // prev defines Queue is a trait and not a type. Not a type because it takes params, cannot create var of type Queue
    +-----------------------------------+
    | def doesNotCompile(q: Queue) = {} |   // <console>:8: error: class Queue takes type parameters def doesNotCompile(q: Queue) = {}
    +-----------------------------------+
    // trait Queue enables you to specify parameterized types, such as Queue[String], Queue[Int], or Queue[AnyRef]:
    +----------------------------------------+
    | def doesCompile(q: Queue[AnyRef]) = {} |  // doesCompile: (q: Queue[AnyRef])Unit
    +----------------------------------------+
    // Queue is a trait and Queue[String] is a type; Queue is also called a type constructor because you can construct a type with it by specifying a type parameter
    // term "generic" means you define many specific types with one generically written class or trait. For example, trait Queue defines a generic queue

    // question: should a Queue[String] be considered a subtype of Queue[AnyRef]
    // question: if S is a subtype of type T, then should Queue[S] be considered a subtype of Queue[T]?
    // If so, you could say that trait Queue is covariant (or “flexible”) in its type parameter T
    // In Scala, however, generic types have by default nonvariant (or “rigid”) subtyping

    // covariant by putting a plus sign (+) before the type parameter; List is covariant in its type parameter, so List[String] is a subtype of List[Any]
    // contravariant by putting a minus sign (-) before the type parameter; Function1 is contravariant in its first type parameter, and so Function1[Any, Any] is a subtype of Function1[String, Any].
    // Covariant Queues mean you could pass a Queue[String] to method, which takes a value parameter Queue[AnyRef].
    // in Scala by default generic types are nonvariant - queues with diff element types would never be in relationship

    // demand covariant
    +-------------------------+
    | trait Queue[+T] { ... } |     // you want Queue[String], for example, to be considered a subtype of Queue[AnyRef]
    +-------------------------+

    // demand contravariant
    +-------------------------+     // if T is a subtype of type S, this would imply that Queue[S] is a subtype of Queue[T]
    | trait Queue[-T] { ... } |
    +-------------------------+

    // example                              
    // nonvariant class with mutable data   // if Cell is covariant - you could do this:
    +---------------------------------+     +----------------------------------+    // creates a cell of strings and stores it in a val named c1
    | class Cell[T](init: T):         |     | val c1 = new Cell[String]("abc") |    // defines a new val, c2, of type Cell[Any], which initialized with c1
    |     private var current = init  |     | val c2: Cell[Any] = c1           |    // oops
    |     def get = current           |     | c2.set(1)                        |    // assign 1 to string which is wrong
    |     def set(x: T) = current = x |     | val s: String = c1.get           |    // Cell of String is not also a Cell of Any
    +---------------------------------+     +----------------------------------+    // cannot use set with an Int argument on a Cell of String

    -Variance and arrays
    // arrays in Java are covariant
    // Java stores the element type of the array at runtime, every time an array element is updated, the new element value is checked against the stored type
    +--------------------------+
    | String[] a1 = { "abc" }; |
    | Object[] a2 = a1;        |
    | a2[0] = new Integer(17); |    // Runtime Exception in thread "main" java.lang.ArrayStoreException:
    | String s = a1[0];        |    // this was done becase "void sort(Object[] a, Comparator cmp) { ... }", so that arrays of arbitrary reference types could be passed to this sort method
    +--------------------------+
    
    // in scala arrays are not covariant
    +-------------------------+
    | val a1 = Array("abc")   |
    | val a2: Array[Any] = a1 | // error: type mismatch; found : Array[String] required: Array[Any]
    +-------------------------+

    -Checking variance annotations
    // proof that functional classes can be broken with covariance (even with no reassignable field)
    // assume queus are covariant, create a subclass that specializes in Int
    +-------------------------------------------+
    | class StrangeIntQueue extends Queue[Int]: |
    |     override def enqueue(x: Int) =        |
    |         println(math.sqrt(x))             |   // prints out the square root for Int
    |         super.enqueue(x)                  |
    | val x: Queue[Any] = new StrangeIntQueue   |   // StrangeIntQueue is a subclass of Queue[Int]
    | x.enqueue("abc")                          |   // oops cannot square root abc
    +-------------------------------------------+   

    +-------------------------+
    | def enqueue(x: T) =     | // turns out that as soon as a generic parameter type appears as the type of a method parameter,
    | ˆˆˆˆ                    |    the containing class or trait may not be covariant in that type parameter
    | covariant type T occurs | +----------+    // special case (because is treated as a getter method "def x: T" and a setter "def x_ = (y:T)" 
    | in type T of val        | | var x: T |       - setter has a param of T - may not be covariant)
    +-------------------------+ +----------+

    // compiler checks each use of each of the class’s type parameters
    // compiler classifies all positions in a class or trait body as positive, negative, or neutral
    // "position" is any location in the class or trait body where a type parameter may be used
    // + may only be used in positive positions
    // - may only be used in negative positions
    // no variance annotation may be used in any position
    // class top level position is positive (type parameter), method type positions are flipped from classes (to negative)
    +------------------------------------------------------+
    | abstract class Cat[-T, +U]:                          |
    |     def meow[W-](volume: T-, listener: Cat[U+, T-]-) |    // W, volume, listener are negative
    |         : Cat[Cat[U+, T-]-, U+]+                     |
    +------------------------------------------------------+

    -Lower bounds
    // Queue[T] cannot be made covariant in T because T appears as a type of a parameter of the enqueue method, and that’s a negative position
    // way to fix this - generalize enqueue by making it polymorphic (i.e., giving the enqueue method itself a type parameter) and using a lower bound for its type parameter
    +--------------------------------------------------------------------------------+
    | class Queue[+T] (private val leading: List[T], private val trailing: List[T]): |
    |     def enqueue[U >: T](x: U) =                                                |  // T as the lower bound for U. As a result, U is required to be a supertype of T
    |         new Queue[U](leading, x :: trailing)                                   |  // class Fruit with two subclasses, Apple and Orange. 
    +--------------------------------------------------------------------------------+  // With new class Queue, it is possible to append an Orange to a Queue[Apple]. The result will be a Queue[Fruit].

    -Contravariance
    +---------------------------+   // OutputChannel is defined to be contravariant in T. So an output channel of AnyRefs, say, is a subtype of an output channel of Strings
    | trait OutputChannel[-T]:  |   // what you can do with an OutputChannel[String]? - writing a String to it, same operation can be done on an OutputChannel[AnyRef].
    |     def write(x: T): Unit |   // you can send any object to an OutputChannel[AnyRef], whereas an OutputChannel[String] requires that the written values are all strings
    +---------------------------+   // Liskov Substitution Principle - It is safe to assume that a type T is a subtype of a type U if you can substitute a value of type T wherever a value of type U is required
    // function A => B
    +--------------------------+    
    | trait Function1[-A, +B]: |
    |     def apply(x: A): B   |
    +--------------------------+
    // Demonstration of function type parameter variance
    +------------------------------------------------------+    +------+            +----------------+          +--------+
    | class Publication(val title: String)                 |    | Book |            | Book => AnyRef |          | AnyRef |
    | class Book(title: String) extends Publication(title) |    +------+            +----------------+          +--------+
    | object Library:                                      |        |                       ^                       ^
    |     val books: Set[Book] =                           |        V                       |                       |
    |         Set(                                         |    +-------------+     +-----------------------+   +--------+    
    |             Book("Programming in Scala"),            |    | Publication |     | Publication => String |   | String |    
    |             Book("Walden")                           |    +-------------+     +-----------------------+   +--------+    
    |         )                                            |    
    |     def printBookList(info: Book => AnyRef) =        |    // declared as Book, the getTitle we’re passing in takes a Publication
    |         for book <- books do println(info(book))     |    // only allows to pass a Book into the function, getTitle’s parameter type is Publication
    | object Customer:                                     |    // every method in Publication is available in Book
    |     def getTitle(p: Publication): String = p.title   |    
    |     def main(args: Array[String]): Unit =            |    // printBookList iterate books and invokes function, passes AnyRef returned to println, which invokes toString
    |         Library.printBookList(getTitle)              |    // this will work with String, as any other subClass of AnyRef
    +------------------------------------------------------+

    -Upper bounds
    // Ordered being mixed into a Person class
    +------------------------------------------------------------------------------------+  +--------------------------------------------+
    | class Person(val firstName: String, val lastName: String) extends Ordered[Person]: |  | val robert = new Person("Robert", "Jones") |
    |     def compare(that: Person) =                                                    |  | val sally = new Person("Sally", "Smith")   |
    |         val lastNameComparison = lastName.compareToIgnoreCase(that.lastName)       |  | robert < sally                             |  // res0: Boolean = true
    |         if lastNameComparison != 0 then lastNameComparison                         |  +--------------------------------------------+
    |         else                                                                       |  +----------------+  // T <: Ordered[T] - T has an upper bound, Ordered[T]
    |             firstName.compareToIgnoreCase(that.firstName)                          |  | >: lower bound |  
    |     override def toString = s"$firstName $lastName"                                |  | <: upper bound |  
    +------------------------------------------------------------------------------------+  +----------------+

    // merge with ordered
    +---------------------------------------------------------------+
    | def orderedMergeSort[T <: Ordered[T]](xs: List[T]): List[T] = |   // T <: Ordered[T] - upper bound - you indicate that the type parameter, T, has an upper bound, Ordered[T]
    |     def merge(xs: List[T], ys: List[T]): List[T] =            |   // This means that the element type of the list passed to orderedMergeSort must be a subtype of Ordered
    |         (xs, ys) match                                        |
    |             case (Nil, _) => ys                               |   // you could pass a List[Person] to orderedMergeSort because Person mixes in Ordered
    |             case (_, Nil) => xs                               |   +---------------------------------------------+
    |             case (x :: xs1, y :: ys1) =>                      |   | val people = List(                          |
    |                 if x < y then x :: merge(xs1, ys)             |   |     new Person("Larry", "Wall"),            |
    |                 else y :: merge(xs, ys1)                      |   |     new Person("Anders", "Hejlsberg"),      |
    |     val n = xs.length / 2                                     |   |     new Person("Guido", "van Rossum"),      |
    |     if n == 0 then xs                                         |   |     new Person("Alan", "Kay"),              |
    |     else                                                      |   |     new Person("Yukihiro", "Matsumoto")     |
    |         val (ys, zs) = xs.splitAt(n)                          |   | )                                           |
    |         merge(orderedMergeSort(ys), orderedMergeSort(zs))     |   | val sortedPeople = orderedMergeSort(people) |
    +---------------------------------------------------------------+   +---------------------------------------------+

    // !!! issue - you couldn’t use the orderedMergeSort function to sort a list of integers, because class Int is not a subtype of Ordered[Int]


###############
# Abstract Members
###############
    // member of a class or trait is abstract if the member does not have a complete definition in the class
    -A quick tour of abstract members                       // example implementation
    +----------------------------+                          +--------------------------------------+
    | trait Abstract:            |                          | class Concrete extends Abstract:     |
    |     type T                 |  // abstract type (T)    |     type T = String                  |
    |     def transform(x: T): T |  // abstract method      |     def transform(x: String) = x + x |
    |     val initial: T         |  // abstract val         |     val initial = "hi"               |
    |     var current: T         |  // abstract var         |     var current = initial            |
    +----------------------------+                          +--------------------------------------+

    -Type members
    // abstract type in Scala is always a member of some class or trait, such as type T in trait Abstract
    // One reason to use a type member is to define a short, descriptive alias for a type whose real name is more verbose

    -Abstract vals
    // abstract                 // concrete implemented
    +---------------------+     +--------------------+
    | val initial: String |     | val initial = "hi" |
    +---------------------+     +--------------------+
    // no value
    +--------------------------------------+    +----------------------------------------------------------+    +------------------------------------------------------------------+
    | val initial: String                  |    | abstract class Apple extends Fruit {                     |    | abstract class BadApple extends Fruit {                          |
    | abstract class Fruit {               |    |     val v: String                                        |    |     def v: String // ERROR: cannot override a ‘val' with a ‘def' |
    |     val v: String // ‘v' for value   |    |     val m: String // OK to override a ‘def' with a ‘val' |    |     def m: String                                                |
    |     def m: String // ‘m' for method  |    | }                                                        |    | }                                                                |
    | }                                    |    +----------------------------------------------------------+    +------------------------------------------------------------------+
    +--------------------------------------+    // abstract val constrains its legal implementation: Any implementation must be a val definition; it may not be a var or a def

    -Abstract vars
    // abstract var declares just a name and a type, but not an initial value
    
    // implicitly declare an abstract       // How abstract vars are expanded into getters and setters.
    getter method, hour, and an abstract    +-------------------------------------------------------+
    setter method, hour_=.                  | trait AbstractTime:                                   |
    +---------------------+                 |     def hour: Int // getter for ‘hour'                |
    | trait AbstractTime: |                 |     def hour_=(x: Int): Unit // setter for ‘hour'     |
    |     var hour: Int   |                 |     def minute: Int // getter for ‘minute'            |
    |     var minute: Int |                 |     def minute_=(x: Int): Unit // setter for ‘minute' |
    +---------------------+                 +-------------------------------------------------------+

    -Initializing abstract vals
    // class parameter argument is evaluated before it is passed to the class constructor (unless the parameter is by-name)
    // implementing val definition in a subclass, by contrast, is evaluated only after the superclass has been initialized

                                // To instantiate a concrete instance of that trait, you need to implement the  abstract val definitions
    +-----------------------+   +----------------------+
    | trait RationalTrait:  |   | new RationalTrait:   |    // anonymous class instantiation has an effect analogous to the instance creation new Rational(1, 2)
    |     val numerArg: Int |   |     val numerArg = 1 |    // expr1 and expr2, are evaluated as part of the initialization of the anonymous class
    |     val denomArg: Int |   |     val denomArg = 2 |    // but the anonymous class is initialized after the RationalTrait
    +-----------------------+   +----------------------+    // numerArg and denomArg are not available during the initialization of RationalTrait
                                +----------------------------+  // expr1 and expr2, are evaluated before class Rational is initialized
                                | new Rational(expr1, expr2) |  // values of expr1 and expr2 are available for the initialization of class Rational
                                +----------------------------+
    // A trait that uses its abstract vals
    +-----------------------------------------------+   +-----------------------------------------------------------+
    | trait RationalTrait:                          |   | new RationalTrait:                                        |
    |     val numerArg: Int                         |   |     val numerArg = 1 * x                                  |
    |     val denomArg: Int                         |   |     val denomArg = 2 * x                                  |   // because denomArg still had its default value of 0 
    |     require(denomArg != 0)                    |   | // java.lang.IllegalArgumentException: requirement failed |   // when class RationalTrait was initialized, which caused the require invocation to fail
    |     private val g = gcd(numerArg, denomArg)   |   +-----------------------------------------------------------+
    |     val numer = numerArg / g                  |   // how to fix?
    |     val denom = denomArg / g                  |   // trait parametric fields and lazy vals
    |     private def gcd(a: Int, b: Int): Int =    |
    |         if (b == 0) a else gcd(b, a % b)      |
    |     override def toString = s"$numer/$denom"  |
    +-----------------------------------------------+

    - Trait parametric fields
    // lets you compute values for fields of a trait before the trait itself is initialized
    // define the fields as parametric fields—trait parameters annotated by val

    // A trait that takes parametric fields                         // usage in anonymous class                         // in a class definition
    +------------------------------------------------------------+  +-------------------------------------------+       +-------------------------------------------------------------------+
    | trait RationalTrait(val numerArg: Int, val denomArg: Int): |  | scala> new RationalTrait(1 * x, 2 * x) {} |       | class RationalClass(n: Int, d: Int) extends RationalTrait(n, d) { |
    |     require(denomArg != 0)                                 |  | val res1: RationalTrait = 1/2             |       |     def + (that: RationalClass) = new RationalClass(              |
    |     private val g = gcd(numerArg, denomArg)                |  +-------------------------------------------+       |         numer * that.denom + that.numer * denom,                  |
    |     val numer = numerArg / g                               |  // in an object definition                          |         denom * that.denom                                        |
    |     val denom = denomArg / g                               |  +----------------------------------------------+    |     )                                                             |
    |     private def gcd(a: Int, b: Int): Int =                 |  | object TwoThirds extends RationalTrait(2, 3) |    | }                                                                 |
    |         if (b == 0) a else gcd(b, a % b)                   |  +----------------------------------------------+    +-------------------------------------------------------------------+
    |     override def toString = s"$numer/$denom"               |
    +------------------------------------------------------------+

    -Lazy vals
    // If val is lazy the initializing expression on the right-hand side will only be evaluated the first time the val is used
                                                            // with lazy val
                                                            // initialization of x will be deferred until the first time x is used
                                                            // unlike a def, a lazy val is never evaluated more than once
    +---------------------------------------------------+   +-----------------------------------------------------------+
    | object Demo:                                      |   | object Demo:                                              |
    |     val x = { println("initializing x"); "done" } |   |     lazy val x = { println("initializing x"); "done" }    |
    | scala> Demo     // initializing x                 |   | scala> Demo     //                                        |
    | scala> Demo.x   // res4: String = done            |   | scala> Demo.x   // initializing x; res6: String = done    |
    +---------------------------------------------------+   +-----------------------------------------------------------+

    // similar to the situation where x is defined as a parameterless method, using a def
    // unlike a def, a lazy val is never evaluated more than once

    +----------------------------------------------+    +--------------------------+
    | trait LazyRationalTrait:                     |    | val x = 2                |
    |     val numerArg: Int                        |    | new LazyRationalTrait {  |     // this one works even though we construct LazyRationalTrait before numerArg/denomArg
    |     val denomArg: Int                        |    |     val numerArg = 1 * x |
    |     lazy val numer = numerArg / g            |    |     val denomArg = 2 * x |    // res7: LazyRationalTrait = 1/2
    |     lazy val denom = denomArg / g            |    | }                        |
    |     override def toString = s"$numer/$denom" |    +--------------------------+
    |     private lazy val g =                     |    // 1. A fresh instance of LazyRationalTrait gets created and the initialization code of LazyRationalTrait is run. This initialization code is empty; none of the fields of LazyRationalTrait is initialized yet
    |         require(denomArg != 0)               |    // 2. Next, the primary constructor of the anonymous subclass defined by the new expression is executed. This involves the initialization of numerArg with 2 and denomArg with 4.
    |         gcd(numerArg, denomArg)              |    // 3. Next, the toString method is invoked on the constructed object by the interpreter, so that the resulting value can be printed.
    |     private def gcd(a: Int, b: Int): Int =   |    // 4. Next, the numer field is accessed for the first time by the toString method in trait LazyRationalTrait, so its initializer is evaluated.
    |         if b == 0 then a else gcd(b, a % b)  |    // 5. The initializer of numer accesses the private field, g, so g is evaluated next. This evaluation accesses numerArg and denomArg, which were defined in Step 2.
    +----------------------------------------------+    // 6. Next, the toString method accesses the value of denom, which causes denom’s evaluation. The evaluation of denom accesses the values of denomArg and g. The initializer of the g field is not re-evaluated, because it was already evaluated in Step 5.
                                                        // 7. Finally, the result string "1/2" is constructed and printed.

    -Abstract types
    +-------------------------------+   +----------------------------------------+
    | class Food                    |   | class Grass extends Food               |  // specialize these two classes to a class of Cows that eat Grass
    | abstract class Animal:        |   | class Cow extends Animal:              |
    |     def eat(food: Food): Unit |   |     override def eat(food: Grass) = {} |  // This won't compile did not override the eat method in class Animal because its parameter type is different
    +-------------------------------+   +----------------------------------------+
    // what kind of Food each Animal eats depends 
       on the Animal                            // Implementing an abstract type in a subclass
    +---------------------------------------+   +----------------------------------------+  +-----------------------------+
    | class Food                            |   | class Grass extends Food               |  | class Fish extends Food     |
    | abstract class Animal:                |   | class Cow extends Animal:              |  | val bessy: Animal = new Cow |
    |     type SuitableFood <: Food         |   |     type SuitableFood = Grass          |  | scala> bessy.eat(new Fish)  | // Found: Fish, Required: bessy.SuitableFood
    |     def eat(food: SuitableFood): Unit |   |     override def eat(food: Grass) = {} |  +-----------------------------+
    +---------------------------------------+   +----------------------------------------+

    -Path-dependent types
    // type like bessy.SuitableFood is called a path-dependent type
    // different paths give rise to different types
                                                    //attempted to feed a dog with food fit for a cow
    +------------------------------------------+    +--------------------------------------+
    | class DogFood extends Food               |    | val bessy = new Cow                  |    // eat method, bessy.SuitableFood, is incompatible with the parameter type of eat, lassie.SuitableFood
    | class Dog extends Animal:                |    | val lassie = new Dog                 |
    |     type SuitableFood = DogFood          |    | lassie eat (new bessy.SuitableFood)  |    // error: type mismatch; found : Grass required: DogFood
    |     override def eat(food: DogFood) = {} |    | val bootsie = new Dog                |
    +------------------------------------------+    | lassie.eat(new bootsie.SuitableFood) |    // Dog instance named lassie could actually eat the suitable food of a different Dog instance (which we’ll name bootsie)
                                                    +--------------------------------------+
    +-----------------------+
    | class Outer:          |
    |     class Inner       |
    | val o1 = new Outer    |   // o1.Inner and o2.Inner are two path-dependent types (and they are different types)
    | val o2 = new Outer    |   // Both of these types conform to (are subtypes of) the more general type Outer#Inner
    +-----------------------+
 
    -Refinement types
    // class inherits from another, the first class is said to be a nominal subtype of the other one
    // Scala supports structural subtyping, where you get a subtyping relationship simply because two types have compatible members
    // suppose Pasture class can contain animals that eat grass
    // option: define trait AnimalThatEatsGrass and mix it into every class where it applies
    +--------------------------------------+
    | Animal { type SuitableFood = Grass } |    // use a refinement type - write the base type, Animal, followed by a sequence of members listed in curly braces
    +--------------------------------------+
    +-------------------------------------------------------------------+
    | class Pasture:                                                    |
    |     var animals: List[Animal { type SuitableFood = Grass }] = Nil |
    |     // ...                                                        |
    +-------------------------------------------------------------------+

    -Case study: Currencies
    // should be able to add two amounts of the same currency, multiply a currency amount by a factor representing an interest rate
    // A first (faulty) design of the Currency class (ok if we want to implement hust 1 currency)
    +-----------------------------------------------------+ +-----------------------------+
    | abstract class Currency:                            | | new Currency:               | // create a concrete currency value by supplying concrete amount and designation values
    |     val amount: Long                                | |     val amount = 79L        |
    |     def designation: String                         | |     def designation = "USD" |
    |     override def toString = s"$amount $designation" | +-----------------------------+
    |     def + (that: Currency): Currency = ...          |
    |     def * (x: Double): Currency = ...               |
    +-----------------------------------------------------+
    // model dollars and euro
    +-----------------------------------------+
    | abstract class Dollar extends Currency: | // would let you add dollars to euros which is wrong
    |     def designation = "USD"             |
    | abstract class Euro extends Currency:   |
    |     def designation = "Euro"            |
    +-----------------------------------------+

    // to handle this situation: If something is not known at the point where a class is defined, make it abstract in the class (applies to both values and types)
    // exact argument and result type of the addition method are not known, so it is a good candidate for an abstract type
    // A second (still imperfect) design of the Currency class
    +-----------------------------------------------------+
    | abstract class AbstractCurrency:                    |
    |     type Currency <: AbstractCurrency               | // Each concrete subclass of AbstractCurrency would need to fix the Currency type to refer to the concrete subclass itself
    |     val amount: Long                                | +-------------------------------------------------+
    |     def designation: String                         | | abstract class Dollar extends AbstractCurrency: |
    |     override def toString = s"$amount $designation" | |     type Currency = Dollar                      |
    |     def + (that: Currency): Currency = ...          | |     def designation = "USD"                     |
    |     def * (x: Double): Currency = ...               | +-------------------------------------------------+
    +-----------------------------------------------------+

    // how should addition be implemented in this class? how would you convert the amount into a currency of the right type?
    // One of the restrictions of Scala’s treatment of abstract types is that you can neither create an instance of an abstract type nor have an abstract type as a supertype of another class
    // workaround - use factory method
    // Instead creating instance of abstract type, declare abstract method that does it, when abstract type is fixed to be some concrete type, you need to give a concrete implementation of the factory method
    +--------------------------------------------------------+
    | abstract class AbstractCurrency:                       |  // has issues
    |     type Currency <: AbstractCurrency // abstract type |  // move abstract type, factory method outside class AbstractCurrency. 
    |     def make(amount: Long): Currency // factory method |  // Create another class that contains the AbstractCurrency class, the Currency type, and the make factory method.
    |     ... // rest of class                               |
    +--------------------------------------------------------+
                                                                                    // Here, US is an object that extends CurrencyZone
    // The full code of class CurrencyZone                                          // defines a class Dollar, which is a subclass of AbstractCurrency.
    +----------------------------------------------------------------------------+  +-----------------------------------------------------+ +---------------------------------------------------+
    | abstract class CurrencyZone:                                               |  | object US extends CurrencyZone:                     | | object Europe extends CurrencyZone:               | 
    |     type Currency <: AbstractCurrency                                      |  |     abstract class Dollar extends AbstractCurrency: | |     abstract class Euro extends AbstractCurrency: | 
    |     def make(x: Long): Currency                                            |  |         def designation = "USD"                     | |         def designation = "EUR"                   |
    |     abstract class AbstractCurrency:                                       |  |         type Currency = Dollar                      | |     type Currency = Euro                          |
    |         val amount: Long                                                   |  |         def make(cents: Long) =                     | |     def make(cents: Long) =                       |
    |         def designation: String                                            |  |             new Dollar:                             | |         new Euro:                                 |
    |         def + (that: Currency): Currency = make(this.amount + that.amount) |  |                 val amount = cents                  | |             val amount = cents                    |
    |         def * (x: Double): Currency = make((this.amount * x).toLong)       |  |         val Cent = make(1)                          | |     val Cent = make(1)                            |
    |         def - (that: Currency): Currency = make(this.amount - that.amount) |  |         val Dollar = make(100)                      | |     val Euro = make(100)                          |
    |         def / (that: Double) = make((this.amount / that).toLong)           |  |         val CurrencyUnit = Dollar                   | |     val CurrencyUnit = Euro                       |
    |         def / (that: Currency) = this.amount.toDouble / that.amount        |  +-----------------------------------------------------+ +---------------------------------------------------+
    |         def from(other: CurrencyZone#AbstractCurrency): Currency =         |  // A converter object with an exchange rates map            +--------------------------------------------------+
    |             make(math.round(other.amount.toDouble * Converter.exchangeRate |  +--------------------------------------------------------+  | scala> val yen = Japan.Yen.from(US.Dollar * 100) |
    |                 (other.designation)(this.designation)))                    |  | object Converter:                                      |  | val yen: Japan.Currency = 10470 JPY              |
    |         private def decimals(n: Long): Int =                               |  |     var exchangeRate =                                 |  | scala> val euros = Europe.Euro.from(yen)         |
    |             if (n == 1) 0 else 1 + decimals(n / 10)                        |  |         Map(                                           |  | val euros: Europe.Currency = 85.03 EUR           |
    |         override def toString =                                            |  |         "USD" -> Map("USD" -> 1.0, "EUR" -> 0.8498,    |  | scala> val dollars = US.Dollar.from(euros)       |
    |             ((amount.toDouble / CurrencyUnit.amount.toDouble)              |  |         "JPY" -> 1.047, "CHF" -> 0.9149),              |  | val dollars: US.Currency = 100.08 USD            |
    |             .formatted(s"%.${decimals(CurrencyUnit.amount)}f")             |  |         "EUR" -> Map("USD" -> 1.177, "EUR" -> 1.0,     |  +--------------------------------------------------+
    |             + " " + designation)                                           |  |         "JPY" -> 1.232, "CHF" -> 1.0765),              |
    |     val CurrencyUnit: Currency                                             |  |         "JPY" -> Map("USD" -> 0.9554, "EUR" -> 0.8121, |  +----------------------------------+
    +----------------------------------------------------------------------------+  |         "JPY" -> 1.0, "CHF" -> 0.8742),                |  | scala> US.Dollar * 100 + dollars |
                                                                                    |         "CHF" -> Map("USD" -> 1.093, "EUR" -> 0.9289,  |  +----------------------------------+
                                                                                    |         "JPY" -> 1.144, "CHF" -> 1.0)                  |
                                                                                    |         )                                              |
                                                                                    +--------------------------------------------------------+


###############
# Givens
###############
    // function may depend on contextual info(syst propd) - functional answer - pass all as params
    // another way - contextual params ("givens") - wyou can leave some arguments relying on compiler to fill values

    -How it works
    // compiler sometimes replaces someCall(a) -> someCall(a)(b)
    // b should be marked as given, param list should begin with using

    // JillsPrefs should be in scope                                    // cannot simply pass param explicitly
    +--------------------------------------------------------------+    +-----------------------------------------------------------------+
    | class PreferredPrompt(val preference: String)                |    | Greeter.greet("Jill")(JillsPrefs.prompt)                        |
    | import JillsPrefs.prompt                                     |    | // method greet in object Greeter does not take more parameters |
    | object Greeter:                                              |    +-----------------------------------------------------------------+
    |     def greet(name: String)(using prompt: PreferredPrompt) = |    // indicate you want to fill in a context parameter explicitly
    |     println(s"Welcome, $name. The system is ready.")         |    +------------------------------------------------+
    |     println(prompt.preference)                               |    | Greeter.greet("Jill")(using JillsPrefs.prompt) |
    | object JillsPrefs:                                           |    +------------------------------------------------+
    |     given prompt: PreferredPrompt =                          |
    |     PreferredPrompt("Your wish> ")                           |    
    +--------------------------------------------------------------+
    // An implicit parameter list with multiple parameters
    +-------------------------------------------------------------------------------------+
    | class PreferredPrompt(val preference: String)                                       |
    | class PreferredDrink(val preference: String)                                        |
    | object Greeter:                                                                     |
    |     def greet(name: String)(using prompt: PreferredPrompt, drink: PreferredDrink) = | // using keyword applies to an entire parameter list, not to individual parameters
    |         println(s"Welcome, $name. The system is ready.")                            | // pass both params explicitly
    |         print("But while you work, ")                                               | +-------------------------------------------+
    |         println(s"why not enjoy a cup of ${drink.preference}?")                     | | Greeter.greet("Joe")(using prompt, drink) |
    |         println(prompt.preference)                                                  | +-------------------------------------------+
    | object JoesPrefs:                                                                   |
    |     given prompt: PreferredPrompt =                                                 |
    |         PreferredPrompt("relax> ")                                                  |
    |     given drink: PreferredDrink =                                                   |
    |         PreferredDrink("tea")                                                       |
    +-------------------------------------------------------------------------------------+

    -Parameterized given types
    // if for insertion sort for list of Ints you will replace Int with T - wont work
    +------------------------------------------------+
    | def isort[T](xs: List[T]): List[T] =           |
    |     if xs.isEmpty then Nil                     |
    |     else insert(xs.head, isort(xs.tail))       |
    | def insert[T](x: T, xs: List[T]): List[T] =    |  // Int class defines a <= method
    |     if xs.isEmpty || x <= xs.head then x :: xs |  // <= not member of T
    |     else xs.head :: insert(x, xs.tail)         |  // 
    +------------------------------------------------+

    // first solution - supply compare function
    +----------------------------------------------------------------------+    +--------------------------------------------------------------------------------------------------------------------------------------+
    | def isort[T](xs: List[T])(lteq: (T, T) => Boolean): List[T] =        |    | isort(List(4, -10, 10))((x: Int, y: Int) => x <= y)                                                                                  |// List(-10, 4, 10)
    |     if xs.isEmpty then Nil                                           |    | isort(List("cherry", "blackberry", "apple", "pear"))((x: String, y: String) => x.compareTo(y) <= 0)                                  |// List(apple, blackberry, cherry, pear)
    |     else insert(xs.head, isort(xs.tail)(lteq))(lteq)                 |    | isort(List(Rational(7, 8), Rational(5, 6), Rational(1, 2)))((x: Rational, y: Rational) =>x.numer * y.denom <= x.denom * y.numer)     |// List(1/2, 5/6, 7/8)
    | def insert[T](x: T, xs: List[T])(lteq: (T, T) => Boolean): List[T] = |    +--------------------------------------------------------------------------------------------------------------------------------------+
    |     if xs.isEmpty || lteq(x, xs.head) then x :: xs                   |
    |     else xs.head :: insert(x, xs.tail)(lteq)                         |
    +----------------------------------------------------------------------+

    // make context parameters
    +-----------------------------------------------------------+   +----------------------------------------------------------------+  
    | trait Ord[T]:                                             |   | def isort[T](xs: List[T])(using ord: Ord[T]): List[T] =        |  
    |     def compare(x: T, y: T): Int                          |   |     if xs.isEmpty then Nil                                     |  
    |     def lteq(x: T, y: T): Boolean = compare(x, y) < 1     |   |     else insert(xs.head, isort(xs.tail))                       |  
    +-----------------------------------------------------------+   | def insert[T](x: T, xs: List[T])(using ord: Ord[T]): List[T] = |  
                                                                    |     if xs.isEmpty || ord.lteq(x, xs.head) then x :: xs         |  
    +---------------------------------------------+                 |     else xs.head :: insert(x, xs.tail)                         |  
    | isort(List(10, 2, -10)) // List(-10, 2, 10) |                 +----------------------------------------------------------------+  
    +---------------------------------------------+
    +--------------------------------------------------------------+    +-----------------------------------------------------------+
    | object Ord:                                                  |    | object Ord:                                               |
    |     // (Not yet idiomatic)                                   |    |     // This is idiomatic                                  |
    |     given intOrd: Ord[Int] =                                 |    |     given intOrd: Ord[Int] with                           |
    |         new Ord[Int]:                                        |    |         def compare(x: Int, y: Int) =                     |
    |             def compare(x: Int, y: Int) =                    |    |             if x == y then 0 else if x > y then 1 else -1 |
    |               if x == y then 0 else if x > y then 1 else -1  |    +-----------------------------------------------------------+
    +--------------------------------------------------------------+
    // With a given Ord[String] declared in the Ord companion, you can now use isort to sort lists of strings
    +-------------------------------------------------------------------------------+   // If a given value does not take parameters, then that given is initialized the first time it’s accessed, similar to a lazy val
    | given stringOrd: Ord[String] with                                             |   // If a given value takes parameters, then a new given is created on every access, much like how a def behaves
    |     def compare(s: String, t: String) = s.compareTo(t)                        |   // Scala compiler transforms givens to lazy vals or defs, additionally marking them as being available for using parameters
    | isort(List("mango", "jackfruit", "durian")) // List(durian, jackfruit, mango) |
    +-------------------------------------------------------------------------------+

    -Anonymous givens
    // compiler looks for givens by type, and you often don’t need to refer to a given’s term at all, you can declare your given value anonymously
    // Instead of                                                   //You can write
    +-------------------------------------------------------------+ +---------------------------------------------------------+
    | given revIntOrd: Ord[Int] with                              | | given Ord[Int] with                                     |
    |     def compare(x: Int, y: Int) =                           | |     def compare(x: Int, y: Int) =                       |
    |         if x == y then 0 else if x > y then -1 else 1       | |         if x == y then 0 else if x > y then -1 else 1   |
    | given revStringOrd: Ord[String] with                        | | given Ord[String] with                                  |
    |     def compare(s: String, t: String) = -s.compareTo(t)     | |     def compare(s: String, t: String) = -s.compareTo(t) |
    +-------------------------------------------------------------+ +---------------------------------------------------------+

    -Parameterized givens as typeclasses
    // enable lists of instances of the Rational class to be sorted by defining a given Ord[Rational]
    +------------------------------------------------------------------+    // An insertion sort function that uses Ordering
    | object Rational:                                                 |    +---------------------------------------------------------------------+
    |     given rationalOrd: Ord[Rational] with                        |    | def isort[T](xs: List[T])(using Ordering[T]): List[T] =             | //  using the Scala Ordering typeclass
    |         def compare(x: Rational, y: Rational) =                  |    |     if xs.isEmpty then Nil                                          |
    |             if x.numer * y.denom < x.denom * y.numer then -1     |    |     else insert(xs.head, isort(xs.tail))                            |
    |             else if x.numer * y.denom > x.denom * y.numer then 1 |    | def insert[T](x: T, xs: List[T])(using ord: Ordering[T]): List[T] = |
    |             else 0                                               |    |     if xs.isEmpty || ord.lteq(x, xs.head) then x :: xs              |
    | isort(List(Rational(4, 5), Rational(1, 2), Rational(2, 3)))      |    |     else xs.head :: insert(x, xs.tail                               |
    | // List(1/2, 2/3, 4/5)                                           |    +---------------------------------------------------------------------+
    +------------------------------------------------------------------+

    // Offering given instances of Ord[T] grants those specific types, T, membership into a set of “types that can be sorted,” 
       despite not sharing any common sortable supertype. This set of types is called a typeclass.

    // Because the isort takes a context parameter of type Ord[T], it is an example of ad hoc polymorphism: 
       isort can sort lists of certain types, T—the types for which given Ord[T] instances exist—and doesn’t compile for any other types

    // A merge sort function that uses Ordering
    +--------------------------------------------------------------+
    | def msort[T](xs: List[T])(using ord: Ordering[T]): List[T] = |    // context parameter of type Ordering[T] provides more information about type T—in this case, how to order Ts
    |     def merge(xs: List[T], ys: List[T]): List[T] =           |
    |         (xs, ys) match                                       |
    |             case (Nil, _) => ys                              |
    |             case (_, Nil) => xs                              |
    |             case (x :: xs1, y :: ys1) =>                     |
    |                 if ord.lt(x, y) then x :: merge(xs1, ys)     |
    |                 else y :: merge(xs, ys1)                     |
    |         val n = xs.length / 2                                |
    |         if n == 0 then xs                                    |
    |         else                                                 |
    |             val (ys, zs) = xs.splitAt(n)                     |
    |             merge(msort(ys), msort(zs))                      |
    +--------------------------------------------------------------+
   
    -Given imports
    // good practice to place givens in singleton objects that will not be found automatically, requiring users to import them
    // regular wildcard import syntax does not import givens
    +---------------------------------------------------------------+    +------------------------------------------------+
    | object TomsPrefs:                                             |    | // imports only favoriteColor and favoriteFood |
    |     val favoriteColor = "blue"                                |    | import TomsPrefs.*                             | // imports all members of TomsPrefs, except given members
    |     def favoriteFood = "steak"                                |    +------------------------------------------------+         +----------------------------------------------------+
    |     given prompt: PreferredPrompt =                           |                                                               | // imports drink, because it a given of            |
    |         PreferredPrompt("enjoy> ")                            |   +-------------------------------------------+               | // type PreferredDrink                             |
    |     given drink: PreferredDrink =                             |   | import TomsPrefs.prompt // imports prompt |               | import TomsPrefs.{given PreferredDrink}            |
    |         PreferredDrink("red wine")                            |   +-------------------------------------------+               | // imports prefPromptOrd and prefDrinkOrd          |
    |     given prefPromptOrd: Ordering[PreferredPrompt] with       |                                                               | import TomsPrefs.{given Ordering[PreferredPrompt], |
    |         def compare(x: PreferredPrompt, y: PreferredPrompt) = |   +-------------------------------------------------------+   | given Ordering[PreferredDrink]}                    |
    |             x.preference.compareTo(y.preference)              |   | // imports prompt, drink, revIntOrd, and revStringOrd |   | // imports prefPromptOrd and prefDrinkOrd          |
    |     given prefDrinkOrd: Ordering[PreferredDrink] with         |   | import TomsPrefs.given                                |   | import TomsPrefs.{given Ordering[?]}               |
    |         def compare(x: PreferredDrink, y: PreferredDrink) =   |   +-------------------------------------------------------+   +----------------------------------------------------+
    |             x.preference.compareTo(y.preference)              |
    +---------------------------------------------------------------+

    -Rules for context parameters
    // Marking rule: Only definitions marked given are available
    +-------------------------------------------------------------+ // compiler will change greet("Amy") to greet("Amy")(amysPrompt)
    | given amysPrompt: PreferredPrompt = PreferredPrompt("hi> ") |    only if amysPrompt is marked as given
    +-------------------------------------------------------------+

    // Visibility rule: An inserted given instance must be in scope as a single identifier, or be associated with a type that is involved in the parameter type
    +------------------------------------------------------------------+
    | object Rational:                                                 |    // If the compiler does not find an applicable given in lexical scope, 
    |     given rationalOrdering: Ordering[Rational] with              |       it will as a second step look for given definitions in the companion object
    |         def compare(x: Rational, y: Rational) =                  |
    |             if x.numer * y.denom < x.denom * y.numer then -1     |
    |             else if x.numer * y.denom > x.denom * y.numer then 1 |
    |             else 0                                               |
    +------------------------------------------------------------------+

    // Explicits-first rule: Whenever code type checks as it is written, no givens are attempted
    // Naming a given
        The name of a given matters only in two situations: If you want to write it explicitly with the using keyword 

    -When multiple givens apply
    +--------------------------------------------------------------+    +--------------------------------------+
    | class PreferredPrompt(val preference: String)                |    | scala> import JillsPrefs.jillsPrompt |    // ambiguous implicit arguments
    | object Greeter:                                              |    | scala> import JoesPrefs.joesPrompt   |
    |     def greet(name: String)(using prompt: PreferredPrompt) = |    +--------------------------------------+
    |         println(s"Welcome, $name. The system is ready.")     |
    |         println(prompt.preference)                           |    // If one of the available givens is strictly more specific than the others, 
    | object JillsPrefs:                                           |       however, then the compiler will choose the more specific one
    |     given jillsPrompt: PreferredPrompt =                     |
    |         PreferredPrompt("Your wish> ")                       |
    | object JoesPrefs:                                            |
    |     given joesPrompt: PreferredPrompt =                      |
    |         PreferredPrompt("relax> ")                           |
    +--------------------------------------------------------------+

    -Debugging givens
    // try passing givens explicitly with using
    // if helps - visibility rule was preventing the given from being used
    // see what givens the compiler is inserting. The -Xprint:typer option to the compiler is useful for this
    +------------------------------------------------------------------+    +-----------------------------------------------------------------+
    | object Mocha:                                                    |    | scalac -Xprint:typer Mocha.scala                                |
    |     class PreferredDrink(val preference: String)                 |    | package <empty> {                                               |
    |     given pref: PreferredDrink = new PreferredDrink("mocha")     |    |     final lazy module val Mocha: Mocha$ = new Mocha$()          |
    |     def enjoy(name: String)(using drink: PreferredDrink): Unit = |    |         def callEnjoy: Unit = Mocha.enjoy("reader")(Mocha.pref) |
    |         print(s"Welcome, $name")                                 |    |     final module class Mocha$() extends Object() {              |
    |         print(". Enjoy a ")                                      |    |         this: Mocha.type =>                                     |
    |         print(drink.preference)                                  |    |       // ...                                                    |
    |         println("!")                                             |    |       final lazy given val pref: Mocha.PreferredDrink =         |
    |     def callEnjoy: Unit = enjoy("reader")                        |    |             new Mocha.PreferredDrink("mocha")                   |
    +------------------------------------------------------------------+    |       def enjoy(name: String)(using drink:                      |
                                                                            |             Mocha.PreferredDrink): Unit = {                     |
                                                                            |           print(                                                |
                                                                            |             _root_.scala.StringContext.apply(["Welcome,         |
                                                                            |                 ","" : String]:String*).s([name : Any]:Any*)    |
                                                                            |           )                                                     |
                                                                            |           print(". Enjoy a ")                                   |
                                                                            |           print(drink.preference)                               |
                                                                            |           println("!")                                          |
                                                                            |         }                                                       |
                                                                            |         def callEnjoy: Unit = Mocha.enjoy("reader")(Mocha.pref) |
                                                                            |     }                                                           |
                                                                            | }                                                               |
                                                                            +-----------------------------------------------------------------+


###############
# Extension Methods
###############
    -The basics
    // function that will perform this transformation:  // One can use it like this                     // can we invoke method directly on Strings, like this?:
    +----------------------------------------+          +------------------------------------------+    +----------------------------------------------------------+
    | def singleSpace(s: String): String =   |          | singleSpace(s) == singleSpace(t) // true |    | s.singleSpace == t.singleSpace // if only this were true |
    |     s.trim.split("\\s+").mkString(" ") |          +------------------------------------------+    +----------------------------------------------------------+
    +----------------------------------------+
    // defining singleSpace as an extension method
    +--------------------------------------------+
    | extension (s: String)                      |  // extension keyword allows you to create the illusion that you’ve added a member function to a class 
    |     def singleSpace: String =              |     without changing the class itself
    |         s.trim.split("\\s+").mkString(" ") |  // (s: String) - receiver of the extension method (means that you want to add the method to String)
    +--------------------------------------------+      // extension method definitions are rewritten in place to methods that take the receiver directly as a parameter
    +----------------------------------------------+    +----------------------------------------+
    | s.singleSpace == t.singleSpace // It's true! |    | // With internal extension marker      |  // compiler gives it an internal marker identifying it as an extension method
    +----------------------------------------------+    | def singleSpace(s: String): String =   |  // if singleSpace is in lexical scope, and is internally marked as an extension method, it can be applied
                                                        |     s.trim.split("\s+").mkString(" ")  |
                                                        +----------------------------------------+

    -Generic extensions
    // list has head and headOption methods                     // list has only tail method, no tailOption
    +------------------------------------------------------+    +--------------------------------------------------+
    | List(1, 2, 3).head  // 1                             |    | List(1, 2, 3).tail // List(2, 3)                 |
    | List.empty.head     // throws NoSuchElementException |    | List.empty.tail // throws NoSuchElementException |
    | List(1, 2, 3).headOption    // Some(1)               |    +--------------------------------------------------+
    | List.empty.headOption       // None                  |
    +------------------------------------------------------+
    // if you eant tailOption - you could provide it as a generic extension
    +-----------------------------------------------------+ +----------------------------------------------------+  +----------------------------------------------------+
    | extension [T](xs: List[T])                          | | List(1, 2, 3).tailOption // Some(List(2, 3))       |  | tailOption[Int](List(1, 2, 3)) // Some(List(2, 3)) |
    |     def tailOption: Option[List[T]] =               | | List.empty[Int].tailOption // None                 |  +----------------------------------------------------+
    |         if xs.nonEmpty then Some(xs.tail) else None | | List("A", "B", "C").tailOption // Some(List(B, C)) |
    +-----------------------------------------------------+ | List.empty[String].tailOption // None              |
                                                            +----------------------------------------------------+

    -Collective extensions
    // When you want to add multiple methods to the same type, you can define them together with a collective extension
    // smallest expressible negative integer is one less than the negation of the largest expressible positive integer
    +-----------------------------+
    | Int.MaxValue // 2147483647  | // Some methods on Int can overflow precisely because of this asymmetry between maximum and minimum values
    | Int.MinValue // -2147483648 | // Int’s abs method computes the absolute value of the integer
    +-----------------------------+ // absolute value of Int’s minimum value is the 2147483648, but that integer is not expressible as an Int
    +--------------------------------------------+
    | Int.MinValue.abs // -2147483648 (overflow) |  // Int’s maximum value, 2147483647, is one less, invoking abs on Int.MinValue overflows and you get back the original MinValue
    +--------------------------------------------+
    // method that returns the absolute value of an Int, but detects overflow   +---------------------------------------------+
    +---------------------------------------------------------+                 | 42.absOption            // Some(42)         |
    | extension (n: Int)                                      |                 | -42.absOption           // Some(42)         |
    |     def absOption: Option[Int] =                        |                 | Int.MaxValue.absOption  // Some(2147483647) |
    |         if n != Int.MinValue then Some(n.abs) else None |                 | Int.MinValue.absOption  // None             |
    +---------------------------------------------------------+                 +---------------------------------------------+
    // sibling methods
    +---------------------------------------------------------+
    | extension (n: Int)                                      |
    |     def isMinValue: Boolean = n == Int.MinValue         |
    |     def absOption: Option[Int] =                        | // Another operation that can overflow at the minimum Int value is negation
    |         if !isMinValue then Some(n.abs) else None       | +-----------------------------------------+ +--------------------------------------------------+
    |     def negateOption: Option[Int] =                     | | -Int.MinValue // -2147483648 (overflow) | | -42.negateOption            // Some(42)          |
    |         if !isMinValue then Some(-n) else None          | +-----------------------------------------+ | 42.negateOption             // Some(-42)         |
    |     def isMinValue(n: Int): Boolean = n == Int.MinValue |                                             | Int.MaxValue.negateOption   // Some(-2147483647) |
    |     def absOption(n: Int): Option[Int] =                |                                             | Int.MinValue.negateOption   // None              |
    |         if !n.isMinValue then Some(n.abs) else None     |                                             +--------------------------------------------------+
    |     def negateOption(n: Int): Option[Int] =             |
    |         if !n.isMinValue then Some(-n) else None        |
    +---------------------------------------------------------+

    -Using a typeclass
    // Any integral type that is based on twoscomplement arithmetic exhibits this same overflow issue
    // you could define a separate collective extension for each
    // you could instead define an extension enabled by a typeclass. 
    // Such an ad hoc extension would work for any type with a given instance of that typeclass
    +--------------------------------------------------------+
    | Long.MinValue.abs   // -9223372036854775808 (overflow) |
    | -Long.MinValue      // -9223372036854775808 (overflow) |
    | Short.MinValue.abs  // -32768 (overflow)               |
    | -Short.MinValue     // -32768 (overflow)               |
    | Byte.MinValue.abs   // -128 (overflow)                 |
    | -Byte.MinValue      // -128 (overflow)                 |
    +--------------------------------------------------------+
    // define a new typeclass trait specifically for twos-complement integral types
    +------------------------------------------------------------+
    | trait TwosComplement[N]:                                   |  // Using a typeclass in an extension.
    |     def equalsMinValue(n: N): Boolean                      |  +--------------------------------------------------------------+
    |     def absOf(n: N): N                                     |  | extension [N](n: N)(using tc: TwosComplement[N])             |
    |     def negationOf(n: N): N                                |  |     def isMinValue: Boolean = tc.equalsMinValue(n)           |
    | object TwosComplement:                                     |  |     def absOption: Option[N] =                               |
    |     given tcOfByte: TwosComplement[Byte] with              |  |         if !isMinValue then Some(tc.absOf(n)) else None      |
    |         def equalsMinValue(n: Byte) = n == Byte.MinValue   |  |     def negateOption: Option[N] =                            |
    |         def absOf(n: Byte) = n.abs                         |  |         if !isMinValue then Some(tc.negationOf(n)) else None |
    |         def negationOf(n: Byte) = (-n).toByte              |  +--------------------------------------------------------------+
    |     given tcOfShort: TwosComplement[Short] with            |
    |         def equalsMinValue(n: Short) = n == Short.MinValue |  +----------------------------------------------------+
    |         def absOf(n: Short) = n.abs                        |  | Byte.MaxValue.negateOption // Some(-127)           |
    |         def negationOf(n: Short) = (-n).toShort            |  | Byte.MinValue.negateOption // None                 |
    |     given tcOfInt: TwosComplement[Int] with                |  | Long.MaxValue.negateOption // -9223372036854775807 |
    |         def equalsMinValue(n: Int) = n == Int.MinValue     |  | Long.MinValue.negateOption // None                 |
    |         def absOf(n: Int) = n.abs                          |  +----------------------------------------------------+
    |         def negationOf(n: Int) = -n                        |
    |     given tcOfLong: TwosComplement[Long] with              |
    |         def equalsMinValue(n: Long) = n == Long.MinValue   |
    |         def absOf(n: Long) = n.abs                         |
    |         def negationOf(n: Long) = -n                       |
    +------------------------------------------------------------+

    -Extension methods for givens
    // purpose of the TwosComplement typeclass is to achieve the design goal of enabling extension methods on a specific set of types
    // Placing extension methods in a singleton
    +------------------------------------------------------------------+    +----------------------------+  // extension methods represent the main design goal 
    | object TwosComplementOps:                                        |    | import TwosComplementOps.* |     and the typeclass plays a supporting role
    |     extension [N](n: N)(using tc: TwosComplement[N])             |    | -42.absOption // Some(42)  |
    |         def isMinValue: Boolean = tc.equalsMinValue(n)           |    +----------------------------+
    |         def absOption: Option[N] =                               |    // typeclass is the main goal and extension methods play a supporting role of making the typeclass easier to use
    |             if !isMinValue then Some(tc.absOf(n)) else None      |    // In such situations, the best home for the extension methods is in the typeclass trait itself
    |         def negateOption: Option[N] =                            |
    |             if !isMinValue then Some(tc.negationOf(n)) else None |    // Ord[T] knows how to compare two instances of type T to determine whether one is greater than other
    +------------------------------------------------------------------+

    +----------------------------------------------------------------+
    | def insert[T](x: T, xs: List[T])(using ord: Ord[T]): List[T] = |
    |     if xs.isEmpty || ord.lteq(x, xs.head) then x :: xs         |  // nothing wrong with “ord.lteq(x, x.head)”, but a more natural way to write this would be:
    |     else xs.head :: insert(x, xs.tail)                         |     x <= x.head // Ah, the clarity!
    +----------------------------------------------------------------+
    // enable such <= syntactic sugar
    // Placing extensions for Ord in a singleton
    +-------------------------------------------------------+    +-----------------------------------------------------------+
    | // (Not yet the best design)                          |    | def insert[T](x: T, xs: List[T])(using Ord[T]): List[T] = |
    | object OrdOps:                                        | -> |     import OrdOps.*                                       |
    |     extension [T](lhs: T)(using ord: Ord[T])          |    |     if xs.isEmpty || x <= xs.head then x :: xs            |
    |         def < (rhs: T): Boolean = ord.lt(lhs, rhs)    |    |     else xs.head :: insert(x, xs.tail)                    |
    |         def <= (rhs: T): Boolean = ord.lteq(lhs, rhs) |    +-----------------------------------------------------------+
    |         def > (rhs: T): Boolean = ord.gt(lhs, rhs)    |
    |         def >= (rhs: T): Boolean = ord.gteq(lhs, rhs) |
    +-------------------------------------------------------+
    // Placing an extension in a typeclass trait
    // extension methods will be available wherever a given instance 
       of the typeclass is being used                                   // no need for import                                           // Typeclass extensions as rewritten by the compiler
    +--------------------------------------------------------+          +-----------------------------------------------------------+   +--------------------------------------------------------+
    | trait Ord[T]:                                          |          | def insert[T](x: T, xs: List[T])(using Ord[T]): List[T] = |   | trait Ord[T]:                                          |
    |     def compare(x: T, y: T): Int                       |          |     if xs.isEmpty || x <= xs.head then x :: xs            |   |     def compare(x: T, y: T): Int                       |
    |     def lt(x: T, y: T): Boolean = compare(x, y) < 0    |          |     else xs.head :: insert(x, xs.tail)                    |   |     def lt(x: T, y: T): Boolean = compare(x, y) < 0    |
    |     def lteq(x: T, y: T): Boolean = compare(x, y) <= 0 |          +-----------------------------------------------------------+   |     def lteq(x: T, y: T): Boolean = compare(x, y) <= 0 |
    |     def gt(x: T, y: T): Boolean = compare(x, y) > 0    |                                                                          |     def gt(x: T, y: T): Boolean = compare(x, y) > 0    |
    |     def gteq(x: T, y: T): Boolean = compare(x, y) >= 0 |                                                                          |     def gteq(x: T, y: T): Boolean = compare(x, y) >= 0 |
    |     // (This is the best design)                       |                                                                          |     // With internal extension markers:                |
    |         extension (lhs: T)                             |                                                                          |     def < (lhs: T)(rhs: T): Boolean = lt(lhs, rhs)     |
    |             def < (rhs: T): Boolean = lt(lhs, rhs)     |                                                                          |     def <= (lhs: T)(rhs: T): Boolean = lteq(lhs, rhs)  |
    |             def <= (rhs: T): Boolean = lteq(lhs, rhs)  |                                                                          |     def > (lhs: T)(rhs: T): Boolean = gt(lhs, rhs)     |
    |             def > (rhs: T): Boolean = gt(lhs, rhs)     |                                                                          |     def >= (lhs: T)(rhs: T): Boolean = gteq(lhs, rhs)  |
    |             def >= (rhs: T): Boolean = gteq(lhs, rhs)  |                                                                          +--------------------------------------------------------+
    +--------------------------------------------------------+

    -Where Scala looks for extension methods
    // first checks to see if that method is defined on the object’s class itself
    // Otherwise, the method call is a candidate compiler error
    // compiler will search for an extension method or implicit conversion that will heal the candidate error
    // extension method search phases:
    // 1. compiler looks in lexical scope
    // 2. looks in three places: at the members of given instances in lexical scope; at the members of the companion objects of the receiver’s class, superclasses, and supertraits
    // if more than one applicable extension method - will choose one that is more specific


###############
# Typeclasses
###############
    // if you need to write function that implements behaviour usefull for some types but not other. Options:
    // 1. define overloaded methods
    // 2. require class of any instance mixes in trait
    // 3. more flexible - define a typeclass, write function to work with types for which a given instance of typeclass trait is defined

    - Why typeclasses
    +-----------------------------------+   // typeclass grouping or set of types
    | abstract def -(x: Double): Double |   // typeclasses support ad hoc polymorphism - functions can be used with a particular, enumerated set of types
    | abstract def -(x: Float): Float   |   // ad hoc polymorphism - "-", "+" can be used with certain types
    | abstract def -(x: Long): Long     |   // pass instances of seven specific types to Int’s minus method
    | abstract def -(x: Int): Int       |   // think of these seven types as a grouping or set of types accepted by the minus method
    | abstract def -(x: Char): Int      |
    | abstract def -(x: Short): Int     |
    | abstract def -(x: Byte): Int      |
    +-----------------------------------+                                                                                                                      
                                                                                                                      
    // Another way to achieve polymorphism in Scala is with a class hierarchy
    +-----------------------------------+   +-----------------------------------+
    | sealed trait RainbowColor         |   | def paint(rc: RainbowColor): Unit |
    | class Red extends RainbowColor    |   +-----------------------------------+
    | class Orange extends RainbowColor |   // subtyping polymorphism - all the instances passed to the paint method must mix in trait RainbowColor and adhere any constraints established by its interface
    | class Yellow extends RainbowColor |   // subtyping enables polymorphism of related types
    | class Green extends RainbowColor  |   // contrast - types accepted by Int’s "-" method, need not adhere to any common interface
    | class Blue extends RainbowColor   |   // ad hoc polymorphism approaches such as overloading and typeclasses enable polymorphism of unrelated types
    | class Indigo extends RainbowColor |
    | class Violet extends RainbowColor |   // if you mix the Ordered trait into a class and implement the abstract compare method, you inherit implementations of <, >, <=, and >=
    +-----------------------------------+      limitation - every T you pass must mix in Ordered[T]. Class could already have other compare method, variance conflict
                                               +-------------------------------------------------------+
                                               | class Hope[+T <: Ordered[T]] extends Ordered[Hope[T]] |   // covariant type T occurs in invariant position in type
                                               +-------------------------------------------------------+
    // Typeclasses solve this problem by defining a separate hierarchy focused on the general concept (serialization or ordering)
    // typeclass instance uses a type parameter to indicate the type for which it is providing a service - no need to change a type to provide the service for that type
    // can easily define given typeclass instances for types that reside in libraries that you can’t change

    // A given Ordering instance for Hope[T]
    +---------------------------------------------------------------------------+
    | import org.stairwaybook.hope.Hope                                         |   // defines a focused hierarchy devoted to ordering, separate from the types being ordered
    | object HopeUtils:                                                         |   // although you can’t mix Ordered into Hope, you can define a given instance of Ordering for Hope. works despite Hope being in a library you can’t change
    |     given hopeOrdering[T](using ord: Ordering[T]): Ordering[Hope[T]] with |   // set of all types T for which given instances of Ordering[T] are defined
    |         def compare(lh: Hope[T], rh: Hope[T]): Int =                      |   //  standard library provides given instances of Ordered for many types (Int, String, etc)
    |             import Hope.{Glad, Sad}                                       |   // adds to the Ordering typeclass types of the form Hope[T] for all types T that are also members of the typeclass
    |             (lh, rh) match                                                |   // Typeclasses support ad hoc polymorphism, because you can write functions that can be used only with types for which given instances of a particular typeclass exists
    |                 case (Sad, Sad) => 0                                      |
    |                 case (Sad, _) => -1                                       |
    |                 case (_, Sad) => +1                                       |
    |                 case (Glad(lhv), Glad(rhv)) =>                            |
    |                     ord.compare(lhv, rhv)                                 |
    +---------------------------------------------------------------------------+

    // typeclasses address the problem that it is difficult, inconvenient, or impossible to jam all services involving a type into the class hierarchy of that type
    // typeclass approach allows you to instead use a second, separate hierarchy focused just on providing the service

    - Context bounds
    // A function with a using parameter.
    +------------------------------------------------------------------------------+
    | def maxList[T](elements: List[T])                                            |
    |     (using ordering: Ordering[T]): T =                                       |    // using parameter used to provide more information about a type mentioned explicitly in an earlier parameter list
    |         elements match                                                       |       in this case, how to order Ts
    |             case List() => throw new IllegalArgumentException("empty list!") |    // compiler will know T at compile time and can therefore determine whether a given definition of type Ordering[T] is available
    |             case List(x) => x                                                |
    |             case x :: rest =>                                                |
    |                 val maxRest = maxList(rest)(using ordering)                  |
    |                 if ordering.gt(x, maxRest) then x                            |
    |                 else maxRest                                                 |
    +------------------------------------------------------------------------------+
    // A function that uses a using parameter internally                                // A function with a context bound
    +------------------------------------------------------------------------------+    +--------------------------------------------------------------------------+
    | def maxList[T](elements: List[T])                                            |    | def maxList[T : Ordering](elements: List[T]): T =                        |
    |     (using ordering: Ordering[T]): T =                                       |    |     elements match                                                       |
    |         elements match                                                       |    |         case List() => throw new IllegalArgumentException("empty list!") |
    |             case List() => throw new IllegalArgumentException("empty list!") |    |         case List(x) => x                                                |
    |             case List(x) => x                                                |    |         case x :: rest =>                                                |
    |             case x :: rest =>                                                |    |             val maxRest = maxList(rest)                                  |
    |                 val maxRest = maxList(rest)   // Uses the given              |    |             if summon[Ordering[T]].gt(x, maxRest) then x                 |    
    |                 if ordering.gt(x, maxRest) then x                            |    |             else maxRest                                                 |
    |                 else maxRest                                                 |    +--------------------------------------------------------------------------+
    +------------------------------------------------------------------------------+    // Scala lets you leave out the name of this parameter and shorten the method header with a context bound

    +-------------------------------+   // effect of calling summon[Foo] is that the compiler will look for a given definition of type Foo
    | def summon[T](using t: T) = t |      will then call the summon method with that object
    +-------------------------------+
    // you are not so much saying what T is; rather, you are saying that there is some form of ordering associated with T
    +----------------+  // context bound                                                +-------------------+
    | [T : Ordering] |  //  First, it introduces a type parameter T as normal           | [T <: Ordered[T]] |   // you are saying that a T is an Ordered[T]
    +----------------+  // Second, it adds a using parameter of type Ordering[T]        +-------------------+
    
    -Main methods  
    // file: echoargs.scala                                                                 // Scala main canly accept any number and types of arguments.
    +---------------------------------+ // execute as a script                              +-----------------------------------------------------------------+
    | @main def echo(args: String*) = | // $ scala echoargs.scala Running as a script       | // In file repeat.scala                                         |
    |     println(args.mkString(" ")) | // Running as a script                              | @main def repeat(word: String, count: Int) =                    |
    +---------------------------------+                                                     |     val msg =                                                   |
                                                                                            |         if count > 0 then                                       |
    // alternative execution as application - compile,                                      |             val words = List.fill(count)(word)                  |
       start main                                                                           |             words.mkString(" ")                                 |
    +----------------------------------------+                                              |         else                                                    |
    | $ scalac echoargs.scala                |                                              |             "Please enter a word and a positive integer count." |
    | $ scala echo Running as an application |                                              |     println(msg)                                                |
    | Running as an application              |                                              |                                                                 |
    +----------------------------------------+                                              | $ scalac repeat.scala                                           |
                                                                                            | $ scala repeat hello 3                                          |
    // How does Scala know how to turn the command line string "3" into an Int 3?           | hello hello hello                                               |
    // It uses a typeclass named FromString, which is member of scala.util.CommandLineParser+-----------------------------------------------------------------+
    // The FromString typeclass trait                   // magine wanted enhance repeat main with a third command line param - "mood"
    +--------------------------------------+            +-----------------------------------+
    | trait FromString[T]:                 |            | // In file moody.scala            |
    |     def fromString(s: String): T     |            | enum Mood:                        |
    +--------------------------------------+            |     case Surpised, Angry, Neutral |
    //A main method that takes a custom type            +-----------------------------------+
    +-----------------------------------------------------------------------+       // teach compiler to transform command line argument to mood
    | // In file moody.scala                                                |       // lets do it in mood companion object
    | val errmsg = "Please enter a word, a positive integer count, and\n" + |       // A given FromString instance for Mood
    |     "and a mood (one of 'angry', 'surprised', or 'neutral')"          |       +----------------------------------------------------------------------+    +----------------------------------+
    | @main def repeat(word: String, count: Int, mood: Mood) =              |       | // In file moody.scala                                               |    | $ scalac moody.scala             |
    |     val msg =                                                         |       | object Mood:                                                         |    | $ scala repeat hello 3 neutral   |
    |         if count > 0 then                                             |       |     import scala.util.CommandLineParser.FromString                   |    | hello hello hello                |
    |             val words = List.fill(count)(word.trim)                   |       |     given moodFromString: FromString[Mood] with                      |    | $ scala repeat hello 3 surprised |
    |             val punc =                                                |       |         def fromString(s: String): Mood =                            |    | hello? hello? hello?             |
    |                 mood match                                            |       |             s.trim.toLowerCase match                                 |    | $ scala repeat hello 3 angry     |
    |                     case Mood.Angry => "!"                            |       |                 case "angry" => Mood.Angry                           |    | hello! hello! hello!             |
    |                     case Mood.Surprised => "?"                        |       |                 case "surprised" => Mood.Surprised                   |    +----------------------------------+
    |                     case Mood.Neutral => ""                           |       |                 case "neutral" => Mood.Neutral                       |
    |             val sep = punc + " "                                      |       |                 case _ => throw new IllegalArgumentException(errmsg) |
    |             words.mkString(sep) + punc                                |       +----------------------------------------------------------------------+
    |         else errmsg                                                   |
    |     println(msg)                                                      |
    +-----------------------------------------------------------------------+
   
    - Multiversal equality
    // in Scala 2 you could compare a string and an option for equality
    +---------------------------------------------------+
    | scala> "hello" == Option("hello") // (in Scala 2) |   // Values of types String and Option[String] cannot be compared with == or !=
    | val res0: Boolean = false                         |   // Scala 3 achieves this improvement in safety through a new feature called multiversal equality
    +---------------------------------------------------+
    // how it worked on JVM with Scala 2 when compiler encountered an invocation of == or !=:
    // 1. checked whether types compared were Java primitive types
          if yes - compiler emmited special Java bytecode for efficient comparison
          if one side only is primitive - it would box it
    // 2. if both sides are refs:
          compiler emmited code to identify if left side is null
          compiler emmited code to identify if right side is null, ensuring that invocatin of == could not throw NullPointException
    // 3. calls equals on left side passing right operand (knowing its not null)          

    // Scala 3 compiler performs the exact same steps as Scala 2 - after making sure comparison should be allowed by looking for a given instance of 
    +-------------------------------+   // CanEqual just gives permission to use == and != for an equality comparison of types L and R
    | sealed trait CanEqual[-L, -R] |   // is contravariant in both params, because of this type CanEqual[Any, Any] is a subtype of any other type
    +-------------------------------+
    // if a given instance of CanEqual[Int, Int] is needed to permit an equality comparison of two Ints, 
       a given instance of CanEqual[Any, Any] will suffice, because CanEqual[Any, Any] is a subtype of CanEqual[Int, Int]
    +-----------------------------------------------+
    | object CanEqual:                              |   // Because of this fact, CanEqual is defined as a sealed trait with just one instance, 
    |     object derived extends CanEqual[Any, Any] |      which has the universally applicable type CanEqual[Any, Any]
    +-----------------------------------------------+
    // example
    // works be default in Scala 3 because types are same   // but because also by default Scala 3 compiler will allow comparison of types
    +------------------------------------+                     for which no given reflexive CanEqual instance exists, following would still compile
    | case class Apple(size: Int)        |                      +--------------------------------+
    | val appleTwo = Apple(2)            |                      | case class Orange(size: Int)   |
    | val appleTwoToo = Apple(2)         |                      | val orangeTwo = Orange(2)      |
    | appleTwo == appleTwoToo // true    |                      | appleTwo == orangeTwo // false |
    +------------------------------------+                      +--------------------------------+
    // in Scala 3, even if no reflexive instances have been defined for the involved types, you can enable "strict equality"
    or
    +--------------------------------------+
    | import scala.language.strictEquality |
    +--------------------------------------+
    // you will get
    // Values of types Apple and Orange cannot be   // unfortunetely same for Apples
       compared with == or !=
    +------------------------------+                +--------------------------------+
    | scala> appleTwo == orangeTwo |                | scala> appleTwo == appleTwoToo |
    +------------------------------+                +--------------------------------+
    // to fix apples comparison under strict equality               // or
    // An explicit CanEqual provider (not idiomatic) (23.11)        // Offering CanEqual through a derives clause.
    +------------------------------------------------------------+  +-----------------------------------------------------------+
    | case class Apple(size: Int)                                |  | case class Apple(size: Int) derives CanEqual // idiomatic |   // typeclass derivation
    | object Apple:                                              |  +-----------------------------------------------------------+
    |     given canEq: CanEqual[Apple, Apple] = CanEqual.derived |  // feature that allows you to delegate the definition of a given typeclass instance to a member, named derived, in the typeclass’s companion object
    +------------------------------------------------------------+  // derives clause will cause the compiler to insert a given provider in Apple’s companion object such as the one shown in 23.11

    - Implicit conversions
    // Scala’s standard library defines an implicit conversion from Int to Long
    // if you pass Int where Long is expected - compiler will transform Int to Long automatically
    // Note that Int can be safely converted to Long

    // implicit conversions fell out of favor because they made code more obscure by removing explicitness
    // Scala 3 alternatives: extension methods and context parameters
    // few use cases remain for implicit conversions, they are still supported, but will give compiler warning

    // how implicits work
    // whenever the compiler sees an X, but needs a Y, it will look for an implicit conversion that converts X to Y
    // example
    +------------------------------------+
    | case class Street(value: String)   |
    | val street = Street("123 Main St") |
    | val streetStr: String = street     |  // wont work
    +------------------------------------+  // but this will: // val streetStr: String = street.value
    // if you dont want to call street.value - offer an implicit conversion from Street to String
    //accomplish this in Scala 3 by defining a given instance of type Conversion[Street, String]
    +-----------------------------------------------------+ // implicit conversion from Street to String
    | abstract class Conversion[-T, +U] extends (T => U): | +------------------------------------------------------------+
    |     def apply(x: T): U                              | | given streetToString: Conversion[Street, String] = _.value |
    +-----------------------------------------------------+ +------------------------------------------------------------+
    // to use implicit conversions without warnings 
        -language:implicitConversions compiler option
        or
        import scala.language.implicitConversions
    // then this should work
                                        // will be rewritten if implicit conversion is available
    +--------------------------------+  +------------------------------------------------+
    | val streetStr: String = street |  | val streetStr: String = streetToString(street) |
    +--------------------------------+  +------------------------------------------------+


###############
# Collections in Depth
###############
    -Mutable and immutable collections
    // three variants are located in packages scala.collection, scala.collection.immutable, and scala.collection.mutable

    -Collections consistency
    +------------------------------------------+
    | Traversable(1, 2, 3)                     |
    | Iterable("x", "y", "z")                  |
    | Map("x" -> 24, "y" -> 25, "z" -> 26)     |
    | Set(Color.Red, Color.Green, Color.Blue)  |
    | SortedSet("hello", "world")              |
    | Buffer(x, y, z)                          |
    | IndexedSeq(1.0, 2.0)                     |
    | LinearSeq(a, b, c)                       |
    | List(1, 2, 3)                            |
    | HashMap("x" -> 24, "y" -> 25, "z" -> 26) |
    +------------------------------------------+

    //
    Traversable
        Iterable
    +------------------------------+    +--------------------------------------+    +--------------------------------------+
    | Seq                          |    | Set                                  |    | Map                                  |
    |     IndexedSeq               |    |     SortedSet                        |    |     SortedMap                        |
    |         ArraySeq             |    |         TreeSet                      |    |         TreeMap                      |
    |         Vector               |    |     HashSet (mutable)                |    |     HashMap (mutable)                |
    |         ArrayDeque (mutable) |    |     LinkedHashSet                    |    |     LinkedHashMap (mutable)          |
    |         Queue (mutable)      |    |     HashSet (immutable)              |    |     HashMap (immutable)              |
    |         Stack (mutable)      |    |     BitSet                           |    |     VectorMap (immutable)            |
    |         Range                |    |     EmptySet, Set1, Set2, Set3, Set4 |    |     EmptyMap, Map1, Map2, Map3, Map4 |
    |         NumericRange         |    +--------------------------------------+    +--------------------------------------+
    |     LinearSeq                |
    |         List                 |
    |         LazyList             |
    |         Queue (immutable)    |
    |     Buffer                   |
    |         ListBuffer           |
    |         ArrayBuffer          |
    +------------------------------+

    - Trait Iterable
    // Iteration                                                // Addition
    +--------------------------------------------------------+  +---------------------------+
    |     //Executes function f for every element of xs. The |  |     // combines xs and ys |
    |     //invocation of f is done for its side effect only |  | xs ++ ys                  |
    | xs.foreach(f)                                          |  | xs.concat(ys)             |
    |                                                        |  +---------------------------+
    |     //yields fixed-sized “chunks” of collection        |  // Abstract method
    | xs.grouped(size)                                       |  +------------------------------------+
    |                                                        |  |     //  yields every element in xs |
    |     // yields a sliding fixed-sized window of elements |  | xs.iterator                        |
    | xs.sliding(size)                                       |  +------------------------------------+
    +--------------------------------------------------------+

    // Size info                                                    // Maps                                                                 // Conversions
    +-----------------------------------------------------------+   +------------------------------------------------------------------+    +------------------+
    | xs.isEmpty                                                |   |     // new collection applying                                   |    | xs.toArray       |
    | xs.nonEmpty                                               |   |     // function f to every element in xs                         |    | xs.toList        |
    | xs.size                                                   |   | xs.map(f)                                                        |    | xs.toIterable    |
    |                                                           |   |                                                                  |    | xs.toSeq         |
    |     // number of elements if it can be computed in        |   |     // new collection made by applying the                       |    | xs.toIndexedSeq  |
    |     // constant time, else -1                             |   |     // collection-valued function f to every element in          |    | xs.toSet         |
    | xs.knownSize                                              |   |     // xs and concatenating the results                          |    | xs.toMap         |
    |                                                           |   | xs.flatMap(f)                                                    |    | xs.to(SortedSet) |
    |     // negative value if xs is shorter than the           |   |                                                                  |    +------------------+
    |     // ys collection, a positive value if it is longer    |   |     // collection obtained from applying the partial             |
    | xs.sizeCompare(ys)                                        |   |     // function f to every element in xs for which it is defined |
    |                                                           |   | xs.collect(f)                                                    |
    |     // Compares the size of the collection with the given |   +------------------------------------------------------------------+
    |     // value while traversing as few elements as possible |
    | xs.sizeIs < 42                                            |
    | xs.sizeIs != 42                                           |
    +-----------------------------------------------------------+

    // Subcollections                                                       // Element retrieval:
    +------------------------------------------------------------------+    +-------------------------------------------------------+
    |     // rest of the collection except xs.head.                    |    |     // first element of the collection                |
    | xs.tail                                                          |    | xs.head                                               |
    |                                                                  |    |                                                       |
    |     // rest of the collection except xs.last.                    |    |     // first element of xs in an option value         |
    | xs.init                                                          |    | xs.headOption                                         |
    |                                                                  |    |                                                       |
    |     // collection consisting of elements in some index           |    |     // last element of the collection                 |
    |     // range of xs (from from, up to and excluding to)           |    | xs.last                                               |
    | xs.slice(from, to)                                               |    |                                                       |
    |                                                                  |    |     // last element of xs in an option value          |
    |     // collection consisting of the first n elements of xs       |    | xs.lastOption                                         |
    | xs.take(n)                                                       |    |                                                       |
    |                                                                  |    |     // option containing the first element in xs that |
    |     // rest of the collection except xs.take(n)                  |    |     // satisfies p                                    |
    | xs.drop(n)                                                       |    | xs.find(p)                                            |
    |                                                                  |    +-------------------------------------------------------+
    |     // longest prefix of elements in the collection              |    // Zippers
    |     // that all satisfy p                                        |    +-----------------------------------------------------------------+
    | xs.takeWhile(p)                                                  |    |     // iterable of pairs of corresponding elements              |
    |                                                                  |    |     // from xs and ys                                           |
    |     // collection without the longest prefix of                  |    | xs.zip(ys)                                                      |
    |     // elements that all satisfy p                               |    |                                                                 |
    | xs.dropWhile(p)                                                  |    |     // value providing methods for manipulating the             |
    |                                                                  |    |     // xs and ys collections element-wise                       |
    |     // collection consisting of the last n elements of xs        |    | xs.lazyZip(ys)                                                  |
    | xs.takeRight(n)                                                  |    |                                                                 |
    |                                                                  |    |     // iterable of pairs of corresponding elements from         |
    |     // rest of the collection except xs.takeRight(n)             |    |     // xs and ys, where the shorter sequence is extended to     |
    | xs.dropRight(n)                                                  |    |     // match the longer one by appending elements x or y        |
    |                                                                  |    | xs.zipAll(ys, x, y)                                             |
    |     // collection consisting of those elements of xs             |    |                                                                 |
    |     // that satisfy the predicate p                              |    |     // iterable of pairs of elements from xs with their indices |
    | xs.filter(p)                                                     |    | xs.zipWithIndex                                                 |
    |                                                                  |    +-----------------------------------------------------------------+
    |     // non-strict filter of this collection                      |    // Strings
    |     // All operations on the resulting filter will only apply    |    +--------------------------------------------+
    |     // to those elements of xs for which the condition p is true |    |     // Adds a string to StringBuilder b    |
    | xs.withFilter(p)                                                 |    | xs.addString(b, start, sep, end)           |
    |                                                                  |    |                                            |
    |     // collection consisting of those elements of xs             |    |     // Converts the collection to a string |
    |     that do not satisfy the predicate p                          |    | xs.mkString(start, sep, end)               |
    | xs.filterNot(p)                                                  |    +--------------------------------------------+
    +------------------------------------------------------------------+

    // Subdivisions                                                             // Element conditions:
    +----------------------------------------------------------------------+    +---------------------------------------------------+
    |     // Splits xs at a position, giving the pair of                   |    |     // boolean indicating whether the predicate p |
    |     // collections (xs.take(n), xs.drop(n))                          |    |     // holds for all elements of xs               |
    | xs.splitAt(n)                                                        |    | xs.forall(p)                                      |
    |                                                                      |    |                                                   |
    |     // Splits xs according to a predicate, giving the pair           |    |     // boolean indicating whether the predicate p |
    |     // of collections (xs.takeWhile(p), xs.dropWhile(p))             |    |     // holds for some element in xs               |
    | xs.span(p)                                                           |    | xs.exists(p)                                      |
    |                                                                      |    |                                                   |
    |     // Splits xs into a pair of collections                          |    |     // number of elements in xs that satisfy the  |
    |     // one with elements that satisfy the predicate p                |    |     // predicate p                                |
    |     // other not - (xs.filter(p), xs.filterNot(p))                   |    | xs.count(p)                                       |
    | xs.partition(p)                                                      |    +---------------------------------------------------+
    |                                                                      |    //Folds
    |     // Transforms each element of xs into an                         |    +-----------------------------------------------------------------+
    |     // Either[X, Y] value, and splits them into a pair of            |    |     // Applies binary operation op between successive           |
    |     // collections, one with elements contained in Left,             |    |     // elements of xs, going left to right, starting with z     |
    |     // the other with elements contained in Right                    |    | xs.foldLeft(z)(op)                                              |
    | xs.partitionMap(f)                                                   |    |                                                                 |
    |                                                                      |    |     // going right to left                                      |
    |     // Partitions xs into a map of collections according             |    | xs.foldRight(z)(op)                                             |
    |     // to a discriminator function f                                 |    |                                                                 |
    | xs.groupBy(f)                                                        |    |     // Applies binary operation op between successive           |
    |                                                                      |    |     // elements of non-empty collection xs, going left to right |
    |     // Partitions xs into a map of collections according             |    | xs.reduceLeft(op)                                               |
    |     // to a discriminator function f, and applies the                |    |                                                                 |
    |     // transformation function g to every element of each collection |    |     // going right to left                                      |
    | xs.groupMap(f)(g)                                                    |    | xs.reduceRight(op)                                              |
    |                                                                      |    +-----------------------------------------------------------------+
    |     // Partitions xs into a map of collections according             |    // Specific folds
    |     // to a discriminator function f, applies the                    |    +---------------------------------------------------------------+
    |     // transformation function g to every element of                 |    |     // sum of the numeric element values of collection xs     |
    |     // each collection, and reduces each collection to a             |    | xs.sum                                                        |
    |     // single value by combining their elements with the             |    |                                                               |
    |     // h function.                                                   |    |     // product of the numeric element values of collection xs |
    | xs.groupMapReduce(f)(g)(h)                                           |    | xs.product                                                    |
    +----------------------------------------------------------------------+    | xs.min, xs.max                                                |
                                                                                +---------------------------------------------------------------+
    // Subcategories of Iterable
    // way each trait (Seq, Set, Map) implements PartialFunction differs
    // what apply method does in each
    +-------------------------------------------------+
    | Seq(1, 2, 3)(1) == 2                            |
    | Set('a', 'b', 'c')('b') == true                 |
    | Map('a' -> 1, 'b' -> 10, 'c' -> 100)('b') == 10 |
    +-------------------------------------------------+

    - The sequence traits Seq, IndexedSeq, and LinearSeq
    // Operations in trait Seq

    //Indexing and length                                   //Index search                                                  // Additions
    +---------------------------------------------------+   +----------------------------------------------------------+    +-------------------------------------------------------+
    |     // element of xs at index i                   |   |     //  index of the first element in xs equal to x      |    |     // new sequence consisting of x prepended to xs   |
    | xs(i)                                             |   | xs.indexOf(x)                                            |    | x +: xs                                               |
    | xs.apply(i)                                       |   |                                                          |    | xs.prepended(x)                                       |
    |                                                   |   |     // index of the last element in xs equal to x        |    |                                                       |
    |     // Tests whether i is contained in xs.indices |   | xs.lastIndexOf(x)                                        |    |     // new sequence consisting of all the elements of |
    | xs.isDefinedAt(i)                                 |   |                                                          |    |     // ys prepended to xs                             |
    |                                                   |   |     // first index of xs, that successive form ys        |    | ys ++: xs                                             |
    |     // same as size                               |   | xs.indexOfSlice(ys)                                      |    | xs.prependedAll(ys)                                   |
    | xs.length                                         |   |                                                          |    |                                                       |
    |                                                   |   |     // last index of xs, that successive form ys         |    |                                                       |
    |     // negative Int if the length of xs is less   |   | xs.lastIndexOfSlice(ys)                                  |    |     // new sequence that consists of x appended to xs |
    |     // than len, a positive Int if it is greater  |   |                                                          |    | xs :+ x                                               |
    | xs.lengthCompare(len)                             |   |     // index of the first element in xs that satisfies p |    | or xs.appended(x)                                     |
    +---------------------------------------------------+   | xs.indexWhere(p)                                         |    |                                                       |
                                                            |                                                          |    |     // new sequence that consists of all the elements |
                                                            |     // length of the longest uninterrupted segment       |    |     // of ys appended to xs. Same as xs ++ ys         |
                                                            |     // that all satisfy the predicate p                  |    | xs :++ ys                                             |
                                                            | xs.segmentLength(p, i)                                   |    | or xs.appendedAll(ys)                                 |
                                                            +----------------------------------------------------------+    |                                                       |
    //Updates:                                                                                                              |     // sequence resulting from appending the value    |
    +-------------------------------------------------------------+                                                         |     // x to xs until length len is reached            |
    |     // sequence resulting from replacing r elements         |                                                         | xs.padTo(len, x)                                      |
    |     // of xs starting with i by the patch ys                | // Sorting:                                             +-------------------------------------------------------+
    | xs.patch(i, ys, r)                                          | +--------------------------------------------------------+  // Reversals
    |                                                             | |     // new seq sorted using standard ordering for type |  +----------------------------------------------+
    |     // copy of xs with the element at index i replaced by x | | xs.sorted                                              |  |     // new seq with elements in reverse      |
    | xs.updated(i, x) A .                                        | |                                                        |  | xs.reverse                                   |
    |                                                             | |     // new seq sorted using lessThan comparison        |  |                                              |
    |     // only available for mutable.Seqs                      | | xs.sortWith(lessThan)                                  |  |     // iterator yielding elements in reverse |
    | xs(i) = x                                                   | |                                                        |  | xs.reverseIterator                           |
    | or, xs.update(i, x)                                         | |     // new seq sorted using result of f                |  +----------------------------------------------+
    +-------------------------------------------------------------+ | xs.sortBy(f)                                           |
                                                                    +--------------------------------------------------------+
    Comparison                                                  //Multiset operations
    +-------------------------------------------------------+   +-------------------------------------------------------------+
    |     // test if xs and ys have same elements           |   |     // intersection of xs and ys that preserves order of xs |
    | xs.sameElements(ys)                                   |   | xs.intersect(ys)                                            |
    |                                                       |   |                                                             |
    |     // test if xs starts with ys                      |   |     // diff between xs and ys that preserves order of xs    |
    | xs.startsWith(ys)                                     |   | xs.diff(ys)                                                 |
    |                                                       |   |                                                             |
    |     // test if xs ends with ys                        |   |     // subseq of xs without duplicates                      |
    | xs.endsWith(ys)                                       |   | xs.distinct                                                 |
    |                                                       |   |                                                             |
    |     // test if xs contains x                          |   |     // subseq of xs without duplicates after applying f     |
    | xs.contains(x)                                        |   | xs.distinctBy(f)                                            |
    |                                                       |   +-------------------------------------------------------------+
    |     // test if sorted seq has x, faster than contains |
    | xs.search(x)                                          |
    |                                                       |
    |     // test if xs has subseq of ys                    |
    | xs.containsSlice(ys)                                  |
    |                                                       |
    |     // test if xs and ys satisfy predicate p          |
    | xs.corresponds(ys)(p)                                 |
    +-------------------------------------------------------+

    // Operations in trait mutable.IndexedSeq
    // Transformations:
    +----------------------------------------------------------+
    |     // Transforms all the elements of xs by applying f   |
    | xs.mapInPlace(f)                                         |
    |                                                          |
    |     // Sorts the elements of xs in place                 |
    | xs.sortInPlace()                                         |
    |                                                          |
    |     // Sorts the elements of xs in place according to an |
    |     // ordering defined on the result of f               |
    | xs.sortInPlaceBy(f)                                      |
    |                                                          |
    |     // sorts with comparison function c                  |
    | xs.sortInPlaceWith(c)                                    |
    +----------------------------------------------------------+

    // Buffers
    // Operations in trait Buffer

    // Appends x to buffer returns buf itself as result             // Removals                                         // Replacement
    +------------------------------------------------------------+  +-----------------------------------------------+   +---------------------------------------------------+
    | buf += x                                                   |  |     // Removes element x from buffer          |   |     // Replaces (at most) n elements of buffer by |
    | buf.append(x)                                              |  | buf -= x                                      |   |     // elements in xs, starting from index i      |
    |                                                            |  | buf.subtractOne(x)                            |   | buf.patchInPlace(i, xs, n)                        |
    |     // Appends all elements in xs to buffer                |  |                                               |   +---------------------------------------------------+
    | buf ++= xs                                                 |  |     // Removes elements in xs from buffer     |
    | buf.appendAll(xs)                                          |  | buf --= xs                                    |
    |                                                            |  | buf.subtractAll(xs)                           |   // Cloning
    |     // Prepends element x to buffer                        |  |                                               |   +---------------------------------------------------+
    | x +=: buf                                                  |  |     // Removes element at index i from buffer |   |     // A new buffer with the same elements as buf |
    | buf.prepend(x)                                             |  | buf.remove(i)                                 |   | buf.clone()                                       |
    |                                                            |  |                                               |   +---------------------------------------------------+
    |     // Prepends all elements in xs to buffer               |  |     // Removes n elements starting at index i |
    | xs ++=: buf                                                |  | buf.remove(i, n)                              |
    | buf.prependAll(xs)                                         |  |                                               |
    |                                                            |  |     // Removes first n elements from buffer   |
    |     // Inserts element x at index i in buffer              |  | buf.trimStart(n)                              |
    | buf.insert(i, x)                                           |  |                                               |
    |                                                            |  |     // Removes last n elements from buffer    |
    |     // Inserts all elements in xs at index i in buffer     |  | buf.trimEnd(n)                                |
    | buf.insertAll(i, xs)                                       |  |                                               |
    |                                                            |  |     // Removes all elements from buffer       |
    |     // Appends element x to buffer until it has n in total |  | buf.clear()                                   |
    | buf.padToInPlace(n, x)                                     |  +-----------------------------------------------+
    +------------------------------------------------------------+

    - Sets
    // default implementation of a mutable set uses a hash table to store the set’s elements
    // default implementation of an immutable set uses a representation that adapts to the number of elements of the set
    // Empty - singleton object, sets of sizes up to four are represented by a single object that stores all elements as fields
    // Beyond that size, immutable sets are implemented as compressed hash-array mapped prefix-trees
    // sets with up to 4 elements faster then mutable sets
    +-------------------------------------------------------+
    | val fruit = Set("apple", "orange", "peach", "banana") |
    | fruit("peach") // true                                |
    | fruit("potato") // false                              |
    +-------------------------------------------------------+
    
    // Operations in trait Set                      // Removals:                                    // Binary operations:
    +--------------------------------------------+  +------------------------------------------+    +--------------------------------------+
    | Tests:                                     |  |     // empty set of the same class as xs |    |     // set intersection of xs and ys |
    |     // Tests whether x is an element of xs |  | xs.empty                                 |    | xs & ys                              |
    | xs.contains(x)                             |  +------------------------------------------+    | xs.intersect(ys)                     |
    | xs(x)                                      |                                                  |                                      |
    |                                            |                                                  |     // set union of xs and ys        |
    |     // Tests whether xs is a subset of ys  |                                                  | xs | ys                              |
    | xs.subsetOf(ys)                            |                                                  | xs.union(ys)                         |
    +--------------------------------------------+                                                  |                                      |
                                                                                                    |     // set difference of xs and ys   |
                                                                                                    | xs &~ ys                             |
                                                                                                    | xs.diff(ys)                          |
                                                                                                    +--------------------------------------+
    // Operations in trait immutable.Set
    // Additions:                                               //Removals:
    +-------------------------------------------------------+   +----------------------------------------------------+
    |     // set containing all elements of xs as well as x |   |     // set containing all elements of xs except    |
    | xs + x                                                |   | xs - x                                             |
    | or xs.incl(x)                                         |   | xs.excl(x)                                         |
    |                                                       |   |                                                    |
    |     // set containing all elements of xs and ys       |   |     // set containing all elements of xs except ys |
    | xs ++ ys                                              |   | xs -- ys                                           |
    | xs.concat(ys)                                         |   | xs.removedAll(ys)                                  |
    +-------------------------------------------------------+   +----------------------------------------------------+

    // Operations in trait mutable.Set
    // Additions:                                               // Removals:                                                // Update:
    +--------------------------------------------------------+  +---------------------------------------------------------+ +--------------------------------------------------+
    |     // added element x to set xs as a side effect      |  |     // Removes element x from set xs as a side effect   | |     // If boolean argument b is true,            |
    |     // and returns xs itself                           |  |     // and returns xs itself                            | |     // adds x to xs, otherwise removes x from xs |
    | xs += x                                                |  | xs -= x                                                 | | xs(x) = b                                        |
    | xs.addOne(x)                                           |  | xs.subtractOne(x)                                       | | xs.update(x, b)                                  |
    |                                                        |  |                                                         | +--------------------------------------------------+
    |     // added elements in ys to set xs as a side effect |  |     // Removes all elements in ys from set xs as a side | // Cloning:
    |     // and returns xs itself                           |  |     // effect and returns xs itself                     | +-----------------------------------------------------+
    | xs ++= ys                                              |  | xs --= ys                                               | |     // new mutable set with the same elements as xs |
    | xs.addAll(ys)                                          |  | xs.subtractAll(ys)                                      | | xs.clone()                                          |
    |                                                        |  |                                                         | +-----------------------------------------------------+
    |     // Adds element x to xs and returns true if x was  |  |     // Removes element x from xs and returns true if x  |
    |     // there before, false if it was there             |  |     // was there, false if wasnt                        |
    | xs.add(x)                                              |  | xs.remove(x)                                            |
    +--------------------------------------------------------+  |                                                         |
                                                                |     // keeps only elements that satisfy predicate       |
                                                                | xs.filterInPlace(p)                                     |
                                                                |                                                         |
                                                                |     // Removes all elements from xs                     |
                                                                | xs.clear()                                              |
                                                                +---------------------------------------------------------+
    // var vs mutable set
    +----------------------+                                                    +-----------------------------------------+
    | var s = Set(1, 2, 3) |                                                    | val s = collection.mutable.Set(1, 2, 3) |
    | s += 4               |    // += and -= on a var of type immutable.Set     | s += 4 // Set(1, 2, 3, 4)               | // s += 4 statement now invokes the += method
    | s -= 2               |    // s += 4 is an abbreviation for s = s + 4      | s -= 2 // Set(1, 3, 4)                  | // on the mutable set value s, changing the set in place
    | s // Set(1, 3, 4)    |                                                    | s // Set(1, 3, 4)                       |
    +----------------------+                                                    +-----------------------------------------+






    -Trait Traversable
    // ts only abstract operation is foreach
    def foreach[U](f: Elem => U)
    Abstract method:
    xs foreach f Executes function f for every element of xs.
    Addition:
        xs ++ ys            // A collection consisting of the elements of both xs and ys. ys is a TraversableOnce collection, i.e., either a Traversable or an Iterator.
    Maps:
        xs map f            // The collection obtained from applying the function f to every element in xs.
        xs flatMap f        // The collection obtained from applying the collection-valued function f to every element in xs and concatenating the results.
        xs collect f        // The collection obtained from applying the partial function f to every element in xs for which it is defined and collecting the results.
    Conversions:
        xs.toArray          // Converts the collection to an array.
        xs.toList           // Converts the collection to a list.
        xs.toIterable       // Converts the collection to an iterable.
        xs.toSeq            // Converts the collection to a sequence.
        xs.toIndexedSeq     // Converts the collection to an indexed sequence.
        xs.toStream         // Converts the collection to a stream (a lazily computed sequence).
        xs.toSet            // Converts the collection to a set.
        xs.toMap            // Converts a collection of key/value pairs to a map.
    Copying:
        xs copyToBuffer buf             // Copies all elements of the collection to buffer buf.
        xs copyToArray(arr, s, len)     // Copies at most len elements of arr, starting at index s. The last two arguments are optional.
    Size info:
        xs.isEmpty          // Tests whether the collection is empty.
        xs.nonEmpty         // Tests whether the collection contains elements.
        xs.size             // The number of elements in the collection.
        xs.hasDefiniteSize  // True if xs is known to have finite size.
    Element retrieval:
        xs.head             // The first element of the collection (or, some element, if no order is defined).
        xs.headOption       // The first element of xs in an option value, or None if xs is empty.
        xs.last             // The last element of the collection (or, some element, if no order is defined).
        xs.lastOption       // The last element of xs in an option value, or None if xs is empty.
        xs find p           // An option containing the first element in xs that satisfies p, or None if no element qualifies.
    Subcollections:
        xs.tail             // The rest of the collection except xs.head.
        xs.init             // The rest of the collection except xs.last.
        xs slice (from, to) // A collection consisting of elements in some index range of xs (from from, up to and excluding to).
        xs take n           // A collection consisting of the first n elements of xs (or, some arbitrary n elements, if no order is defined).
        xs drop n           // The rest of the collection except xs take n.
        xs takeWhile p      // The longest prefix of elements in the collection that all satisfy p.
        xs dropWhile p      // The collection without the longest prefix of elements that all satisfy p
        xs filter p         // The collection consisting of those elements of xs that satisfy the predicate p.
        xs withFilter p     // A non-strict filter of this collection. All operations on the resulting filter will only apply to those elements of xs for which the condition p is true.
        xs filterNot p      // The collection consisting of those elements of xs that do not satisfy the predicate p.
    Subdivisions:
        xs splitAt n        // Splits xs at a position, giving the pair of collections (xs take n, xs drop n).
        xs span p           // Splits xs according to a predicate, giving the pair of collections (xs takeWhile p, xs.dropWhile p).
        xs partition p      // Splits xs into a pair of collections; one with elements that satisfy the predicate p, the other with elements that do not, giving the pair of collections (xs filter p, xs.filterNot p).
        xs groupBy f        // Partitions xs into a map of collections according to a discriminator function f.
    Element conditions:
        xs forall p         // A boolean indicating whether the predicate p holds for all elements of xs.
        xs exists p         // A boolean indicating whether the predicate p holds for some element in xs.
        xs count p          // The number of elements in xs that satisfy the predicate p.
    Folds:
        (z /: xs)(op)       // Applies binary operation op between successive elements of xs, going left to right, starting with z.
        (xs :\ z)(op)       // Applies binary operation op between successive elements of xs, going right to left, starting with z.
        xs.foldLeft(z)(op)  // Same as (z /: xs)(op).
        xs.foldRight(z)(op) // Same as (xs :\ z)(op).
        xs reduceLeft op    // Applies binary operation op between successive elements of non-empty collection xs, going left to right.
        xs reduceRight op   // Applies binary operation op between successive elements of non-empty collection xs, going right to left.
    Specific folds:
        xs.sum              // The sum of the numeric element values of collection xs.
        xs.product          // The product of the numeric element values of collection xs.
        xs.min              // The minimum of the ordered element values of collection xs.
        xs.max              // The maximum of the ordered element values of collection xs.
    Strings:
        xs addString (b, start, sep, end)   // Adds a string to StringBuilder b that shows all elements of xs between separators sep enclosed in strings start and end. start, sep, and end are all optional.
        xs mkString (start, sep, end)       // Converts the collection to a string that shows all elements of xs between separators sep enclosed in strings start and end. start, sep, and end are all optional.
        xs.stringPrefix                     // The collection name at the beginning of the string returned from xs.toString.
    Views:
        xs.view             // Produces a view over xs.
        xs view (from, to)  // Produces a view that represents the elements in some index range of xs

    -Trait Iterable
    def foreach[U](f: Elem => U): Unit = {
        val it = iterator
        while (it.hasNext) f(it.next())
    }
    val xs = List(1, 2, 3, 4, 5)                    // xs: List[Int] = List(1, 2, 3, 4, 5)
    val git = xs grouped 3                          // git: Iterator[List[Int]] = non-empty iterator
    git.next()                                      // res2: List[Int] = List(1, 2, 3)
    git.next()                                      // res3: List[Int] = List(4, 5)
    val sit = xs sliding 3                          // sit: Iterator[List[Int]] = non-empty iterator
    sit.next()                                      // res4: List[Int] = List(1, 2, 3)
    sit.next()                                      // res5: List[Int] = List(2, 3, 4)
    sit.next()                                      // res6: List[Int] = List(3, 4, 5)
    Abstract method:
        xs.iterator             // An iterator that yields every element in xs, in the same order as foreach traverses elements
    Other iterators:
        xs grouped size         // An iterator that yields fixed-sized “chunks” of this collection
        xs sliding size         // An iterator that yields a sliding fixed-sized window of elements in this collection
    Subcollections:
        xs takeRight n          // A collection consisting of the last n elements of xs (or, some arbitrary n elements, if no order is defined)
        xs dropRight n          // The rest of the collection except xs takeRight n
    Zippers:
        xs zip ys               // An iterable of pairs of corresponding elements from xs and ys
        xs zipAll (ys, x, y)    // An iterable of pairs of corresponding elements from xs and ys, where the shorter sequence is extended to match the longer one by appending elements x or y
        xs.zipWithIndex         // An iterable of pairs of elements from xs with their indicies
    Comparison:
        xs sameElements ys      // Tests whether xs and ys contain the same elements in the same order

    -Why have both Traversable and Iterable?
    // to implement foreach for iterable is harder then for  traversable
    sealed abstract class Tree extends Traversable[Int] {
        def foreach[U](f: Int => U) = this match {
        case Node(elem) => f(elem)
        case Branch(l, r) => l foreach f; r foreach f
        }
    }

    -The sequence traits Seq, IndexedSeq, and LinearSeq
    //sequence is a kind of iterable that has a length and whose elements have fixed index positions, starting from 0
    Indexing and length:
        xs(i)               // (or, written out, xs apply i) The element of xs at index i.
        xs isDefinedAt i    // Tests whether i is contained in xs.indices.
        xs.length           // The length of the sequence (same as size).
        xs.lengthCompare ys // Returns -1 if xs is shorter than ys, +1 if it is longer, and 0 is they have the same length. Works even if one of the sequences is infinite.
        xs.indices          // The index range of xs, extending from 0 to xs.length - 1.
    Index search:
        xs indexOf x        // The index of the first element in xs equal to x (several variants exist).
        xs lastIndexOf x    // The index of the last element in xs equal to x (several variants exist).
        xs indexOfSlice ys  // The first index of xs such that successive elements starting from that index form the sequence ys.
        xs lastIndexOfSlice ys  // The last index of xs such that successive elements starting from that index form the sequence ys.
        xs indexWhere p     // The index of the first element in xs that satisfies p (several variants exist).
        xs segmentLength (p, i) // The length of the longest uninterrupted segment of elements in xs, starting with xs(i), that all satisfy the predicate p.
        xs prefixLength p   // The length of the longest prefix of elements in xs that all satisfy the predicate p.
    Additions:
        x +: xs             // A new sequence consisting of x prepended to xs.
        xs :+ x             // A new sequence that consists of x append to xs.
        xs padTo (len, x)   // The sequence resulting from appending the value x to xs until length len is reached.
    Updates:
        xs patch (i, ys, r) // The sequence resulting from replacing r elements of xs starting with i by the patch ys.
        xs updated (i, x)   // A copy of xs with the element at index i replaced by x.
        xs(i) = x           // (or, written out, xs.update(i, x), only available for mutable.Seqs) Changes the element of xs at index i to y.
    Sorting:
        xs.sorted           // A new sequence obtained by sorting the elements of xs using the standard ordering of the element type of xs.
        xs sortWith lessThan    // A new sequence obtained by sorting the elements of xs, using lessThan as comparison operation.
        xs sortBy f         // A new sequence obtained by sorting the elements of xs. Comparison between two elements proceeds by mapping the function f over both and comparing the results.
    Reversals:
        xs.reverse          // A sequence with the elements of xs in reverse order.
        xs.reverseIterator  // An iterator yielding all the elements of xs in reverse order.
        xs reverseMap f     // A sequence obtained by mapping f over the elements of xs in reverse order.
    Comparisons:
        xs startsWith ys    // Tests whether xs starts with sequence ys (several variants exist).
        xs endsWith ys      // Tests whether xs ends with sequence ys (several variants exist).
        xs contains x       // Tests whether xs has an element equal to x.
        xs containsSlice ys // Tests whether xs has a contiguous subsequence equal to ys. (xs corresponds ys)(p) Tests whether corresponding elements of xs and ys satisfy the binary predicate p.
    Multiset operations:
        xs intersect ys     // The multi-set intersection of sequences xs and ys that preserves the order of elements in xs.
        xs diff ys          // The multi-set difference of sequences xs and ys that preserves the order of elements in xs.
        xs union ys         // Multiset union; same as xs ++ ys.
        xs.distinct         // A subsequence of xs that contains no duplicated element.

    -Buffers
    // allow not only updates of existing elements but also element insertions, element removals, and efficient additions of new elements at the end of the buffer
    Additions:
        buf += x                //Appends element x to buffer buf, and returns buf itself as result
        buf += (x, y, z)        //Appends given elements to buffer
        buf ++= xs              //Appends all elements in xs to buffer
        x +=: buf               //Prepends element x to buffer
        xs ++=: buf             //Prepends all elements in xs to buffer
        buf insert (i, x)       //Inserts element x at index i in buffer
        buf insertAll (i, xs)   //Inserts all elements in xs at index i in buffer
    Removals:
        buf -= x                // Removes element x from buffer
        buf remove i            // Removes element at index i from buffer
        buf remove (i, n)       // Removes n elements starting at index i from buffer
        buf trimStart n         // Removes first n elements from buffer
        buf trimEnd n           // Removes last n elements from buffer
        buf.clear()             // Removes all elements from buffer
    Cloning:
        buf.clone               // A new buffer with the same elements as buf

    -Sets
    // Iterables that contain no duplicate elements
    Tests:
        xs contains x           // Tests whether x is an element of xs 
        xs(x)                   // Same as xs contains x
        xs subsetOf ys          // Tests whether xs is a subset of ys
    Additions:
        xs + x                  // The set containing all elements of xs as well as x
        xs + (x, y, z)          // The set containing all elements of xs as well as the given additional elements
        xs ++ ys                // The set containing all elements of xs as well as all elements of ys
    Removals:
        xs - x                  // The set containing all elements of xs except x
        xs - (x, y, z)          // The set containing all elements of xs except the given elements
        xs -- ys                // The set containing all elements of xs except the elements of ys
        xs.empty                // An empty set of the same class as xs
    Binary operations:
        xs & ys                 // The set intersection of xs and ys
        xs intersect ys         // Same as xs & ys
        xs | ys                 // The set union of xs and ys
        xs union ys             // Same as xs | ys
        xs &~ ys                // The set difference of xs and ys
        xs diff ys              // Same as xs &~ ys

    // Mutable sets:
    Additions:
        xs += x             // Adds element x to set xs as a side effect and returns xs itself
        xs += (x, y, z)     // Adds the given elements to set xs as a side effect and returns xs itself
        xs ++= ys           // Adds all elements in ys to set xs as a side effect and returns xs itself
        xs add x            // Adds element x to xs and returns true if x was not previously contained in the set, false if it was previously contained
    Removals:
        xs -= x             // Removes element x from set xs as a side effect and returns xs itself
        xs -= (x, y, z)     // Removes the given elements from set xs as a side effect and returns xs itself
        xs --= ys           // Removes all elements in ys from set xs as a side effect and returns xs itself
        xs remove x         // Removes element x from xs and returns true if x was previously contained in the set, false if it was not previously contained
        xs retain p         // Keeps only those elements in xs that satisfy
    predicate p
        xs.clear()          // Removes all elements from xs
    Update:
        xs(x) = b           // (or, written out, xs.update(x, b)) If boolean argument b is true, adds x to xs, otherwise removes x from xs
    Cloning:
        xs.clone            // A new mutable set with the same elements as xs
    // example
    var s = Set(1, 2, 3)    // s: scala.collection.immutable.Set[Int] = Set(1, 2, 3)
    s += 4; s -= 2          // we used += and -= on a var of type immutable.Set. s += 4 is an abbreviation for s = s + 4. So this invokes the addition method + on the set s and then assigns the result back to the s variable
    s                       // res10: scala.collection.immutable.Set[Int] = Set(1, 3, 4)
    // mutable
    val s = collection.mutable.Set(1, 2, 3)     // s: scala.collection.mutable.Set[Int] = Set(1, 2, 3)
    s += 4                  // res11: s.type = Set(1, 2, 3, 4)
    s -= 2                  // res12: s.type = Set(1, 3, 4)

    -Maps
    // Iterables of pairs of keys and values
    Map("x" -> 24, "y" -> 25, "z" -> 26)        // exactly the same as Map(("x", 24), ("y", 25), ("z", 26))
    Lookups:
        ms get k            // The value associated with key k in map ms as an option, or None if not found
        ms(k)               // (or, written out, ms apply k) The value associated with key k in map ms, or a thrown exception if not found
        ms getOrElse (k, d) // The value associated with key k in map ms, or the default value d if not found
        ms contains k       // Tests whether ms contains a mapping for key k
        ms isDefinedAt k    // Same as contains
    Additions and updates:
        ms + (k -> v)           // The map containing all mappings of ms as well as the mapping k -> v from key k to value v
        ms + (k -> v, l -> w)   // The map containing all mappings of ms as well as
    the given key/value pairs
        ms ++ kvs           // The map containing all mappings of ms as well as all key/value pairs of kvs
        ms updated (k, v)   // Same as ms + (k -> v)
    Removals:
        ms - k              // The map containing all mappings of ms except for any mapping of key k
        ms - (k, l, m)      // The map containing all mappings of ms except for any mapping with the given keys
        ms -- ks            // The map containing all mappings of ms except for any mapping with a key in ks
    Subcollections:
        ms.keys             // An iterable containing each key in ms
        ms.keySet           // A set containing each key in ms
        ms.keysIterator     // An iterator yielding each key in ms
        ms.values           // An iterable containing each value associated with a key in ms
        ms.valuesIterator   // An iterator yielding each value associated with a key in ms
    Transformation:
        ms filterKeys p     // A map view containing only those mappings in ms where the key satisfies predicate p
        ms mapValues f      // A map view resulting from applying function f to each value associated with a key in ms
    // mutable
    Additions and updates:
        ms(k) = v           // (or, written out, ms.update(k, v)) Adds mapping from key k to value v to map ms as a side effect, overwriting any previous mapping of k
        ms += (k -> v)      // Adds mapping from key k to value v to map ms as a side effect and returns ms itself
        ms += (k -> v, l -> w)  // Adds the given mappings to ms as a side effect and returns ms itself
        ms ++= kvs          // Adds all mappings in kvs to ms as a side effect and returns ms itself
        ms put (k, v)       // Adds mapping from key k to value v to ms and returns any value previously associated with k as an option
        ms getOrElseUpdate (k, d)   // If key k is defined in map ms, returns its associated value. Otherwise, updates ms with the mapping k -> d and returns d
    Removals:
        ms -= k             // Removes mapping with key k from ms as a side effect and returns ms itself
        ms -= (k, l, m)     // Removes mappings with the given keys from ms as a side effect and returns ms itself
        ms --= ks           // Removes all keys in ks from ms as a side effect and returns ms itself
        ms remove k         // Removes any mapping with key k from ms and returns any value previously associated with k as an option
        ms retain p         // Keeps only those mappings in ms that have a key satisfying predicate p.
        ms.clear()          // Removes all mappings from ms
    Transformation and cloning:
        ms transform f      // Transforms all associated values in map ms with function f
        ms.clone            //Returns a new mutable map with the same mappings as ms
    // getOrElseUpdate is useful for accessing maps that act as caches.
    val cache = collection.mutable.Map[String, String]()
    def cachedF(s: String) = cache.getOrElseUpdate(s, f(s))
    cachedF("abc")          // taking my time.  res16: String = cba
    cachedF("abc")          // res17: String = cba
    def cachedF(arg: String) = cache get arg match {
        case Some(result) => result
        case None =>
            val result = f(arg)
            cache(arg) = result
            result
    }

    -Concrete immutable collection classes
    -Lists
    //constant-time access to first element, rest of the list, cons operation for adding a new element to the front of the list

    -Streams
    // like a list except that its elements are computed lazily, Otherwise, streams have the same performance characteristics as lists
    val str = 1 #:: 2 #:: 3 #:: Stream.empty        // str: scala.collection.immutable.Stream[Int] = Stream(1, ?)
    def fibFrom(a: Int, b: Int): Stream[Int] =      // without #:: every call to the function would result in another call
        a #:: fibFrom(b, a + b)                     // fibFrom: (a: Int, b: Int)Stream[Int]
    val fibs = fibFrom(1, 1).take(7)                // fibs: scala.collection.immutable.Stream[Int] = Stream(1, ?)
    fibs.toList                                     // res23: List[Int] = List(1, 1, 2, 3, 5, 8, 13)

    -Vectors
    // efficient access to elements beyond the head
    val vec = scala.collection.immutable.Vector.empty
    val vec2 = vec :+ 1 :+ 2                        // vec2: scala.collection.immutable.Vector[Int] = Vector(1, 2)
    val vec3 = 100 +: vec2                          // vec3: scala.collection.immutable.Vector[Int] = Vector(100, 1, 2)
    vec3(0)                                         // res24: Int = 100
    // Every tree node contains up to 32 elements of the vector or contains up to 32 other tree nodes
    // ectors are immutable, so you cannot change an element of a vector in place, you can create a new vector that differs from a given vector only in a single element
    val vec = Vector(1, 2, 3)
    vec updated (2, 4)                              // res25: scala.collection.immutable.Vector[Int] = Vector(1, 2, 4)
    vec                                             // res26: scala.collection.immutable.Vector[Int] = Vector(1, 2, 3)
    // Updating an element in the middle of a vector can be done by copying the node that contains the element, and every node that points to it,
    // starting from the root of the tree. This means that a functional update creates between one and five nodes that each contain up to 32 elements or subtrees.
    // This is certainly more expensive than an in-place update in a mutable array, but still a lot cheaper than copying the whole vector.
    // they are currently the default implementation of immutable indexed sequences
    collection.immutable.IndexedSeq(1, 2, 3)        // res27: scala.collection.immutable.IndexedSeq[Int] = Vector(1, 2, 3)

    -Immutable stacks
    // push an element onto a stack with push, pop an element with pop
    val stack = scala.collection.immutable.Stack.empty
    val hasOne = stack.push(1)                      // hasOne: scala.collection.immutable.Stack[Int] = Stack(1)
    stack                                           // res28: scala.collection.immutable.Stack[Nothing] = Stack()
    hasOne.top                                      // res29: Int = 1
    hasOne.pop                                      // res30: scala.collection.immutable.Stack[Int] = Stack()
    // rarely in Scala programs because their functionality is subsumed by lists

    -Immutable queues
    val empty = scala.collection.immutable.Queue[Int]()
    val has1 = empty.enqueue(1)                     // has1: scala.collection.immutable.Queue[Int] = Queue(1)
    val has123 = has1.enqueue(List(2, 3))           // has123: scala.collection.immutable.Queue[Int] = Queue(1, 2, 3)
    val (element, has23) = has123.dequeue           // element: Int = 1; has23: scala.collection.immutable.Queue[Int] = Queue(2, 3)

    -Ranges
    1 to 3                                          // res31: scala.collection.immutable.Range.Inclusive = Range(1, 2, 3)
    5 to 14 by 3                                    // res32: scala.collection.immutable.Range = Range(5, 8, 11, 14)
    1 until 3                                       // res33: scala.collection.immutable.Range = Range(1, 2)

    -Hash tries
    // standard way to implement immutable sets and maps efficiently
    // trees where every node has 32 elements or 32 subtrees, but selection is done based on a hash code.
    // to find a given key in a map, you use the lowest five bits of the hash code of the key to select the first subtree, the next five bits the next subtree, and so on

    -Red-black trees
    // balanced binary trees where some nodes are designated “red” and others “black.” standard implementation of SortedSet in Scala
    val set = collection.immutable.TreeSet.empty[Int]   // set: scala.collection.immutable.TreeSet[Int] = TreeSet()
    set + 1 + 3 + 3                                     // res34: scala.collection.immutable.TreeSet[Int] = TreeSet(1, 3)

    -Immutable bit sets
    // bit set containing 3, 2, and 0 would be represented as the integer 1101 in binary, which is 13 in decimal
    val bits = scala.collection.immutable.BitSet.empty
    val moreBits = bits + 3 + 4 + 4                     // moreBits: scala.collection.immutable.BitSet = BitSet(3, 4)
    moreBits(3)                                         // res35: Boolean = true
    moreBits(0)                                         //res36: Boolean = false

    -List maps
    val map = collection.immutable.ListMap( 1 -> "one", 2 -> "two")     // 
    map(2)                                              // res37: String = "two"

    -Concrete mutable collection classes
    -Array buffers
    // holds an arra
    y and a size, can have data efficiently added to the end, Appending an item to an array buffer takes amortized constant time
    // good whenever the new items are always added to the end
    // useful for building arrays
    val buf = collection.mutable.ArrayBuffer.empty[Int]
    buf += 1                                        // res38: buf.type = ArrayBuffer(1)
    buf += 10                                       // res39: buf.type = ArrayBuffer(1, 10)
    buf.toArray                                     // res40: Array[Int] = Array(1, 10)
    -List buffers
    // like an array buffer except that it uses a linked list internally instead of an array
    // if need to convert the buffer to a list once it is built up, use a list buffer instead of an array buffer
    // useful for building lists
    val buf = collection.mutable.ListBuffer.empty[Int]
    buf += 1                                        // res41: buf.type = ListBuffer(1)
    buf += 10                                       // res42: buf.type = ListBuffer(1, 10)
    buf.toList                                      // res43: List[Int] = List(1, 10)
    -String builders
    // useful for building strings
    val buf = new StringBuilder
    buf += 'a'                                      // res44: buf.type = a
    buf ++= "bcdef"                                 // res45: buf.type = abcdef
    buf.toString                                    // res46: String = abcdef
    -Linked lists
    // LinkedList.empty.isEmpty
    // best operated on sequentially. In addition, linked lists make it easy to insert an element or linked list into another linked list
    -Double linked lists
    // DoubleLinkedLists
    // main benefit of that additional link is that it makes element removal very fast
    -Mutable lists
    // MutableList
    // list append a constant time operation because it avoids having to traverse the list in search for its terminal node
    // MutableList is currently the standard implementation of mutable.LinearSeq in Scala
    -Queues
    val queue = new scala.collection.mutable.Queue[String]
    queue += "a"                                    // res47: queue.type = Queue(a)
    queue ++= List("b", "c")                        // res48: queue.type = Queue(a, b, c)
    queue                                           // res49: scala.collection.mutable.Queue[String] = Queue(a, b, c)
    queue.dequeue                                   // res50: String = a
    queue                                           // res51: scala.collection.mutable.Queue[String] = Queue(b, c)
    -Array sequences
    // ArraySeq
    // if you want an array for its performance characteristics, but you also want to create generic instances of the sequence where you do not know the type of the elements and do not have a ClassTag to provide it at run-time
    -Stacks
    val stack = new scala.collection.mutable.Stack[Int]
    stack.push(1)                                   // res52: stack.type = Stack(1)
    stack                                           // res53: scala.collection.mutable.Stack[Int] = Stack(1)
    stack.push(2)                                   // res54: stack.type = Stack(2, 1)
    stack                                           // res55: scala.collection.mutable.Stack[Int] = Stack(2, 1)
    stack.top                                       // res56: Int = 2
    stack                                           // res57: scala.collection.mutable.Stack[Int] = Stack(2, 1)
    stack.pop                                       // res58: Int = 2
    stack                                           // res59: scala.collection.mutable.Stack[Int] = Stack(1)
    -Array stacks
    // gets resized as needed
    // fast indexing and is generally slightly more efficient for most operations than a normal mutable stack
    -Hash tables
    // stores its elements in an underlying array
    // To get a guaranteed iteration order, use a linked hash map or set instead of a regular one
    val map = collection.mutable.HashMap.empty[Int,String]
    map += (1 -> "make a web site")                 // res60: map.type = Map(1 > make a web site)
    map += (3 -> "profit!")                         // res61: map.type = Map(1 -> make a web site, 3 -> profit!)
    map(1)                                          // res62: String = make a web site
    map contains 2                                  // res63: Boolean = false
    -Weak hash maps
    // key and its associated value will disappear from the map if there is no other reference to that key
    // As soon as a key object becomes unreachable, it’s entry is removed from the weak hash map
    -Concurrent Maps
    // can be accessed by several threads at once
    -Mutable bit sets
    // more efficient at updating than immutable ones, because they don’t have to copy around Longs that haven’t changed.
    val bits = scala.collection.mutable.BitSet.empty
    bits += 1                                       // res64: bits.type = BitSet(1)
    bits += 3                                       // res65: bits.type = BitSet(1, 3)
    bits                                            // res66: scala.collection.mutable.BitSet = BitSet(1, 3)

    -Arrays
    // Scala array Array[Int] is represented as a Java int[]
    // compatible with Scala sequences—you can pass an Array[T] where a Seq[T] (thanks to implicit conversions)
    val a1 = Array(1, 2, 3)                         // a1: Array[Int] = Array(1, 2, 3)
    val a2 = a1 map (_ * 3)                         // a2: Array[Int] = Array(3, 6, 9)
    val a3 = a2 filter (_ % 2 != 0)                 // a3: Array[Int] = Array(3, 9)
    a3.reverse                                      // res1: Array[Int] = Array(9, 3)
    // whenever an array would be used as a Seq, implicitly wrap it in a subclass of Seq. The name of that subclass is scala.collection.mutable.WrappedArray
    val seq: Seq[Int] = a1                          // seq: Seq[Int] = WrappedArray(1, 2, 3)
    val a4: Array[Int] = seq.toArray                // a4: Array[Int] = Array(1, 2, 3)
    a1 eq a4                                        // res2: Boolean = true

    -Strings
    // operations are supported by two implicit conversions (conversion maps a String to a WrappedString, which is a subclass of immutable.IndexedSeq)
    val str = "hello"                               
    str.reverse                                     // res6: String = olleh
    str.map(_.toUpper)                              // res7: String = HELLO
    str drop 3                                      // res8: String = lo
    str slice (1, 4)                                // res9: String = ell
    val s: Seq[Char] = str                          // s: Seq[Char] = WrappedString(h, e, l, l, o)

    -Performance characteristics
    // Performance characteristics of sequence types
                    head    tail    apply   update  prepend     append  insert
    immutable   
        List        C       C       L       L       C           L       -
        Stream      C       C       L       L       C           L       -
        Vector      eC      eC      eC      eC      eC          eC      -
        Stack       C       C       L       L       C           L       -
        Queue       aC      aC      L       L       L           C       -
        Range       C       C       C       -       -           -       -
        String      C       L       C       L       L           L       -
    mutable
        ArrayBuffer C       L       C       C       L           aC      L
        ListBuffer  C       L       L       L       C           C       L
        StringBldr  C       L       C       C       L           aC      L
        MutableList C       L       L       L       C           C       L
        Queue       C       L       L       L       C           C       L
        ArraySeq    C       L       C       C       -           -       -
        Stack       C       L       L       L       C           L       L
        ArrayStack  C       L       C       C       aC          L       L
        Array       C       L       C       C       -           -       -
    // Performance characteristics of set and map types
                        lookup  add     remove  min
    immutable
        HashSet/HashMap eC      eC      eC      L
        TreeSet/TreeMap Log     Log     Log     Log
        BitSet          C       L       L       eCa
        ListMap         L       L       L       L
    mutable
        HashSet/HashMap eC      eC      eC      L
        WeakHashMap     eC      eC      eC      L
        BitSet          C       aC      C       eCa

    -Equality
    // List(1, 2, 3) == Vector(1, 2, 3), and HashSet(1, 2) == TreeSet(2, 1).

    -Views
    // map, filter, and ++ make new collections
    // non-strict transformer, consider the following implementation of a lazy map operation
    def lazyMap[T, U](coll: Iterable[T], f: T => U) =
        new Iterable[U] {                               // constructs a new Iterable without stepping through all elements of the given collection coll
            def iterator = coll.iterator map f
        }
    // If xs is some collection, then xs.view is the same collection, but with all transformers implemented lazily
    v = Vector(1 to 10: _*)
    v map (_ + 1) map (_ * 2)                           // res5: scala.collection.immutable.Vector[Int] = Vector(4, 6, 8, 10, 12, 14, 16, 18, 20, 22)
    // v map (_ + 1) constructs a new vector, map (_ * 2) constructs third ( which is wastefull)
    // general way to avoid the intermediate results is by turning the vector first into a view
    (v.view map (_ + 1) map (_ * 2)).force              // res12: Seq[Int] = Vector(4, 6, 8, 10, 12, 14, 16, 18, 20, 22)
    // by switching a collection to a view the construction of intermediate results can be avoided

    -Iterators
    // An iterator is not a collection, but rather a way to access the elements of a collection one by one

    -Buffered iterators
    // Sometimes you want an iterator that can “look ahead”
    // head on a buffered iterator will return its first element, but will not advance the iterator
    def skipEmptyWords(it: BufferedIterator[String]) =
        while (it.head.isEmpty) { it.next() }
    // Every iterator can be converted to a buffered iterator by calling its buffered
    val it = Iterator(1, 2, 3, 4)
    val bit = it.buffered
    bit.head                        // res10: Int = 1
    bit.next()                      // res11: Int = 1
    bit.next()                      // res11: Int = 2


###############
# Assertions and Tests
###############
    -Assertions
    def above(that: Element): Element = {
        val this1 = this widen that.width
        val that1 = that widen this.width
        assert(this1.width == that1.width)
        elem(this1.contents ++ that1.contents)
    }

    private def widen(w: Int): Element =
        if (w <= width)
            this
        else {
            val left = elem(' ', (w - width) / 2, height)
            var right = elem(' ', w - width - left.width, height)
            left beside this beside right
        } ensuring (w <= _.width)                                   // underscore is a placeholder for the one argument passed to the predicate, the Element result of the widen method
        //  If the width passed as w to widen is less than or equal to the width of the result Element, the predicate will result in true

    -Testing in Scala
    import org.scalatest.FunSuite
    import Element.elem
    class ElementSuite extends FunSuite {                   // central concept in ScalaTest is the suite - collection of tests
        test("elem result should have passed width") {      // specify the name of the test as a string between the parentheses and the test code itself between curly braces
            val ele = elem('x', 2, 3)                       // test code is a function passed as a by-name parameter to test, which registers it for later execution
            assert(ele.width == 2)
        }
    }

    -Informative failure reports
    val caught =
        intercept[ArithmeticException] {
            1 / 0
        }
    assert(caught.getMessage == "/ by zero")

    -Tests as specifications
    import org.scalatest._
    class TVSetSpec extends FeatureSpec with GivenWhenThen {
        feature("TV power button") {
            scenario("User presses power button when TV is off") {
                Given("a TV set that is switched off")
                When("the power button is pressed")
                Then("the TV should switch on")
                pending
            }
        }
    }

    -Property-based testing
    import org.scalatest.WordSpec
    import org.scalatest.prop.PropertyChecks
    import org.scalatest.MustMatchers._
    import Element.elem
    class ElementSpec extends WordSpec with PropertyChecks {
        "elem result" must {
            "have passed width" in {
                forAll { (w: Int) =>
                    whenever (w > 0) {
                        elem('x', w, 3).width must equal (w)
                    }
                }
            }
        }
    }

    -Organizing and running tests
    scalac -cp scalatest.jar TVSetSpec.scala



###############
# Implicit Conversions and Parameters
###############
    -Implicit conversions
    val button = new JButton
    button.addActionListener(                                   // Scala program that uses Swing must use inner classes just like in Java
        new ActionListener {
            def actionPerformed(event: ActionEvent) = {
                println("pressed!")                             // only new information here
            }
        }
    )
    // first step is to write an implicit conversion between the two types
    implicit def function2ActionListener(f: ActionEvent => Unit) =
        new ActionListener {                                    // one-argument method that takes a function and returns an action listener
            def actionPerformed(event: ActionEvent) = f(event)
        }
    // called directly
    button.addActionListener(
        function2ActionListener((_: ActionEvent) => println("pressed!"))
    )
    // Because function2ActionListener is marked as implicit, it can be left out and the compiler will insert it automatically
    button.addActionListener(                                   // compiler first tries to compile it as is, but it sees a type error
        (_: ActionEvent) => println("pressed!")                 // Before giving up, it looks for an implicit conversion that can repair the problem. In this case, it finds function2ActionListener. It tries that conversion method, sees that it works, and moves on
    )

    -Rules for implicits
    // if x + y does not type check, then the compiler might change it to convert(x) + y, where convert is some available implicit conversion
    // f convert changes x into something that has a + method, then this change might fix a program so that it type checks and runs correctly
    -Marking rule: Only definitions marked implicit are available
    // implicit keyword is used to mark which declarations the compiler may use as implicit
    implicit def intToString(x: Int) = x.toString
    -Scope rule: An inserted implicit conversion must be in scope as a single identifier, or be associated with the source or target type of the conversion
    //compiler will not insert a conversion of the form someVariable.convert - you would need to import it, which would make it available as a single identifier
    object Dollar {                                             // compiler will find such an associated conversion every time it needs to convert from an instance of type Dollar
        implicit def dollarToEuro(x: Dollar): Euro = ...
    }
    class Dollar { ... }
    -One-at-a-time rule: Only one implicit is inserted
    // compiler will never rewrite x + y to convert1(convert2(x)) + y.
    -Explicits-first rule: Whenever code type checks as it is written, no implicits are attempted
    // compiler will not change code that already works
    -Naming an implicit conversion
    // matters if you want to use it explicitly or import something specific
    -Where implicits are tried
    // conversions to an expected type, conversions of the receiver of a selection, and implicit parameters

    -Implicit conversion to an expected type
    // Whenever the compiler sees an X, but needs a Y, it will look for an implicit function that converts X to Y
    val i: Int = 3.5                                            // error: type mismatch; found : Double(3.5) required: Int
    implicit def doubleToInt(x: Double) = x.toInt
    val i: Int = 3.5                                            // i: Int = 3

    -Converting the receiver
    // suppose you write down obj.doIt, and obj does not have a member named doIt. The compiler will try to insert conversions before giving up
    -Interoperating with new types
    class Rational(n: Int, d: Int) {
    ...
        def + (that: Rational): Rational = ...
        def + (that: Int): Rational = ...
    }
    val oneHalf = new Rational(1, 2)
    1 + oneHalf                                                 // error: overloaded method value + with
    implicit def intToRational(x: Int) = new Rational(x, 1)     // implicit conversion from Int to Rational
    1 + oneHalf                                                 // res2: Rational = 3/2

    -Simulating new syntax
    Map(1 -> "one", 2 -> "two", 3 -> "three")
    package scala
    object Predef {
        class ArrowAssoc[A](x: A) {                             // implicit conversion from Any to ArrowAssoc
            def ->[B](y: B): Tuple2[A, B] = Tuple2(x, y)        // When you write 1 -> "one", the compiler inserts a conversion from 1 to ArrowAssoc so that the -> method can be found.
        }
        implicit def any2ArrowAssoc[A](x: A): ArrowAssoc[A] =
            new ArrowAssoc(x)
        ...
    }

    -Implicit classes
    // for implicit class -compiler generates an implicit conversion from the class’s constructor parameter to the class itself
    case class Rectangle(width: Int, height: Int)
    implicit class RectangleMaker(width: Int) {
        def x(height: Int) = Rectangle(width, height)
    }
    // Automatically generated
    implicit def RectangleMaker(width: Int) =
        new RectangleMaker(width)
    // can create points by putting an x in between two integers
    val myRectangle = 3 x 4                                     // myRectangle: Rectangle = Rectangle(3,4)

    -Implicit parameters
    // compiler will sometimes replace someCall(a) with someCall(a)(b), or new SomeClass(a) with new SomeClass(a)(b),
    class PreferredPrompt(val preference: String)
    object Greeter {
        def greet(name: String)(implicit prompt: PreferredPrompt) = {   // last parameter list is marked implicit
            println("Welcome, " + name + ". The system is ready.")
            println(prompt.preference)
        }
    }
    val bobsPrompt = new PreferredPrompt("relax> ")                     // But you can still provide the prompt explicitly, like this
    Greeter.greet("Bob")(bobsPrompt)
    object JoesPrefs {
        implicit val prompt = new PreferredPrompt("Yes, master> ")      // let the compiler supply the parameter implicitly, you must first define a variable of the expected type, which in this case is PreferredPrompt
    }
    import JoesPrefs._

    def maxListImpParm[T](elements: List[T])(implicit ordering: Ordering[T]): T =
        elements match {
            case List() => throw new IllegalArgumentException("empty list!")
            case List(x) => x
            case x :: rest =>
            val maxRest = maxListImpParm(rest)(ordering)
            if (ordering.gt(x, maxRest)) x
            else maxRest
        }
    // standard Scala library provides implicit "ordering" methods for many common types
    maxListImpParm(List(1,5,10,3))                                      // res9: Int = 10
    maxListImpParm(List("one", "two", "three"))                         // res11: String = two

    -Context bounds
    def maxListImpParm[T](elements: List[T])(implicit ordering: Ordering[T]): T =
        elements match {
            case List() => throw new IllegalArgumentException("empty list!")
            case List(x) => x
            case x :: rest =>
            val maxRest = maxListImpParm(rest)                          // (ordering) is implicit
            if (ordering.gt(x, maxRest)) x                              // this ordering is still explicit
            else maxRest
        }
    def implicitly[T](implicit t: T) = t
    // effect of calling implicitly[Foo] is that the compiler will look for an implicit definition of type Foo. It will then call the implicitly method with that object, which in turn returns the object right back
    def maxListImpParm[T](elements: List[T])(implicit ordering: Ordering[T]): T =
        elements match {
            case List() => throw new IllegalArgumentException("empty list!")
            case List(x) => x
            case x :: rest =>
            val maxRest = maxListImpParm(rest)
            if (implicitly[Ordering[T]].gt(x, maxRest)) x
            else maxRest
        }

    -When multiple conversions apply
    // If one of the available conversions is strictly more specific than the others, then the compiler will choose the more specific one
    def printLength(seq: Seq[Int]) = println(seq.length)
    implicit def intToRange(i: Int) = 1 to i                            // intToRange: (i: Int)scala.collection.immutable.Range.Inclusive
    implicit def intToDigits(i: Int) =i.toString.toList.map(_.toInt)    // intToDigits: (i: Int)List[Int]

    -Debugging implicits
    // it helps to write the wrapString conversion explicitly to find out what went wrong
    // If you are brave, try scala Xprint: typer to get an interactive shell that prints out the post-typing source code it uses internally


###############
# Implementing Lists
###############
    -The List class in principle
    // abstract class List - comes with two subclasses for :: and Nil
    //            List[+T]                  // lists are covariant [+T] can assign a value of type List[Int] to a variable of type List[Any]
    //        «sealed abstract»
    //    ::[T]               Nil
    //«final case»        «case object»                
    val xs = List(1, 2, 3)
    var ys: List[Any] = xs
    // All list operations can be defined in terms of three basic methods: 
    def isEmpty: Boolean                    // defined in the subobject Nil and the subclass ::.
    def head: T
    def tail: List[T]

    -The Nil object
    // Nil object inherits from type List[Nothing] because of covariance, this means that Nil is compatible with every instance of the List type
    case object Nil extends List[Nothing] {
        override def isEmpty = true
        def head: Nothing = throw new NoSuchElementException("head of empty list")
        def tail: List[Nothing] = throw new NoSuchElementException("tail of empty list")
    }

    -The :: class (pronounced "cons" for "construct")
    // x :: xs is treated as ::(x, xs) where :: is a case class
    final case class ::[T](hd: T, tl: List[T]) extends List[T] {
        def head = hd
        def tail = tl
        override def isEmpty: Boolean = false
    }

    -Some more methods
    //
    def length: Int =
        if (isEmpty) 0 else 1 + tail.length
    //or:
    def drop(n: Int): List[T] =
        if (isEmpty) Nil
        else if (n <= 0) this
        else tail.drop(n-1)
    //or:
    def map[U](f: T => U): List[U] =
        if (isEmpty) Nil
        else f(head) :: tail.map(f)

    -List construction
    // methods :: and ::: - end in a colon so they bound to the right operand
    // x :: xs is treated as the method call xs.::(x), not x.::(xs).
    abstract class Fruit
    class Apple extends Fruit
    class Orange extends Fruit
    val apples = new Apple :: Nil               // apples: List[Apple] = List(Apple@e885c6a)
    val fruits = new Orange :: apples           // fruits: List[Fruit] = List(Orange@3f51b349, Apple@e885c6a)
    def ::[U >: T](x: U): List[U] = new scala.::(x, this)       // U is constrained in [U >: T] to be a supertype of the list elem T    

    -The ListBuffer class
    // typical access pattern for a list is recursive
    def incAll(xs: List[Int]): List[Int] = xs match {
        case List() => List()
        case x :: xs1 => x + 1 :: incAll(xs1)   // not tail recursive (recursive call to incAll above occurs inside a :: operation)
    }                                           // Therefore each recursive call requires a new stack frame
    // cannot apply incAll to lists of much more than about 30,000 to 50,000 elements
    // A very inefficient possibility is to use :::, the list append operator
    var result = List[Int]()                        // a very inefficient approach
    for (x <- xs) result = result ::: List(x + 1)   // Because ::: takes time proportional to the length of its first operand, the whole operation takes time proportional to the square of the length of the list
    result
    // List buffers let you accumulate the elements of a list. To do this, you use an operation such as “buf += elem”,which appends the element elem at the end of the list buffer buf
    import scala.collection.mutable.ListBuffer
    val buf = new ListBuffer[Int]
    for (x <- xs) buf += x + 1
    buf.toList

    -The List class in practice
    // most methods in the real implementation of class List avoid recursion and use loops with list buffers instead
    final override def map[U](f: T => U): List[U] = {
        val b = new ListBuffer[U]
        var these = this
        while (!these.isEmpty) {
            b += f(these.head)
            these = these.tail
        }
        b.toList
    }
    // The definition of the :: subclass of List.
    final case class ::[U](hd: U, private[scala] var tl: List[U]) extends List[U] {
        def head = hd
        def tail = tl
        override def isEmpty: Boolean = false
    }

    -Functional on the outside
    // lists are purely functional on the “outside” but have an imperative implementation using list buffers on the “inside.”
    val ys = 1 :: xs        // e tails of lists ys and zs are shared; they point to the same data structure.
    val zs = 2 :: xs
    // Scala’s List and ListBuffer is quite similar to what’s done in Java’s pair of classes String and StringBuffer


###############
# For Expressions Revisited
###############
    case class Person(name: String,isMale: Boolean, children: Person*)
    val lara = Person("Lara", false)
    val bob = Person("Bob", true)
    val julie = Person("Julie", false, lara, bob)
    val persons = List(lara, bob, julie)
    //  say you want to find out the names of all pairs of mothers and their children in that list
    persons filter (p => !p.isMale) flatMap (p =>(p.children map (c => (p.name, c.name))))      // res0: List[(String, String)] = List((Julie,Lara), (Julie,Bob)) 
    //  Is there a simpler way?
    for (p <- persons; if !p.isMale; c <- p.children)
        yield (p.name, c.name)              // res2: List[(String, String)] = List((Julie,Lara), (Julie,Bob))

    -For expressions
    for ( seq ) yield expr                  // seq is a sequence of generators, definitions, and filters, with semicolons between successive elements.
    for (p <- persons; n = p.name; if (n startsWith "To"))      // one generator, one definition, and one filter
    yield n
    // or
    for {
        p <- persons            // a generator
        n = p.name              // a definition
        if (n startsWith "To")  // a filter - filter drops from the iteration all elements for which expr returns false
    } yield n
    // several generators
    for (x <- List(1, 2); y <- List("one", "two"))
    yield (x, y)                // res3: List[(Int, String)] = List((1,one), (1,two), (2,one), (2,two))

    -The n-queens problem
    // Given a standard chess-board, place eight queens such that no queen is in check from any other
    // you need to place a queen in each row each time checking that a newly placed queen is not in check from any other queens
    // solution can be presented by a list of length k of coordinates (row, column)
    def queens(n: Int): List[List[(Int, Int)]] = {
        def placeQueens(k: Int): List[List[(Int, Int)]] =
            if (k == 0)
                List(List())
            else
                for {
                    queens <-placeQueens(k-1)
                    column <-1 to n
                    queen = (k, column)
                    if isSafe(queen, queens)
                } yield queen :: queens
        placeQueens(n)
    }
    def isSafe(queen: (Int, Int), queens: List[(Int, Int)]) =
        queens forall (q => !inCheck(queen, q))
    def inCheck(q1: (Int, Int), q2: (Int, Int)) =
        q1._1 == q2._1 ||               // same row
        q1._2 == q2._2 ||               // same column
        (q1._1 q2._
        1).abs == (q1._2 q2._2).abs     // on diagonal

    -Querying with for expressions
    // case class Book(title: String, authors: String*)
    val books: List[Book] =
        List(
            Book(
                "Structure and Interpretation of Computer Programs",
                "Abelson, Harold", "Sussman, Gerald J."
            ),
            Book(
                "Principles of Compiler Design",
                "Aho, Alfred", "Ullman, Jeffrey"
            ),
            Book(
                "Programming in Modula2",
                "Wirth, Niklaus"
            ),
            Book(
                "Elements of ML Programming",
                "Ullman, Jeffrey"
            ),
            Book(
                "The Java Language Specification", "Gosling, James",
                "Joy, Bill", "Steele, Guy", "Bracha, Gilad"
            )
        )
    // find the titles of all books whose author’s last name is "Gosling"
    for (b <-books;a <-b.authors; if a startsWith "Gosling")
        yield b.title                   // res4: List[String] = List(The Java Language Specification)
    // find the titles of all books that have the string “Program” in their title
    for (b <-books; if (b.title indexOf "Program") >= 0)
        yield b.title                   // res5: List[String] = List(Structure and Interpretation of Computer Programs, Programming in Modula2, Elements of ML Programming)
    // find the names of all authors who have written at least two books in the database:
    for (b1 <-books; b2 <-books; if b1 != b2; a1 <-b1.authors; a2 <b2.authors if a1 == a2)
        yield a1                        // res6: List[String] = List(Ullman, Jeffrey, Ullman, Jeffrey)
    def removeDuplicates[A](xs: List[A]): List[A] = {
        if (xs.isEmpty) xs
        else
            xs.head :: removeDuplicates(xs.tail filter (x => x != xs.head))
    }
    xs.head :: removeDuplicates(
        for (x <-xs.tail if x != xs.head) yield x
    )

    -Translation of for expressions
    -Translating for expressions with one generator
    for (x <-expr1) yield expr2                     // expr1.map(x => expr2)
    -Translating for expressions starting with a generator and a filter
    for (x <-expr1; if expr2) yield expr3           // for (x <-expr1 withFilter (x => expr2)) yield expr3  --> expr1 withFilter (x => expr2) map (x => expr3)
    -Translating for expressions starting with two generators
    for (x <-expr1; y <-expr2; seq) yield expr3     // expr1.flatMap(x => for (y <-expr2; seq) yield expr3)
    for (b1 <-books; b2 <-books if b1 != b2; a1 <-b1.authors; a2 <-b2.authors if a1 == a2)
        yield a1
    books flatMap (b1 =>
        books withFilter (b2 => b1 != b2) flatMap (b2 =>
            b1.authors flatMap (a1 =>
                b2.authors withFilter (a2 => a1 == a2) map (a2 =>
                    a1))))

    -Going the other way
    object Demo {
        def map[A, B](xs: List[A], f: A => B): List[B] =
            for (x <-xs) yield f(x)
        def flatMap[A, B](xs: List[A], f: A => List[B]): List[B] =
            for (x <-xs; y <-f(x)) yield y
        def filter[A](xs: List[A], p: A => Boolean): List[A] =
            for (x <-xs if p(x)) yield x
    }




###############
# The Architecture of Scala Collections
###############
    -Builders
    // all collection operations are implemented in terms of traversals and builders
    package scala.collection.generic
    class Builder[-Elem, +To] {
        def +=(elem: Elem): this.type
        def result(): To
        def clear()
        def mapResult[NewTo](f: To => NewTo): Builder[Elem, NewTo]
        = ...
    }

    -Factoring out common operations
    def map[B, That](f: Elem => B) 
        (implicit bf: CanBuildFrom[Repr, B, That]): That = {    // uses a builder factory that’s passed as an additional implicit parameter of type CanBuildFrom
        val b = bf(this)
        for (x <- this) b += f(x)
        b.result
    }
    package scala.collection.generic
    trait CanBuildFrom[-From, -Elem, +To] {
        // Creates a new builder
        def apply(from: From): Builder[Elem, To]
    }
    CanBuildFrom[Set[_], A, Set[A]]
    // when operating on an arbitrary Set, expressed by the wildcard type Set[_], you can build a Set again no matter what the element type A is

    -Integrating new collections
    -Integrating sequences
    abstract class Base
        case object A extends Base
        case object T extends Base
        case object G extends Base
        case object U extends Base
        object Base {
            val fromInt: Int => Base = Array(A, T, G, U)                    // implemented as an array
            val toInt: Base => Int = Map(A -> 0, T -> 1, G -> 2, U -> 3)    // implemented as a Map from Base values to integers  
    }
    // RNA strands class, final version.
    final class RNA private (val groups: Array[Int], val length: Int) extends IndexedSeq[Base] with IndexedSeqLike[Base, RNA] {
        import RNA._
        // Mandatory re-implementation of ‘newBuilder‘ in ‘IndexedSeq‘
        override protected[this] def newBuilder: Builder[Base, RNA] = RNA.newBuilder
        // Mandatory implementation of ‘apply‘ in ‘IndexedSeq‘
        def apply(idx: Int): Base = {
            if (idx < 0 || length <= idx)
                throw new IndexOutOfBoundsException
            Base.fromInt(groups(idx / N) >> (idx % N * S) & M)
        }
        // Optional re-implementation of foreach, to make it more efficient.
        override def foreach[U](f: Base => U): Unit = {
            var i = 0
            var b = 0
            while (i < length) {
                b = if (i % N == 0) groups(i / N) else b >>> S
                f(Base.fromInt(b & M))
                i += 1
            }
        }
    }
    // RNA companion object—final version
    object RNA {
        private val S = 2 // number of bits in group
        private val M = (1 << S) - 1 // bitmask to isolate a group
        private val N = 32 / S // number of groups in an Int
        def fromSeq(buf: Seq[Base]): RNA = {
            val groups = new Array[Int]((buf.length + N - 1) / N)
            for (i <- 0 until buf.length)
                groups(i / N) |= Base.toInt(buf(i)) << (i % N * S)
            new RNA(groups, buf.length)
        }
        def apply(bases: Base*) = fromSeq(bases)
        def newBuilder: Builder[Base, RNA] =
            new ArrayBuffer mapResult fromSeq
        implicit def canBuildFrom: CanBuildFrom[RNA, Base, RNA] =
            new CanBuildFrom[RNA, Base, RNA] {
                def apply(): Builder[Base, RNA] = newBuilder
                def apply(from: RNA): Builder[Base, RNA] = newBuilder
        }
    }


###############
# Extractors
###############
    -An example: extracting email addresses
    def isEMail(s: String): Boolean
    def domain(s: String): String
    def user(s: String): String
    // bad
    if (isEMail(s)) println(user(s) + " AT " + domain(s))
    else println("not an email address")
    // good
    s match {
        case EMail(user, domain) => println(user + " AT " + domain)
        case _ => println("not an email address")
    }

    -Extractors
    // extractor in Scala is an object that has a method called unapply (to match a value and take it apart)
    // The EMail string extractor object
    object EMail {
        // The injection method (optional)
        def apply(user: String, domain: String) = user + "@" + domain       // takes two strings and forms an email address string out of them
        // The extraction method (mandatory)
        def unapply(str: String): Option[(String, String)] = {              // takes an email address and returns potentially two strings
            val parts = str split "@"
            if (parts.length == 2) Some(parts(0), parts(1)) else None
        }
    }
    unapply("John@epfl.ch") equals Some("John", "epfl.ch")
    unapply("John Doe") equals None

    -Patterns with zero or one variables
    // The Twice string extractor object.
    object Twice {
        def apply(s: String): String = s + s
        def unapply(s: String): Option[String] = {
            val length = s.length / 2
            val half = s.substring(0, length)
            if (half == s.substring(length)) Some(half) else None
        }
    }

    -Variable argument extractors
    dom match {
        case Domain("org", "acm") => println("acm.org")
        case Domain("com", "sun", "java") => println("java.sun.com")
        case Domain("net", _*) => println("a .net domain")
    }
    // unapply methods encountered so far are not sufficient to support vararg matching
    object Domain {
        // The injection method (optional)
        def apply(parts: String*): String =
            parts.reverse.mkString(".")
        // The extraction method (mandatory)
        def unapplySeq(whole: String): Option[Seq[String]] =
            Some(whole.split("\\.").reverse)
    }
    def isTomInDotCom(s: String): Boolean = s match {
        case EMail("tom", Domain("com", _*)) => true
        case _ => false
    }
    isTomInDotCom("tom@sun.com")                        // res3: Boolean = true
    isTomInDotCom("peter@sun.com")                      // res4: Boolean = false
    isTomInDotCom("tom@acm.org")                        // res5: Boolean = false

    -Extractors and sequence patterns
    List()
    List(x, y, _*)
    Array(x, 0, 0, _)
    // all possible because List companion has
    package scala
    object List {
        def apply[T](elems: T*) = elems.toList
        def unapplySeq[T](x: List[T]): Option[Seq[T]] = Some(x)
        ...
    }

    -Extractors versus case classes
    // case class pattern corresponds to the concrete representation type of the selector object
    // extractors enable patterns that have nothing to do with the data type of the object that’s selected on

    -Regular expressions
    // Forming regular expressions
    ab?                             // An ‘a’, possibly followed by a ‘b’.
    [a-dA-D]\w*                     // A word starting with a letter between a and d in lower or upper case, followed by a sequence of zero or more “word characters” denoted by \w. (A word character is a letter, digit, or underscore.)
    (-)?(\d+)(\.\d*)?               // A number consisting of an optional minus sign, followed by one or more digits, optionally followed by a period and zero or more digits. The number contains three groups, i.e., the minus sign, the part before the decimal point, and the fractional part including the decimal point. Groups are enclosed in parentheses.
    val Decimal = new Regex("(-)?(\\d+)(\\.\\d*)?")
    val input = "for 1.0 to 99 by 3"    // input: String = for 1.0 to 99 by 3
    for (s <-Decimal findAllIn input)   // -1.0 99 3
        println(s)


###############
# Annotations
###############
    -Syntax of annotations
    @deprecated def bigMistake() = //...
    @deprecated class QuickAndDirty {
        //...
    }
    (e: @unchecked) match {
        // nonexhaustive cases...
    }


###############
# Modular Programming Using Objects
###############
    - A recipe application
    // A simple Food entity class.
    package org.stairwaybook.recipe
    abstract class Food(val name: String) {
        override def toString = name
    }
    // Simple Recipe entity class
    package org.stairwaybook.recipe
    class Recipe( val name: String, val ingredients: List[Food], val instructions: String) {
        override def toString = name
    }
    // Food and Recipe examples for use in tests.
    package org.stairwaybook.recipe
    object Apple extends Food("Apple")
    object Orange extends Food("Orange")
    object Cream extends Food("Cream")
    object Sugar extends Food("Sugar")
    object FruitSalad extends Recipe(
        "fruit salad",
        List(Apple, Orange, Cream, Sugar),
        "Stir it all together."
    )
    // Mock database and browser modules
    package org.stairwaybook.recipe
    object SimpleDatabase {
        def allFoods = List(Apple, Orange, Cream, Sugar)
        def foodNamed(name: String): Option[Food] =
            allFoods.find(_.name == name)
        def allRecipes: List[Recipe] = List(FruitSalad)
    }
    object SimpleBrowser {
        def recipesUsing(food: Food) =
            SimpleDatabase.allRecipes.filter(recipe =>
                recipe.ingredients.contains(food))
    }
    val apple = SimpleDatabase.foodNamed("Apple").get       // apple: Food = Apple
    SimpleBrowser.recipesUsing(apple)                       // res0: List[Recipe] = List(fruit salad)
    // Database and browser modules with categories added.
    package org.stairwaybook.recipe
    object SimpleDatabase {
        def allFoods = List(Apple, Orange, Cream, Sugar)
        def foodNamed(name: String): Option[Food] =
            allFoods.find(_.name == name)
        def allRecipes: List[Recipe] = List(FruitSalad)
        case class FoodCategory(name: String, foods: List[Food])
            private var categories = List(
                FoodCategory("fruits", List(Apple, Orange)),
                FoodCategory("misc", List(Cream, Sugar)))
        def allCategories = categories
    }
    object SimpleBrowser {
        def recipesUsing(food: Food) =
            SimpleDatabase.allRecipes.filter(recipe =>
                recipe.ingredients.contains(food))
        def displayCategory(category: SimpleDatabase.FoodCategory) = {
            println(category)
        }
    }

    -Abstraction
    // problem is that there is essentially a “hard link” from the browser module to the database modules: 
    SimpleDatabase.allRecipes.filter(recipe => ...
    // A Browser class with an abstract database val
    abstract class Browser {
        val database: Database
        def recipesUsing(food: Food) =
            database.allRecipes.filter(recipe =>
                recipe.ingredients.contains(food))
        def displayCategory(category: database.FoodCategory) = {
            println(category)
        }
    }
    // You would like to reuse the browser code for each of the instances, because the only thing different about the browsers is which database they refer to
    // A Database class with abstract methods
    abstract class Database {
        def allFoods: List[Food]
        def allRecipes: List[Recipe]
        def foodNamed(name: String) =
            allFoods.find(f => f.name == name)
        case class FoodCategory(name: String, foods: List[Food])
        def allCategories: List[FoodCategory]
    }
    // The SimpleDatabase object as a Database subclass
    object SimpleDatabase extends Database {
        def allFoods = List(Apple, Orange, Cream, Sugar)
        def allRecipes: List[Recipe] = List(FruitSalad)
        private var categories = List(
            FoodCategory("fruits", List(Apple, Orange)),
            FoodCategory("misc", List(Cream, Sugar)))
        def allCategories = categories
    }
    val apple = SimpleDatabase.foodNamed("Apple").get           // apple: Food = Apple
    // The SimpleBrowser object as a Browser subclass
    object SimpleBrowser extends Browser {
        val database = SimpleDatabase
    }
    // you can create a second mock database - student database and browser
    object StudentDatabase extends Database {
        object FrozenFood extends Food("FrozenFood")
        object HeatItUp extends Recipe(
            "heat it up",
             List(FrozenFood),
            "Microwave the 'food' for 10 minutes.")
        def allFoods = List(FrozenFood)
        def allRecipes = List(HeatItUp)
        def allCategories = List(FoodCategory("edible", List(FrozenFood)))
    }
        object StudentBrowser extends Browser {
            val database = StudentDatabase
    }

    -Splitting modules into traits
    // A trait for food categories
    trait FoodCategories {
        case class FoodCategory(name: String, foods: List[Food])
        def allCategories: List[FoodCategory]
    }
    // A Database class that mixes in the FoodCategories trait
    abstract class Database extends FoodCategories {
        def allFoods: List[Food]
        def allRecipes: List[Recipe]
        def foodNamed(name: String) =
            allFoods.find(f => f.name == name)
    }
    // A SimpleFoods trait
    trait SimpleFoods {
        object Pear extends Food("Pear")
        def allFoods = List(Apple, Pear)
        def allCategories = Nil
    }
    // A SimpleDatabase object composed solely of mixins
    object SimpleDatabase extends Database with SimpleFoods with SimpleRecipes
    // A SimpleRecipes trait with a self type
    trait SimpleRecipes {
        this: SimpleFoods =>
        object FruitSalad extends Recipe(
            "fruit salad",
            List(Apple, Pear), // Now Pear is in scope
            "Mix it all together."
        )
        def allRecipes = List(FruitSalad)
    }

    -Runtime linking
    // you can decide which modules will link to which depending on runtime computations
    // An app that dynamically selects a module implementation
    object GotApples {
        def main(args: Array[String]) = {
            val db: Database =
                if(args(0) == "student")
                    StudentDatabase
                else
                    SimpleDatabase
        object browser extends Browser {
            val database = db
        }
        val apple = SimpleDatabase.foodNamed("Apple").get
        for(recipe <-browser.recipesUsing(apple))
            println(recipe)
        }
    }

    -Tracking module instances
    // in the previous section each module has its own contents, including any nested classes


###############
# Object Equality
###############
    -Equality in Scala
    // For value types, == is value comparison, just like in Java. For reference types, == is the same as equals in Scala
    final def == (that: Any): Boolean =
        if (null eq this) {null eq that} else {this equals that}

    -Writing an equality method
    // Pitfall #1: Defining equals with the wrong signature
    class Point(val x: Int, val y: Int) { ... }
    // An utterly wrong definition of equals
    def equals(other: Point): Boolean =
        this.x == other.x && this.y == other.y
    val p1, p2 = new Point(1, 2)
    p1 equals p2                                            // res0: Boolean = true
    val coll = mutable.HashSet(p1)
    coll contains p2                                        // res2: Boolean = false
    // equals method operates on generic sets, it calls the generic equals method in Object instead of the overloaded variant in Point
    // A better definition, but still not perfect
    override def equals(other: Any) = other match {
        case that: Point => this.x == that.x && this.y == that.y
        case _ => false
    }
    // Pitfall #2: Changing equals without also changing hashCode
    val p1, p2 = new Point(1, 2)
    collection.mutable.HashSet(p1) contains p2              // res4: Boolean = false
    class Point(val x: Int, val y: Int) {
        override def hashCode = (x, y).##                   // invoked on a collection or a tuple, it computes a mixed hash that is sensitive to the hash codes of all the elements in the collection
        override def equals(other: Any) = other match {
            case that: Point => this.x == that.x && this.y == that.y
            case _ => false
        }
    }
    // Pitfall #3: Defining equals in terms of mutable fields
    class Point(var x: Int, var y: Int) { // Problematic    // fields x and y are now vars instead of vals
        override def hashCode = (x, y).##
        override def equals(other: Any) = other match {
            case that: Point => this.x == that.x && this.y == that.y
            case _ => false
        }
    }
    val p = new Point(1, 2)
    val coll = collection.mutable.HashSet(p)
    coll contains p                                         // res5: Boolean = true
    p.x += 1
    coll contains p                                         // res7: Boolean = false

    //Pitfall #4: Failing to define equals as an equivalence relation
    It is reflexive: For any non-null value x , the expression x.equals(x) should return true.
    • It is symmetric: For any non-null values x and y, x.equals(y) should return true if and only if y.equals(x) returns true.
    • It is transitive: For any non-null values x, y, and z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) should return true.
    • It is consistent: For any non-null values x and y, multiple invocations of x.equals(y) should consistently return true or consistently return false, provided no information used in equals comparisons on the objects is modified.
    • For any non-null value x, x.equals(null) should return false
    class ColoredPoint(x: Int, y: Int, val color: Color.Value) extends Point(x, y) {
        override def hashCode = (super.hashCode, color).##
        override def equals(other: Any) = other match {
            case that: ColoredPoint => (that canEqual this) && super.equals(that) && this.color == that.color
            case _ => false
    }
        override def canEqual(other: Any) =
            other.isInstanceOf[ColoredPoint]
    }
    val p = new Point(1, 2)
    val cp = new ColoredPoint(1, 2, Color.Indigo)
    val pAnon = new Point(1, 1) { override val y = 2 }
    val coll = List(p)
    coll contains p             // res16: Boolean = true
    coll contains cp            // res17: Boolean = false
    coll contains pAnon         // res18: Boolean = true

    -Defining equality for parameterized types
    // Hierarchy for binary trees-
    trait Tree[+T] {
        def elem: T
        def left: Tree[T]
        def right: Tree[T]
    }
    object EmptyTree extends Tree[Nothing] {
        def elem =
            throw new NoSuchElementException("EmptyTree.elem")
        def left =
            throw new NoSuchElementException("EmptyTree.left")
        def right =
            throw new NoSuchElementException("EmptyTree.right")
    }
    class Branch[+T](
        val elem: T,
        val left: Tree[T],
        val right: Tree[T]
    ) extends Tree[T]
    // implementation
    override def equals(other: Any) = other match {
        case that: Branch[T] => this.elem == that.elem &&       // non variable type-argument T in type pattern is unchecked since it is eliminated by erasure
                                this.left == that.left &&
                                this.right == that.right
        case _ => false
    }
    // fix
    case that: Branch[t] => this.elem == that.elem &&           // pattern starting with a lower-case letter represents an unknown type
                            this.left == that.left &&
                            this.right == that.right
    case that: Branch[_] =>
    // hashcode
    override def hashCode: Int = (elem, left, right).##

    // canEqual
    def canEqual(other: Any) = other match {
        case that: Branch[_] => true
        case _ => false
    }
    // or def canEqual(other: Any) = other.isInstanceOf[Branch[_]]

    -Recipes for equals and hashCode
    // A parameterized type with equals and hashCode
    class Branch[T](
        val elem: T,
        val left: Tree[T],
        val right: Tree[T]
    ) extends Tree[T] {
        override def equals(other: Any) = other match {
            case that: Branch[_] => (that canEqual this) &&
                                     this.elem == that.elem &&
                                     this.left == that.left &&
                                     this.right == that.right
            case _ => false
        }
        def canEqual(other: Any) = other.isInstanceOf[Branch[_]]
        override def hashCode: Int = (elem, left, right).##
    }


###############
# Futures and Concurrency
###############
    -Trouble in paradise
    var counter = 0
    synchronized {
        // One thread in here at a time
        counter = counter + 1
    }

    -Asynchronous execution and Trys
    // Scala method performs a computation “while you wait” and returns a result
    import scala.concurrent.ExecutionContext.Implicits.global
    val fut = Future { Thread.sleep(10000); 21 + 21 }           // asynchronously executes the block of code, using the global execution context
    fut.isCompleted                                             // res0: Boolean = false
    fut.value                                                   // res1: Option[scala.util.Try[Int]] = None
    fut.isCompleted                                             // res2: Boolean = true
    fut.value                                                   // res3: Option[scala.util.Try[Int]] = Some(Success(42))

    //         Try[+T]
    //     «sealed abstract»
    // Success[T]          Failure[T]
    // «final case»        «final case»    
    // when working with a Future representing an asynchronous activity, you use Try to deal with the possibility that the activity fails to yield a value and instead completes abruptly an exception
    val fut = Future { Thread.sleep(10000); 21 / 0 }
    fut.value                                                   // res4: Option[scala.util.Try[Int]] = None
    // after ten seconds
    fut.value                                                   // res5: Option[scala.util.Try[Int]] = Some(Failure(java.lang.ArithmeticException: / by zero))

    -Working with Futures
    // Transforming Futures with map
    val fut = Future { Thread.sleep(10000); 21 + 21 }
    val result = fut.map(x => x + 1)                            // yield another future
    result.value                                                // res5: Option[scala.util.Try[Int]] = None
    // after 10 sec
    result.value                                                // res6: Option[scala.util.Try[Int]] = Some(Success(43))
    // Transforming Futures with for expressions
    val fut1 = Future { Thread.sleep(10000); 21 + 21 }
    val fut2 = Future { Thread.sleep(10000); 23 + 23 }
    for {                                                       // here futures will run in parallel
        x <-fut1
        y <-fut2
    } yield x + y                                               // res7: scala.concurrent.Future[Int] = ...
    res7.value                                                  // res8: Option[scala.util.Try[Int]] = Some(Success(88))
    // below it will take 20 secs to run because they will run in sequence
    for {
        x <-Future { Thread.sleep(10000); 21 + 21 }
        y <-Future { Thread.sleep(10000); 23 + 23 }
    } yield x + y
    // Creating the Future: Future.failed, Future.successful, Future.fromTry, and Promises
    // methods for creating already-completed futures: successful, failed, and fromTry
    Future.successful { 21 + 21 }                           // res2: scala.concurrent.Future[Int] = ... future that has already succeeded
    Future.failed(new Exception("bummer!"))                 // res3: scala.concurrent.Future[Nothing] = ...
    import scala.util.{Success,Failure}
    import scala.util.{Success, Failure}
    Future.fromTry(Success { 21 + 21 })                     // res4: scala.concurrent.Future[Int] = ...
    Future.fromTry(Failure(new Exception("bummer!")))       // res5: scala.concurrent.Future[Nothing] = ...
    // using prmise
    val pro = Promise[Int]                                  // pro: scala.concurrent.Promise[Int] = ...
    val fut = pro.future                                    // fut: scala.concurrent.Future[Int] = ...
    fut.value                                               // res8: Option[scala.util.Try[Int]] = None-Testing with Futures
    pro.success(42)                                         // res9: pro.type = ...
    fut.value                                               // res10: Option[scala.util.Try[Int]] = Some(Success(42))
    // Filtering: filter and collect
    // filter method validates the future result, leaving it the same if it is valid
    val fut = Future { 42 }                                 //fut: scala.concurrent.Future[Int] = ...
    val valid = fut.filter(res => res > 0)                  // valid: scala.concurrent.Future[Int] = ...
    valid.value                                             // res0: Option[scala.util.Try[Int]] = Some(Success(42))
    val invalid = fut.filter(res => res < 0)                // invalid: scala.concurrent.Future[Int] = ...
    invalid.value                                           // res1: Option[scala.util.Try[Int]] = Some(Failure(java.util.NoSuchElementException: Future.filter predicate is not satisfied))
    // inside for
    val valid = for (res <-fut if res > 0) yield res        // valid: scala.concurrent.Future[Int] = ...
    valid.value                                             // res2: Option[scala.util.Try[Int]] = Some(Success(42))
    // collect method allows you to validate the future value and transform it in one operation
    val valid = fut collect { case res if res > 0 => res + 46 }
    valid.value                                             // res17: Option[scala.util.Try[Int]] = Some(Success(88))
    val invalid = fut collect { case res if res < 0 => res + 46 }
    invalid.value                                           // res18: Option[scala.util.Try[Int]] = Some(Failure(java.util.NoSuchElementException: Future.collect partial function is not defined at: 42))
    // Dealing with failure: failed, fallBackTo, recover, and recoverWith
    val failure = Future { 42 / 0 }
    failure.value                                           // res23: Option[scala.util.Try[Int]] = Some(Failure(java.lang.ArithmeticException: / by zero)
    val expectedFailure = failure.failed                    // expectedFailure: scala.concurrent.Future[Throwable] = ...
    expectedFailure.value                                   // res25: Option[scala.util.Try[Throwable]] = Some(Success(java.lang.ArithmeticException: / by zero))
    val success = Future { 42 / 1 }
    success.value                                           // res21: Option[scala.util.Try[Int]] = Some(Success(42))
    // future on which the failed method is called ultimately succeeds
    // Mapping both possibilities: transform
    // transform method accepts two functions with which to transform a future: one to use in case of success and the other in case of failure
    val first = success.transform(
        res => res * 1,
        ex => new Exception("see cause", ex)
    )
    val second = failure.transform(
        res => res * 1,
        ex => new Exception("see cause", ex)
    )
    second.value                                            // res43: Option[scala.util.Try[Int]] =Some(Failure(java.lang.Exception: see cause)
    val firstCase = success.transform { // Scala 2.12
        case Success(res) => Success(res * 1)
        case Failure(ex) => Failure(new Exception("see cause", ex))
    }
    val secondCase = failure.transform {
        case Success(res) => Success(res * 1)
        case Failure(ex) => Failure(new Exception("see cause", ex))
    }
    // using transform to transform a failure into success
    val nonNegative = failure.transform { // Scala 2.12
        case Success(res) => Success(res.abs + 1)
        case Failure(_) => Success(0)
    }
    // Combining futures: zip, Future.fold, Future.reduce, Future.sequence, and Future.traverse
    // zip method will transform two successful futures into a future tuple of both values
    val zippedSuccess = success zip recovered
    zippedSuccess.value                                     // res46: Option[scala.util.Try[(Int, Int)]] = Some(Success((42,1)))
    val zippedFailure = success zip failure
    zippedFailure.value                                     // res48: Option[scala.util.Try[(Int, Int)]] = Some(Failure(java.lang.ArithmeticException: / by zero))
    // fold
    val fortyTwo = Future { 21 + 21 }
    val fortySix = Future { 23 + 23 }
    val futureNums = List(fortyTwo, fortySix)
    val folded = Future.fold(futureNums)(0) { (acc, num) => acc + num }     // If any future in the collection fails, the resulting future will fail
    // reduce method performs a fold without a zero, using the initial future result as the start value
    val reduced = Future.reduce(futureNums) { (acc, num) => acc + num }
    // Performing side-effects: foreach, onComplete, and andThen
    // you may need to perform a side effect after a future completes
    failure.foreach(ex => println(ex))                      // println is not executed in the case of a failed future
    success.foreach(res => println(res))                    // 42
    // for without yield will rewrite to an invocation of foreach
    for (res <- failure) println(res)
    for (res <- success) println(res)                       // 42
    // onComplete executed for both cases (no order)
    success onComplete {
        case Success(res) => println(res)
        case Failure(ex) => println(ex)
    }                                                       // 42
    scala> failure onComplete {
        case Success(res) => println(res)
        case Failure(ex) => println(ex)
    }                                                       // java.lang.ArithmeticException: / by zero
    // andThen
    val newFuture = success andThen {
        case Success(res) => println(res)
        case Failure(ex) => println(ex)
    }                                                       // 42
    newFuture.value                                         // res76: Option[scala.util.Try[Int]] = Some(Success(42))
    // Other methods added in 2.12: flatten, zipWith, and transformWith
    val nestedFuture = Future { Future { 42 } }             // nestedFuture: Future[Future[Int]] = ...
    val flattened = nestedFuture.flatten                    // flattened: scala.concurrent.Future[Int] = Future(Success(42))
    // zipWith
    val futNum = Future { 21 + 21 }
    val futStr = Future { "ans" + "wer" }
    val zipped = futNum zip futStr                          // zipped: scala.concurrent.Future[(Int, String)] = ...
    val mapped = zipped map {
        case (num, str) => s"$num is the $str"
    }                                                       // mapped: scala.concurrent.Future[String] = ...
    scala> mapped.value                                     // res2: Option[scala.util.Try[String]] = Some(Success(42 is the answer))
    // in one line
    val fut = futNum.zipWith(futStr) { // Scala 2.12
        case (num, str) => s"$num is the $str"
    }

    -Testing with Futures
    // Scala does allow you to block on a future result when you need to.
    import scala.concurrent.Await
    import scala.concurrent.Await
    import scala.concurrent.duration._
    import scala.concurrent.duration._
    val fut = Future { Thread.sleep(10000); 21 + 21 }
    val x = Await.result(fut, 15.seconds) // blocks         // x: Int = 42
    // place where blocking has been generally accepted is in tests of asynchronous code
    import org.scalatest.Matchers._
    import org.scalatest.Matchers._
    x should be (42)                                        // res0: org.scalatest.Assertion = Succeeded