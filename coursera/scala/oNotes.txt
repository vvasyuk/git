###############
# Classes and Objects
###############
class ChecksumAccumulator {
    private var sum = 0
    def add(b: Byte): Unit = { sum += b }
    def checksum(): Int = ~(sum & 0xFF) + 1
}

-Singleton objects
import scala.collection.mutable
object ChecksumAccumulator {
    private val cache = mutable.Map.empty[String, Int]
    def calculate(s: String): Int =
        if (cache.contains(s))
            cache(s)
        else {
            val acc = new ChecksumAccumulator
            for (c <s)
            acc.add(c.toByte)
            val cs = acc.checksum()
            cache += (s >
            cs)
            cs
        }
}

-A Scala application
import ChecksumAccumulator.calculate
object Summer {
    def main(args: Array[String]) = {
        for (arg <args)
            println(arg + ": " + calculate(arg))
    }
}

-The App trait
import ChecksumAccumulator.calculate
object FallWinterSpringSummer extends App {
    for (season <List("fall", "winter", "spring"))
        println(season + ": " + calculate(season))
}


###############
# Basic Types and Operations
###############
-Character literals
val a = 'A'         // a: Char = A
val d = '\u0041'    // d: Char = A
val f = '\u0044'    // f: Char = D
val B\u0041\u0044 = 1   //BAD: Int = 1

-String interpolation
val name = "reader"         // println(s"Hello, $name!")
s"The answer is ${6 * 7}."  // res0: String = The answer is 42.

infix operator                  // method between the object and the parameter ("7 + 2")
prefix operator (only +,-,!,~)  // method before the object on which you are invoking the method (-7, !found). "-2.0" transformed into (2.0).unary_-
postfix operator                // method after the object ("7 toLong")

-Bitwise operations
1 & 2   // 1 (0001) and 2 (0010) = 0 (0000)
1 | 2   // 1 (0001) and 2 (0010) = 3 (0011)
1 ˆ 3   // 1 (0001) and 2 (0010) = 2 (0010)
~1      // inverts each bit in 1 (0001), yielding -2, which in binary looks like 11111111111111111111111111111110.
1 << 2  // 4

-Operator precedence and associativity
* / %
+ :
= !
< >
&
ˆ
|
(all letters)
(all assignment operators)


###############
# Functional Objects
###############
class Rational(n: Int, d: Int) {                    // primary constructor will be created with these two params
    require(d != 0)                                 // class body code will be added to primary constructor (precondition of the primary constructor that d must be non-zero)
    private val g = gcd(n.abs, d.abs)
    val numer = n / g
    val denom = d / g
    def this(n: Int) = this(n, 1)                   // auxiliary constructors invokes the primary constructor
    def + (that: Rational): Rational =              // simply that.d will not work because d is not accessible outside object where they invoked, so we added numer, denum fields
        new Rational(numer * that.denom + 
        that.numer * denom,denom * that.denom)
    def + (i: Int): Rational =
        new Rational(numer + i * denom, denom)
    def (that: Rational): Rational =
        new Rational(numer * that.denom that.numer* 
        denom,denom * that.denom)
    def (i: Int): Rational =
        new Rational(numer i* denom, denom)
    def * (that: Rational): Rational =
        new Rational(numer * that.numer, denom * 
        that.denom)
    def * (i: Int): Rational =
        new Rational(numer * i, denom)
    def / (that: Rational): Rational =
        new Rational(numer * that.denom, denom * 
        that.numer)
    def / (i: Int): Rational =
        new Rational(numer, denom * i)
    override def toString = numer + "/" + denom     // override default override
    private def gcd(a: Int, b: Int): Int =
        if (b == 0) a else gcd(b, a % b)
}

-Implicit conversions
r * 2   // works
2 * r   // does not work, 2 is Int - not method that takes Rational argument
implicit def intToRational(x: Int) = new Rational(x)


###############
# Built-in Control Structures
###############
-If expressions
val filename = if (!args.isEmpty) args(0) else "default.txt"

-While loops
def gcdLoop(x: Long, y: Long): Long = {
    var a = x
    var b = y
    while (a != 0) {
        val temp = a
        a = b % a
        b = temp
    }
    b
}

while ((line = readLine()) != "")   // This doesn't work! (line = readLine()) retunrs Unit
    println("Read: " + line)

-For expressions
for (file <- filesHere)             // for file in filesHere
    println(file)
for (i <- 1 to 4)                   //
    println("Iteration " + i)
-Filtering
for (
    file <- filesHere
    if file.isFile
    if file.getName.endsWith(".scala")
) println(file)
-Nested iteration
def fileLines(file: java.io.File) =
    scala.io.Source.fromFile(file).getLines().toList
def grep(pattern: String) =
    for (
        file <- filesHere
        if file.getName.endsWith(".scala");
        line <- fileLines(file)
        if line.trim.matches(pattern)
    ) println(file + ": " + line.trim)
grep(".*gcd.*")
-Producing a new collection
def scalaFiles =                    // type of the resulting collection is based on the kind of collections processed in the iteration clauses
    for {
        file <- filesHere
        if file.getName.endsWith(".scala")
    } yield file                    // In this case the result is an Array[File], because filesHere is an array and the type of the yielded expression is File

-Exception handling with try expressions
val half =
    if (n % 2 == 0)
        n / 2                       // One branch of an if computes a value, while the other throws an exception and computes Nothing
    else
        throw new RuntimeException("n must be even")    // If n is not even, an exception will be thrown before half can be initialized to anything at all

-Catching exception
try {
    val f = new FileReader("input.txt")
    // Use and close file
} catch {
    case ex: FileNotFoundException => // Handle missing file
    case ex: IOException => // Handle other I/O error
}

-The finally clause
val file = new FileReader("input.txt")
try {
    // Use the file
} finally {
    file.close() // Be sure to close the file
}

-Yielding a value
def urlFor(path: String) =
    try {
        new URL(path)
    } catch {
        case e: MalformedURLException =>
        new URL("http://www.scalalang.org") // this one is returned if eexception is thrown and cought
    }

-Match expressions
val firstArg = if (!args.isEmpty) args(0) else ""
val friend = firstArg match {
    case "salt" => "pepper"
    case "chips" => "salsa"
    case "eggs" => "bacon"
    case _ => "huh?"
}
println(friend)

-Living without break and continue
var i = 0
var foundIt = false
while (i < args.length && !foundIt) {
    if (!args(i).startsWith("")){
        if (args(i).endsWith(".scala"))
            foundIt = true
        }
    i = i + 1
}
-get ird of vars
def searchFrom(i: Int): Int =
    if (i >= args.length) 1
    else if (args(i).startsWith("")) searchFrom(i + 1)
    else if (args(i).endsWith(".scala")) i
    else searchFrom(i + 1)
val i = searchFrom(0)


###############
# Functions and Closures
###############
-Methods
object LongLines {
    def processFile(filename: String, width: Int) = {
        val source = Source.fromFile(filename)
        for (line <- source.getLines())
            processLine(filename, width, line)
    }
    private def processLine(filename: String,width: Int, line: String) = {
        if (line.length > width)
            println(filename + ": " + line.trim)
    }
}
object FindLongLines {
    def main(args: Array[String]) = {
        val width = args(0).toInt
        for (arg <args.drop(1))
            LongLines.processFile(arg, width)
    }
}

-Local functions
object LongLines {
    def processFile(filename: String, width: Int) = {
        def processLine(line: String) = {
            if (line.length > width)                // local functions can access the parameters of their enclosing function
                println(filename + ": " + line.trim)
        }
        val source = Source.fromFile(filename)
        for (line <-source.getLines())
            processLine(line)
    }
}

-First-class functions
// A function literal is compiled into a class that when instantiated at runtime is a function value
// function literals exist in the source code
// function values exist as objects at runtime
// Every function value is an instance of some class that extends one of several FunctionN traits in package scala

(x: Int) => x + 1                   // function literal
var increase = (x: Int) => x + 1    // Function values are objects, so you can store them in variables
increase(10)                        // you can call them

-Short forms of function literals
someNumbers.filter(x => x > 0)

-Placeholder syntax
someNumbers.filter(_ > 0)
val f = (_: Int) + (_: Int)     // f: (Int, Int) => Int = <function2>
f(5, 10)

-Partially applied functions
// Although the previous examples substitute underscores in place of individual parameters, you can also replace an entire parameter list with an underscore
// when you invoke a function, passing in any needed arguments, you apply that function to the arguments
// given
def sum(a: Int, b: Int, c: Int) = a + b + c
// You could apply the function sum to the arguments 1, 2, and 3 like this
sum(1, 2, 3)

// partially applied function is an expression in which you don’t supply all of the arguments needed by the function. Instead, you supply some, or none
val a = sum _       // partially applied function expression involving sum, in which you supply none of the three required args
a(1, 2, 3)          // Scala compiler translates the expression a(1, 2, 3) into an invocation of the function value’s apply method, passing in the three arguments 1, 2, and 3.

val b = sum(1, _: Int, 3)   // you can also express a partially applied function by supplying only some of the required arguments
b(2)                        // res13: Int = 6

-Closures
(x: Int) => x + more        // A function object that captures free variables, and is said to be "closed" over the variables visible at the time it is created.
var more = 1
val addMore = (x: Int) => x + more  // addMore: Int => Int = <function1>
addMore(10)                         // res16: Int = 11
more = 9999                         // What happens if more changes after the closure is created? In Scala, the answer is that the closure sees the change
addMore(10)                         // res17: Int = 10009

val someNumbers = List(11,10,5,0, 5, 10)
var sum = 0
someNumbers.foreach(sum += _)       // sum = 11

-Special function call forms

-Repeated parameters
def echo(args: String*) = for (arg <args) println(arg)  // echo("hello", "world!")
echo(Array("What's", "up", "doc?"))                     // error: type mismatch found : Array[String] required: String. fix: echo(arr: _*)
// This notation tells the compiler to pass each element of arr as its own argument to echo, rather than all of it as a single argument.

-Named arguments
def speed(distance: Float, time: Float): Float = distance / time    // speed(distance = 100, time = 10)

-Default parameter values
def printTime2(out: java.io.PrintStream = Console.out, divisor: Int = 1) =
    out.println("time = " + System.currentTimeMillis()/divisor)

-Tail recursion
// Functions like approximate, which call themselves as their last action, are called tail recursive. The Scala compiler detects tail recursion and replaces it with a jump back to the beginning of the function, after updating the function parameters with the new values.
def approximate(guess: Double): Double =
    if (isGoodEnough(guess)) guess
    else approximate(improve(guess))


###############
# Control Abstraction
###############
-Reducing code duplication
object FileMatcher {
    private def filesHere = (new java.io.File(".")).listFiles
    def filesEnding(query: String) =
        for (file <-filesHere; if file.getName.endsWith(query))
            yield file
    def filesContaining(query: String) =                            // function works just like filesEnding only difference is that this function uses contains instead of endsWith
        for (file <-filesHere; if file.getName.contains(query))
        yield file            
            
}
// While you cannot pass around a method name as a value, you can get the same effect by passing around a function value
def filesMatching(query: String, matcher: (String, String) => Boolean) = {      // uses matcher to check the file name against the query
    for (file <-filesHere; if matcher(file.getName, query))
        yield file
}
def filesEnding(query: String) = filesMatching(query, _.endsWith(_))

// full simplified version
object FileMatcher {
    private def filesHere = (new java.io.File(".")).listFiles
    private def filesMatching(matcher: String => Boolean) =
        for (file <-filesHere; if matcher(file.getName))
            yield file
    def filesEnding(query: String) = filesMatching(_.endsWith(query))
    def filesContaining(query: String) = filesMatching(_.contains(query))
    def filesRegex(query: String) = filesMatching(_.matches(query))
}

-Simplifying client code
def containsNeg(nums: List[Int]) = nums.exists(_ < 0)
def containsOdd(nums: List[Int]) = nums.exists(_ % 2 == 1)

-Currying
def curriedSum(x: Int)(y: Int) = x + y      // curriedSum: (x: Int)(y: Int)Int
curriedSum(1)(2)                            // res5: Int = 3; two traditional function invocations back to back; The first function invocation takes a single Int parameter named x, and returns a function value for the second function
val onePlus = curriedSum(1)_                // placeholder for the second parameter list
onePlus(2)                                  // res7: Int = 3

-Writing new control structures
def twice(op: Double => Double, x: Double) = op(op(x))
twice(_ + 1, 5)                             // res9: Double = 7.0
// Any time you find a control pattern repeated in multiple parts of your code, you should think about implementing it as a new control structure
// Consider now a more widely used coding pattern: open a resource, operate on it, and then close the resource
// loan pattern: (because a control-abstraction function, such as withPrintWriter, opens a resource and “loans” it to a function)
def withPrintWriter(file: File, op: PrintWriter => Unit) = {
    val writer = new PrintWriter(file)
    try {
        op(writer)
    } finally {
        writer.close()                      // impossible to forget to close the file
    }
}
withPrintWriter(new File("date.txt"), writer => writer.println(new java.util.Date))

-By-name parameters
// you want to implement an assertion construct called myAssert
var assertionsEnabled = true
def myAssert(predicate: () => Boolean) =
    if (assertionsEnabled && !predicate())
        throw new AssertionError
myAssert(() => 5 > 3)
// By-name parameters exist precisely so you can remove () => part
def byNameAssert(predicate: => Boolean) =
    if (assertionsEnabled && !predicate)
        throw new AssertionError
byNameAssert(5 > 3)                         // function value will be created whose apply method will evaluate 5 > 3, and this function value will be passed to byNameAssert


###############
# Composition and Inheritance
###############
-A two-dimensional layout library
// ibrary for building and rendering two-dimensional layout elements
val column1 = elem("hello") above elem("***")
val column2 = elem("***") above elem("world")
column1 beside column2
result:
hello ***
*** world

-Abstract classes
abstract class Element {
    def contents: Array[String]     // no abstract modifier, method abstract if no implementation
}

-Defining parameterless methods
// if function has no params - use no braces (if only this function does no side-effect)
abstract class Element {
    def contents: Array[String]
    def height: Int = contents.length                               // notice no braces
    def width: Int = if (height == 0) 0 else contents(0).length
}

-Extending classes
class ArrayElement(conts: Array[String]) extends Element {          // inherit all non-private members from class Element
    def contents: Array[String] = conts                             // private members of the superclass are not inherited in a subclass
}
// hieararchy is next ArrayElement<-Element<-AnyRef
val ae = new ArrayElement(Array("hello", "world"))
ae.width                                            // res0: Int = 5
val e: Element = new ArrayElement(Array("hello"))

-Overriding methods and fields
// fields and methods belong to the same namespace - possible for a field to override a parameterless method
class ArrayElement(conts: Array[String]) extends Element {
    val contents: Array[String] = conts                     // val here overrides def in abstract
}

-Defining parametric fields
// can remove const param by combining the parameter and the field in a single parametric field definition
class ArrayElement(val contents: Array[String]) extends Element         // val defines at the same time a parameter and field with the same name (with var it can be reassignable)

-Invoking superclass constructors
// element consisting of a single line given by a string
class LineElement(s: String) extends ArrayElement(Array(s)) {           // Array(s) passed to primary constructor of a parent class (like in java)
    override def width = s.length
    override def height = 1
}

-Using override modifiers
// Scala requires override modifier for all members that override a concrete member in a parent class

-Polymorphism and dynamic binding
class UniformElement(ch: Char,override val width: Int,override val height: Int) extends Element {
    private val line = ch.toString * width
    def contents = Array.fill(height)(line)
}
val e1: Element = new ArrayElement(Array("hello", "world"))
val ae: ArrayElement = new LineElement("hello")
val e2: Element = ae
val e3: Element = new UniformElement('x', 2, 3)
// method invocations on variables and expressions are dynamically bound (determined at run time based on the class of the object)

-Declaring final members

-Using composition and inheritance
// previous version, LineElement had an inheritance relationship with ArrayElement, from which it inherited contents
// It now has a composition relationship with Array: it holds a reference to an array
class LineElement(s: String) extends Element {
    val contents = Array(s)
    override def width = s.length
    override def height = 1
}

-Implementing above, beside, and toString
// above first version
def above(that: Element): Element =
    new ArrayElement(this.contents ++ that.contents)

// beside
def beside(that: Element): Element = new ArrayElement(
    for (
        (line1, line2) <- this.contents zip that.contents       // this.contents and that.contents, are transformed into an array of pairs (as Tuple2s are called) using the zip operator
    ) yield line1 + line2
)

// toString
override def toString = contents mkString "\n"

-Defining a factory object
// A straightforward solution is to create a companion object of class Element and make this the factory object for layout elements
object Element {
    def elem(contents: Array[String]): Element = new ArrayElement(contents)
    def elem(chr: Char, width: Int, height: Int): Element = new UniformElement(chr, width, height)
    def elem(line: String): Element = new LineElement(line)
}

-Heighten and widen
import Element.elem
abstract class Element {
    def contents: Array[String]
    def width: Int = contents(0).length
    def height: Int = contents.length
    def above(that: Element): Element = {
        val this1 = this widen that.width
        val that1 = that widen this.width
        elem(this1.contents ++ that1.contents)
    }
    def beside(that: Element): Element = {
        val this1 = this heighten that.height
        val that1 = that heighten this.height
        elem(
            for ((line1, line2) <- this1.contents zip that1.contents)
                yield line1 + line2)
    }
    def widen(w: Int): Element =
        if (w <= width) this
        else {
        val left = elem(' ', (w - width) / 2, height)
        val right = elem(' ', w - width - left.width, height)
        left beside this beside right
        }
    def heighten(h: Int): Element =
    if (h <= height) this
    else {
        val top = elem(' ', width, (h - height) / 2)
        val bot = elem(' ', width, h - height - top.height)
        top above this above bot
    }
    override def toString = contents mkString "\n"
}


-Putting it all together
import Element.elem
object Spiral {
    val space = elem(" ")
    val corner = elem("+")
    def spiral(nEdges: Int, direction: Int): Element = {
        if (nEdges == 1)
            elem("+")
        else {
            val sp = spiral(nEdges - 1, (direction + 3) % 4)
            def verticalBar = elem('|', 1, sp.height)
            def horizontalBar = elem('-', sp.width, 1)
            if (direction == 0)                                         // bottom to up
                (corner beside horizontalBar) above (sp beside space)
            else if (direction == 1)                                    // right to left
                (sp above space) beside (corner above verticalBar)
            else if (direction == 2)                                    // top to bottom
                (space beside sp) above (horizontalBar beside corner)
            else                                                        // right to left
                (verticalBar above corner) beside (space above sp)
        }
    }
    def main(args: Array[String]) = {
        val nSides = args(0).toInt
        println(spiral(nSides, 0))
    }
}


###############
# Scala’s Hierarchy
###############
-Scala’s class hierarchy
//top of the hierarchy is class Any, methods:
final def ==(that: Any): Boolean
final def !=(that: Any): Boolean
def equals(that: Any): Boolean
def ##: Int
def hashCode: Int
def toString: String
// methods min, max, until, to, and abs are all defined in a class scala.runtime.RichInt, and there is an implicit conversion from class Int to RichInt. The conversion is applied whenever a method is invoked on an Int that is undefined in Int but defined in RichInt.
#########################################################################################################
#+---+                                                                                                  #
#|any|                                                                                                  #
#+---+                                                                                                  #
#|    +------+                                                                                  +------+#
#+----+anyVal+-+--------+--------+--------+--------+--------+--------+--------+--------+<-------+Nothng|#
#|    +------+ |        |        |        |        |        |        |        |        |        +------+#
#|             +------+ +------+ +------+ +------+ +------+ +------+ +------+ +------+ +------+         #
#|             |Double| |Float | |Long  | |Int   | |Short | |Byte  | |Char  | |Bolean| |Unit  |         #
#|             +------+ +------+ +------+ +------+ +------+ +------+ +------+ +------+ +------+         #
#|                                                                                                      #
#|                                                                                                      #
#|    +------+                                     +------+                                             #
#+----+anyRef+-+--------+--------+--------+<-------+Null  |                                             #
#     +------+ |        |        |        |        +------+                                             #
#              +------+ +------+ +------+ +------+                                                      #
#              |Itrble+<+Seq   +<+List  | |Option|                                                      #
#              +------+ +------+ +------+ +------+                                                      #
#########################################################################################################

-How primitives are implemented
// class AnyRef defines an additional eq method, which cannot be overridden and is implemented as reference equality (i.e., it behaves like == in Java for reference types).
val x = new String("abc")
val y = new String("abc")
x == y                      // res13: Boolean = true
x eq y                      // res14: Boolean = false
x ne y                      // res15: Boolean = true

-Bottom types
// Null is a subclass of every reference class
// Nothing is a subtype of every other type
val i: Int = null               // error: an expression of type Null is ineligible for implicit conversion
def error(message: String): Nothing =
    throw new RuntimeException(message)     // return type of error is Nothing
    
def divide(x: Int, y: Int): Int =
    if (y != 0) x / y
    else error("can't divide by zero")      // Because Nothing is a subtype of Int, the type of the whole conditional is Int, as required.

-Defining your own value classes
// must have exactly one parameter and it must have nothing inside it except defs
class Dollars(val amount: Int) extends AnyVal {
    override def toString() = "$" + amount
}
val money = new Dollars(1000000)        // money: Dollars = $1000000; money.amount  -> res16: Int = 1000000


###############
# Traits
###############
-How traits work
trait Philosophical {                                   // default superclass of AnyRef
    def philosophize() = {
        println("I consume memory, therefore I am!")
    }
}
class Frog extends Philosophical {
    override def toString = "green"
}
val frog = new Frog          // frog: Frog = green
frog.philosophize()          // I consume memory, therefore I am!
// can mix a trait into a class that explicitly extends a superclass
class Animal
class Frog extends Animal with Philosophical {
    override def toString = "green"
    override def philosophize() = {                         // override method in trait
        println("It ain't easy being " + toString + "!")
    }
}
val phrog: Philosophical = new Frog                         // phrog: Philosophical = green
phrog.philosophize()                                        // It ain't easy being green!

-Thin versus rich interfaces
// One major use of traits is to automatically add methods to a class

-Example: Rectangular objects
class Point(val x: Int, val y: Int)
trait Rectangular {
    def topLeft: Point
    def bottomRight: Point
    def left = topLeft.x
    def right = bottomRight.x
    def width = right - left
    // and many more geometric methods...
}
abstract class Component extends Rectangular {
    // other methods...
}
class Rectangle(val topLeft: Point, val bottomRight: Point) extends Rectangular {
    // other methods...
}
val rect = new Rectangle(new Point(1, 1), new Point(10, 10))
rect.left               // res2: Int = 1
rect.right              // res3: Int = 10

