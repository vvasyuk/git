###############
# Classes and Objects
###############
class ChecksumAccumulator {
    private var sum = 0
    def add(b: Byte): Unit = { sum += b }
    def checksum(): Int = ~(sum & 0xFF) + 1
}

-Singleton objects
import scala.collection.mutable
object ChecksumAccumulator {
    private val cache = mutable.Map.empty[String, Int]
    def calculate(s: String): Int =
        if (cache.contains(s))
            cache(s)
        else {
            val acc = new ChecksumAccumulator
            for (c <s)
            acc.add(c.toByte)
            val cs = acc.checksum()
            cache += (s >
            cs)
            cs
        }
}

-A Scala application
import ChecksumAccumulator.calculate
object Summer {
    def main(args: Array[String]) = {
        for (arg <args)
            println(arg + ": " + calculate(arg))
    }
}

-The App trait
import ChecksumAccumulator.calculate
object FallWinterSpringSummer extends App {
    for (season <List("fall", "winter", "spring"))
        println(season + ": " + calculate(season))
}


###############
# Basic Types and Operations
###############
-Character literals
val a = 'A'         // a: Char = A
val d = '\u0041'    // d: Char = A
val f = '\u0044'    // f: Char = D
val B\u0041\u0044 = 1   //BAD: Int = 1

-String interpolation
val name = "reader"         // println(s"Hello, $name!")
s"The answer is ${6 * 7}."  // res0: String = The answer is 42.

infix operator                  // method between the object and the parameter ("7 + 2")
prefix operator (only +,-,!,~)  // method before the object on which you are invoking the method (-7, !found). "-2.0" transformed into (2.0).unary_-
postfix operator                // method after the object ("7 toLong")

-Bitwise operations
1 & 2   // 1 (0001) and 2 (0010) = 0 (0000)
1 | 2   // 1 (0001) and 2 (0010) = 3 (0011)
1 ˆ 3   // 1 (0001) and 2 (0010) = 2 (0010)
~1      // inverts each bit in 1 (0001), yielding -2, which in binary looks like 11111111111111111111111111111110.
1 << 2  // 4

-Operator precedence and associativity
* / %
+ :
= !
< >
&
ˆ
|
(all letters)
(all assignment operators)


###############
# Functional Objects
###############
class Rational(n: Int, d: Int) {                    // primary constructor will be created with these two params
    require(d != 0)                                 // class body code will be added to primary constructor (precondition of the primary constructor that d must be non-zero)
    private val g = gcd(n.abs, d.abs)
    val numer = n / g
    val denom = d / g
    def this(n: Int) = this(n, 1)                   // auxiliary constructors invokes the primary constructor
    def + (that: Rational): Rational =              // simply that.d will not work because d is not accessible outside object where they invoked, so we added numer, denum fields
        new Rational(numer * that.denom + 
        that.numer * denom,denom * that.denom)
    def + (i: Int): Rational =
        new Rational(numer + i * denom, denom)
    def (that: Rational): Rational =
        new Rational(numer * that.denom that.numer* 
        denom,denom * that.denom)
    def (i: Int): Rational =
        new Rational(numer i* denom, denom)
    def * (that: Rational): Rational =
        new Rational(numer * that.numer, denom * 
        that.denom)
    def * (i: Int): Rational =
        new Rational(numer * i, denom)
    def / (that: Rational): Rational =
        new Rational(numer * that.denom, denom * 
        that.numer)
    def / (i: Int): Rational =
        new Rational(numer, denom * i)
    override def toString = numer + "/" + denom     // override default override
    private def gcd(a: Int, b: Int): Int =
        if (b == 0) a else gcd(b, a % b)
}

-Implicit conversions
r * 2   // works
2 * r   // does not work, 2 is Int - not method that takes Rational argument
implicit def intToRational(x: Int) = new Rational(x)


###############
# Built-in Control Structures
###############
-If expressions
val filename = if (!args.isEmpty) args(0) else "default.txt"

-While loops
def gcdLoop(x: Long, y: Long): Long = {
    var a = x
    var b = y
    while (a != 0) {
        val temp = a
        a = b % a
        b = temp
    }
    b
}

while ((line = readLine()) != "")   // This doesn't work! (line = readLine()) retunrs Unit
    println("Read: " + line)

-For expressions
for (file <- filesHere)             // for file in filesHere
    println(file)
for (i <- 1 to 4)                   //
    println("Iteration " + i)
-Filtering
for (
    file <- filesHere
    if file.isFile
    if file.getName.endsWith(".scala")
) println(file)
-Nested iteration
def fileLines(file: java.io.File) =
    scala.io.Source.fromFile(file).getLines().toList
def grep(pattern: String) =
    for (
        file <- filesHere
        if file.getName.endsWith(".scala");
        line <- fileLines(file)
        if line.trim.matches(pattern)
    ) println(file + ": " + line.trim)
grep(".*gcd.*")
-Producing a new collection
def scalaFiles =                    // type of the resulting collection is based on the kind of collections processed in the iteration clauses
    for {
        file <- filesHere
        if file.getName.endsWith(".scala")
    } yield file                    // In this case the result is an Array[File], because filesHere is an array and the type of the yielded expression is File

-Exception handling with try expressions
val half =
    if (n % 2 == 0)
        n / 2                       // One branch of an if computes a value, while the other throws an exception and computes Nothing
    else
        throw new RuntimeException("n must be even")    // If n is not even, an exception will be thrown before half can be initialized to anything at all

-Catching exception
try {
    val f = new FileReader("input.txt")
    // Use and close file
} catch {
    case ex: FileNotFoundException => // Handle missing file
    case ex: IOException => // Handle other I/O error
}

-The finally clause
val file = new FileReader("input.txt")
try {
    // Use the file
} finally {
    file.close() // Be sure to close the file
}

-Yielding a value
def urlFor(path: String) =
    try {
        new URL(path)
    } catch {
        case e: MalformedURLException =>
        new URL("http://www.scalalang.org") // this one is returned if eexception is thrown and cought
    }

-Match expressions
val firstArg = if (!args.isEmpty) args(0) else ""
val friend = firstArg match {
    case "salt" => "pepper"
    case "chips" => "salsa"
    case "eggs" => "bacon"
    case _ => "huh?"
}
println(friend)

-Living without break and continue
var i = 0
var foundIt = false
while (i < args.length && !foundIt) {
    if (!args(i).startsWith("")){
        if (args(i).endsWith(".scala"))
            foundIt = true
        }
    i = i + 1
}
-get ird of vars
def searchFrom(i: Int): Int =
    if (i >= args.length) 1
    else if (args(i).startsWith("")) searchFrom(i + 1)
    else if (args(i).endsWith(".scala")) i
    else searchFrom(i + 1)
val i = searchFrom(0)


###############
# Functions and Closures
###############
-Methods
object LongLines {
    def processFile(filename: String, width: Int) = {
        val source = Source.fromFile(filename)
        for (line <- source.getLines())
            processLine(filename, width, line)
    }
    private def processLine(filename: String,width: Int, line: String) = {
        if (line.length > width)
            println(filename + ": " + line.trim)
    }
}
object FindLongLines {
    def main(args: Array[String]) = {
        val width = args(0).toInt
        for (arg <args.drop(1))
            LongLines.processFile(arg, width)
    }
}

-Local functions
object LongLines {
    def processFile(filename: String, width: Int) = {
        def processLine(line: String) = {
            if (line.length > width)                // local functions can access the parameters of their enclosing function
                println(filename + ": " + line.trim)
        }
        val source = Source.fromFile(filename)
        for (line <-source.getLines())
            processLine(line)
    }
}

-First-class functions
// A function literal is compiled into a class that when instantiated at runtime is a function value
// function literals exist in the source code
// function values exist as objects at runtime
// Every function value is an instance of some class that extends one of several FunctionN traits in package scala

(x: Int) => x + 1                   // function literal
var increase = (x: Int) => x + 1    // Function values are objects, so you can store them in variables
increase(10)                        // you can call them

-Short forms of function literals
someNumbers.filter(x => x > 0)

-Placeholder syntax
someNumbers.filter(_ > 0)
val f = (_: Int) + (_: Int)     // f: (Int, Int) => Int = <function2>
f(5, 10)

-Partially applied functions
// Although the previous examples substitute underscores in place of individual parameters, you can also replace an entire parameter list with an underscore
// when you invoke a function, passing in any needed arguments, you apply that function to the arguments
// given
def sum(a: Int, b: Int, c: Int) = a + b + c
// You could apply the function sum to the arguments 1, 2, and 3 like this
sum(1, 2, 3)

// partially applied function is an expression in which you don’t supply all of the arguments needed by the function. Instead, you supply some, or none
val a = sum _       // partially applied function expression involving sum, in which you supply none of the three required args
a(1, 2, 3)          // Scala compiler translates the expression a(1, 2, 3) into an invocation of the function value’s apply method, passing in the three arguments 1, 2, and 3.

val b = sum(1, _: Int, 3)   // you can also express a partially applied function by supplying only some of the required arguments
b(2)                        // res13: Int = 6

-Closures
(x: Int) => x + more        // A function object that captures free variables, and is said to be "closed" over the variables visible at the time it is created.
var more = 1
val addMore = (x: Int) => x + more  // addMore: Int => Int = <function1>
addMore(10)                         // res16: Int = 11
more = 9999                         // What happens if more changes after the closure is created? In Scala, the answer is that the closure sees the change
addMore(10)                         // res17: Int = 10009

val someNumbers = List(11,10,5,0, 5, 10)
var sum = 0
someNumbers.foreach(sum += _)       // sum = 11

-Special function call forms

-Repeated parameters
def echo(args: String*) = for (arg <args) println(arg)  // echo("hello", "world!")
echo(Array("What's", "up", "doc?"))                     // error: type mismatch found : Array[String] required: String. fix: echo(arr: _*)
// This notation tells the compiler to pass each element of arr as its own argument to echo, rather than all of it as a single argument.

-Named arguments
def speed(distance: Float, time: Float): Float = distance / time    // speed(distance = 100, time = 10)

-Default parameter values
def printTime2(out: java.io.PrintStream = Console.out, divisor: Int = 1) =
    out.println("time = " + System.currentTimeMillis()/divisor)

-Tail recursion
// Functions like approximate, which call themselves as their last action, are called tail recursive. The Scala compiler detects tail recursion and replaces it with a jump back to the beginning of the function, after updating the function parameters with the new values.
def approximate(guess: Double): Double =
    if (isGoodEnough(guess)) guess
    else approximate(improve(guess))


###############
# Control Abstraction
###############
-Reducing code duplication
object FileMatcher {
    private def filesHere = (new java.io.File(".")).listFiles
    def filesEnding(query: String) =
        for (file <-filesHere; if file.getName.endsWith(query))
            yield file
    def filesContaining(query: String) =                            // function works just like filesEnding only difference is that this function uses contains instead of endsWith
        for (file <-filesHere; if file.getName.contains(query))
        yield file            
            
}
// While you cannot pass around a method name as a value, you can get the same effect by passing around a function value
def filesMatching(query: String, matcher: (String, String) => Boolean) = {      // uses matcher to check the file name against the query
    for (file <-filesHere; if matcher(file.getName, query))
        yield file
}
def filesEnding(query: String) = filesMatching(query, _.endsWith(_))

// full simplified version
object FileMatcher {
    private def filesHere = (new java.io.File(".")).listFiles
    private def filesMatching(matcher: String => Boolean) =
        for (file <-filesHere; if matcher(file.getName))
            yield file
    def filesEnding(query: String) = filesMatching(_.endsWith(query))
    def filesContaining(query: String) = filesMatching(_.contains(query))
    def filesRegex(query: String) = filesMatching(_.matches(query))
}

-Simplifying client code
def containsNeg(nums: List[Int]) = nums.exists(_ < 0)
def containsOdd(nums: List[Int]) = nums.exists(_ % 2 == 1)

-Currying
def curriedSum(x: Int)(y: Int) = x + y      // curriedSum: (x: Int)(y: Int)Int
curriedSum(1)(2)                            // res5: Int = 3; two traditional function invocations back to back; The first function invocation takes a single Int parameter named x, and returns a function value for the second function
val onePlus = curriedSum(1)_                // placeholder for the second parameter list
onePlus(2)                                  // res7: Int = 3

-Writing new control structures
def twice(op: Double => Double, x: Double) = op(op(x))
twice(_ + 1, 5)                             // res9: Double = 7.0
// Any time you find a control pattern repeated in multiple parts of your code, you should think about implementing it as a new control structure
// Consider now a more widely used coding pattern: open a resource, operate on it, and then close the resource
// loan pattern: (because a control-abstraction function, such as withPrintWriter, opens a resource and “loans” it to a function)
def withPrintWriter(file: File, op: PrintWriter => Unit) = {
    val writer = new PrintWriter(file)
    try {
        op(writer)
    } finally {
        writer.close()                      // impossible to forget to close the file
    }
}
withPrintWriter(new File("date.txt"), writer => writer.println(new java.util.Date))

-By-name parameters
// you want to implement an assertion construct called myAssert
var assertionsEnabled = true
def myAssert(predicate: () => Boolean) =
    if (assertionsEnabled && !predicate())
        throw new AssertionError
myAssert(() => 5 > 3)
// By-name parameters exist precisely so you can remove () => part
def byNameAssert(predicate: => Boolean) =
    if (assertionsEnabled && !predicate)
        throw new AssertionError
byNameAssert(5 > 3)                         // function value will be created whose apply method will evaluate 5 > 3, and this function value will be passed to byNameAssert


###############
# Composition and Inheritance
###############
-A two-dimensional layout library
// ibrary for building and rendering two-dimensional layout elements
val column1 = elem("hello") above elem("***")
val column2 = elem("***") above elem("world")
column1 beside column2
result:
hello ***
*** world

-Abstract classes
abstract class Element {
    def contents: Array[String]     // no abstract modifier, method abstract if no implementation
}

-Defining parameterless methods
// if function has no params - use no braces (if only this function does no side-effect)
abstract class Element {
    def contents: Array[String]
    def height: Int = contents.length                               // notice no braces
    def width: Int = if (height == 0) 0 else contents(0).length
}

-Extending classes
class ArrayElement(conts: Array[String]) extends Element {          // inherit all non-private members from class Element
    def contents: Array[String] = conts                             // private members of the superclass are not inherited in a subclass
}
// hieararchy is next ArrayElement<-Element<-AnyRef
val ae = new ArrayElement(Array("hello", "world"))
ae.width                                            // res0: Int = 5
val e: Element = new ArrayElement(Array("hello"))

-Overriding methods and fields
// fields and methods belong to the same namespace - possible for a field to override a parameterless method
class ArrayElement(conts: Array[String]) extends Element {
    val contents: Array[String] = conts                     // val here overrides def in abstract
}

-Defining parametric fields
// can remove const param by combining the parameter and the field in a single parametric field definition
class ArrayElement(val contents: Array[String]) extends Element         // val defines at the same time a parameter and field with the same name (with var it can be reassignable)

-Invoking superclass constructors
// element consisting of a single line given by a string
class LineElement(s: String) extends ArrayElement(Array(s)) {           // Array(s) passed to primary constructor of a parent class (like in java)
    override def width = s.length
    override def height = 1
}

-Using override modifiers
// Scala requires override modifier for all members that override a concrete member in a parent class

-Polymorphism and dynamic binding
class UniformElement(ch: Char,override val width: Int,override val height: Int) extends Element {
    private val line = ch.toString * width
    def contents = Array.fill(height)(line)
}
val e1: Element = new ArrayElement(Array("hello", "world"))
val ae: ArrayElement = new LineElement("hello")
val e2: Element = ae
val e3: Element = new UniformElement('x', 2, 3)
// method invocations on variables and expressions are dynamically bound (determined at run time based on the class of the object)

-Declaring final members

-Using composition and inheritance
// previous version, LineElement had an inheritance relationship with ArrayElement, from which it inherited contents
// It now has a composition relationship with Array: it holds a reference to an array
class LineElement(s: String) extends Element {
    val contents = Array(s)
    override def width = s.length
    override def height = 1
}

-Implementing above, beside, and toString
// above first version
def above(that: Element): Element =
    new ArrayElement(this.contents ++ that.contents)

// beside
def beside(that: Element): Element = new ArrayElement(
    for (
        (line1, line2) <- this.contents zip that.contents       // this.contents and that.contents, are transformed into an array of pairs (as Tuple2s are called) using the zip operator
    ) yield line1 + line2
)

// toString
override def toString = contents mkString "\n"

-Defining a factory object
// A straightforward solution is to create a companion object of class Element and make this the factory object for layout elements
object Element {
    def elem(contents: Array[String]): Element = new ArrayElement(contents)
    def elem(chr: Char, width: Int, height: Int): Element = new UniformElement(chr, width, height)
    def elem(line: String): Element = new LineElement(line)
}

-Heighten and widen
import Element.elem
abstract class Element {
    def contents: Array[String]
    def width: Int = contents(0).length
    def height: Int = contents.length
    def above(that: Element): Element = {
        val this1 = this widen that.width
        val that1 = that widen this.width
        elem(this1.contents ++ that1.contents)
    }
    def beside(that: Element): Element = {
        val this1 = this heighten that.height
        val that1 = that heighten this.height
        elem(
            for ((line1, line2) <- this1.contents zip that1.contents)
                yield line1 + line2)
    }
    def widen(w: Int): Element =
        if (w <= width) this
        else {
        val left = elem(' ', (w - width) / 2, height)
        val right = elem(' ', w - width - left.width, height)
        left beside this beside right
        }
    def heighten(h: Int): Element =
    if (h <= height) this
    else {
        val top = elem(' ', width, (h - height) / 2)
        val bot = elem(' ', width, h - height - top.height)
        top above this above bot
    }
    override def toString = contents mkString "\n"
}


-Putting it all together
import Element.elem
object Spiral {
    val space = elem(" ")
    val corner = elem("+")
    def spiral(nEdges: Int, direction: Int): Element = {
        if (nEdges == 1)
            elem("+")
        else {
            val sp = spiral(nEdges - 1, (direction + 3) % 4)
            def verticalBar = elem('|', 1, sp.height)
            def horizontalBar = elem('-', sp.width, 1)
            if (direction == 0)                                         // bottom to up
                (corner beside horizontalBar) above (sp beside space)
            else if (direction == 1)                                    // right to left
                (sp above space) beside (corner above verticalBar)
            else if (direction == 2)                                    // top to bottom
                (space beside sp) above (horizontalBar beside corner)
            else                                                        // right to left
                (verticalBar above corner) beside (space above sp)
        }
    }
    def main(args: Array[String]) = {
        val nSides = args(0).toInt
        println(spiral(nSides, 0))
    }
}


###############
# Scala’s Hierarchy
###############
-Scala’s class hierarchy
//top of the hierarchy is class Any, methods:
final def ==(that: Any): Boolean
final def !=(that: Any): Boolean
def equals(that: Any): Boolean
def ##: Int
def hashCode: Int
def toString: String
// methods min, max, until, to, and abs are all defined in a class scala.runtime.RichInt, and there is an implicit conversion from class Int to RichInt. The conversion is applied whenever a method is invoked on an Int that is undefined in Int but defined in RichInt.
#########################################################################################################
#+---+                                                                                                  #
#|any|                                                                                                  #
#+---+                                                                                                  #
#|    +------+                                                                                  +------+#
#+----+anyVal+-+--------+--------+--------+--------+--------+--------+--------+--------+<-------+Nothng|#
#|    +------+ |        |        |        |        |        |        |        |        |        +------+#
#|             +------+ +------+ +------+ +------+ +------+ +------+ +------+ +------+ +------+         #
#|             |Double| |Float | |Long  | |Int   | |Short | |Byte  | |Char  | |Bolean| |Unit  |         #
#|             +------+ +------+ +------+ +------+ +------+ +------+ +------+ +------+ +------+         #
#|                                                                                                      #
#|                                                                                                      #
#|    +------+                                     +------+                                             #
#+----+anyRef+-+--------+--------+--------+<-------+Null  |                                             #
#     +------+ |        |        |        |        +------+                                             #
#              +------+ +------+ +------+ +------+                                                      #
#              |Itrble+<+Seq   +<+List  | |Option|                                                      #
#              +------+ +------+ +------+ +------+                                                      #
#########################################################################################################

-How primitives are implemented
// class AnyRef defines an additional eq method, which cannot be overridden and is implemented as reference equality (i.e., it behaves like == in Java for reference types).
val x = new String("abc")
val y = new String("abc")
x == y                      // res13: Boolean = true
x eq y                      // res14: Boolean = false
x ne y                      // res15: Boolean = true

-Bottom types
// Null is a subclass of every reference class
// Nothing is a subtype of every other type
val i: Int = null               // error: an expression of type Null is ineligible for implicit conversion
def error(message: String): Nothing =
    throw new RuntimeException(message)     // return type of error is Nothing
    
def divide(x: Int, y: Int): Int =
    if (y != 0) x / y
    else error("can't divide by zero")      // Because Nothing is a subtype of Int, the type of the whole conditional is Int, as required.

-Defining your own value classes
// must have exactly one parameter and it must have nothing inside it except defs
class Dollars(val amount: Int) extends AnyVal {
    override def toString() = "$" + amount
}
val money = new Dollars(1000000)        // money: Dollars = $1000000; money.amount  -> res16: Int = 1000000


###############
# Traits
###############
-How traits work
trait Philosophical {                                   // default superclass of AnyRef
    def philosophize() = {
        println("I consume memory, therefore I am!")
    }
}
class Frog extends Philosophical {
    override def toString = "green"
}
val frog = new Frog          // frog: Frog = green
frog.philosophize()          // I consume memory, therefore I am!
// can mix a trait into a class that explicitly extends a superclass
class Animal
class Frog extends Animal with Philosophical {
    override def toString = "green"
    override def philosophize() = {                         // override method in trait
        println("It ain't easy being " + toString + "!")
    }
}
val phrog: Philosophical = new Frog                         // phrog: Philosophical = green
phrog.philosophize()                                        // It ain't easy being green!

-Thin versus rich interfaces
// One major use of traits is to automatically add methods to a class

-Example: Rectangular objects
class Point(val x: Int, val y: Int)
trait Rectangular {
    def topLeft: Point
    def bottomRight: Point
    def left = topLeft.x
    def right = bottomRight.x
    def width = right - left
    // and many more geometric methods...
}
abstract class Component extends Rectangular {
    // other methods...
}
class Rectangle(val topLeft: Point, val bottomRight: Point) extends Rectangular {
    // other methods...
}
val rect = new Rectangle(new Point(1, 1), new Point(10, 10))
rect.left               // res2: Int = 1
rect.right              // res3: Int = 10

-The Ordered trait
class Rational(n: Int, d: Int) extends Ordered[Rational] {
    // ...
    def compare(that: Rational) =                               //  define a compare method 
        (this.numer * that.denom) - (that.numer * this.denom)   // zero - same, negative - receiver less than argument, positive - receiver greater than argument
}
new Rational(1, 2) < new Rational(1, 3)         // res5: Boolean = false

-Traits as stackable modifications
abstract class IntQueue {
    def get(): Int
    def put(x: Int)
}
class BasicIntQueue extends IntQueue {
    private val buf = new ArrayBuffer[Int]
    def get() = buf.remove(0)
    def put(x: Int) = { buf += x }              // adds elements to the other end
}
val queue = new BasicIntQueue
queue.put(10)
queue.put(20)
queue.get()                                     // res9: Int = 10
queue.get()                                     // res10: Int = 20
trait Doubling extends IntQueue {
    abstract override def put(x: Int) = { super.put(2 * x) }        // super calls in a trait are dynamically bound, the super call in trait Doubling will work so long as the trait is mixed in after another trait or class that gives a concrete definition to the method
}
class MyQueue extends BasicIntQueue with Doubling
val queue = new MyQueue
queue.put(10)
queue.get()                                     // res12: Int = 20
trait Incrementing extends IntQueue {
    abstract override def put(x: Int) = { super.put(x + 1) }
}
trait Filtering extends IntQueue {
    abstract override def put(x: Int) = {if (x >= 0) super.put(x)}
}
val queue = (new BasicIntQueue with Incrementing with Filtering)    // method in the +trait furthest to the right is called first. If that method calls super, it invokes the method in the next trait to its left, and so on

-Why not multiple inheritance?
// When you instantiate a class with new, Scala takes the class, and all of its inherited classes and traits, and puts them in a single, linear order.
// Then, whenever you call super inside one of those classes, the invoked method is the next one up the chain. If all of the methods but the last call super, the net result is stackable behavior.

-To trait or not to trait?
// If the behavior will not be reused, then make it a concrete class.
// If it might be reused in multiple, unrelated classes, make it a trait
// If you want to inherit from it in Java code, use an abstract class
// If you plan to distribute it in compiled form, and you expect outside groups to write classes inheriting from it, you might lean towards using an abstract class
// If you still do not know, after considering the above, then start by making it as a trait


###############
# Packages and Imports
###############
-Putting code in packages
package bobsrockets.navigation
class Navigator
// C# style
package bobsrockets.navigation {
    class Navigator
}

-Concise access to related code
// In file launch.scala
package launch {
    class Booster3
}
// In file bobsrockets.scala
package bobsrockets {
    package navigation {
        package launch {
            class Booster1
        }
        class MissionControl {
            val booster1 = new launch.Booster1
            val booster2 = new bobsrockets.launch.Booster2
            val booster3 = new _root_.launch.Booster3           // gives you the top-level launch package
        }
    }
    package launch {
        class Booster2
    }
}

-Imports
import bobsdelights.Fruit                       // easy access to Fruit
import bobsdelights._                           // easy access to all members of bobsdelights
import bobsdelights.Fruits._                    // easy access to all members of Fruits
import Fruits.{Apple, Orange}                   // selective
import Fruits.{Apple => McIntosh, Orange}       // Apple object is renamed to McIntosh
import Fruits.{Pear => _, _}                    // except pear

package bobsdelights
abstract class Fruit(
    val name: String,
    val color: String
)
object Fruits {
    object Apple extends Fruit("apple", "red")
    object Orange extends Fruit("orange", "orange")
    object Pear extends Fruit("pear", "yellowish")
    val menu = List(Apple, Orange, Pear)
}

-Implicit imports
//  added to the top of every source file with extension ".scala"
import java.lang._      // everything in the java.lang package
import scala._          // everything in the scala package
import Predef._         // everything in the Predef object

-Access modifiers
// Private members - visible only inside the class or object that contains the member definition (Outter class sees no private memeber of inner)
// Protected members - accessible from subclasses of the class in which the member is defined (not packge as in java)
// Public members - default - accessed from anywhere

-Package objects
// Any kind of definition that you can put inside a class can also be at the top level of a package (method you’d like to be in scope for an entire package)
// Each package is allowed to have one package object. Any definitions placed in a package object are considered members of the package itself.
// In file bobsdelights/package.scala
package object bobsdelights {
    def showFruit(fruit: Fruit) = {
        import fruit._
        println(name + "s are " + color)
    }
}
// In file PrintMenu.scala
package printmenu
import bobsdelights.Fruits
import bobsdelights.showFruit
object PrintMenu {
    def main(args: Array[String]) = {
        for (fruit <- Fruits.menu) {
            showFruit(fruit)
        }
    }
}


###############
# Assertions and Tests
###############
-Assertions
def above(that: Element): Element = {
    val this1 = this widen that.width
    val that1 = that widen this.width
    assert(this1.width == that1.width)
    elem(this1.contents ++ that1.contents)
}

private def widen(w: Int): Element =
    if (w <= width)
        this
    else {
        val left = elem(' ', (w - width) / 2, height)
        var right = elem(' ', w - width - left.width, height)
        left beside this beside right
    } ensuring (w <= _.width)                                   // underscore is a placeholder for the one argument passed to the predicate, the Element result of the widen method
    //  If the width passed as w to widen is less than or equal to the width of the result Element, the predicate will result in true

-Testing in Scala
import org.scalatest.FunSuite
import Element.elem
class ElementSuite extends FunSuite {                   // central concept in ScalaTest is the suite - collection of tests
    test("elem result should have passed width") {      // specify the name of the test as a string between the parentheses and the test code itself between curly braces
        val ele = elem('x', 2, 3)                       // test code is a function passed as a by-name parameter to test, which registers it for later execution
        assert(ele.width == 2)
    }
}

-Informative failure reports
val caught =
    intercept[ArithmeticException] {
        1 / 0
    }
assert(caught.getMessage == "/ by zero")

-Tests as specifications
import org.scalatest._
class TVSetSpec extends FeatureSpec with GivenWhenThen {
    feature("TV power button") {
        scenario("User presses power button when TV is off") {
            Given("a TV set that is switched off")
            When("the power button is pressed")
            Then("the TV should switch on")
            pending
        }
    }
}

-Property-based testing
import org.scalatest.WordSpec
import org.scalatest.prop.PropertyChecks
import org.scalatest.MustMatchers._
import Element.elem
class ElementSpec extends WordSpec with PropertyChecks {
    "elem result" must {
        "have passed width" in {
            forAll { (w: Int) =>
                whenever (w > 0) {
                    elem('x', w, 3).width must equal (w)
                }
            }
        }
    }
}

-Organizing and running tests
scalac -cp scalatest.jar TVSetSpec.scala


###############
# Case Classes and Pattern Matching
###############
-A simple example
abstract class Expr
case class Var(name: String) extends Expr
case class Number(num: Double) extends Expr
case class UnOp(operator: String, arg: Expr) extends Expr
case class BinOp(operator: String, left: Expr, right: Expr) extends Expr

-Case classes
// can do Var("x") instead on new Var("x")
val v = Var("x")
val op = BinOp("+", Number(1), v)
// all arguments in the parameter list of a case class implicitly get a val prefix, so they are maintained as fields
v.name                      // res0: String = x
op.left                     // res1: Expr = Number(1.0)
// compiler adds “natural” implementations of methods toString, hashCode, and equals
// compiler adds a copy method
op.copy(operator = "-")     // res4: BinOp = BinOp(-,Number(1.0),Var(x))

-Pattern matching
simplifyTop(UnOp("-", UnOp("-", Var("x"))))
// A constant pattern like "+" or 1 matches values that are equal to the constant with respect to ==
// A variable pattern like e matches every value

def simplifyTop(expr: Expr): Expr = expr match {                // A match expression is evaluated by trying each of the patterns in the order they are written
    case UnOp("-", UnOp("-", e)) => e // Double negation        // constructor pattern looks like UnOp("-", e). This pattern matches all values of type UnOp whose first argument matches "-" and whose second argument matches e
    case BinOp("+", e, Number(0)) => e // Adding zero           // e - a variable that is bound within the associated pattern
    case BinOp("*", e, Number(1)) => e // Multiplying by one
    case _ => expr                                              // wildcard pattern (_) also matches every value
}

-match compared to switch
// match is an expression in Scala (i.e., it always results in a value)
// Scala’s alternative expressions never “fall through” into the next case
// Third, if none of the patterns match, an exception named MatchError is thrown

-Kinds of patterns
-Wildcard patterns
expr match {
    case BinOp(op, left, right) => println(expr + " is a binary operation")
    case _ =>                                                                   // handle the default case
}
expr match {
    case BinOp(_, _, _) => println(expr + " is a binary operation")             // dont care about elements of binary operation
    case _ => println("It's something else")
}

-Constant patterns
def describe(x: Any) = x match {
    case 5 => "five"
    case true => "truth"
    case "hello" => "hi!"
    case Nil => "the empty list"
    case _ => "something else"
}
describe(5)                  // res6: String = five
describe(true)               // res7: String = truth
describe("hello")            // res8: String = hi!
describe(Nil)                // res9: String = the empty list
describe(List(1,2,3))        // res10: String = something else

-Variable patterns
expr match {
    case 0 => "zero"
    case somethingElse => "not zero: " + somethingElse      // default case for all other values
}

import math.{E, Pi}
E match {
    case Pi => "strange math? Pi = " + Pi   // name starting with a lowercase letter is taken to be a pattern variable; all other references are taken to be constants
    case _ => "OK"
}
// res11: String = OK                       // As expected, E does not match Pi, so the "strange math" case is not used.
val pi = math.Pi                            // pi: Double = 3.141592653589793
scala> E match {
    case pi => "strange math? Pi = " + pi   // res12: String = strange math? Pi = 2.718281828459045
}
// and you are not allowed to add a default case cause variable pattern is default
E match {
    case pi => "strange math? Pi = " + pi
    case _ => "OK"                          // <console>:12: warning: unreachable code case _ => "OK"
}
// You can still use a lowercase name for a pattern constant if the constant is a field of some object, you can prefix it with a qualifier
// 1. pi is a variable pattern, but this.pi or obj.pi are constants
// 2. you can alternatively enclose the variable name in back ticks
E match {
    case `pi` => "strange math? Pi = " + pi
    case _ => "OK"                          // res14: String = OK
}

-Constructor patterns
// Scala patterns support deep matches
expr match {
    case BinOp("+", e, Number(0)) => println("a deep match")        // if BinOp is case class - first check if object is member of case class, then check constructor parameters match
    case _ =>
}

-Sequence patterns
expr match {
    case List(0, _, _) => println("found it")       // three-element list starting with zero
    case List(1, _*) => println("found it")         // matches 1 and any number of elements within a sequence
    case _ =>
}

-Tuple patterns
def tupleDemo(expr: Any) =
    expr match {
        case (a, b, c) => println("matched " + a + b + c)       // matches an arbitrary 3-tuple
        case _ =>
    }
tupleDemo(("a ", 3, "-tuple"))                                  // matched a 3-tuple

-Typed patterns
def generalSize(x: Any) = x match {
    case s: String => s.length
    case m: Map[_, _] => m.size
    case _ => -1
}

-Type erasure
// no information about type arguments is maintained at runtime
// there is no way to determine at runtime whether a given Map object has been created with two Int arguments
def isIntIntMap(x: Any) = x match {
    case m: Map[Int, Int] => true       // warning: non-variable type argument Int in type pattern is unchecked since it is eliminated by erasure
    case _ => false
}
scala> isIntIntMap(Map(1 -> 1))                 // res19: Boolean = true
scala> isIntIntMap(Map("abc" -> "abc"))         // res20: Boolean = true
// exception is Array because type is stored in array
def isStringArray(x: Any) = x match {
    case a: Array[String] => "yes"
    case _ => "no"
}
isStringArray(Array("abc"))                     // res21: String = yes
isStringArray(Array(1, 2, 3))                   // res22: String = no

-Variable binding
// variable-binding pattern with e as the variable and UnOp("abs", _) as the pattern
// If the entire pattern match succeeds, then the portion that matched the UnOp("abs", _) part is made available as variable e
expr match {
    case UnOp("abs", e @ UnOp("abs", _)) => e   // looks for the absolute value operation being applied twice in a row
    case _ =>
}

-Pattern guards
// pattern variable may only appear once in a pattern
def simplifyAdd(e: Expr) = e match {
    case BinOp("+", x, x) => BinOp("*", x, Number(2))   // error: x is already defined as value x
    case _ => e
}
// reformulate
def simplifyAdd(e: Expr) = e match {
    case BinOp("+", x, y) if x == y => BinOp("*", x, Number(2))     // pattern guard goes after if
    case _ => e
}

-Pattern overlaps
// If you wrote them in the other order, then the catch-all case would be run in favor of the more specific rules
def simplifyAll(expr: Expr): Expr = expr match {
    case UnOp("-",UnOp("-",e))      =>simplifyAll(e) // '-'is its own inverse
    case BinOp("+", e, Number(0))   =>simplifyAll(e) // '0' is a neutral element for ‘+'
    case BinOp("*", e, Number(1))   =>simplifyAll(e) // '1' is a neutral element for ‘*'
    case UnOp(op, e)                =>UnOp(op, simplifyAll(e))
    case BinOp(op, l, r)            =>BinOp(op, simplifyAll(l), simplifyAll(r))
    case _ => expr
}

-Sealed classes
// How can you ever feel safe that you covered all the cases in pattern matching?
// A sealed class cannot have any new subclasses added except the ones in the same file
// you only need to worry about the subclasses you already know about
sealed abstract class Expr
case class Var(name: String) extends Expr
case class Number(num: Double) extends Expr
case class UnOp(operator: String, arg: Expr) extends Expr
case class BinOp(operator: String, left: Expr, right: Expr) extends Expr
def describe(e: Expr): String = e match {       // warning: match is not exhaustive!
    case Number(_) => "a number"                // missing combination UnOp
    case Var(_) => "a variable"                 // missing combination BinOp
}
// no warning
def describe(e: Expr): String = (e: @unchecked) match {
    case Number(_) => "a number"
    case Var(_) => "a variable"
    case _ => throw new RuntimeException        // or this
}

-The Option type
// Option two forms: Some(x) and None object
val capitals = Map("France" >"Paris", "Japan" >"Tokyo")
capitals get "France"                           // res23: Option[String] = Some(Paris)
capitals get "North Pole"                       // res24: Option[String] = None
def show(x: Option[String]) = x match {
    case Some(s) => s
    case None => "?"
}
show(capitals get "Japan")               // res25: String = Tokyo
show(capitals get "France")              // res26: String = Paris
show(capitals get "North Pole")          // res27: String = ?

-Patterns everywhere
-Patterns in variable definitions
val myTuple = (123, "abc")
val (number, string) = myTuple          // number: Int = 123; string: String = abc
val exp = new BinOp("*", Number(5), Number(1))
val BinOp(op, left, right) = exp        // op: String = *; left: Expr = Number(5.0); right: Expr = Number(1.0)

-Case sequences as partial functions
val withDefault: Option[Int] => Int = { // A sequence of cases (i.e., alternatives) in curly braces can be used anywhere a function literal can be used
    case Some(x) => x                   // case sequence is a function literal, only more general
    case None => 0
}
withDefault(Some(10))            // res28: Int = 10
withDefault(None)                // res29: Int = 0
// Akka actors library allows its receive method to be defined as a series of cases
var sum = 0
def receive = {
    case Data(byte)             =>sum += byte
    case GetChecksum(requester) =>val checksum = ~(sum & 0xFF) + 1
    requester ! checksum
}
// sequence of cases gives you a partial function If you apply such a function on a value it does not support,it will generate a run-time exception
// warning: match is not exhaustive! missing combination Nil
val second: List[Int] => Int = {
    case x :: y :: _ => y       // will succeed if you pass it a three-element list
}
second(List(5, 6, 7))           // res24: Int = 6
second(List())                  // scala.MatchError: List()

-Patterns in for expressions
// for expression retrieves all key/value pairs from the capitals map
for ((country, city) <capitals)
    println("The capital of " + country + " is " + city)
// the second element None in the results list does not match the pattern Some(fruit); therefore it does not show up in the output.
val results = List(Some("apple"), None, Some("orange"))
for (Some(fruit) <results)
    println(fruit)              // apple, orange

-A larger example
                     x
x/(x+1)     -->     ---      
                    x+1
// concentrate on horizontal layout
BinOp("+",
    BinOp("*",
        BinOp("+", Var("x"), Var("y")),
        Var("z")),
    Number(1))
// code needs to know about the relative precedence of each operator
Map( "|" > 0, "||" > 0, "&" > 1, "&&" > 1, ... )

package org.stairwaybook.expr
import org.stairwaybook.layout.Element.elem
sealed abstract class Expr
case class Var(name: String) extends Expr
case class Number(num: Double) extends Expr
case class UnOp(operator: String, arg: Expr) extends Expr
case class BinOp(operator: String, left: Expr, right: Expr) extends Expr
class ExprFormatter {
    // Contains operators in groups of increasing precedence
    private val opGroups =
        Array(
            Set("|", "||"),
            Set("&", "&&"),
            Set("ˆ"),
            Set("==", "!="),
            Set("<", "<=", ">", ">="),
            Set("+", ""),
            Set("*", "%")
        )
// A mapping from operators to their precedence
    private val precedence = {
        val assocs =
            for {
                i <- 0 until opGroups.length
                op <- opGroups(i)
            } yield op -> i
        assocs.toMap
    }
private val unaryPrecedence = opGroups.length
private val fractionPrecedence = 1
import org.stairwaybook.layout.Element
    private def format(e: Expr, enclPrec: Int): Element =
        e match {
            case Var(name) => elem(name)                                            // 1.If the expression is a variable, the result is an element formed from the variable’s name.
            case Number(num) => 
                def stripDot(s: String) =                                           // 2.cleans up the display of a floating-point number by stripping any ".0" suffix from a string
                    if (s endsWith ".0") s.substring(0, s.length 2)
                    else s
                elem(stripDot(num.toString))
            case UnOp(op, arg) => elem(op) beside format(arg, unaryPrecedence)      // 3.if arg is a binary operation (but not a fraction) it will always be displayed in parentheses
            case BinOp("/", left, right) =>                                         // 4.If the expression is a fraction, an intermediate result frac is formed by placing the formatted 
                val top = format(left, fractionPrecedence)                          // operands left and right on top of each other, separated by an horizontal line element
                val bot = format(right, fractionPrecedence)                         // 
                val line = elem('',top.width max bot.width, 1)
                val frac = top above line above bot
                if (enclPrec != fractionPrecedence) frac
                else elem(" ") beside frac beside elem(" ")
            case BinOp(op, left, right) =>                                          // applies for all other binary operations
                val opPrec = precedence(op)
                val l = format(left, opPrec)
                val r = format(right, opPrec + 1)
                val oper = l beside elem(" " + op + " ") beside r
                if (enclPrec <= opPrec) oper
                else elem("(") beside oper beside elem(")")
        }
    def format(e: Expr): Element = format(e, 0)
}
import org.stairwaybook.expr._
object Express extends App {
    val f = new ExprFormatter                                                                           1          
    val e1 = BinOp("*", BinOp("/", Number(1), Number(2)),BinOp("+", Var("x"), Number(1)))       -->     - * (x + 1)
    println(f.format(e1)+ "\n\n")                                                                       2          
}


###############
# Working with Lists 
###############
-List literals
// lists are immutable, lists have a recursive structure, whereas arrays are flat
val fruit = List("apples", "oranges", "pears")
val nums = List(1, 2, 3, 4)
val empty = List()

-The List type
// The list type in Scala is covariant
// if S is a subtype of T, then List[S] is a subtype of List[T]
// List[String] is a subtype of List[Object]
val fruit: List[String] = List("apples", "oranges", "pears")
val nums: List[Int] = List(1, 2, 3,
val empty: List[Nothing] = List()       // Because lists are covariant, it follows that List[Nothing] is a subtype of List[T]
val xs: List[String] = List()           // List() is also of type List[String]!        

-Constructing lists
// lists are built from two fundamental building blocks, Nil and :: (pronounced "cons")
// x :: xs represents a list whose first element is x, followed by (the elements of) list xs
val fruit = "apples" :: ("oranges" :: ("pears" :: Nil))
val nums = 1 :: 2 :: 3 :: 4 :: Nil

-Basic operations on lists
head    // returns the first element of a list
tail    // returns a list consisting of all elements except the first
isEmpty // returns true if the list is empty
// insertion sort - sort a non-empty list x :: xs, sort the remainder xs and insert the first element x at the right position in the result
def isort(xs: List[Int]): List[Int] =
    if (xs.isEmpty) Nil
    else insert(xs.head, isort(xs.tail))
def insert(x: Int, xs: List[Int]): List[Int] =
    if (xs.isEmpty || x <= xs.head) x :: xs
    else xs.head :: insert(x, xs.tail)

-List patterns
val List(a, b, c) = fruit       // match on all elements of a list (a: String = apples ,b: String = oranges ,c: String = pears)
val a :: b :: rest = fruit      // (a: String = apples, b: String = oranges, rest: List[String] = List(pears))
// sorting
def isort(xs: List[Int]): List[Int] = xs match {
    case List()     => List()
    case x :: xs1   => insert(x, isort(xs1))
}
def insert(x: Int, xs: List[Int]): List[Int] = xs match {
    case List()     => List(x)
    case y :: ys    => if (x <= y) x :: xs else y :: insert(x, ys)
}

-First-order methods on class List
// A method is first-order if it does not take any functions as arguments

-Concatenating two lists
List(1, 2) ::: List(3, 4, 5)        // res0: List[Int] = List(1, 2, 3, 4, 5)

-The Divide and Conquer principle
// implementing concatenation
def append[T](xs: List[T], ys: List[T]): List[T] =
    xs match {
        case List() => ys
        case x :: xs1 => x :: append(xs1, ys)
}

-Taking the length of a list: length
List(1, 2, 3).length            // res3: Int = 3 (needs to traverse the whole list)

-Accessing the end of a list: init and last
val abcde = List('a', 'b', 'c', 'd', 'e')
abcde.last                      // res4: Char = e   (need to traverse the whole list to compute their result)
abcde.init                      // res5: List[Char] = List(a, b, c, d)  (need to traverse the whole list to compute their result)

-Reversing lists: reverse
abcde.reverse
// Reverse could be implemented using concatenation (:::)
// complexity is quadratic, compared to the standard reversal of a mutable, linked list, which has linear complexity
def rev[T](xs: List[T]): List[T] = xs match {
    case List() => xs
    case x :: xs1 => rev(xs1) ::: List(x)
}

-Prefixes and suffixes: drop, take, and splitAt
abcde take 2         // res8: List[Char] = List(a, b)
abcde drop 2         // res9: List[Char] = List(c, d, e)
abcde splitAt 2      // res10: (List[Char], List[Char]) = (List(a, b),List(c, d, e))

-Element selection: apply and indices
abcde apply 2                       // res11: Char = c (rare in Scala)
abcde(2)                            // res12: Char = c (rare in Scala)
abcde.indices                       // res13: scala.collection.immutable.Range = Range(0, 1, 2, 3, 4)

-Flattening a list of lists: flatten
List(List(1, 2), List(3), List(), List(4, 5)).flatten   // res14: List[Int] = List(1, 2, 3, 4, 5)
fruit.map(_.toCharArray).flatten                        // res15: List[Char] = List(a, p, p, l, e, s, o, r, a, n, g, e,s, p, e, a, r, s)

-Zipping lists: zip and unzip
// takes two lists and forms a list of pairs
abcde.indices zip abcde                                 // res17: scala.collection.immutable.IndexedSeq[(Int, Char)] = Vector((0,a), (1,b), (2,c), (3,d), (4,e))
val zipped = abcde zip List(1, 2, 3)                    // zipped: List[(Char, Int)] = List((a,1), (b,2), (c,3))
abcde.zipWithIndex                                      // res18: List[(Char, Int)] = List((a,0), (b,1), (c,2), (d,3), (e,4))
zipped.unzip                                            // res19: (List[Char], List[Int]) = (List(a, b, c),List(1, 2, 3))

-Displaying lists: toString and mkString
abcde.toString                                          // res20: String = List(a, b, c, d, e)
abcde mkString ("[", ",", "]")                          // res21: String = [a,b,c,d,e]
abcde mkString ""                                       // res22: String = abcde
abcde.mkString                                          // res23: String = abcde
abcde mkString                                          // ("List(", ", ", ")")  res24: String = List(a, b, c, d, e)
val buf = new StringBuilder
abcde addString (buf, "(", ";", ")")                    // res25: StringBuilder = (a;b;c;d;e)

-Converting lists: iterator, toArray, copyToArray
val arr = abcde.toArray                                 // arr: Array[Char] = Array(a, b, c, d, e)
arr.toList                                              // res26: List[Char] = List(a, b, c, d, e)
val arr2 = new Array[Int](10)                           // arr2: Array[Int] = Array(0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
List(1, 2, 3) copyToArray (arr2, 3)
arr2                                                    // res28: Array[Int] = Array(0, 0, 0, 1, 2, 3, 0, 0, 0, 0)
val it = abcde.iterator
it.next                                                 // res29: Char = a
it.next                                                 // res30: Char = b

-Example: Merge sort
def msort[T](less: (T, T) => Boolean)(xs: List[T]): List[T] = {
    def merge(xs: List[T], ys: List[T]): List[T] =
        (xs, ys) match {
            case (Nil, _) => ys
            case (_, Nil) => xs
            case (x :: xs1, y :: ys1) =>
                if (less(x, y)) x :: merge(xs1, ys)
                else y :: merge(xs, ys1)
    }
    val n = xs.length / 2
    if (n == 0) xs
    else {
        val (ys, zs) = xs splitAt n
        merge(msort(less)(ys), msort(less)(zs))
    }
}
msort((x: Int, y: Int) => x < y)(List(5, 7, 1, 3))      // res31: List[Int] = List(1, 3, 5, 7)
val intSort = msort((x: Int, y: Int) => x < y) _
val reverseIntSort = msort((x: Int, y: Int) => x > y) _
val mixedInts = List(4, 1, 9, 0, 5, 8, 3, 6, 2, 7)
intSort(mixedInts)                                      // res0: List[Int] = List(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
reverseIntSort(mixedInts)                               // res1: List[Int] = List(9, 8, 7, 6, 5, 4, 3, 2, 1, 0)

-Higher-order methods on class List
-Mapping over lists: map, flatMap and foreach
List(1, 2, 3) map (_ + 1)                               // res32: List[Int] = List(2, 3, 4)
val words = List("the", "quick", "brown", "fox")        // words: List[String] = List(the, quick, brown, fox)
words map (_.length)                                    // res33: List[Int] = List(3, 5, 5, 3)
words map (_.toList.reverse.mkString)                   // res34: List[String] = List(eht, kciuq, nworb, xof)
words map (_.toList)                                    // res35: List[List[Char]] = List(List(t, h, e), List(q, u, i, c, k), List(b, r, o, w, n), List(f, o, x))
words flatMap (_.toList)                                // res36: List[Char] = List(t, h, e, q, u, i, c, k, b, r, o, w, n, f, o, x)
// 1. generate a list of integers from 1 (including) until 5 (excluding),
// 2. a second time to generate a list of integers from 1 until i, for each value of i taken from the first list
// 3. The map in this expression generates a list of tuples (i; j)
List.range(1, 5) flatMap (i => List.range(1, i) map (j => (i, j)))      // res37: List[(Int, Int)] = List((2,1), (3,1), (3,2), (4,1),(4,2), (4,3))
var sum = 0
List(1, 2, 3, 4, 5) foreach (sum += _)
sum                                                      // res39: Int = 15

-Filtering lists: filter, partition, find, takeWhile, dropWhile, and span
List(1, 2, 3, 4, 5) filter (_ % 2 == 0)                 // res40: List[Int] = List(2, 4)
words filter (_.length == 3)                            // res41: List[String] = List(the, fox)
// partition method is like filter but returns a pair of lists (for true,false)
List(1, 2, 3, 4, 5) partition (_ % 2 == 0)              // res42: (List[Int], List[Int]) = (List(2, 4),List(1, 3, 5))
// find method is also similar to filter, but it returns the first element satisfying a given predicate
List(1, 2, 3, 4, 5) find (_ % 2 == 0)                   // res43: Option[Int] = Some(2)
scala> List(1, 2, 3, 4, 5) find (_ <= 0)                // res44: Option[Int] = None
// takeWhile and dropWhile operators also take a predicate - takes/drops longest prefix
List(1, 2, 3, 4, 5) takeWhile (_ > 0)                   // res45: List[Int] = List(1, 2, 3)
words dropWhile (_ startsWith "t")                      // res46: List[String] = List(quick, brown, fox)
// span method combines takeWhile and dropWhile in one operation, just like splitAt combines take and drop
List(1, 2, 3, 4, 5) span (_ > 0)                        // res47: (List[Int], List[Int]) = (List(1, 2, 3),List(4, 5))

-Predicates over lists: forall and exists
// forall p takes as arguments a list xs and a predicate p. Its result is true if all elements in the list satisfy p
def hasZeroRow(m: List[List[Int]]) =
    m exists (row => row forall (_ == 0))
hasZeroRow(diag3)                                       // res48: Boolean = false

-Folding lists: /: and :\
// fold left operation “(z /: xs) (op)” involves three objects: a start value z, a list xs, and a binary operation op
// (z /: List(a, b, c)) (op) equals op(op(op(z, a), b), c)
//      op
//     /  \
//    op   c
//   /  \
//  op   b
// /  \
//z    a
("" /: words) (_ + " " + _)                             // res49: String = " the quick brown fox"
// (List(a, b, c) :\ z) (op) equals op(a, op(b, op(c, z)))
//  op
// /  \
//a   op
//   /  \
//  b   op
//     /  \
//    c    z
// concatenates all elements in a list of lists
def flattenLeft[T](xss: List[List[T]]) = (List[T]() /: xss) (_ ::: _)
def flattenRight[T](xss: List[List[T]]) = (xss :\ List[T]()) (_ ::: _)      // more efficient, because flattenLeft(xss) copies the first element list xss.head n􀀀1 times, where n is the length of the list xss

-Example: List reversal using fold
def reverseLeft[T](xs: List[T]) = (List[T]() /: xs) {(ys, y) => y :: ys}

-Sorting lists: sortWith
List(1, 3, 4, 2, 6) sortWith (_ < _)                // res51: List[Int] = List(3, 1, 2, 4, 6)
words sortWith (_.length > _.length)                // res52: List[String] = List(quick, brown, the, fox)

-Methods of the List object
-Creating lists from their elements: List.apply
List.apply(1, 2, 3)                                 // res53: List[Int] = List(1, 2, 3)

-Creating a range of numbers: List.range
List.range(1, 5)                                    // res54: List[Int] = List(1, 2, 3, 4)
List.range(1, 9, 2)                                 // res55: List[Int] = List(1, 3, 5, 7)
List.range(9, 1, 3)                                 // res56: List[Int] = List(9, 6, 3)

-Creating uniform lists: List.fill
List.fill(5)('a')                                   // res57: List[Char] = List(a, a, a, a, a)
List.fill(3)("hello")                               // res58: List[String] = List(hello, hello, hello)
// multidimensional lists
List.fill(2, 3)('b')                                // res59: List[List[Char]] = List(List(b, b, b), List(b, b, b))

-Tabulating a function: List.tabulate
// tabulate method creates a list whose elements are computed according to a supplied function
val squares = List.tabulate(5)(n => n * n)          // squares: List[Int] = List(0, 1, 4, 9, 16)

-Concatenating multiple lists: List.concat
List.concat(List('a', 'b'), List('c'))              // res60: List[Char] = List(a, b, c)
List.concat(List(), List('b'), List('c'))           // res61: List[Char] = List(b, c)
List.concat()                                       // res62: List[Nothing] = List()

-Processing multiple lists together
(List(10, 20), List(3, 4, 5)).zipped.map(_ * _)                 // res63: List[Int] = List(30, 80)
(List("abc", "de"), List(3, 2)).zipped.forall(_.length == _)    // res64: Boolean = true
(List("abc", "de"), List(3, 2)).zipped.exists(_.length != _)    // res65: Boolean = false


###############
# Working with Other Collections
###############
-Sequences
// Lists, Arrays, List buffers, Array buffers, StringOps
-Lists
// fast add to start of list, but they do not provide fast access to arbitrary indexes because the implementation must iterate through the list linearly
val colors = List("red", "blue", "green")
colors.head                                     // res0: String = red
colors.tail                                     // res1: List[String] = List(blue, green)

-Arrays
// efficiently access an element at an arbitrary position
val fiveInts = new Array[Int](5)                // fiveInts: Array[Int] = Array(0, 0, 0, 0, 0)
val fiveToOne = Array(5, 4, 3, 2, 1)            // fiveToOne: Array[Int] = Array(5, 4, 3, 2, 1)
fiveInts(0) = fiveToOne(4)
fiveInts                                        // res3: Array[Int] = Array(1, 0, 0, 0, 0)

-List buffers
// mutable object, more efficiently when you need to append
// += append
// +=: prepand
import scala.collection.mutable.ListBuffer
import scala.collection.mutable.ListBuffer
val buf = new ListBuffer[Int]
buf += 1
buf += 2                                            // res5: buf.type = ListBuffer(1, 2)
buf                                                 // res6: scala.collection.mutable.ListBuffer[Int] = ListBuffer(1, 2)
3 +=: buf                                           // res7: buf.type = ListBuffer(3, 1, 2)
buf.toList                                          // res8: List[Int] = List(3, 1, 2)

-Array buffers
// like an array, except that you can additionally add and remove elements from the beginning and end of the sequence
import scala.collection.mutable.ArrayBuffer
val buf = new ArrayBuffer[Int]()
buf += 12                                           // res9: buf.type = ArrayBuffer(12)
buf += 15                                           // res10: buf.type = ArrayBuffer(12, 15)
buf                                                 // res11: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(12, 15)
buf.length                                          // res12: Int = 2
buf(0)                                              // res13: Int = 12

-Strings (via StringOps)
def hasUpperCase(s: String) = s.exists(_.isUpper)
hasUpperCase("Robert Frost")                        // res14: Boolean = true
hasUpperCase("e e cummings")                        // res15: Boolean = false

-Sets and maps
object Predef {
    type Map[A, +B] = collection.immutable.Map[A, B]
    type Set[A] = collection.immutable.Set[A]
    val Map = collection.immutable.Map
    val Set = collection.immutable.Set
    // ...
}

-Using sets
val text = "See Spot run. Run, Spot. Run!"
val wordsArray = text.split("[ !,.]+")              // wordsArray: Array[String] = Array(See, Spot, run, Run, Spot, Run)
val words = mutable.Set.empty[String]               // words: scala.collection.mutable.Set[String] = Set()
for (word <wordsArray)
    words += word.toLowerCase
words                                               // res17: scala.collection.mutable.Set[String] = Set(see, run, spot)

val nums = Set(1, 2, 3)                             // Creates an immutable set (nums.toString returns Set(1, 2, 3))
nums + 5                                            // Adds an element (returns Set(1, 2, 3, 5))
nums - 3                                            // Removes an element (returns Set(1, 2))
nums ++ List(5, 6)                                  // Adds multiple elements (returns Set(1, 2, 3, 5, 6))
nums -- List(1, 2)                                  // Removes multiple elements (returns Set(3))
nums & Set(1, 3, 5, 7)                              // Takes the intersection of two sets (returns Set(1, 3))
nums.size                                           // Returns the size of the set (returns 3)
nums.contains(3)                                    // Checks for inclusion (returns true)
import scala.collection.mutable                     // Makes the mutable collections easy to access
val words = mutable.Set.empty[String]               // Creates an empty, mutable set (words.toString returns Set())
words += "the"                                      // Adds an element (words.toString returns Set(the))
words -= "the"                                      // Removes an element, if it exists (words.toString returns Set())
words ++= List("do", "re", "mi")                    // Adds multiple elements (words.toString returns Set(do, re, mi))
words --= List("do", "re")                          // Removes multiple elements (words.toString returns Set(mi))
words.clear                                         // Removes all elements (words.toString returns Set())

-Using maps
val map = mutable.Map.empty[String, Int]
map("hello") = 1
map("there") = 2
map                                                 // res20: scala.collection.mutable.Map[String,Int] = Map(hello -> 1, there -> 2)
map("hello")                                        // res21: Int = 1
// Putting it all together, here is a method that counts the number of times each word occurs in a string
def countWords(text: String) = {
    val counts = mutable.Map.empty[String, Int]
    for (rawWord <- text.split("[ ,!.]+")) {
        val word = rawWord.toLowerCase
        val oldCount =
            if (counts.contains(word)) counts(word)
            else 0
        counts += (word -> (oldCount + 1))
    }
    counts
}
countWords("See Spot run! Run, Spot. Run!")         // res22: scala.collection.mutable.Map[String,Int] = Map(spot -> 2, see -> 1, run -> 3)

val nums = Map("i" -> 1, "ii" ->2)          // Creates an immutable map (nums.toString returns Map(i -> 1, ii -> 2))
nums + ("vi" -> 6)                          // Adds an entry (returns Map(i -> 1, ii -> 2, vi -> 6))
nums - "ii"                                 // Removes an entry (returns Map(i ->1))
nums ++ List("iii" -> 3, "v" -> 5)          // Adds multiple entries (returns Map(i -> 1, ii -> 2, iii -> 3, v -> 5))
nums -- List("i", "ii")                     // Removes multiple entries (returns Map())
nums.size                                   // Returns the size of the map (returns 2)
nums.contains("ii")                         // Checks for inclusion (returns true)
nums("ii")                                  // Retrieves the value at a specified key (returns 2)
nums.keys                                   // Returns the keys (returns an Iterable over the strings "i" and "ii")
nums.keySet                                 // Returns the keys as a set (returns Set(i, ii))
nums.values                                 // Returns the values (returns an Iterable over the integers 1 and 2)
nums.isEmpty                                // Indicates whether the map is empty
(returns false)
import scala.collection.mutable             // Makes the mutable collections easy to access
val words = mutable.Map.empty[String, Int]  // Creates an empty, mutable map
words += ("one" -> 1)                       // Adds a map entry from "one" to 1 (words.toString returns Map(one -> 1))
words -= "one"                              // Removes a map entry, if it exists (words.toString returns Map())
words ++= List("one" -> 1, "two" -> 2, "three" -> 3)    // Adds multiple map entries (words.toString returns Map(one -> 1, two -> 2, three -> 3))
words --= List("one", "two")                // Removes multiple objects (words.toString returns Map(three -> 3))

-Default sets and maps
// mutable Set/Map use HashSet/HashMap
// immutable Set use Set1,2,3,4,HashSet(when more then 5 elements) - uses uses hash tries
// immutable Map use Map1,2,3,4,HashMap(when more then 5 elements) - uses uses hash tries

-Sorted sets and maps
// These traits are implemented by classes TreeSet and TreeMap, which use a red-black tree to keep elements (in the case of TreeSet) or keys (in the case of TreeMap) in order
import scala.collection.immutable.TreeSet
val ts = TreeSet(9, 3, 1, 8, 0, 2, 7, 4, 6, 5)  // ts: scala.collection.immutable.TreeSet[Int] = TreeSet(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
val cs = TreeSet('f', 'u', 'n')                 // cs: scala.collection.immutable.TreeSet[Char] = TreeSet(f, n, u)
import scala.collection.immutable.TreeMap
var tm = TreeMap(3 -> 'x', 1 -> 'x', 4 -> 'x')  // tm: scala.collection.immutable.TreeMap[Int,Char] = Map(1 ->x, 3 ->x, 4 ->x)
tm += (2 ->'x')
tm                                              // res30: scala.collection.immutable.TreeMap[Int,Char] = Map(1 ->x, 2 ->x, 3 ->x, 4 ->x)

-Selecting mutable versus immutable collections
// immutable sets do not support a += operator
val people = Set("Nancy", "Jane")
people += "Bob"                                 // <console>:14: error: value += is not a member of
// if you declare people as a var, instead of a val, then the collection can be “updated” with a += operation
// a new collection will be created, and then people will be reassigned to refer to the new collection
var people = Set("Nancy", "Jane")
people += "Bob"
people                                          // res34: scala.collection.immutable.Set[String] = Set(Nancy, Jane, Bob)
people -= "Jane"
people ++= List("Tom", "Harry")
people                                          // res37: scala.collection.immutable.Set[String] = Set(Nancy, Bob, Tom, Harry)
var capital = Map("US" -> "Washington", "France" -> "Paris")
capital += ("Japan" -> "Tokyo")
println(capital("France"))
import scala.collection.mutable.Map             // only change needed!

-Initializing collections
List(1, 2, 3)
Set('a', 'b', 'c')
import scala.collection.mutable
mutable.Map("hi" -> 2, "there" ->5)
Array(1.0, 2.0, 3.0)
import scala.collection.mutable
val stuff = mutable.Set(42)
stuff += "abracadabra"                          // <console>:16: error: type mismatch;
val stuff = mutable.Set[Any](42)                // stuff: scala.collection.mutable.Set[Any] = Set(42)
// have a list, but you want a TreeSet
val colors = List("blue", "yellow", "red", "green")
import scala.collection.immutable.TreeSet
val treeSet = TreeSet(colors)                   // error: No implicit Ordering defined for List[String]
val treeSet = TreeSet[String]() ++ colors       // treeSet: scala.collection.immutable.TreeSet[String] = TreeSet(blue, green, red, yellow)

-Converting to array or list
treeSet.toList                                  // res50: List[String] = List(blue, green, red, yellow)
treeSet.toArray                                 // res51: Array[String] = Array(blue, green, red, yellow)

-Converting between mutable and immutable sets and maps
import scala.collection.mutable
treeSet                                         // res52: scala.collection.immutable.TreeSet[String] = TreeSet(blue, green, red, yellow)
val mutaSet = mutable.Set.empty ++= treeSet     // mutaSet: scala.collection.mutable.Set[String] = Set(red, blue, green, yellow)
val immutaSet = Set.empty ++ mutaSet            // immutaSet: scala.collection.immutable.Set[String] = Set(red, blue, green, yellow)
// same for maps
val muta = mutable.Map("i" -> 1, "ii" -> 2)
val immu = Map.empty ++ muta                    // immu: scala.collection.immutable.Map[String,Int] = Map(ii -> 2, i -> 1)

-Tuples
// can hold objects with different types
(1, "hello", Console)
// method that finds the longest word in a collection and also returns its index
def longestWord(words: Array[String]) = {
    var word = words(0)
    var idx = 0
    for (i <- 1 until words.length)
        if (words(i).length > word.length) {
        word = words(i)
        idx = i
        }
    (word, idx)
}
val longest = longestWord("The quick brown fox".split(" "))     // longest: (String, Int) = (quick,1)
longest._1                  // res53: String = quick
longest._2                  // res54: Int = 1
val (word, idx) = longest   // word: String = quick;  idx: Int = 1


###############
# Mutable Objects
###############
-What makes an object mutable
class BankAccount {
    private var bal: Int = 0
    def balance: Int = bal
    def deposit(amount: Int) = {
        require(amount > 0)
        bal += amount
    }
    def withdraw(amount: Int): Boolean =
        if (amount > bal) false
        else {
        bal -= amount
        true
    }
}
val account = new BankAccount
account deposit 100
account withdraw 80             // res1: Boolean = true
account withdraw 80             // res2: Boolean = false

-Reassignable variables and properties
// in scala every var that is a non-private member of some object implicitly defines a getter and a setter method with it.
// getter of a var x is just named "x", while its setter is named "x_="
var hour = 12                   // generates a getter, “hour”, and setter, “hour_=”, in addition to a reassignable field
class Time {
    private[this] var h = 12
    private[this] var m = 0
    def hour: Int = h
    def hour_= (x: Int) = {         // when you call t.hour=25 - "hour_" will be cassed
        require(0 <= x && x < 24)
        h = x
    }
    def minute = m
    def minute_= (x: Int) = {
        require(0 <= x && x < 60)
        m = x
    }
}
// define a getter and a setter without an associated field
class Thermometer {
    var celsius: Float = _                                          // "= _" - sets to default (0) value
    def fahrenheit = celsius * 9 / 5 + 32                           // convert from celsius
    def fahrenheit_= (f: Float) = {celsius = (f 32)* 5 / 9}         // convert to celsius
    override def toString = fahrenheit + "F/" + celsius + "C"
}

-Case study: Discrete event simulation
-A language for digital circuits
-The Simulation API
-Circuit Simulation

-Type Parameterization
-Functional queues
// A functional queue is a data structure with three operations:
// head     returns the first element of the queue
// tail     returns a queue without its first element
// enqueue  returns a new queue with a given element appended at the end
// Not efficient implementation
class SlowAppendQueue[T](elems: List[T]) { 
    def head = elems.head
    def tail = new SlowAppendQueue(elems.tail)
    def enqueue(x: T) = new SlowAppendQueue(elems ::: List(x))      // takes time proportional to the number of elements stored in the queue
}
// Not efficient as well
class SlowHeadQueue[T](smele: List[T]) { 
    def head = smele.last                                           // takes time proportional to the number of elements stored in the queue
    def tail = new SlowHeadQueue(smele.init)                        // takes time proportional to the number of elements stored in the queue
    def enqueue(x: T) = new SlowHeadQueue(x :: smele)               // takes constant time
}
// mixed approach
class Queue[T](private val leading: List[T],private val trailing: List[T]) {
    private def mirror =
        if (leading.isEmpty)
            new Queue(trailing.reverse, Nil)
        else
            this
    def head = mirror.leading.head
    def tail = {
        val q = mirror
        new Queue(q.leading.tail, q.trailing)
    }
    def enqueue(x: T) =
        new Queue(leading, x :: trailing)
}

-Private constructors and factory methods
class Queue[T] private (                    // private modifier between the class name and its parameters indicates that the constructor of Queue is private (accessed only from class or companion object)
    private val leading: List[T],           // primary constructor
    private val trailing: List[T]           // primary constructor
)
new Queue(List(1, 2), List(3))                  // error: constructor Queue in class Queue cannot be accessed in object $iw
def this() = this(Nil, Nil)                     // build empty queue
def this(elems: T*) = this(elems.toList, Nil)   // T* - repeated params
// companion object of the class
object Queue {
    def apply[T](xs: T*) = new Queue[T](xs.toList, Nil)     // constructs a queue with initial elements ‘xs'
}
Queue(1, 2, 3)

-An alternative: private classes
trait Queue[T] {
    def head: T
    def tail: Queue[T]
    def enqueue(x: T): Queue[T]
}
object Queue {
    def apply[T](xs: T*): Queue[T] =
        new QueueImpl[T](xs.toList, Nil)
    private class QueueImpl[T](private val leading: List[T],private val trailing: List[T]) extends Queue[T] {
        def mirror =
            if (leading.isEmpty)
                new QueueImpl(trailing.reverse, Nil)
            else
                this
        def head: T = mirror.leading.head
        def tail: QueueImpl[T] = {
            val q = mirror
            new QueueImpl(q.leading.tail, q.trailing)
        }
        def enqueue(x: T) =
            new QueueImpl(leading, x :: trailing)
    }
}

-Variance annotations
// prev defines Queue is a trait and not a type. Not a type because it takes params, cannot create var of type Queue
def doesNotCompile(q: Queue) = {}           // <console>:8: error: class Queue takes type parameters def doesNotCompile(q: Queue) = {}
// trait Queue enables you to specify parameterized types, such as Queue[String], Queue[Int], or Queue[AnyRef]:
def doesCompile(q: Queue[AnyRef]) = {}      // doesCompile: (q: Queue[AnyRef])Unit
// Queue is a trait and Queue[String] is a type; Queue is also called a type constructor because you can construct a type with it by specifying a type parameter
// term "generic" means you define many specific types with one generically written class or trait. For example, trait Queue defines a generic queue

// covariant by putting a plus sign (+) before the type parameter; List is covariant in its type parameter, so List[String] is a subtype of List[Any]
// contravariant by putting a minus sign (-) before the type parameter; Function1 is contravariant in its first type parameter, and so Function1[Any, Any] is a subtype of Function1[String, Any].
// Covariant Queues mean you could pass a Queue[String] to method, which takes a value parameter Queue[AnyRef].
// in Scala by default generic types are nonvariant - queues with diff element types would never be in relationship

// demand covariant
trait Queue[+T] { ... }         // you want Queue[String], for example, to be considered a subtype of Queue[AnyRef]
// demand contravariant
trait Queue[-T] { ... }
// example
class Cell[T](init: T) {
    private[this] var current = init
    def get = current
    def set(x: T) = { current = x }
}
// if Cell is covariant - you could do this:
val c1 = new Cell[String]("abc")    // creates a cell of strings and stores it in a val named c1
val c2: Cell[Any] = c1              // defines a new val, c2, of type Cell[Any], which initialized with c1
c2.set(1)                           // oops
val s: String = c1.get              // assign 1 to string which is wrong

-Variance and arrays
// arrays in Java are covariant
// Java stores the element type of the array at runtime, every time an array element is updated, the new element value is checked against the stored type
String[] a1 = { "abc" };
Object[] a2 = a1;
a2[0] = new Integer(17);             // Exception in thread "main" java.lang.ArrayStoreException:
String s = a1[0];                  
// this was done becase "void sort(Object[] a, Comparator cmp) { ... }", so that arrays of arbitrary reference types could be passed to this sort method
// in scala arrays are not covariant
val a1 = Array("abc")
val a2: Array[Any] = a1             // error: type mismatch; found : Array[String] required: Array[Any]

-Checking variance annotations
// proof that functional classes can be broken with covariance (even with no reassignable field)
// assume queus are covariant, create a subclass that specializes in Int
class StrangeIntQueue extends Queue[Int] {
    override def enqueue(x: Int) = {
        println(math.sqrt(x))               // prints out the square root
        super.enqueue(x)
    }
}
val x: Queue[Any] = new StrangeIntQueue     // trangeIntQueue is a subclass of Queue[Int]
x.enqueue("abc")                            // oops cannot square root abc
// !!!!!
// !!!!!
// !!!!!
// turns out that as soon as a generic parameter type appears as the type of a method parameter, the containing class or trait may not be covariant in that type parameter
var x: T                                    // special case (because is treated as a getter method "def x: T" and a setter "def x_ = (y:T)" - setter has a param of T - may not be covariant)
// compiler checks each use of each of the class’s type parameters
// + may only be used in positive positions
// - may only be used in negative positions
// no variance annotation may be used in any position
// class top level position is positive, method type positions are flipped from classes (to negative)

-Lower bounds
// Queue[T] cannot be made covariant in T because T appears as a type of a parameter of the enqueue method, and that’s a negative position
class Queue[+T] (private val leading: List[T], private val trailing: List[T] ) {
    def enqueue[U >: T](x: U) =                                 // T as the lower bound for U. As a result, U is required to be a supertype of T
        new Queue[U](leading, x :: trailing) // ...
}
// class Fruit with two subclasses, Apple and Orange. With new class Queue, it is possible to append an Orange to a Queue[Apple]. The result will be a Queue[Fruit].

-Contravariance
trait OutputChannel[-T]{        // OutputChannel is defined to be contravariant in T. So an output channel of AnyRefs, say, is a subtype of an output channel of Strings
    def write(x: T)             // what you can do with an OutputChannel[String]? - writing a String to it, same operation can be done on an OutputChannel[AnyRef].          
}                               // you can send any object to an OutputChannel[AnyRef], whereas an OutputChannel[String] requires that the written values are all strings
// Liskov Substitution Principle - It is safe to assume that a type T is a subtype of a type U if you can substitute a value of type T wherever a value of type U is required
// 

-Object private data
-Upper bounds
// Ordered being mixed into a Person class
val robert = new Person("Robert", "Jones")
val sally = new Person("Sally", "Smith")
robert < sally                                  // res0: Boolean = true
class Person(val firstName: String, val lastName: String) extends Ordered[Person] {
    def compare(that: Person) = {
        val lastNameComparison = lastName.compareToIgnoreCase(that.lastName)
        if (lastNameComparison != 0)
            lastNameComparison
        else
            firstName.compareToIgnoreCase(that.firstName)
    }
    override def toString = firstName + " " + lastName
}
// merge with ordered
def orderedMergeSort[T <: Ordered[T]](xs: List[T]): List[T] = {         // T <: Ordered[T] - upper bound - you indicate that the type parameter, T, has an upper bound, Ordered[T]
    def merge(xs: List[T], ys: List[T]): List[T] =                      // This means that the element type of the list passed to orderedMergeSort must be a subtype of Ordered
        (xs, ys) match {                                                
            case (Nil, _) => ys
            case (_, Nil) => xs
            case (x :: xs1, y :: ys1) =>
                if (x < y) x :: merge(xs1, ys)
                else y :: merge(xs, ys1)
        }
    val n = xs.length / 2
    if (n == 0) xs
    else {
        val (ys, zs) = xs splitAt n
        merge(orderedMergeSort(ys), orderedMergeSort(zs))
    }
}
// you could pass a List[Person] to orderedMergeSort because Person mixes in Ordered
val people = List(
    new Person("Larry", "Wall"),
    new Person("Anders", "Hejlsberg"),
    new Person("Guido", "van Rossum"),
    new Person("Alan", "Kay"),
    new Person("Yukihiro", "Matsumoto")
)
val sortedPeople = orderedMergeSort(people)


###############
# Abstract Members
###############
-A quick tour of abstract members                               // example implementation
trait Abstract {                                                class Concrete extends Abstract {
    type T                          // abstract type (T)            type T = String
    def transform(x: T): T          // abstract method              def transform(x: String) = x + x
    val initial: T                  // abstract val                 val initial = "hi"
    var current: T                  // abstract var                 var current = initial
}                                                               }

-Type members
// abstract type in Scala is always a member of some class or trait, such as type T in trait Abstract
// One reason to use a type member is to define a short, descriptive alias for a type whose real name is more verbose

-Abstract vals
val initial: String                 // no value
abstract class Fruit {
    val v: String // ‘v' for value
    def m: String // ‘m' for method
}
abstract class Apple extends Fruit {
    val v: String
    val m: String // OK to override a ‘def' with a ‘val'
}
abstract class BadApple extends Fruit {
    def v: String // ERROR: cannot override a ‘val' with a ‘def'
    def m: String
}

-Abstract vars
// abstract var declares just a name and a type, but not an initial value
trait AbstractTime {
    var hour: Int       // implicitly declare an abstract getter method, hour, and an abstract setter method, hour_=.
    var minute: Int
}

-Initializing abstract vals
// traits don’t have a constructor to which you could pass parameters
// So the usual notion of parameterizing a trait works via abstract vals that are implemented in subclasses
                            // To instantiate a concrete instance of that trait, you need to implement the  abstract val definitions
trait RationalTrait {       new RationalTrait {         // expression yields an instance of an anonymous class
    val numerArg: Int           val numerArg = 1        // RationalTrait inited before numerArg and denomArg
    val denomArg: Int           val denomArg = 2
}                           }

-Pre-initialized fields
// anonymous classes Pre-initialized fields
new {
    val numerArg = 1 * x        // initialize a field of a subclass before the superclass is called
    val denomArg = 2 * x
} with RationalTrait            // create an instance of RationalTrait - res1: RationalTrait = 1/2
// Pre-initialized fields in an object definition.
object twoThirds extends {
    val numerArg = 2            // numerArg inited before RationalTrait is constructed
    val denomArg = 3
} with RationalTrait
// Pre-initialized fields in a class definition
class RationalClass(n: Int, d: Int) extends {
    val numerArg = n            // initialized before the superclass constructor is called
    val denomArg = d
} with RationalTrait {
    def + (that: RationalClass) = new RationalClass(
        numer * that.denom + that.numer * denom,
        denom * that.denom
    )
}

-Lazy vals
// If val is lazy the initializing expression on the right-hand side will only be evaluated the first time the val is used
object Demo {
    val x = { println("initializing x"); "done" }
}
Demo            // initializing x
Demo.x          // res4: String = done
// with lazy
object Demo {
    lazy val x = { println("initializing x"); "done" }
}
Demo            //
Demo.x          // initializing x; res6: String = done
// similar to the situation where x is defined as a parameterless method, using a def
// unlike a def, a lazy val is never evaluated more than once
trait LazyRationalTrait {
    val numerArg: Int
    val denomArg: Int
    lazy val numer = numerArg / g
    lazy val denom = denomArg / g
    override def toString = numer + "/" + denom
    private lazy val g = {
        require(denomArg != 0)
        gcd(numerArg, denomArg)
    }
    private def gcd(a: Int, b: Int): Int =
        if (b == 0) a else gcd(b, a % b)
}
val x = 2
new LazyRationalTrait {         // this one works even though we construct LazyRationalTrait before numerArg/denomArg
    val numerArg = 1 * x
    val denomArg = 2 * x        // res7: LazyRationalTrait = 1/2
}
// 1. A fresh instance of LazyRationalTrait gets created and the initialization code of LazyRationalTrait is run. This initialization code is empty; none of the fields of LazyRationalTrait is initialized yet
// 2. Next, the primary constructor of the anonymous subclass defined by the new expression is executed. This involves the initialization of numerArg with 2 and denomArg with 4.
// 3. Next, the toString method is invoked on the constructed object by the interpreter, so that the resulting value can be printed.
// 4. Next, the numer field is accessed for the first time by the toString method in trait LazyRationalTrait, so its initializer is evaluated.
// 5. The initializer of numer accesses the private field, g, so g is evaluated next. This evaluation accesses numerArg and denomArg, which were defined in Step 2.
// 6. Next, the toString method accesses the value of denom, which causes denom’s evaluation. The evaluation of denom accesses the values of denomArg and g. The initializer of the g field is not re-evaluated, because it was already evaluated in Step 5.
// 7. Finally, the result string "1/2" is constructed and printed.

-Abstract types
class Food
abstract class Animal {
    def eat(food: Food)
}
// specialize these two classes to a class of Cows that eat Grass
class Grass extends Food
class Cow extends Animal {
    override def eat(food: Grass) = {}          // This won't compile did not override the eat method in class Animal because its parameter type is different
}
// following script would pass the type checker
class Food
abstract class Animal {
    type SuitableFood <: Food                   // Animal can eat only food that’s suitable (upper bound Food)
    def eat(food: SuitableFood)                 // any concrete instantiation of SuitableFood (in a subclass of Animal) must be a subclass of Food
}
class Grass extends Food
class Cow extends Animal {
    type SuitableFood = Grass
    override def eat(food: Grass) = {}
}
class Fish extends Food
val bessy: Animal = new Cow
bessy eat (new Fish)                            // error: type mismatch; found : Fish required: bessy.SuitableFood

-Path-dependent types
// different paths give rise to different types
class DogFood extends Food
class Dog extends Animal {
    type SuitableFood = DogFood
    override def eat(food: DogFood) = {}
}
//attempted to feed a dog with food fit for a cow
val bessy = new Cow                             // eat method, bessy.SuitableFood, is incompatible with the parameter type of eat, lassie.SuitableFood
val lassie = new Dog
lassie eat (new bessy.SuitableFood)             // error: type mismatch; found : Grass required: DogFood
val bootsie = new Dog
lassie eat (new bootsie.SuitableFood)           // Dog instance named lassie could actually eat the suitable food of a different Dog instance (which we’ll name bootsie)

-Refinement types
// class inherits from another, the first class is said to be a nominal subtype of the other one
// Scala supports structural subtyping, where you get a subtyping relationship simply because two types have compatible members
// suppose Pasture class can contain animals that eat grass
// option: define trait AnimalThatEatsGrass and mix it into every class where it applies
Animal { type SuitableFood = Grass }            // use a refinement type - write the base type, Animal, followed by a sequence of members listed in curly braces
class Pasture {
    var animals: List[Animal { type SuitableFood = Grass }] = Nil
    // ...
}

-Enumerations
object Color extends Enumeration {              // Enumeration defines an inner class named Value. same-named parameterless Value method returns a fresh instance of that class
    val Red = Value                             // provides three values: Color.Red, Color.Green, and Color.Blue
    val Green = Value                           // Color.Green is of type Color.Value
    val Blue = Value
}
// or
object Color extends Enumeration {
    val Red, Green, Blue = Value
}
import Color._
Green
object Direction extends Enumeration {
    val North = Value("North")                  // associate names with enumeration values by using a different overloaded variant of the Value method
    val East = Value("East")
    val South = Value("South")
    val West = Value("West")
}
for (d <-Direction.values) print(d + " ")       // North East South West

-Case study: Currencies
// should be able to add two amounts of the same currency, multiply a currency amount by a factor representing an interest rate
// A first (faulty) design of the Currency class
abstract class Currency {
    val amount: Long
    def designation: String
    override def toString = amount + " " + designation
    def + (that: Currency): Currency = ...
    def * (x: Double): Currency = ...
}
new Currency {                                  // create a concrete currency value by supplying concrete amount and designation values
    val amount = 79L
    def designation = "USD"
}
abstract class Dollar extends Currency {        // would let you add dollars to euros which is wrong
    def designation = "USD"
}
abstract class Euro extends Currency {
    def designation = "Euro"
}
// to handle this situation: If something is not known at the point where a class is defined, make it abstract in the class (applies to both values and types)
// exact argument and result type of the addition method are not known, so it is a good candidate for an abstract type
// A second (still imperfect) design of the Currency class
abstract class AbstractCurrency {
    type Currency <: AbstractCurrency           // Each concrete subclass of AbstractCurrency would need to fix the Currency type to refer to the concrete subclass itself
    val amount: Long
    def designation: String
    override def toString = amount + " " + designation
    def + (that: Currency): Currency = ...
    def * (x: Double): Currency = ...
}
abstract class Dollar extends AbstractCurrency {
    type Currency = Dollar
    def designation = "USD"
}
// how should addition be implemented in this class? how would you convert the amount into a currency of the right type?
// One of the restrictions of Scala’s treatment of abstract types is that you can neither create an instance of an abstract type nor have an abstract type as a supertype of another class
// workaround - use factory method
// Instead creating instance of abstract type, declare abstract method that does it, when abstract type is fixed to be some concrete type, you need to give a concrete implementation of the factory method
abstract class AbstractCurrency {
    type Currency <: AbstractCurrency   // abstract type
    def make(amount: Long): Currency    // factory method
    ... // rest of class
}
// above has issues
// move abstract type, factory method outside class AbstractCurrency. Create another class that contains the AbstractCurrency class, the Currency type, and the make factory method.
// final implementation
abstract class CurrencyZone {
    type Currency <: AbstractCurrency
    def make(x: Long): Currency
    abstract class AbstractCurrency {
        val amount: Long
        def designation: String
        def + (that: Currency): Currency = make(this.amount + that.amount)
        def * (x: Double): Currency = make((this.amount * x).toLong)
        def from(other: CurrencyZone#AbstractCurrency): Currency = make(math.round(
            other.amount.toDouble * Converter.exchangeRate
            (other.designation)(this.designation)))
        private def decimals(n: Long): Int =
            if (n == 1) 0 else 1 + decimals(n / 10)
        override def toString =
            ((amount.toDouble / CurrencyUnit.amount.toDouble)
            formatted ("%." + decimals(CurrencyUnit.amount) + "f")
            + " " + designation)
    }
    val CurrencyUnit: Currency
}
object US extends CurrencyZone {                            // Here, US is an object that extends CurrencyZone
    abstract class Dollar extends AbstractCurrency {        // defines a class Dollar, which is a subclass of AbstractCurrency.
        def designation = "USD"
    }
    type Currency = Dollar
    def make(cents: Long) = new Dollar {
        val amount = cents
    }
    val Cent = make(1)
    val Dollar = make(100)
    val CurrencyUnit = Dollar
}


###############
# Implicit Conversions and Parameters
###############
-Implicit conversions
val button = new JButton
button.addActionListener(                                   // Scala program that uses Swing must use inner classes just like in Java
    new ActionListener {
        def actionPerformed(event: ActionEvent) = {
            println("pressed!")                             // only new information here
        }
    }
)
// first step is to write an implicit conversion between the two types
implicit def function2ActionListener(f: ActionEvent => Unit) =
    new ActionListener {                                    // one-argument method that takes a function and returns an action listener
        def actionPerformed(event: ActionEvent) = f(event)
    }
// called directly
button.addActionListener(
    function2ActionListener((_: ActionEvent) => println("pressed!"))
)
// Because function2ActionListener is marked as implicit, it can be left out and the compiler will insert it automatically
button.addActionListener(                                   // compiler first tries to compile it as is, but it sees a type error
    (_: ActionEvent) => println("pressed!")                 // Before giving up, it looks for an implicit conversion that can repair the problem. In this case, it finds function2ActionListener. It tries that conversion method, sees that it works, and moves on
)

-Rules for implicits
// if x + y does not type check, then the compiler might change it to convert(x) + y, where convert is some available implicit conversion
// f convert changes x into something that has a + method, then this change might fix a program so that it type checks and runs correctly
-Marking rule: Only definitions marked implicit are available
// implicit keyword is used to mark which declarations the compiler may use as implicit
implicit def intToString(x: Int) = x.toString
-Scope rule: An inserted implicit conversion must be in scope as a single identifier, or be associated with the source or target type of the conversion
//compiler will not insert a conversion of the form someVariable.convert - you would need to import it, which would make it available as a single identifier
object Dollar {                                             // compiler will find such an associated conversion every time it needs to convert from an instance of type Dollar
    implicit def dollarToEuro(x: Dollar): Euro = ...
}
class Dollar { ... }
-One-at-a-time rule: Only one implicit is inserted
// compiler will never rewrite x + y to convert1(convert2(x)) + y.
-Explicits-first rule: Whenever code type checks as it is written, no implicits are attempted
// compiler will not change code that already works
-Naming an implicit conversion
// matters if you want to use it explicitly or import something specific
-Where implicits are tried
// conversions to an expected type, conversions of the receiver of a selection, and implicit parameters

-Implicit conversion to an expected type
// Whenever the compiler sees an X, but needs a Y, it will look for an implicit function that converts X to Y
val i: Int = 3.5                                            // error: type mismatch; found : Double(3.5) required: Int
implicit def doubleToInt(x: Double) = x.toInt
val i: Int = 3.5                                            // i: Int = 3

-Converting the receiver
// suppose you write down obj.doIt, and obj does not have a member named doIt. The compiler will try to insert conversions before giving up
-Interoperating with new types
class Rational(n: Int, d: Int) {
...
    def + (that: Rational): Rational = ...
    def + (that: Int): Rational = ...
}
val oneHalf = new Rational(1, 2)
1 + oneHalf                                                 // error: overloaded method value + with
implicit def intToRational(x: Int) = new Rational(x, 1)     // implicit conversion from Int to Rational
1 + oneHalf                                                 // res2: Rational = 3/2

-Simulating new syntax
Map(1 -> "one", 2 -> "two", 3 -> "three")
package scala
object Predef {
    class ArrowAssoc[A](x: A) {                             // implicit conversion from Any to ArrowAssoc
        def ->[B](y: B): Tuple2[A, B] = Tuple2(x, y)        // When you write 1 -> "one", the compiler inserts a conversion from 1 to ArrowAssoc so that the -> method can be found.
    }
    implicit def any2ArrowAssoc[A](x: A): ArrowAssoc[A] =
        new ArrowAssoc(x)
    ...
}

-Implicit classes
// for implicit class -compiler generates an implicit conversion from the class’s constructor parameter to the class itself
case class Rectangle(width: Int, height: Int)
implicit class RectangleMaker(width: Int) {
    def x(height: Int) = Rectangle(width, height)
}
// Automatically generated
implicit def RectangleMaker(width: Int) =
    new RectangleMaker(width)
// can create points by putting an x in between two integers
val myRectangle = 3 x 4                                     // myRectangle: Rectangle = Rectangle(3,4)

-Implicit parameters
// compiler will sometimes replace someCall(a) with someCall(a)(b), or new SomeClass(a) with new SomeClass(a)(b),
class PreferredPrompt(val preference: String)
object Greeter {
    def greet(name: String)(implicit prompt: PreferredPrompt) = {   // last parameter list is marked implicit
        println("Welcome, " + name + ". The system is ready.")
        println(prompt.preference)
    }
}
val bobsPrompt = new PreferredPrompt("relax> ")                     // But you can still provide the prompt explicitly, like this
Greeter.greet("Bob")(bobsPrompt)
object JoesPrefs {
    implicit val prompt = new PreferredPrompt("Yes, master> ")      // let the compiler supply the parameter implicitly, you must first define a variable of the expected type, which in this case is PreferredPrompt
}
import JoesPrefs._

def maxListImpParm[T](elements: List[T])(implicit ordering: Ordering[T]): T =
    elements match {
        case List() => throw new IllegalArgumentException("empty list!")
        case List(x) => x
        case x :: rest =>
        val maxRest = maxListImpParm(rest)(ordering)
        if (ordering.gt(x, maxRest)) x
        else maxRest
    }
// standard Scala library provides implicit "ordering" methods for many common types
maxListImpParm(List(1,5,10,3))                                      // res9: Int = 10
maxListImpParm(List("one", "two", "three"))                         // res11: String = two

-Context bounds
def maxListImpParm[T](elements: List[T])(implicit ordering: Ordering[T]): T =
    elements match {
        case List() => throw new IllegalArgumentException("empty list!")
        case List(x) => x
        case x :: rest =>
        val maxRest = maxListImpParm(rest)                          // (ordering) is implicit
        if (ordering.gt(x, maxRest)) x                              // this ordering is still explicit
        else maxRest
    }
def implicitly[T](implicit t: T) = t
// effect of calling implicitly[Foo] is that the compiler will look for an implicit definition of type Foo. It will then call the implicitly method with that object, which in turn returns the object right back
def maxListImpParm[T](elements: List[T])(implicit ordering: Ordering[T]): T =
    elements match {
        case List() => throw new IllegalArgumentException("empty list!")
        case List(x) => x
        case x :: rest =>
        val maxRest = maxListImpParm(rest)
        if (implicitly[Ordering[T]].gt(x, maxRest)) x
        else maxRest
    }

-When multiple conversions apply
// If one of the available conversions is strictly more specific than the others, then the compiler will choose the more specific one
def printLength(seq: Seq[Int]) = println(seq.length)
implicit def intToRange(i: Int) = 1 to i                            // intToRange: (i: Int)scala.collection.immutable.Range.Inclusive
implicit def intToDigits(i: Int) =i.toString.toList.map(_.toInt)    // intToDigits: (i: Int)List[Int]

-Debugging implicits
// it helps to write the wrapString conversion explicitly to find out what went wrong
// If you are brave, try scala Xprint: typer to get an interactive shell that prints out the post-typing source code it uses internally


###############
# Implementing Lists
###############
-The List class in principle
// abstract class List - comes with two subclasses for :: and Nil
//            List[+T]                  // lists are covariant [+T] can assign a value of type List[Int] to a variable of type List[Any]
//        «sealed abstract»
//    ::[T]               Nil
//«final case»        «case object»                
val xs = List(1, 2, 3)
var ys: List[Any] = xs
// All list operations can be defined in terms of three basic methods: 
def isEmpty: Boolean                    // defined in the subobject Nil and the subclass ::.
def head: T
def tail: List[T]

-The Nil object
// Nil object inherits from type List[Nothing] because of covariance, this means that Nil is compatible with every instance of the List type
case object Nil extends List[Nothing] {
    override def isEmpty = true
    def head: Nothing = throw new NoSuchElementException("head of empty list")
    def tail: List[Nothing] = throw new NoSuchElementException("tail of empty list")
}

-The :: class (pronounced "cons" for "construct")
// x :: xs is treated as ::(x, xs) where :: is a case class
final case class ::[T](hd: T, tl: List[T]) extends List[T] {
    def head = hd
    def tail = tl
    override def isEmpty: Boolean = false
}

-Some more methods
//
def length: Int =
    if (isEmpty) 0 else 1 + tail.length
//or:
def drop(n: Int): List[T] =
    if (isEmpty) Nil
    else if (n <= 0) this
    else tail.drop(n-1)
//or:
def map[U](f: T => U): List[U] =
    if (isEmpty) Nil
    else f(head) :: tail.map(f)

-List construction
// methods :: and ::: - end in a colon so they bound to the right operand
// x :: xs is treated as the method call xs.::(x), not x.::(xs).
abstract class Fruit
class Apple extends Fruit
class Orange extends Fruit
val apples = new Apple :: Nil               // apples: List[Apple] = List(Apple@e885c6a)
val fruits = new Orange :: apples           // fruits: List[Fruit] = List(Orange@3f51b349, Apple@e885c6a)
def ::[U >: T](x: U): List[U] = new scala.::(x, this)       // U is constrained in [U >: T] to be a supertype of the list elem T    

-The ListBuffer class
// typical access pattern for a list is recursive
def incAll(xs: List[Int]): List[Int] = xs match {
    case List() => List()
    case x :: xs1 => x + 1 :: incAll(xs1)   // not tail recursive (recursive call to incAll above occurs inside a :: operation)
}                                           // Therefore each recursive call requires a new stack frame
// cannot apply incAll to lists of much more than about 30,000 to 50,000 elements
// A very inefficient possibility is to use :::, the list append operator
var result = List[Int]()                        // a very inefficient approach
for (x <- xs) result = result ::: List(x + 1)   // Because ::: takes time proportional to the length of its first operand, the whole operation takes time proportional to the square of the length of the list
result
// List buffers let you accumulate the elements of a list. To do this, you use an operation such as “buf += elem”,which appends the element elem at the end of the list buffer buf
import scala.collection.mutable.ListBuffer
val buf = new ListBuffer[Int]
for (x <- xs) buf += x + 1
buf.toList

-The List class in practice
// most methods in the real implementation of class List avoid recursion and use loops with list buffers instead
final override def map[U](f: T => U): List[U] = {
    val b = new ListBuffer[U]
    var these = this
    while (!these.isEmpty) {
        b += f(these.head)
        these = these.tail
    }
    b.toList
}
// The definition of the :: subclass of List.
final case class ::[U](hd: U, private[scala] var tl: List[U]) extends List[U] {
    def head = hd
    def tail = tl
    override def isEmpty: Boolean = false
}

-Functional on the outside
// lists are purely functional on the “outside” but have an imperative implementation using list buffers on the “inside.”
val ys = 1 :: xs        // e tails of lists ys and zs are shared; they point to the same data structure.
val zs = 2 :: xs
// Scala’s List and ListBuffer is quite similar to what’s done in Java’s pair of classes String and StringBuffer


###############
# For Expressions Revisited
###############
case class Person(name: String,isMale: Boolean, children: Person*)
val lara = Person("Lara", false)
val bob = Person("Bob", true)
val julie = Person("Julie", false, lara, bob)
val persons = List(lara, bob, julie)
//  say you want to find out the names of all pairs of mothers and their children in that list
persons filter (p => !p.isMale) flatMap (p =>(p.children map (c => (p.name, c.name))))      // res0: List[(String, String)] = List((Julie,Lara), (Julie,Bob)) 
//  Is there a simpler way?
for (p <- persons; if !p.isMale; c <- p.children)
    yield (p.name, c.name)              // res2: List[(String, String)] = List((Julie,Lara), (Julie,Bob))

-For expressions
for ( seq ) yield expr                  // seq is a sequence of generators, definitions, and filters, with semicolons between successive elements.
for (p <- persons; n = p.name; if (n startsWith "To"))      // one generator, one definition, and one filter
yield n
// or
for {
    p <- persons            // a generator
    n = p.name              // a definition
    if (n startsWith "To")  // a filter - filter drops from the iteration all elements for which expr returns false
} yield n
// several generators
for (x <- List(1, 2); y <- List("one", "two"))
yield (x, y)                // res3: List[(Int, String)] = List((1,one), (1,two), (2,one), (2,two))

-The n-queens problem
// Given a standard chess-board, place eight queens such that no queen is in check from any other
// you need to place a queen in each row each time checking that a newly placed queen is not in check from any other queens
// solution can be presented by a list of length k of coordinates (row, column)
def queens(n: Int): List[List[(Int, Int)]] = {
    def placeQueens(k: Int): List[List[(Int, Int)]] =
        if (k == 0)
            List(List())
        else
            for {
                queens <-placeQueens(k-1)
                column <-1 to n
                queen = (k, column)
                if isSafe(queen, queens)
            } yield queen :: queens
    placeQueens(n)
}
def isSafe(queen: (Int, Int), queens: List[(Int, Int)]) =
    queens forall (q => !inCheck(queen, q))
def inCheck(q1: (Int, Int), q2: (Int, Int)) =
    q1._1 == q2._1 ||               // same row
    q1._2 == q2._2 ||               // same column
    (q1._1 q2._
    1).abs == (q1._2 q2._2).abs     // on diagonal

-Querying with for expressions
// case class Book(title: String, authors: String*)
val books: List[Book] =
    List(
        Book(
            "Structure and Interpretation of Computer Programs",
            "Abelson, Harold", "Sussman, Gerald J."
        ),
        Book(
            "Principles of Compiler Design",
            "Aho, Alfred", "Ullman, Jeffrey"
        ),
        Book(
            "Programming in Modula2",
            "Wirth, Niklaus"
        ),
        Book(
            "Elements of ML Programming",
            "Ullman, Jeffrey"
        ),
        Book(
            "The Java Language Specification", "Gosling, James",
            "Joy, Bill", "Steele, Guy", "Bracha, Gilad"
        )
    )
// find the titles of all books whose author’s last name is "Gosling"
for (b <-books;a <-b.authors; if a startsWith "Gosling")
    yield b.title                   // res4: List[String] = List(The Java Language Specification)
// find the titles of all books that have the string “Program” in their title
for (b <-books; if (b.title indexOf "Program") >= 0)
    yield b.title                   // res5: List[String] = List(Structure and Interpretation of Computer Programs, Programming in Modula2, Elements of ML Programming)
// find the names of all authors who have written at least two books in the database:
for (b1 <-books; b2 <-books; if b1 != b2; a1 <-b1.authors; a2 <b2.authors if a1 == a2)
    yield a1                        // res6: List[String] = List(Ullman, Jeffrey, Ullman, Jeffrey)
def removeDuplicates[A](xs: List[A]): List[A] = {
    if (xs.isEmpty) xs
    else
        xs.head :: removeDuplicates(xs.tail filter (x => x != xs.head))
}
xs.head :: removeDuplicates(
    for (x <-xs.tail if x != xs.head) yield x
)

-Translation of for expressions
-Translating for expressions with one generator
for (x <-expr1) yield expr2                     // expr1.map(x => expr2)
-Translating for expressions starting with a generator and a filter
for (x <-expr1; if expr2) yield expr3           // for (x <-expr1 withFilter (x => expr2)) yield expr3  --> expr1 withFilter (x => expr2) map (x => expr3)
-Translating for expressions starting with two generators
for (x <-expr1; y <-expr2; seq) yield expr3     // expr1.flatMap(x => for (y <-expr2; seq) yield expr3)
for (b1 <-books; b2 <-books if b1 != b2; a1 <-b1.authors; a2 <-b2.authors if a1 == a2)
    yield a1
books flatMap (b1 =>
    books withFilter (b2 => b1 != b2) flatMap (b2 =>
        b1.authors flatMap (a1 =>
            b2.authors withFilter (a2 => a1 == a2) map (a2 =>
                a1))))

-Going the other way
object Demo {
    def map[A, B](xs: List[A], f: A => B): List[B] =
        for (x <-xs) yield f(x)
    def flatMap[A, B](xs: List[A], f: A => List[B]): List[B] =
        for (x <-xs; y <-f(x)) yield y
    def filter[A](xs: List[A], p: A => Boolean): List[A] =
        for (x <-xs if p(x)) yield x
}


###############
# Collections in Depth
###############
-Mutable and immutable collections
// three variants are located in packages scala.collection, scala.collection.immutable, and scala.collection.mutable

-Collections consistency
Traversable(1, 2, 3)
Iterable("x", "y", "z")
Map("x" -> 24, "y" -> 25, "z" -> 26)
Set(Color.Red, Color.Green, Color.Blue)
SortedSet("hello", "world")
Buffer(x, y, z)
IndexedSeq(1.0, 2.0)
LinearSeq(a, b, c)
List(1, 2, 3)
HashMap("x" -> 24, "y" -> 25, "z" -> 26)
//
Traversable
    Iterable
        Seq
            IndexedSeq
                Vector
                ResizableArray
                GenericArray
            LinearSeq
                MutableList
                List
                Stream
            Buffer
                ListBuffer
                ArrayBuffer
        Set
            SortedSet
                TreeSet
            HashSet (mutable)
            LinkedHashSet
            HashSet (immutable)
            BitSet
            EmptySet, Set1, Set2, Set3, Set4
        Map
            SortedMap
                TreeMap
            HashMap (mutable)
            LinkedHashMap (mutable)
            HashMap (immutable)
            EmptyMap, Map1, Map2, Map3, Map4

-Trait Traversable
// ts only abstract operation is foreach
def foreach[U](f: Elem => U)
Abstract method:
xs foreach f Executes function f for every element of xs.
Addition:
    xs ++ ys            // A collection consisting of the elements of both xs and ys. ys is a TraversableOnce collection, i.e., either a Traversable or an Iterator.
Maps:
    xs map f            // The collection obtained from applying the function f to every element in xs.
    xs flatMap f        // The collection obtained from applying the collection-valued function f to every element in xs and concatenating the results.
    xs collect f        // The collection obtained from applying the partial function f to every element in xs for which it is defined and collecting the results.
Conversions:
    xs.toArray          // Converts the collection to an array.
    xs.toList           // Converts the collection to a list.
    xs.toIterable       // Converts the collection to an iterable.
    xs.toSeq            // Converts the collection to a sequence.
    xs.toIndexedSeq     // Converts the collection to an indexed sequence.
    xs.toStream         // Converts the collection to a stream (a lazily computed sequence).
    xs.toSet            // Converts the collection to a set.
    xs.toMap            // Converts a collection of key/value pairs to a map.
Copying:
    xs copyToBuffer buf             // Copies all elements of the collection to buffer buf.
    xs copyToArray(arr, s, len)     // Copies at most len elements of arr, starting at index s. The last two arguments are optional.
Size info:
    xs.isEmpty          // Tests whether the collection is empty.
    xs.nonEmpty         // Tests whether the collection contains elements.
    xs.size             // The number of elements in the collection.
    xs.hasDefiniteSize  // True if xs is known to have finite size.
Element retrieval:
    xs.head             // The first element of the collection (or, some element, if no order is defined).
    xs.headOption       // The first element of xs in an option value, or None if xs is empty.
    xs.last             // The last element of the collection (or, some element, if no order is defined).
    xs.lastOption       // The last element of xs in an option value, or None if xs is empty.
    xs find p           // An option containing the first element in xs that satisfies p, or None if no element qualifies.
Subcollections:
    xs.tail             // The rest of the collection except xs.head.
    xs.init             // The rest of the collection except xs.last.
    xs slice (from, to) // A collection consisting of elements in some index range of xs (from from, up to and excluding to).
    xs take n           // A collection consisting of the first n elements of xs (or, some arbitrary n elements, if no order is defined).
    xs drop n           // The rest of the collection except xs take n.
    xs takeWhile p      // The longest prefix of elements in the collection that all satisfy p.
    xs dropWhile p      // The collection without the longest prefix of elements that all satisfy p
    xs filter p         // The collection consisting of those elements of xs that satisfy the predicate p.
    xs withFilter p     // A non-strict filter of this collection. All operations on the resulting filter will only apply to those elements of xs for which the condition p is true.
    xs filterNot p      // The collection consisting of those elements of xs that do not satisfy the predicate p.
Subdivisions:
    xs splitAt n        // Splits xs at a position, giving the pair of collections (xs take n, xs drop n).
    xs span p           // Splits xs according to a predicate, giving the pair of collections (xs takeWhile p, xs.dropWhile p).
    xs partition p      // Splits xs into a pair of collections; one with elements that satisfy the predicate p, the other with elements that do not, giving the pair of collections (xs filter p, xs.filterNot p).
    xs groupBy f        // Partitions xs into a map of collections according to a discriminator function f.
Element conditions:
    xs forall p         // A boolean indicating whether the predicate p holds for all elements of xs.
    xs exists p         // A boolean indicating whether the predicate p holds for some element in xs.
    xs count p          // The number of elements in xs that satisfy the predicate p.
Folds:
    (z /: xs)(op)       // Applies binary operation op between successive elements of xs, going left to right, starting with z.
    (xs :\ z)(op)       // Applies binary operation op between successive elements of xs, going right to left, starting with z.
    xs.foldLeft(z)(op)  // Same as (z /: xs)(op).
    xs.foldRight(z)(op) // Same as (xs :\ z)(op).
    xs reduceLeft op    // Applies binary operation op between successive elements of non-empty collection xs, going left to right.
    xs reduceRight op   // Applies binary operation op between successive elements of non-empty collection xs, going right to left.
Specific folds:
    xs.sum              // The sum of the numeric element values of collection xs.
    xs.product          // The product of the numeric element values of collection xs.
    xs.min              // The minimum of the ordered element values of collection xs.
    xs.max              // The maximum of the ordered element values of collection xs.
Strings:
    xs addString (b, start, sep, end)   // Adds a string to StringBuilder b that shows all elements of xs between separators sep enclosed in strings start and end. start, sep, and end are all optional.
    xs mkString (start, sep, end)       // Converts the collection to a string that shows all elements of xs between separators sep enclosed in strings start and end. start, sep, and end are all optional.
    xs.stringPrefix                     // The collection name at the beginning of the string returned from xs.toString.
Views:
    xs.view             // Produces a view over xs.
    xs view (from, to)  // Produces a view that represents the elements in some index range of xs

-Trait Iterable
def foreach[U](f: Elem => U): Unit = {
    val it = iterator
    while (it.hasNext) f(it.next())
}
val xs = List(1, 2, 3, 4, 5)                    // xs: List[Int] = List(1, 2, 3, 4, 5)
val git = xs grouped 3                          // git: Iterator[List[Int]] = non-empty iterator
git.next()                                      // res2: List[Int] = List(1, 2, 3)
git.next()                                      // res3: List[Int] = List(4, 5)
val sit = xs sliding 3                          // sit: Iterator[List[Int]] = non-empty iterator
sit.next()                                      // res4: List[Int] = List(1, 2, 3)
sit.next()                                      // res5: List[Int] = List(2, 3, 4)
sit.next()                                      // res6: List[Int] = List(3, 4, 5)
Abstract method:
    xs.iterator             // An iterator that yields every element in xs, in the same order as foreach traverses elements
Other iterators:
    xs grouped size         // An iterator that yields fixed-sized “chunks” of this collection
    xs sliding size         // An iterator that yields a sliding fixed-sized window of elements in this collection
Subcollections:
    xs takeRight n          // A collection consisting of the last n elements of xs (or, some arbitrary n elements, if no order is defined)
    xs dropRight n          // The rest of the collection except xs takeRight n
Zippers:
    xs zip ys               // An iterable of pairs of corresponding elements from xs and ys
    xs zipAll (ys, x, y)    // An iterable of pairs of corresponding elements from xs and ys, where the shorter sequence is extended to match the longer one by appending elements x or y
    xs.zipWithIndex         // An iterable of pairs of elements from xs with their indicies
Comparison:
    xs sameElements ys      // Tests whether xs and ys contain the same elements in the same order

-Why have both Traversable and Iterable?
// to implement foreach for iterable is harder then for  traversable
sealed abstract class Tree extends Traversable[Int] {
    def foreach[U](f: Int => U) = this match {
    case Node(elem) => f(elem)
    case Branch(l, r) => l foreach f; r foreach f
    }
}

-The sequence traits Seq, IndexedSeq, and LinearSeq
//sequence is a kind of iterable that has a length and whose elements have fixed index positions, starting from 0
Indexing and length:
    xs(i)               // (or, written out, xs apply i) The element of xs at index i.
    xs isDefinedAt i    // Tests whether i is contained in xs.indices.
    xs.length           // The length of the sequence (same as size).
    xs.lengthCompare ys // Returns -1 if xs is shorter than ys, +1 if it is longer, and 0 is they have the same length. Works even if one of the sequences is infinite.
    xs.indices          // The index range of xs, extending from 0 to xs.length - 1.
Index search:
    xs indexOf x        // The index of the first element in xs equal to x (several variants exist).
    xs lastIndexOf x    // The index of the last element in xs equal to x (several variants exist).
    xs indexOfSlice ys  // The first index of xs such that successive elements starting from that index form the sequence ys.
    xs lastIndexOfSlice ys  // The last index of xs such that successive elements starting from that index form the sequence ys.
    xs indexWhere p     // The index of the first element in xs that satisfies p (several variants exist).
    xs segmentLength (p, i) // The length of the longest uninterrupted segment of elements in xs, starting with xs(i), that all satisfy the predicate p.
    xs prefixLength p   // The length of the longest prefix of elements in xs that all satisfy the predicate p.
Additions:
    x +: xs             // A new sequence consisting of x prepended to xs.
    xs :+ x             // A new sequence that consists of x append to xs.
    xs padTo (len, x)   // The sequence resulting from appending the value x to xs until length len is reached.
Updates:
    xs patch (i, ys, r) // The sequence resulting from replacing r elements of xs starting with i by the patch ys.
    xs updated (i, x)   // A copy of xs with the element at index i replaced by x.
    xs(i) = x           // (or, written out, xs.update(i, x), only available for mutable.Seqs) Changes the element of xs at index i to y.
Sorting:
    xs.sorted           // A new sequence obtained by sorting the elements of xs using the standard ordering of the element type of xs.
    xs sortWith lessThan    // A new sequence obtained by sorting the elements of xs, using lessThan as comparison operation.
    xs sortBy f         // A new sequence obtained by sorting the elements of xs. Comparison between two elements proceeds by mapping the function f over both and comparing the results.
Reversals:
    xs.reverse          // A sequence with the elements of xs in reverse order.
    xs.reverseIterator  // An iterator yielding all the elements of xs in reverse order.
    xs reverseMap f     // A sequence obtained by mapping f over the elements of xs in reverse order.
Comparisons:
    xs startsWith ys    // Tests whether xs starts with sequence ys (several variants exist).
    xs endsWith ys      // Tests whether xs ends with sequence ys (several variants exist).
    xs contains x       // Tests whether xs has an element equal to x.
    xs containsSlice ys // Tests whether xs has a contiguous subsequence equal to ys. (xs corresponds ys)(p) Tests whether corresponding elements of xs and ys satisfy the binary predicate p.
Multiset operations:
    xs intersect ys     // The multi-set intersection of sequences xs and ys that preserves the order of elements in xs.
    xs diff ys          // The multi-set difference of sequences xs and ys that preserves the order of elements in xs.
    xs union ys         // Multiset union; same as xs ++ ys.
    xs.distinct         // A subsequence of xs that contains no duplicated element.

-Buffers
// allow not only updates of existing elements but also element insertions, element removals, and efficient additions of new elements at the end of the buffer
Additions:
    buf += x                //Appends element x to buffer buf, and returns buf itself as result
    buf += (x, y, z)        //Appends given elements to buffer
    buf ++= xs              //Appends all elements in xs to buffer
    x +=: buf               //Prepends element x to buffer
    xs ++=: buf             //Prepends all elements in xs to buffer
    buf insert (i, x)       //Inserts element x at index i in buffer
    buf insertAll (i, xs)   //Inserts all elements in xs at index i in buffer
Removals:
    buf -= x                // Removes element x from buffer
    buf remove i            // Removes element at index i from buffer
    buf remove (i, n)       // Removes n elements starting at index i from buffer
    buf trimStart n         // Removes first n elements from buffer
    buf trimEnd n           // Removes last n elements from buffer
    buf.clear()             // Removes all elements from buffer
Cloning:
    buf.clone               // A new buffer with the same elements as buf

-Sets
// Iterables that contain no duplicate elements
Tests:
    xs contains x           // Tests whether x is an element of xs 
    xs(x)                   // Same as xs contains x
    xs subsetOf ys          // Tests whether xs is a subset of ys
Additions:
    xs + x                  // The set containing all elements of xs as well as x
    xs + (x, y, z)          // The set containing all elements of xs as well as the given additional elements
    xs ++ ys                // The set containing all elements of xs as well as all elements of ys
Removals:
    xs - x                  // The set containing all elements of xs except x
    xs - (x, y, z)          // The set containing all elements of xs except the given elements
    xs -- ys                // The set containing all elements of xs except the elements of ys
    xs.empty                // An empty set of the same class as xs
Binary operations:
    xs & ys                 // The set intersection of xs and ys
    xs intersect ys         // Same as xs & ys
    xs | ys                 // The set union of xs and ys
    xs union ys             // Same as xs | ys
    xs &~ ys                // The set difference of xs and ys
    xs diff ys              // Same as xs &~ ys

// Mutable sets:
Additions:
    xs += x             // Adds element x to set xs as a side effect and returns xs itself
    xs += (x, y, z)     // Adds the given elements to set xs as a side effect and returns xs itself
    xs ++= ys           // Adds all elements in ys to set xs as a side effect and returns xs itself
    xs add x            // Adds element x to xs and returns true if x was not previously contained in the set, false if it was previously contained
Removals:
    xs -= x             // Removes element x from set xs as a side effect and returns xs itself
    xs -= (x, y, z)     // Removes the given elements from set xs as a side effect and returns xs itself
    xs --= ys           // Removes all elements in ys from set xs as a side effect and returns xs itself
    xs remove x         // Removes element x from xs and returns true if x was previously contained in the set, false if it was not previously contained
    xs retain p         // Keeps only those elements in xs that satisfy
predicate p
    xs.clear()          // Removes all elements from xs
Update:
    xs(x) = b           // (or, written out, xs.update(x, b)) If boolean argument b is true, adds x to xs, otherwise removes x from xs
Cloning:
    xs.clone            // A new mutable set with the same elements as xs
// example
var s = Set(1, 2, 3)    // s: scala.collection.immutable.Set[Int] = Set(1, 2, 3)
s += 4; s -= 2          // we used += and -= on a var of type immutable.Set. s += 4 is an abbreviation for s = s + 4. So this invokes the addition method + on the set s and then assigns the result back to the s variable
s                       // res10: scala.collection.immutable.Set[Int] = Set(1, 3, 4)
// mutable
val s = collection.mutable.Set(1, 2, 3)     // s: scala.collection.mutable.Set[Int] = Set(1, 2, 3)
s += 4                  // res11: s.type = Set(1, 2, 3, 4)
s -= 2                  // res12: s.type = Set(1, 3, 4)

-Maps
// Iterables of pairs of keys and values
Map("x" -> 24, "y" -> 25, "z" -> 26)        // exactly the same as Map(("x", 24), ("y", 25), ("z", 26))
Lookups:
    ms get k            // The value associated with key k in map ms as an option, or None if not found
    ms(k)               // (or, written out, ms apply k) The value associated with key k in map ms, or a thrown exception if not found
    ms getOrElse (k, d) // The value associated with key k in map ms, or the default value d if not found
    ms contains k       // Tests whether ms contains a mapping for key k
    ms isDefinedAt k    // Same as contains
Additions and updates:
    ms + (k -> v)           // The map containing all mappings of ms as well as the mapping k -> v from key k to value v
    ms + (k -> v, l -> w)   // The map containing all mappings of ms as well as
the given key/value pairs
    ms ++ kvs           // The map containing all mappings of ms as well as all key/value pairs of kvs
    ms updated (k, v)   // Same as ms + (k -> v)
Removals:
    ms - k              // The map containing all mappings of ms except for any mapping of key k
    ms - (k, l, m)      // The map containing all mappings of ms except for any mapping with the given keys
    ms -- ks            // The map containing all mappings of ms except for any mapping with a key in ks
Subcollections:
    ms.keys             // An iterable containing each key in ms
    ms.keySet           // A set containing each key in ms
    ms.keysIterator     // An iterator yielding each key in ms
    ms.values           // An iterable containing each value associated with a key in ms
    ms.valuesIterator   // An iterator yielding each value associated with a key in ms
Transformation:
    ms filterKeys p     // A map view containing only those mappings in ms where the key satisfies predicate p
    ms mapValues f      // A map view resulting from applying function f to each value associated with a key in ms
// mutable
Additions and updates:
    ms(k) = v           // (or, written out, ms.update(k, v)) Adds mapping from key k to value v to map ms as a side effect, overwriting any previous mapping of k
    ms += (k -> v)      // Adds mapping from key k to value v to map ms as a side effect and returns ms itself
    ms += (k -> v, l -> w)  // Adds the given mappings to ms as a side effect and returns ms itself
    ms ++= kvs          // Adds all mappings in kvs to ms as a side effect and returns ms itself
    ms put (k, v)       // Adds mapping from key k to value v to ms and returns any value previously associated with k as an option
    ms getOrElseUpdate (k, d)   // If key k is defined in map ms, returns its associated value. Otherwise, updates ms with the mapping k -> d and returns d
Removals:
    ms -= k             // Removes mapping with key k from ms as a side effect and returns ms itself
    ms -= (k, l, m)     // Removes mappings with the given keys from ms as a side effect and returns ms itself
    ms --= ks           // Removes all keys in ks from ms as a side effect and returns ms itself
    ms remove k         // Removes any mapping with key k from ms and returns any value previously associated with k as an option
    ms retain p         // Keeps only those mappings in ms that have a key satisfying predicate p.
    ms.clear()          // Removes all mappings from ms
Transformation and cloning:
    ms transform f      // Transforms all associated values in map ms with function f
    ms.clone            //Returns a new mutable map with the same mappings as ms
// getOrElseUpdate is useful for accessing maps that act as caches.
val cache = collection.mutable.Map[String, String]()
def cachedF(s: String) = cache.getOrElseUpdate(s, f(s))
cachedF("abc")          // taking my time.  res16: String = cba
cachedF("abc")          // res17: String = cba
def cachedF(arg: String) = cache get arg match {
    case Some(result) => result
    case None =>
        val result = f(arg)
        cache(arg) = result
        result
}

-Concrete immutable collection classes
-Lists
//constant-time access to first element, rest of the list, cons operation for adding a new element to the front of the list

-Streams
// like a list except that its elements are computed lazily, Otherwise, streams have the same performance characteristics as lists
val str = 1 #:: 2 #:: 3 #:: Stream.empty        // str: scala.collection.immutable.Stream[Int] = Stream(1, ?)
def fibFrom(a: Int, b: Int): Stream[Int] =      // without #:: every call to the function would result in another call
    a #:: fibFrom(b, a + b)                     // fibFrom: (a: Int, b: Int)Stream[Int]
val fibs = fibFrom(1, 1).take(7)                // fibs: scala.collection.immutable.Stream[Int] = Stream(1, ?)
fibs.toList                                     // res23: List[Int] = List(1, 1, 2, 3, 5, 8, 13)

-Vectors
// efficient access to elements beyond the head
val vec = scala.collection.immutable.Vector.empty
val vec2 = vec :+ 1 :+ 2                        // vec2: scala.collection.immutable.Vector[Int] = Vector(1, 2)
val vec3 = 100 +: vec2                          // vec3: scala.collection.immutable.Vector[Int] = Vector(100, 1, 2)
vec3(0)                                         // res24: Int = 100
// Every tree node contains up to 32 elements of the vector or contains up to 32 other tree nodes
// ectors are immutable, so you cannot change an element of a vector in place, you can create a new vector that differs from a given vector only in a single element
val vec = Vector(1, 2, 3)
vec updated (2, 4)                              // res25: scala.collection.immutable.Vector[Int] = Vector(1, 2, 4)
vec                                             // res26: scala.collection.immutable.Vector[Int] = Vector(1, 2, 3)
// Updating an element in the middle of a vector can be done by copying the node that contains the element, and every node that points to it,
// starting from the root of the tree. This means that a functional update creates between one and five nodes that each contain up to 32 elements or subtrees.
// This is certainly more expensive than an in-place update in a mutable array, but still a lot cheaper than copying the whole vector.
// they are currently the default implementation of immutable indexed sequences
collection.immutable.IndexedSeq(1, 2, 3)        // res27: scala.collection.immutable.IndexedSeq[Int] = Vector(1, 2, 3)

-Immutable stacks
// push an element onto a stack with push, pop an element with pop
val stack = scala.collection.immutable.Stack.empty
val hasOne = stack.push(1)                      // hasOne: scala.collection.immutable.Stack[Int] = Stack(1)
stack                                           // res28: scala.collection.immutable.Stack[Nothing] = Stack()
hasOne.top                                      // res29: Int = 1
hasOne.pop                                      // res30: scala.collection.immutable.Stack[Int] = Stack()
// rarely in Scala programs because their functionality is subsumed by lists

-Immutable queues
val empty = scala.collection.immutable.Queue[Int]()
val has1 = empty.enqueue(1)                     // has1: scala.collection.immutable.Queue[Int] = Queue(1)
val has123 = has1.enqueue(List(2, 3))           // has123: scala.collection.immutable.Queue[Int] = Queue(1, 2, 3)
val (element, has23) = has123.dequeue           // element: Int = 1; has23: scala.collection.immutable.Queue[Int] = Queue(2, 3)

-Ranges
1 to 3                                          // res31: scala.collection.immutable.Range.Inclusive = Range(1, 2, 3)
5 to 14 by 3                                    // res32: scala.collection.immutable.Range = Range(5, 8, 11, 14)
1 until 3                                       // res33: scala.collection.immutable.Range = Range(1, 2)

-Hash tries
// standard way to implement immutable sets and maps efficiently
// trees where every node has 32 elements or 32 subtrees, but selection is done based on a hash code.
// to find a given key in a map, you use the lowest five bits of the hash code of the key to select the first subtree, the next five bits the next subtree, and so on

-Red-black trees
// balanced binary trees where some nodes are designated “red” and others “black.” standard implementation of SortedSet in Scala
val set = collection.immutable.TreeSet.empty[Int]   // set: scala.collection.immutable.TreeSet[Int] = TreeSet()
set + 1 + 3 + 3                                     // res34: scala.collection.immutable.TreeSet[Int] = TreeSet(1, 3)

-Immutable bit sets
// bit set containing 3, 2, and 0 would be represented as the integer 1101 in binary, which is 13 in decimal
val bits = scala.collection.immutable.BitSet.empty
val moreBits = bits + 3 + 4 + 4                     // moreBits: scala.collection.immutable.BitSet = BitSet(3, 4)
moreBits(3)                                         // res35: Boolean = true
moreBits(0)                                         //res36: Boolean = false

-List maps
val map = collection.immutable.ListMap( 1 -> "one", 2 -> "two")     // 
map(2)                                              // res37: String = "two"

-Concrete mutable collection classes
-Array buffers
// holds an array and a size, can have data efficiently added to the end, Appending an item to an array buffer takes amortized constant time
// good whenever the new items are always added to the end
// useful for building arrays
val buf = collection.mutable.ArrayBuffer.empty[Int]
buf += 1                                        // res38: buf.type = ArrayBuffer(1)
buf += 10                                       // res39: buf.type = ArrayBuffer(1, 10)
buf.toArray                                     // res40: Array[Int] = Array(1, 10)
-List buffers
// like an array buffer except that it uses a linked list internally instead of an array
// if need to convert the buffer to a list once it is built up, use a list buffer instead of an array buffer
// useful for building lists
val buf = collection.mutable.ListBuffer.empty[Int]
buf += 1                                        // res41: buf.type = ListBuffer(1)
buf += 10                                       // res42: buf.type = ListBuffer(1, 10)
buf.toList                                      // res43: List[Int] = List(1, 10)
-String builders
// useful for building strings
val buf = new StringBuilder
buf += 'a'                                      // res44: buf.type = a
buf ++= "bcdef"                                 // res45: buf.type = abcdef
buf.toString                                    // res46: String = abcdef
-Linked lists
// LinkedList.empty.isEmpty
// best operated on sequentially. In addition, linked lists make it easy to insert an element or linked list into another linked list
-Double linked lists
// DoubleLinkedLists
// main benefit of that additional link is that it makes element removal very fast
-Mutable lists
// MutableList
// list append a constant time operation because it avoids having to traverse the list in search for its terminal node
// MutableList is currently the standard implementation of mutable.LinearSeq in Scala
-Queues
val queue = new scala.collection.mutable.Queue[String]
queue += "a"                                    // res47: queue.type = Queue(a)
queue ++= List("b", "c")                        // res48: queue.type = Queue(a, b, c)
queue                                           // res49: scala.collection.mutable.Queue[String] = Queue(a, b, c)
queue.dequeue                                   // res50: String = a
queue                                           // res51: scala.collection.mutable.Queue[String] = Queue(b, c)
-Array sequences
// ArraySeq
// if you want an array for its performance characteristics, but you also want to create generic instances of the sequence where you do not know the type of the elements and do not have a ClassTag to provide it at run-time
-Stacks
val stack = new scala.collection.mutable.Stack[Int]
stack.push(1)                                   // res52: stack.type = Stack(1)
stack                                           // res53: scala.collection.mutable.Stack[Int] = Stack(1)
stack.push(2)                                   // res54: stack.type = Stack(2, 1)
stack                                           // res55: scala.collection.mutable.Stack[Int] = Stack(2, 1)
stack.top                                       // res56: Int = 2
stack                                           // res57: scala.collection.mutable.Stack[Int] = Stack(2, 1)
stack.pop                                       // res58: Int = 2
stack                                           // res59: scala.collection.mutable.Stack[Int] = Stack(1)
-Array stacks
// gets resized as needed
// fast indexing and is generally slightly more efficient for most operations than a normal mutable stack
-Hash tables
// stores its elements in an underlying array
// To get a guaranteed iteration order, use a linked hash map or set instead of a regular one
val map = collection.mutable.HashMap.empty[Int,String]
map += (1 -> "make a web site")                 // res60: map.type = Map(1 > make a web site)
map += (3 -> "profit!")                         // res61: map.type = Map(1 -> make a web site, 3 -> profit!)
map(1)                                          // res62: String = make a web site
map contains 2                                  // res63: Boolean = false
-Weak hash maps
// key and its associated value will disappear from the map if there is no other reference to that key
// As soon as a key object becomes unreachable, it’s entry is removed from the weak hash map
-Concurrent Maps
// can be accessed by several threads at once
-Mutable bit sets
// more efficient at updating than immutable ones, because they don’t have to copy around Longs that haven’t changed.
val bits = scala.collection.mutable.BitSet.empty
bits += 1                                       // res64: bits.type = BitSet(1)
bits += 3                                       // res65: bits.type = BitSet(1, 3)
bits                                            // res66: scala.collection.mutable.BitSet = BitSet(1, 3)

-Arrays
// Scala array Array[Int] is represented as a Java int[]
// compatible with Scala sequences—you can pass an Array[T] where a Seq[T] (thanks to implicit conversions)
val a1 = Array(1, 2, 3)                         // a1: Array[Int] = Array(1, 2, 3)
val a2 = a1 map (_ * 3)                         // a2: Array[Int] = Array(3, 6, 9)
val a3 = a2 filter (_ % 2 != 0)                 // a3: Array[Int] = Array(3, 9)
a3.reverse                                      // res1: Array[Int] = Array(9, 3)
// whenever an array would be used as a Seq, implicitly wrap it in a subclass of Seq. The name of that subclass is scala.collection.mutable.WrappedArray
val seq: Seq[Int] = a1                          // seq: Seq[Int] = WrappedArray(1, 2, 3)
val a4: Array[Int] = seq.toArray                // a4: Array[Int] = Array(1, 2, 3)
a1 eq a4                                        // res2: Boolean = true

-Strings
// operations are supported by two implicit conversions (conversion maps a String to a WrappedString, which is a subclass of immutable.IndexedSeq)
val str = "hello"                               
str.reverse                                     // res6: String = olleh
str.map(_.toUpper)                              // res7: String = HELLO
str drop 3                                      // res8: String = lo
str slice (1, 4)                                // res9: String = ell
val s: Seq[Char] = str                          // s: Seq[Char] = WrappedString(h, e, l, l, o)

-Performance characteristics
// Performance characteristics of sequence types
                head    tail    apply   update  prepend     append  insert
immutable   
    List        C       C       L       L       C           L       -
    Stream      C       C       L       L       C           L       -
    Vector      eC      eC      eC      eC      eC          eC      -
    Stack       C       C       L       L       C           L       -
    Queue       aC      aC      L       L       L           C       -
    Range       C       C       C       -       -           -       -
    String      C       L       C       L       L           L       -
mutable
    ArrayBuffer C       L       C       C       L           aC      L
    ListBuffer  C       L       L       L       C           C       L
    StringBldr  C       L       C       C       L           aC      L
    MutableList C       L       L       L       C           C       L
    Queue       C       L       L       L       C           C       L
    ArraySeq    C       L       C       C       -           -       -
    Stack       C       L       L       L       C           L       L
    ArrayStack  C       L       C       C       aC          L       L
    Array       C       L       C       C       -           -       -
// Performance characteristics of set and map types
                    lookup  add     remove  min
immutable
    HashSet/HashMap eC      eC      eC      L
    TreeSet/TreeMap Log     Log     Log     Log
    BitSet          C       L       L       eCa
    ListMap         L       L       L       L
mutable
    HashSet/HashMap eC      eC      eC      L
    WeakHashMap     eC      eC      eC      L
    BitSet          C       aC      C       eCa

-Equality































