###############
# Classes and Objects
###############
class ChecksumAccumulator {
    private var sum = 0
    def add(b: Byte): Unit = { sum += b }
    def checksum(): Int = ~(sum & 0xFF) + 1
}

-Singleton objects
import scala.collection.mutable
object ChecksumAccumulator {
    private val cache = mutable.Map.empty[String, Int]
    def calculate(s: String): Int =
        if (cache.contains(s))
            cache(s)
        else {
            val acc = new ChecksumAccumulator
            for (c <s)
            acc.add(c.toByte)
            val cs = acc.checksum()
            cache += (s >
            cs)
            cs
        }
}

-A Scala application
import ChecksumAccumulator.calculate
object Summer {
    def main(args: Array[String]) = {
        for (arg <args)
            println(arg + ": " + calculate(arg))
    }
}

-The App trait
import ChecksumAccumulator.calculate
object FallWinterSpringSummer extends App {
    for (season <List("fall", "winter", "spring"))
        println(season + ": " + calculate(season))
}


###############
# Basic Types and Operations
###############
-Character literals
val a = 'A'         // a: Char = A
val d = '\u0041'    // d: Char = A
val f = '\u0044'    // f: Char = D
val B\u0041\u0044 = 1   //BAD: Int = 1

-String interpolation
val name = "reader"         // println(s"Hello, $name!")
s"The answer is ${6 * 7}."  // res0: String = The answer is 42.

infix operator                  // method between the object and the parameter ("7 + 2")
prefix operator (only +,-,!,~)  // method before the object on which you are invoking the method (-7, !found). "-2.0" transformed into (2.0).unary_-
postfix operator                // method after the object ("7 toLong")

-Bitwise operations
1 & 2   // 1 (0001) and 2 (0010) = 0 (0000)
1 | 2   // 1 (0001) and 2 (0010) = 3 (0011)
1 ˆ 3   // 1 (0001) and 2 (0010) = 2 (0010)
~1      // inverts each bit in 1 (0001), yielding -2, which in binary looks like 11111111111111111111111111111110.
1 << 2  // 4

-Operator precedence and associativity
* / %
+ :
= !
< >
&
ˆ
|
(all letters)
(all assignment operators)


###############
# Functional Objects
###############
class Rational(n: Int, d: Int) {                    // primary constructor will be created with these two params
    require(d != 0)                                 // class body code will be added to primary constructor (precondition of the primary constructor that d must be non-zero)
    private val g = gcd(n.abs, d.abs)
    val numer = n / g
    val denom = d / g
    def this(n: Int) = this(n, 1)                   // auxiliary constructors invokes the primary constructor
    def + (that: Rational): Rational =              // simply that.d will not work because d is not accessible outside object where they invoked, so we added numer, denum fields
        new Rational(numer * that.denom + 
        that.numer * denom,denom * that.denom)
    def + (i: Int): Rational =
        new Rational(numer + i * denom, denom)
    def (that: Rational): Rational =
        new Rational(numer * that.denom that.numer* 
        denom,denom * that.denom)
    def (i: Int): Rational =
        new Rational(numer i* denom, denom)
    def * (that: Rational): Rational =
        new Rational(numer * that.numer, denom * 
        that.denom)
    def * (i: Int): Rational =
        new Rational(numer * i, denom)
    def / (that: Rational): Rational =
        new Rational(numer * that.denom, denom * 
        that.numer)
    def / (i: Int): Rational =
        new Rational(numer, denom * i)
    override def toString = numer + "/" + denom     // override default override
    private def gcd(a: Int, b: Int): Int =
        if (b == 0) a else gcd(b, a % b)
}

-Implicit conversions
r * 2   // works
2 * r   // does not work, 2 is Int - not method that takes Rational argument
implicit def intToRational(x: Int) = new Rational(x)


###############
# Built-in Control Structures
###############
-If expressions
val filename = if (!args.isEmpty) args(0) else "default.txt"

-While loops
def gcdLoop(x: Long, y: Long): Long = {
    var a = x
    var b = y
    while (a != 0) {
        val temp = a
        a = b % a
        b = temp
    }
    b
}

while ((line = readLine()) != "")   // This doesn't work! (line = readLine()) retunrs Unit
    println("Read: " + line)

-For expressions
for (file <- filesHere)             // for file in filesHere
    println(file)
for (i <- 1 to 4)                   //
    println("Iteration " + i)
-Filtering
for (
    file <- filesHere
    if file.isFile
    if file.getName.endsWith(".scala")
) println(file)
-Nested iteration
def fileLines(file: java.io.File) =
    scala.io.Source.fromFile(file).getLines().toList
def grep(pattern: String) =
    for (
        file <- filesHere
        if file.getName.endsWith(".scala");
        line <- fileLines(file)
        if line.trim.matches(pattern)
    ) println(file + ": " + line.trim)
grep(".*gcd.*")
-Producing a new collection
def scalaFiles =                    // type of the resulting collection is based on the kind of collections processed in the iteration clauses
    for {
        file <- filesHere
        if file.getName.endsWith(".scala")
    } yield file                    // In this case the result is an Array[File], because filesHere is an array and the type of the yielded expression is File

-Exception handling with try expressions
val half =
    if (n % 2 == 0)
        n / 2                       // One branch of an if computes a value, while the other throws an exception and computes Nothing
    else
        throw new RuntimeException("n must be even")    // If n is not even, an exception will be thrown before half can be initialized to anything at all

-Catching exception
try {
    val f = new FileReader("input.txt")
    // Use and close file
} catch {
    case ex: FileNotFoundException => // Handle missing file
    case ex: IOException => // Handle other I/O error
}

-The finally clause
val file = new FileReader("input.txt")
try {
    // Use the file
} finally {
    file.close() // Be sure to close the file
}

-Yielding a value
def urlFor(path: String) =
    try {
        new URL(path)
    } catch {
        case e: MalformedURLException =>
        new URL("http://www.scalalang.org") // this one is returned if eexception is thrown and cought
    }

-Match expressions
val firstArg = if (!args.isEmpty) args(0) else ""
val friend = firstArg match {
    case "salt" => "pepper"
    case "chips" => "salsa"
    case "eggs" => "bacon"
    case _ => "huh?"
}
println(friend)

-Living without break and continue
var i = 0
var foundIt = false
while (i < args.length && !foundIt) {
    if (!args(i).startsWith("")){
        if (args(i).endsWith(".scala"))
            foundIt = true
        }
    i = i + 1
}
-get ird of vars
def searchFrom(i: Int): Int =
    if (i >= args.length) 1
    else if (args(i).startsWith("")) searchFrom(i + 1)
    else if (args(i).endsWith(".scala")) i
    else searchFrom(i + 1)
val i = searchFrom(0)


###############
# Functions and Closures
###############
-Methods
object LongLines {
    def processFile(filename: String, width: Int) = {
        val source = Source.fromFile(filename)
        for (line <- source.getLines())
            processLine(filename, width, line)
    }
    private def processLine(filename: String,width: Int, line: String) = {
        if (line.length > width)
            println(filename + ": " + line.trim)
    }
}
object FindLongLines {
    def main(args: Array[String]) = {
        val width = args(0).toInt
        for (arg <args.drop(1))
            LongLines.processFile(arg, width)
    }
}

-Local functions
object LongLines {
    def processFile(filename: String, width: Int) = {
        def processLine(line: String) = {
            if (line.length > width)                // local functions can access the parameters of their enclosing function
                println(filename + ": " + line.trim)
        }
        val source = Source.fromFile(filename)
        for (line <-source.getLines())
            processLine(line)
    }
}

-First-class functions
// A function literal is compiled into a class that when instantiated at runtime is a function value
// function literals exist in the source code
// function values exist as objects at runtime
// Every function value is an instance of some class that extends one of several FunctionN traits in package scala

(x: Int) => x + 1                   // function literal
var increase = (x: Int) => x + 1    // Function values are objects, so you can store them in variables
increase(10)                        // you can call them

-Short forms of function literals
someNumbers.filter(x => x > 0)

-Placeholder syntax
someNumbers.filter(_ > 0)
val f = (_: Int) + (_: Int)     // f: (Int, Int) => Int = <function2>
f(5, 10)

-Partially applied functions
// Although the previous examples substitute underscores in place of individual parameters, you can also replace an entire parameter list with an underscore
// when you invoke a function, passing in any needed arguments, you apply that function to the arguments
// given
def sum(a: Int, b: Int, c: Int) = a + b + c
// You could apply the function sum to the arguments 1, 2, and 3 like this
sum(1, 2, 3)

// partially applied function is an expression in which you don’t supply all of the arguments needed by the function. Instead, you supply some, or none
val a = sum _       // partially applied function expression involving sum, in which you supply none of the three required args
a(1, 2, 3)          // Scala compiler translates the expression a(1, 2, 3) into an invocation of the function value’s apply method, passing in the three arguments 1, 2, and 3.

val b = sum(1, _: Int, 3)   // you can also express a partially applied function by supplying only some of the required arguments
b(2)                        // res13: Int = 6

-Closures
(x: Int) => x + more        // A function object that captures free variables, and is said to be "closed" over the variables visible at the time it is created.
var more = 1
val addMore = (x: Int) => x + more  // addMore: Int => Int = <function1>
addMore(10)                         // res16: Int = 11
more = 9999                         // What happens if more changes after the closure is created? In Scala, the answer is that the closure sees the change
addMore(10)                         // res17: Int = 10009

val someNumbers = List(11,10,5,0, 5, 10)
var sum = 0
someNumbers.foreach(sum += _)       // sum = 11

-Special function call forms

-Repeated parameters
def echo(args: String*) = for (arg <args) println(arg)  // echo("hello", "world!")
echo(Array("What's", "up", "doc?"))                     // error: type mismatch found : Array[String] required: String. fix: echo(arr: _*)
// This notation tells the compiler to pass each element of arr as its own argument to echo, rather than all of it as a single argument.

-Named arguments
def speed(distance: Float, time: Float): Float = distance / time    // speed(distance = 100, time = 10)

-Default parameter values
def printTime2(out: java.io.PrintStream = Console.out, divisor: Int = 1) =
    out.println("time = " + System.currentTimeMillis()/divisor)

-Tail recursion
// Functions like approximate, which call themselves as their last action, are called tail recursive. The Scala compiler detects tail recursion and replaces it with a jump back to the beginning of the function, after updating the function parameters with the new values.
def approximate(guess: Double): Double =
    if (isGoodEnough(guess)) guess
    else approximate(improve(guess))

