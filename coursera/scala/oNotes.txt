###############
# Classes and Objects
###############
class ChecksumAccumulator {
    private var sum = 0
    def add(b: Byte): Unit = { sum += b }
    def checksum(): Int = ~(sum & 0xFF) + 1
}

-Singleton objects
import scala.collection.mutable
object ChecksumAccumulator {
    private val cache = mutable.Map.empty[String, Int]
    def calculate(s: String): Int =
        if (cache.contains(s))
            cache(s)
        else {
            val acc = new ChecksumAccumulator
            for (c <s)
            acc.add(c.toByte)
            val cs = acc.checksum()
            cache += (s >
            cs)
            cs
        }
}

-A Scala application
import ChecksumAccumulator.calculate
object Summer {
    def main(args: Array[String]) = {
        for (arg <args)
            println(arg + ": " + calculate(arg))
    }
}

-The App trait
import ChecksumAccumulator.calculate
object FallWinterSpringSummer extends App {
    for (season <List("fall", "winter", "spring"))
        println(season + ": " + calculate(season))
}


###############
# Basic Types and Operations
###############
-Character literals
val a = 'A'         // a: Char = A
val d = '\u0041'    // d: Char = A
val f = '\u0044'    // f: Char = D
val B\u0041\u0044 = 1   //BAD: Int = 1

-String interpolation
val name = "reader"         // println(s"Hello, $name!")
s"The answer is ${6 * 7}."  // res0: String = The answer is 42.

infix operator                  // method between the object and the parameter ("7 + 2")
prefix operator (only +,-,!,~)  // method before the object on which you are invoking the method (-7, !found). "-2.0" transformed into (2.0).unary_-
postfix operator                // method after the object ("7 toLong")

-Bitwise operations
1 & 2   // 1 (0001) and 2 (0010) = 0 (0000)
1 | 2   // 1 (0001) and 2 (0010) = 3 (0011)
1 ˆ 3   // 1 (0001) and 2 (0010) = 2 (0010)
~1      // inverts each bit in 1 (0001), yielding -2, which in binary looks like 11111111111111111111111111111110.
1 << 2  // 4

-Operator precedence and associativity
* / %
+ :
= !
< >
&
ˆ
|
(all letters)
(all assignment operators)


###############
# Functional Objects
###############
class Rational(n: Int, d: Int) {                    // primary constructor will be created with these two params
    require(d != 0)                                 // class body code will be added to primary constructor (precondition of the primary constructor that d must be non-zero)
    private val g = gcd(n.abs, d.abs)
    val numer = n / g
    val denom = d / g
    def this(n: Int) = this(n, 1)                   // auxiliary constructors invokes the primary constructor
    def + (that: Rational): Rational =              // simply that.d will not work because d is not accessible outside object where they invoked, so we added numer, denum fields
        new Rational(numer * that.denom + 
        that.numer * denom,denom * that.denom)
    def + (i: Int): Rational =
        new Rational(numer + i * denom, denom)
    def (that: Rational): Rational =
        new Rational(numer * that.denom that.numer* 
        denom,denom * that.denom)
    def (i: Int): Rational =
        new Rational(numer i* denom, denom)
    def * (that: Rational): Rational =
        new Rational(numer * that.numer, denom * 
        that.denom)
    def * (i: Int): Rational =
        new Rational(numer * i, denom)
    def / (that: Rational): Rational =
        new Rational(numer * that.denom, denom * 
        that.numer)
    def / (i: Int): Rational =
        new Rational(numer, denom * i)
    override def toString = numer + "/" + denom     // override default override
    private def gcd(a: Int, b: Int): Int =
        if (b == 0) a else gcd(b, a % b)
}

-Implicit conversions
r * 2   // works
2 * r   // does not work, 2 is Int - not method that takes Rational argument
implicit def intToRational(x: Int) = new Rational(x)


###############
# Built-in Control Structures
###############
-If expressions
val filename = if (!args.isEmpty) args(0) else "default.txt"

-While loops
def gcdLoop(x: Long, y: Long): Long = {
    var a = x
    var b = y
    while (a != 0) {
        val temp = a
        a = b % a
        b = temp
    }
    b
}

while ((line = readLine()) != "")   // This doesn't work! (line = readLine()) retunrs Unit
    println("Read: " + line)

-For expressions
for (file <- filesHere)             // for file in filesHere
    println(file)
for (i <- 1 to 4)                   //
    println("Iteration " + i)
-Filtering
for (
    file <- filesHere
    if file.isFile
    if file.getName.endsWith(".scala")
) println(file)
-Nested iteration
def fileLines(file: java.io.File) =
    scala.io.Source.fromFile(file).getLines().toList
def grep(pattern: String) =
    for (
        file <- filesHere
        if file.getName.endsWith(".scala");
        line <- fileLines(file)
        if line.trim.matches(pattern)
    ) println(file + ": " + line.trim)
grep(".*gcd.*")
-Producing a new collection
def scalaFiles =                    // type of the resulting collection is based on the kind of collections processed in the iteration clauses
    for {
        file <- filesHere
        if file.getName.endsWith(".scala")
    } yield file                    // In this case the result is an Array[File], because filesHere is an array and the type of the yielded expression is File

-Exception handling with try expressions
val half =
    if (n % 2 == 0)
        n / 2                       // One branch of an if computes a value, while the other throws an exception and computes Nothing
    else
        throw new RuntimeException("n must be even")    // If n is not even, an exception will be thrown before half can be initialized to anything at all

-Catching exception
try {
    val f = new FileReader("input.txt")
    // Use and close file
} catch {
    case ex: FileNotFoundException => // Handle missing file
    case ex: IOException => // Handle other I/O error
}

-The finally clause
val file = new FileReader("input.txt")
try {
    // Use the file
} finally {
    file.close() // Be sure to close the file
}

-Yielding a value
def urlFor(path: String) =
    try {
        new URL(path)
    } catch {
        case e: MalformedURLException =>
        new URL("http://www.scalalang.org") // this one is returned if eexception is thrown and cought
    }

-Match expressions
val firstArg = if (!args.isEmpty) args(0) else ""
val friend = firstArg match {
    case "salt" => "pepper"
    case "chips" => "salsa"
    case "eggs" => "bacon"
    case _ => "huh?"
}
println(friend)

-Living without break and continue
var i = 0
var foundIt = false
while (i < args.length && !foundIt) {
    if (!args(i).startsWith("")){
        if (args(i).endsWith(".scala"))
            foundIt = true
        }
    i = i + 1
}
-get ird of vars
def searchFrom(i: Int): Int =
    if (i >= args.length) 1
    else if (args(i).startsWith("")) searchFrom(i + 1)
    else if (args(i).endsWith(".scala")) i
    else searchFrom(i + 1)
val i = searchFrom(0)


###############
# Functions and Closures
###############
-Methods
object LongLines {
    def processFile(filename: String, width: Int) = {
        val source = Source.fromFile(filename)
        for (line <- source.getLines())
            processLine(filename, width, line)
    }
    private def processLine(filename: String,width: Int, line: String) = {
        if (line.length > width)
            println(filename + ": " + line.trim)
    }
}
object FindLongLines {
    def main(args: Array[String]) = {
        val width = args(0).toInt
        for (arg <args.drop(1))
            LongLines.processFile(arg, width)
    }
}

-Local functions
object LongLines {
    def processFile(filename: String, width: Int) = {
        def processLine(line: String) = {
            if (line.length > width)                // local functions can access the parameters of their enclosing function
                println(filename + ": " + line.trim)
        }
        val source = Source.fromFile(filename)
        for (line <-source.getLines())
            processLine(line)
    }
}

-First-class functions
// A function literal is compiled into a class that when instantiated at runtime is a function value
// function literals exist in the source code
// function values exist as objects at runtime
// Every function value is an instance of some class that extends one of several FunctionN traits in package scala

(x: Int) => x + 1                   // function literal
var increase = (x: Int) => x + 1    // Function values are objects, so you can store them in variables
increase(10)                        // you can call them

-Short forms of function literals
someNumbers.filter(x => x > 0)

-Placeholder syntax
someNumbers.filter(_ > 0)
val f = (_: Int) + (_: Int)     // f: (Int, Int) => Int = <function2>
f(5, 10)

-Partially applied functions
// Although the previous examples substitute underscores in place of individual parameters, you can also replace an entire parameter list with an underscore
// when you invoke a function, passing in any needed arguments, you apply that function to the arguments
// given
def sum(a: Int, b: Int, c: Int) = a + b + c
// You could apply the function sum to the arguments 1, 2, and 3 like this
sum(1, 2, 3)

// partially applied function is an expression in which you don’t supply all of the arguments needed by the function. Instead, you supply some, or none
val a = sum _       // partially applied function expression involving sum, in which you supply none of the three required args
a(1, 2, 3)          // Scala compiler translates the expression a(1, 2, 3) into an invocation of the function value’s apply method, passing in the three arguments 1, 2, and 3.

val b = sum(1, _: Int, 3)   // you can also express a partially applied function by supplying only some of the required arguments
b(2)                        // res13: Int = 6

-Closures
(x: Int) => x + more        // A function object that captures free variables, and is said to be "closed" over the variables visible at the time it is created.
var more = 1
val addMore = (x: Int) => x + more  // addMore: Int => Int = <function1>
addMore(10)                         // res16: Int = 11
more = 9999                         // What happens if more changes after the closure is created? In Scala, the answer is that the closure sees the change
addMore(10)                         // res17: Int = 10009

val someNumbers = List(11,10,5,0, 5, 10)
var sum = 0
someNumbers.foreach(sum += _)       // sum = 11

-Special function call forms

-Repeated parameters
def echo(args: String*) = for (arg <args) println(arg)  // echo("hello", "world!")
echo(Array("What's", "up", "doc?"))                     // error: type mismatch found : Array[String] required: String. fix: echo(arr: _*)
// This notation tells the compiler to pass each element of arr as its own argument to echo, rather than all of it as a single argument.

-Named arguments
def speed(distance: Float, time: Float): Float = distance / time    // speed(distance = 100, time = 10)

-Default parameter values
def printTime2(out: java.io.PrintStream = Console.out, divisor: Int = 1) =
    out.println("time = " + System.currentTimeMillis()/divisor)

-Tail recursion
// Functions like approximate, which call themselves as their last action, are called tail recursive. The Scala compiler detects tail recursion and replaces it with a jump back to the beginning of the function, after updating the function parameters with the new values.
def approximate(guess: Double): Double =
    if (isGoodEnough(guess)) guess
    else approximate(improve(guess))


###############
# Control Abstraction
###############
-Reducing code duplication
object FileMatcher {
    private def filesHere = (new java.io.File(".")).listFiles
    def filesEnding(query: String) =
        for (file <-filesHere; if file.getName.endsWith(query))
            yield file
    def filesContaining(query: String) =                            // function works just like filesEnding only difference is that this function uses contains instead of endsWith
        for (file <-filesHere; if file.getName.contains(query))
        yield file            
            
}
// While you cannot pass around a method name as a value, you can get the same effect by passing around a function value
def filesMatching(query: String, matcher: (String, String) => Boolean) = {      // uses matcher to check the file name against the query
    for (file <-filesHere; if matcher(file.getName, query))
        yield file
}
def filesEnding(query: String) = filesMatching(query, _.endsWith(_))

// full simplified version
object FileMatcher {
    private def filesHere = (new java.io.File(".")).listFiles
    private def filesMatching(matcher: String => Boolean) =
        for (file <-filesHere; if matcher(file.getName))
            yield file
    def filesEnding(query: String) = filesMatching(_.endsWith(query))
    def filesContaining(query: String) = filesMatching(_.contains(query))
    def filesRegex(query: String) = filesMatching(_.matches(query))
}

-Simplifying client code
def containsNeg(nums: List[Int]) = nums.exists(_ < 0)
def containsOdd(nums: List[Int]) = nums.exists(_ % 2 == 1)

-Currying
def curriedSum(x: Int)(y: Int) = x + y      // curriedSum: (x: Int)(y: Int)Int
curriedSum(1)(2)                            // res5: Int = 3; two traditional function invocations back to back; The first function invocation takes a single Int parameter named x, and returns a function value for the second function
val onePlus = curriedSum(1)_                // placeholder for the second parameter list
onePlus(2)                                  // res7: Int = 3

-Writing new control structures
def twice(op: Double => Double, x: Double) = op(op(x))
twice(_ + 1, 5)                             // res9: Double = 7.0
// Any time you find a control pattern repeated in multiple parts of your code, you should think about implementing it as a new control structure
// Consider now a more widely used coding pattern: open a resource, operate on it, and then close the resource
// loan pattern: (because a control-abstraction function, such as withPrintWriter, opens a resource and “loans” it to a function)
def withPrintWriter(file: File, op: PrintWriter => Unit) = {
    val writer = new PrintWriter(file)
    try {
        op(writer)
    } finally {
        writer.close()                      // impossible to forget to close the file
    }
}
withPrintWriter(new File("date.txt"), writer => writer.println(new java.util.Date))

-By-name parameters
// you want to implement an assertion construct called myAssert
var assertionsEnabled = true
def myAssert(predicate: () => Boolean) =
    if (assertionsEnabled && !predicate())
        throw new AssertionError
myAssert(() => 5 > 3)
// By-name parameters exist precisely so you can remove () => part
def byNameAssert(predicate: => Boolean) =
    if (assertionsEnabled && !predicate)
        throw new AssertionError
byNameAssert(5 > 3)                         // function value will be created whose apply method will evaluate 5 > 3, and this function value will be passed to byNameAssert


###############
# Composition and Inheritance
###############
-A two-dimensional layout library
// ibrary for building and rendering two-dimensional layout elements
val column1 = elem("hello") above elem("***")
val column2 = elem("***") above elem("world")
column1 beside column2
result:
hello ***
*** world

-Abstract classes
abstract class Element {
    def contents: Array[String]     // no abstract modifier, method abstract if no implementation
}

-Defining parameterless methods
// if function has no params - use no braces (if only this function does no side-effect)
abstract class Element {
    def contents: Array[String]
    def height: Int = contents.length                               // notice no braces
    def width: Int = if (height == 0) 0 else contents(0).length
}

-Extending classes
class ArrayElement(conts: Array[String]) extends Element {          // inherit all non-private members from class Element
    def contents: Array[String] = conts                             // private members of the superclass are not inherited in a subclass
}
// hieararchy is next ArrayElement<-Element<-AnyRef
val ae = new ArrayElement(Array("hello", "world"))
ae.width                                            // res0: Int = 5
val e: Element = new ArrayElement(Array("hello"))

-Overriding methods and fields
// fields and methods belong to the same namespace - possible for a field to override a parameterless method
class ArrayElement(conts: Array[String]) extends Element {
    val contents: Array[String] = conts                     // val here overrides def in abstract
}

-Defining parametric fields
// can remove const param by combining the parameter and the field in a single parametric field definition
class ArrayElement(val contents: Array[String]) extends Element         // val defines at the same time a parameter and field with the same name (with var it can be reassignable)

-Invoking superclass constructors
// element consisting of a single line given by a string
class LineElement(s: String) extends ArrayElement(Array(s)) {           // Array(s) passed to primary constructor of a parent class (like in java)
    override def width = s.length
    override def height = 1
}

-Using override modifiers
// Scala requires override modifier for all members that override a concrete member in a parent class

-Polymorphism and dynamic binding
class UniformElement(ch: Char,override val width: Int,override val height: Int) extends Element {
    private val line = ch.toString * width
    def contents = Array.fill(height)(line)
}
val e1: Element = new ArrayElement(Array("hello", "world"))
val ae: ArrayElement = new LineElement("hello")
val e2: Element = ae
val e3: Element = new UniformElement('x', 2, 3)
// method invocations on variables and expressions are dynamically bound (determined at run time based on the class of the object)

-Declaring final members

-Using composition and inheritance
// previous version, LineElement had an inheritance relationship with ArrayElement, from which it inherited contents
// It now has a composition relationship with Array: it holds a reference to an array
class LineElement(s: String) extends Element {
    val contents = Array(s)
    override def width = s.length
    override def height = 1
}

-Implementing above, beside, and toString
// above first version
def above(that: Element): Element =
    new ArrayElement(this.contents ++ that.contents)

// beside
def beside(that: Element): Element = new ArrayElement(
    for (
        (line1, line2) <- this.contents zip that.contents       // this.contents and that.contents, are transformed into an array of pairs (as Tuple2s are called) using the zip operator
    ) yield line1 + line2
)

// toString
override def toString = contents mkString "\n"

-Defining a factory object
// A straightforward solution is to create a companion object of class Element and make this the factory object for layout elements
object Element {
    def elem(contents: Array[String]): Element = new ArrayElement(contents)
    def elem(chr: Char, width: Int, height: Int): Element = new UniformElement(chr, width, height)
    def elem(line: String): Element = new LineElement(line)
}

-Heighten and widen
import Element.elem
abstract class Element {
    def contents: Array[String]
    def width: Int = contents(0).length
    def height: Int = contents.length
    def above(that: Element): Element = {
        val this1 = this widen that.width
        val that1 = that widen this.width
        elem(this1.contents ++ that1.contents)
    }
    def beside(that: Element): Element = {
        val this1 = this heighten that.height
        val that1 = that heighten this.height
        elem(
            for ((line1, line2) <- this1.contents zip that1.contents)
                yield line1 + line2)
    }
    def widen(w: Int): Element =
        if (w <= width) this
        else {
        val left = elem(' ', (w - width) / 2, height)
        val right = elem(' ', w - width - left.width, height)
        left beside this beside right
        }
    def heighten(h: Int): Element =
    if (h <= height) this
    else {
        val top = elem(' ', width, (h - height) / 2)
        val bot = elem(' ', width, h - height - top.height)
        top above this above bot
    }
    override def toString = contents mkString "\n"
}


-Putting it all together
import Element.elem
object Spiral {
    val space = elem(" ")
    val corner = elem("+")
    def spiral(nEdges: Int, direction: Int): Element = {
        if (nEdges == 1)
            elem("+")
        else {
            val sp = spiral(nEdges - 1, (direction + 3) % 4)
            def verticalBar = elem('|', 1, sp.height)
            def horizontalBar = elem('-', sp.width, 1)
            if (direction == 0)                                         // bottom to up
                (corner beside horizontalBar) above (sp beside space)
            else if (direction == 1)                                    // right to left
                (sp above space) beside (corner above verticalBar)
            else if (direction == 2)                                    // top to bottom
                (space beside sp) above (horizontalBar beside corner)
            else                                                        // right to left
                (verticalBar above corner) beside (space above sp)
        }
    }
    def main(args: Array[String]) = {
        val nSides = args(0).toInt
        println(spiral(nSides, 0))
    }
}


###############
# Scala’s Hierarchy
###############
-Scala’s class hierarchy
//top of the hierarchy is class Any, methods:
final def ==(that: Any): Boolean
final def !=(that: Any): Boolean
def equals(that: Any): Boolean
def ##: Int
def hashCode: Int
def toString: String
// methods min, max, until, to, and abs are all defined in a class scala.runtime.RichInt, and there is an implicit conversion from class Int to RichInt. The conversion is applied whenever a method is invoked on an Int that is undefined in Int but defined in RichInt.
#########################################################################################################
#+---+                                                                                                  #
#|any|                                                                                                  #
#+---+                                                                                                  #
#|    +------+                                                                                  +------+#
#+----+anyVal+-+--------+--------+--------+--------+--------+--------+--------+--------+<-------+Nothng|#
#|    +------+ |        |        |        |        |        |        |        |        |        +------+#
#|             +------+ +------+ +------+ +------+ +------+ +------+ +------+ +------+ +------+         #
#|             |Double| |Float | |Long  | |Int   | |Short | |Byte  | |Char  | |Bolean| |Unit  |         #
#|             +------+ +------+ +------+ +------+ +------+ +------+ +------+ +------+ +------+         #
#|                                                                                                      #
#|                                                                                                      #
#|    +------+                                     +------+                                             #
#+----+anyRef+-+--------+--------+--------+<-------+Null  |                                             #
#     +------+ |        |        |        |        +------+                                             #
#              +------+ +------+ +------+ +------+                                                      #
#              |Itrble+<+Seq   +<+List  | |Option|                                                      #
#              +------+ +------+ +------+ +------+                                                      #
#########################################################################################################

-How primitives are implemented
// class AnyRef defines an additional eq method, which cannot be overridden and is implemented as reference equality (i.e., it behaves like == in Java for reference types).
val x = new String("abc")
val y = new String("abc")
x == y                      // res13: Boolean = true
x eq y                      // res14: Boolean = false
x ne y                      // res15: Boolean = true

-Bottom types
// Null is a subclass of every reference class
// Nothing is a subtype of every other type
val i: Int = null               // error: an expression of type Null is ineligible for implicit conversion
def error(message: String): Nothing =
    throw new RuntimeException(message)     // return type of error is Nothing
    
def divide(x: Int, y: Int): Int =
    if (y != 0) x / y
    else error("can't divide by zero")      // Because Nothing is a subtype of Int, the type of the whole conditional is Int, as required.

-Defining your own value classes
// must have exactly one parameter and it must have nothing inside it except defs
class Dollars(val amount: Int) extends AnyVal {
    override def toString() = "$" + amount
}
val money = new Dollars(1000000)        // money: Dollars = $1000000; money.amount  -> res16: Int = 1000000


###############
# Traits
###############
-How traits work
trait Philosophical {                                   // default superclass of AnyRef
    def philosophize() = {
        println("I consume memory, therefore I am!")
    }
}
class Frog extends Philosophical {
    override def toString = "green"
}
val frog = new Frog          // frog: Frog = green
frog.philosophize()          // I consume memory, therefore I am!
// can mix a trait into a class that explicitly extends a superclass
class Animal
class Frog extends Animal with Philosophical {
    override def toString = "green"
    override def philosophize() = {                         // override method in trait
        println("It ain't easy being " + toString + "!")
    }
}
val phrog: Philosophical = new Frog                         // phrog: Philosophical = green
phrog.philosophize()                                        // It ain't easy being green!

-Thin versus rich interfaces
// One major use of traits is to automatically add methods to a class

-Example: Rectangular objects
class Point(val x: Int, val y: Int)
trait Rectangular {
    def topLeft: Point
    def bottomRight: Point
    def left = topLeft.x
    def right = bottomRight.x
    def width = right - left
    // and many more geometric methods...
}
abstract class Component extends Rectangular {
    // other methods...
}
class Rectangle(val topLeft: Point, val bottomRight: Point) extends Rectangular {
    // other methods...
}
val rect = new Rectangle(new Point(1, 1), new Point(10, 10))
rect.left               // res2: Int = 1
rect.right              // res3: Int = 10

-The Ordered trait
class Rational(n: Int, d: Int) extends Ordered[Rational] {
    // ...
    def compare(that: Rational) =                               //  define a compare method 
        (this.numer * that.denom) - (that.numer * this.denom)   // zero - same, negative - receiver less than argument, positive - receiver greater than argument
}
new Rational(1, 2) < new Rational(1, 3)         // res5: Boolean = false

-Traits as stackable modifications
abstract class IntQueue {
    def get(): Int
    def put(x: Int)
}
class BasicIntQueue extends IntQueue {
    private val buf = new ArrayBuffer[Int]
    def get() = buf.remove(0)
    def put(x: Int) = { buf += x }              // adds elements to the other end
}
val queue = new BasicIntQueue
queue.put(10)
queue.put(20)
queue.get()                                     // res9: Int = 10
queue.get()                                     // res10: Int = 20
trait Doubling extends IntQueue {
    abstract override def put(x: Int) = { super.put(2 * x) }        // super calls in a trait are dynamically bound, the super call in trait Doubling will work so long as the trait is mixed in after another trait or class that gives a concrete definition to the method
}
class MyQueue extends BasicIntQueue with Doubling
val queue = new MyQueue
queue.put(10)
queue.get()                                     // res12: Int = 20
trait Incrementing extends IntQueue {
    abstract override def put(x: Int) = { super.put(x + 1) }
}
trait Filtering extends IntQueue {
    abstract override def put(x: Int) = {if (x >= 0) super.put(x)}
}
val queue = (new BasicIntQueue with Incrementing with Filtering)    // method in the +trait furthest to the right is called first. If that method calls super, it invokes the method in the next trait to its left, and so on

-Why not multiple inheritance?
// When you instantiate a class with new, Scala takes the class, and all of its inherited classes and traits, and puts them in a single, linear order.
// Then, whenever you call super inside one of those classes, the invoked method is the next one up the chain. If all of the methods but the last call super, the net result is stackable behavior.

-To trait or not to trait?
// If the behavior will not be reused, then make it a concrete class.
// If it might be reused in multiple, unrelated classes, make it a trait
// If you want to inherit from it in Java code, use an abstract class
// If you plan to distribute it in compiled form, and you expect outside groups to write classes inheriting from it, you might lean towards using an abstract class
// If you still do not know, after considering the above, then start by making it as a trait


###############
# Packages and Imports
###############
-Putting code in packages
package bobsrockets.navigation
class Navigator
// C# style
package bobsrockets.navigation {
    class Navigator
}

-Concise access to related code
// In file launch.scala
package launch {
    class Booster3
}
// In file bobsrockets.scala
package bobsrockets {
    package navigation {
        package launch {
            class Booster1
        }
        class MissionControl {
            val booster1 = new launch.Booster1
            val booster2 = new bobsrockets.launch.Booster2
            val booster3 = new _root_.launch.Booster3           // gives you the top-level launch package
        }
    }
    package launch {
        class Booster2
    }
}

-Imports
import bobsdelights.Fruit                       // easy access to Fruit
import bobsdelights._                           // easy access to all members of bobsdelights
import bobsdelights.Fruits._                    // easy access to all members of Fruits
import Fruits.{Apple, Orange}                   // selective
import Fruits.{Apple => McIntosh, Orange}       // Apple object is renamed to McIntosh
import Fruits.{Pear => _, _}                    // except pear

package bobsdelights
abstract class Fruit(
    val name: String,
    val color: String
)
object Fruits {
    object Apple extends Fruit("apple", "red")
    object Orange extends Fruit("orange", "orange")
    object Pear extends Fruit("pear", "yellowish")
    val menu = List(Apple, Orange, Pear)
}

-Implicit imports
//  added to the top of every source file with extension ".scala"
import java.lang._      // everything in the java.lang package
import scala._          // everything in the scala package
import Predef._         // everything in the Predef object

-Access modifiers
// Private members - visible only inside the class or object that contains the member definition (Outter class sees no private memeber of inner)
// Protected members - accessible from subclasses of the class in which the member is defined (not packge as in java)
// Public members - default - accessed from anywhere

-Package objects
// Any kind of definition that you can put inside a class can also be at the top level of a package (method you’d like to be in scope for an entire package)
// Each package is allowed to have one package object. Any definitions placed in a package object are considered members of the package itself.
// In file bobsdelights/package.scala
package object bobsdelights {
    def showFruit(fruit: Fruit) = {
        import fruit._
        println(name + "s are " + color)
    }
}
// In file PrintMenu.scala
package printmenu
import bobsdelights.Fruits
import bobsdelights.showFruit
object PrintMenu {
    def main(args: Array[String]) = {
        for (fruit <- Fruits.menu) {
            showFruit(fruit)
        }
    }
}


###############
# Assertions and Tests
###############
-Assertions
def above(that: Element): Element = {
    val this1 = this widen that.width
    val that1 = that widen this.width
    assert(this1.width == that1.width)
    elem(this1.contents ++ that1.contents)
}

private def widen(w: Int): Element =
    if (w <= width)
        this
    else {
        val left = elem(' ', (w - width) / 2, height)
        var right = elem(' ', w - width - left.width, height)
        left beside this beside right
    } ensuring (w <= _.width)                                   // underscore is a placeholder for the one argument passed to the predicate, the Element result of the widen method
    //  If the width passed as w to widen is less than or equal to the width of the result Element, the predicate will result in true

-Testing in Scala
import org.scalatest.FunSuite
import Element.elem
class ElementSuite extends FunSuite {                   // central concept in ScalaTest is the suite - collection of tests
    test("elem result should have passed width") {      // specify the name of the test as a string between the parentheses and the test code itself between curly braces
        val ele = elem('x', 2, 3)                       // test code is a function passed as a by-name parameter to test, which registers it for later execution
        assert(ele.width == 2)
    }
}

-Informative failure reports
val caught =
    intercept[ArithmeticException] {
        1 / 0
    }
assert(caught.getMessage == "/ by zero")

-Tests as specifications
import org.scalatest._
class TVSetSpec extends FeatureSpec with GivenWhenThen {
    feature("TV power button") {
        scenario("User presses power button when TV is off") {
            Given("a TV set that is switched off")
            When("the power button is pressed")
            Then("the TV should switch on")
            pending
        }
    }
}

-Property-based testing
import org.scalatest.WordSpec
import org.scalatest.prop.PropertyChecks
import org.scalatest.MustMatchers._
import Element.elem
class ElementSpec extends WordSpec with PropertyChecks {
    "elem result" must {
        "have passed width" in {
            forAll { (w: Int) =>
                whenever (w > 0) {
                    elem('x', w, 3).width must equal (w)
                }
            }
        }
    }
}

-Organizing and running tests
scalac -cp scalatest.jar TVSetSpec.scala


###############
# Case Classes and Pattern Matching
###############
-A simple example
abstract class Expr
case class Var(name: String) extends Expr
case class Number(num: Double) extends Expr
case class UnOp(operator: String, arg: Expr) extends Expr
case class BinOp(operator: String, left: Expr, right: Expr) extends Expr

-Case classes
// can do Var("x") instead on new Var("x")
val v = Var("x")
val op = BinOp("+", Number(1), v)
// all arguments in the parameter list of a case class implicitly get a val prefix, so they are maintained as fields
v.name                      // res0: String = x
op.left                     // res1: Expr = Number(1.0)
// compiler adds “natural” implementations of methods toString, hashCode, and equals
// compiler adds a copy method
op.copy(operator = "-")     // res4: BinOp = BinOp(-,Number(1.0),Var(x))

-Pattern matching
simplifyTop(UnOp("-", UnOp("-", Var("x"))))
// A constant pattern like "+" or 1 matches values that are equal to the constant with respect to ==
// A variable pattern like e matches every value

def simplifyTop(expr: Expr): Expr = expr match {                // A match expression is evaluated by trying each of the patterns in the order they are written
    case UnOp("-", UnOp("-", e)) => e // Double negation        // constructor pattern looks like UnOp("-", e). This pattern matches all values of type UnOp whose first argument matches "-" and whose second argument matches e
    case BinOp("+", e, Number(0)) => e // Adding zero           // e - a variable that is bound within the associated pattern
    case BinOp("*", e, Number(1)) => e // Multiplying by one
    case _ => expr                                              // wildcard pattern (_) also matches every value
}

-match compared to switch
// match is an expression in Scala (i.e., it always results in a value)
// Scala’s alternative expressions never “fall through” into the next case
// Third, if none of the patterns match, an exception named MatchError is thrown

-Kinds of patterns
-Wildcard patterns
expr match {
    case BinOp(op, left, right) => println(expr + " is a binary operation")
    case _ =>                                                                   // handle the default case
}
expr match {
    case BinOp(_, _, _) => println(expr + " is a binary operation")             // dont care about elements of binary operation
    case _ => println("It's something else")
}

-Constant patterns
def describe(x: Any) = x match {
    case 5 => "five"
    case true => "truth"
    case "hello" => "hi!"
    case Nil => "the empty list"
    case _ => "something else"
}
describe(5)                  // res6: String = five
describe(true)               // res7: String = truth
describe("hello")            // res8: String = hi!
describe(Nil)                // res9: String = the empty list
describe(List(1,2,3))        // res10: String = something else

-Variable patterns
expr match {
    case 0 => "zero"
    case somethingElse => "not zero: " + somethingElse      // default case for all other values
}

import math.{E, Pi}
E match {
    case Pi => "strange math? Pi = " + Pi   // name starting with a lowercase letter is taken to be a pattern variable; all other references are taken to be constants
    case _ => "OK"
}
// res11: String = OK                       // As expected, E does not match Pi, so the "strange math" case is not used.
val pi = math.Pi                            // pi: Double = 3.141592653589793
scala> E match {
    case pi => "strange math? Pi = " + pi   // res12: String = strange math? Pi = 2.718281828459045
}
// and you are not allowed to add a default case cause variable pattern is default
E match {
    case pi => "strange math? Pi = " + pi
    case _ => "OK"                          // <console>:12: warning: unreachable code case _ => "OK"
}
// You can still use a lowercase name for a pattern constant if the constant is a field of some object, you can prefix it with a qualifier
// 1. pi is a variable pattern, but this.pi or obj.pi are constants
// 2. you can alternatively enclose the variable name in back ticks
E match {
    case `pi` => "strange math? Pi = " + pi
    case _ => "OK"                          // res14: String = OK
}

-Constructor patterns
// Scala patterns support deep matches
expr match {
    case BinOp("+", e, Number(0)) => println("a deep match")        // if BinOp is case class - first check if object is member of case class, then check constructor parameters match
    case _ =>
}

-Sequence patterns
expr match {
    case List(0, _, _) => println("found it")       // three-element list starting with zero
    case List(1, _*) => println("found it")         // matches 1 and any number of elements within a sequence
    case _ =>
}

-Tuple patterns
def tupleDemo(expr: Any) =
    expr match {
        case (a, b, c) => println("matched " + a + b + c)       // matches an arbitrary 3-tuple
        case _ =>
    }
tupleDemo(("a ", 3, "-tuple"))                                  // matched a 3-tuple

-Typed patterns
def generalSize(x: Any) = x match {
    case s: String => s.length
    case m: Map[_, _] => m.size
    case _ => -1
}

-Type erasure
// no information about type arguments is maintained at runtime
// there is no way to determine at runtime whether a given Map object has been created with two Int arguments
def isIntIntMap(x: Any) = x match {
    case m: Map[Int, Int] => true       // warning: non-variable type argument Int in type pattern is unchecked since it is eliminated by erasure
    case _ => false
}
scala> isIntIntMap(Map(1 -> 1))                 // res19: Boolean = true
scala> isIntIntMap(Map("abc" -> "abc"))         // res20: Boolean = true
// exception is Array because type is stored in array
def isStringArray(x: Any) = x match {
    case a: Array[String] => "yes"
    case _ => "no"
}
isStringArray(Array("abc"))                     // res21: String = yes
isStringArray(Array(1, 2, 3))                   // res22: String = no

-Variable binding
// variable-binding pattern with e as the variable and UnOp("abs", _) as the pattern
// If the entire pattern match succeeds, then the portion that matched the UnOp("abs", _) part is made available as variable e
expr match {
    case UnOp("abs", e @ UnOp("abs", _)) => e   // looks for the absolute value operation being applied twice in a row
    case _ =>
}

-Pattern guards
// pattern variable may only appear once in a pattern
def simplifyAdd(e: Expr) = e match {
    case BinOp("+", x, x) => BinOp("*", x, Number(2))   // error: x is already defined as value x
    case _ => e
}
// reformulate
def simplifyAdd(e: Expr) = e match {
    case BinOp("+", x, y) if x == y => BinOp("*", x, Number(2))     // pattern guard goes after if
    case _ => e
}

-Pattern overlaps
// If you wrote them in the other order, then the catch-all case would be run in favor of the more specific rules
def simplifyAll(expr: Expr): Expr = expr match {
    case UnOp("-",UnOp("-",e))      =>simplifyAll(e) // '-'is its own inverse
    case BinOp("+", e, Number(0))   =>simplifyAll(e) // '0' is a neutral element for ‘+'
    case BinOp("*", e, Number(1))   =>simplifyAll(e) // '1' is a neutral element for ‘*'
    case UnOp(op, e)                =>UnOp(op, simplifyAll(e))
    case BinOp(op, l, r)            =>BinOp(op, simplifyAll(l), simplifyAll(r))
    case _ => expr
}

-Sealed classes
// How can you ever feel safe that you covered all the cases in pattern matching?
// A sealed class cannot have any new subclasses added except the ones in the same file
// you only need to worry about the subclasses you already know about
sealed abstract class Expr
case class Var(name: String) extends Expr
case class Number(num: Double) extends Expr
case class UnOp(operator: String, arg: Expr) extends Expr
case class BinOp(operator: String, left: Expr, right: Expr) extends Expr
def describe(e: Expr): String = e match {       // warning: match is not exhaustive!
    case Number(_) => "a number"                // missing combination UnOp
    case Var(_) => "a variable"                 // missing combination BinOp
}
// no warning
def describe(e: Expr): String = (e: @unchecked) match {
    case Number(_) => "a number"
    case Var(_) => "a variable"
    case _ => throw new RuntimeException        // or this
}

-The Option type
// Option two forms: Some(x) and None object
val capitals = Map("France" >"Paris", "Japan" >"Tokyo")
capitals get "France"                           // res23: Option[String] = Some(Paris)
capitals get "North Pole"                       // res24: Option[String] = None
def show(x: Option[String]) = x match {
    case Some(s) => s
    case None => "?"
}
show(capitals get "Japan")               // res25: String = Tokyo
show(capitals get "France")              // res26: String = Paris
show(capitals get "North Pole")          // res27: String = ?

-Patterns everywhere
-Patterns in variable definitions
val myTuple = (123, "abc")
val (number, string) = myTuple          // number: Int = 123; string: String = abc
val exp = new BinOp("*", Number(5), Number(1))
val BinOp(op, left, right) = exp        // op: String = *; left: Expr = Number(5.0); right: Expr = Number(1.0)

-Case sequences as partial functions
val withDefault: Option[Int] => Int = { // A sequence of cases (i.e., alternatives) in curly braces can be used anywhere a function literal can be used
    case Some(x) => x                   // case sequence is a function literal, only more general
    case None => 0
}
withDefault(Some(10))            // res28: Int = 10
withDefault(None)                // res29: Int = 0
// Akka actors library allows its receive method to be defined as a series of cases
var sum = 0
def receive = {
    case Data(byte)             =>sum += byte
    case GetChecksum(requester) =>val checksum = ~(sum & 0xFF) + 1
    requester ! checksum
}
// sequence of cases gives you a partial function If you apply such a function on a value it does not support,it will generate a run-time exception
// warning: match is not exhaustive! missing combination Nil
val second: List[Int] => Int = {
    case x :: y :: _ => y       // will succeed if you pass it a three-element list
}
second(List(5, 6, 7))           // res24: Int = 6
second(List())                  // scala.MatchError: List()

-Patterns in for expressions
// for expression retrieves all key/value pairs from the capitals map
for ((country, city) <capitals)
    println("The capital of " + country + " is " + city)
// the second element None in the results list does not match the pattern Some(fruit); therefore it does not show up in the output.
val results = List(Some("apple"), None, Some("orange"))
for (Some(fruit) <results)
    println(fruit)              // apple, orange

-A larger example
                     x
x/(x+1)     -->     ---      
                    x+1
// concentrate on horizontal layout
BinOp("+",
    BinOp("*",
        BinOp("+", Var("x"), Var("y")),
        Var("z")),
    Number(1))
// code needs to know about the relative precedence of each operator
Map( "|" > 0, "||" > 0, "&" > 1, "&&" > 1, ... )

package org.stairwaybook.expr
import org.stairwaybook.layout.Element.elem
sealed abstract class Expr
case class Var(name: String) extends Expr
case class Number(num: Double) extends Expr
case class UnOp(operator: String, arg: Expr) extends Expr
case class BinOp(operator: String, left: Expr, right: Expr) extends Expr
class ExprFormatter {
    // Contains operators in groups of increasing precedence
    private val opGroups =
        Array(
            Set("|", "||"),
            Set("&", "&&"),
            Set("ˆ"),
            Set("==", "!="),
            Set("<", "<=", ">", ">="),
            Set("+", ""),
            Set("*", "%")
        )
// A mapping from operators to their precedence
    private val precedence = {
        val assocs =
            for {
                i <- 0 until opGroups.length
                op <- opGroups(i)
            } yield op -> i
        assocs.toMap
    }
private val unaryPrecedence = opGroups.length
private val fractionPrecedence = 1
import org.stairwaybook.layout.Element
    private def format(e: Expr, enclPrec: Int): Element =
        e match {
            case Var(name) => elem(name)                                            // 1.If the expression is a variable, the result is an element formed from the variable’s name.
            case Number(num) => 
                def stripDot(s: String) =                                           // 2.cleans up the display of a floating-point number by stripping any ".0" suffix from a string
                    if (s endsWith ".0") s.substring(0, s.length 2)
                    else s
                elem(stripDot(num.toString))
            case UnOp(op, arg) => elem(op) beside format(arg, unaryPrecedence)      // 3.if arg is a binary operation (but not a fraction) it will always be displayed in parentheses
            case BinOp("/", left, right) =>                                         // 4.If the expression is a fraction, an intermediate result frac is formed by placing the formatted 
                val top = format(left, fractionPrecedence)                          // operands left and right on top of each other, separated by an horizontal line element
                val bot = format(right, fractionPrecedence)                         // 
                val line = elem('',top.width max bot.width, 1)
                val frac = top above line above bot
                if (enclPrec != fractionPrecedence) frac
                else elem(" ") beside frac beside elem(" ")
            case BinOp(op, left, right) =>                                          // applies for all other binary operations
                val opPrec = precedence(op)
                val l = format(left, opPrec)
                val r = format(right, opPrec + 1)
                val oper = l beside elem(" " + op + " ") beside r
                if (enclPrec <= opPrec) oper
                else elem("(") beside oper beside elem(")")
        }
    def format(e: Expr): Element = format(e, 0)
}
import org.stairwaybook.expr._
object Express extends App {
    val f = new ExprFormatter                                                                           1          
    val e1 = BinOp("*", BinOp("/", Number(1), Number(2)),BinOp("+", Var("x"), Number(1)))       -->     - * (x + 1)
    println(f.format(e1)+ "\n\n")                                                                       2          
}


###############
# Working with Lists 
###############
-List literals
// lists are immutable, lists have a recursive structure, whereas arrays are flat
val fruit = List("apples", "oranges", "pears")
val nums = List(1, 2, 3, 4)
val empty = List()

-The List type
// The list type in Scala is covariant
// if S is a subtype of T, then List[S] is a subtype of List[T]
// List[String] is a subtype of List[Object]
val fruit: List[String] = List("apples", "oranges", "pears")
val nums: List[Int] = List(1, 2, 3,
val empty: List[Nothing] = List()       // Because lists are covariant, it follows that List[Nothing] is a subtype of List[T]
val xs: List[String] = List()           // List() is also of type List[String]!        

-Constructing lists
// lists are built from two fundamental building blocks, Nil and :: (pronounced "cons")
// x :: xs represents a list whose first element is x, followed by (the elements of) list xs
val fruit = "apples" :: ("oranges" :: ("pears" :: Nil))
val nums = 1 :: 2 :: 3 :: 4 :: Nil

-Basic operations on lists
head    // returns the first element of a list
tail    // returns a list consisting of all elements except the first
isEmpty // returns true if the list is empty
// insertion sort - sort a non-empty list x :: xs, sort the remainder xs and insert the first element x at the right position in the result
def isort(xs: List[Int]): List[Int] =
    if (xs.isEmpty) Nil
    else insert(xs.head, isort(xs.tail))
def insert(x: Int, xs: List[Int]): List[Int] =
    if (xs.isEmpty || x <= xs.head) x :: xs
    else xs.head :: insert(x, xs.tail)

-List patterns
val List(a, b, c) = fruit       // match on all elements of a list (a: String = apples ,b: String = oranges ,c: String = pears)
val a :: b :: rest = fruit      // (a: String = apples, b: String = oranges, rest: List[String] = List(pears))
// sorting
def isort(xs: List[Int]): List[Int] = xs match {
    case List()     => List()
    case x :: xs1   => insert(x, isort(xs1))
}
def insert(x: Int, xs: List[Int]): List[Int] = xs match {
    case List()     => List(x)
    case y :: ys    => if (x <= y) x :: xs else y :: insert(x, ys)
}

-First-order methods on class List
// A method is first-order if it does not take any functions as arguments

-Concatenating two lists
List(1, 2) ::: List(3, 4, 5)        // res0: List[Int] = List(1, 2, 3, 4, 5)

-The Divide and Conquer principle
// implementing concatenation
def append[T](xs: List[T], ys: List[T]): List[T] =
    xs match {
        case List() => ys
        case x :: xs1 => x :: append(xs1, ys)
}

-Taking the length of a list: length
List(1, 2, 3).length            // res3: Int = 3 (needs to traverse the whole list)

-Accessing the end of a list: init and last
val abcde = List('a', 'b', 'c', 'd', 'e')
abcde.last                      // res4: Char = e   (need to traverse the whole list to compute their result)
abcde.init                      // res5: List[Char] = List(a, b, c, d)  (need to traverse the whole list to compute their result)

Reversing lists: reverse


























