###############
# week 1
###############

- call by value(default)
def callByValue(x: Int) = {}	# evaluated once when entering method
- call by name
def callByName(x: => Int) = {}	# evaluated each time when called

- conditionals
def and(x:Boolean, y:Boolean) = if (x) y else false

- square root
def sqrt(x:Int) = srtIter(1.0,x)
def srtIter(guess: Double, x:Double):Double = if (isGoodEnough(guess,x)) guess else sqrtIter(improve(guess,x)x)
def isGoodEnough(guess:Double, x:Double) = abs(guess*guess-x)/x < 0.001
def improve(guess:Double, x:Double) = abs(guess+x/guess)/2

- greatest common divisor
def gcd(a:Int, b:Int) = if (b==0) a else gcd(b, a%b)

- factorial
def factorial(n:Int) = if (n==0) 1 else n*factorial(n-1)
- factorial (tail)
def factorialTail(n:Int):Int = {
	def loop(acc:Int, n:Int) = if (n==0) acc else loop(acc*n, n-1)
	loop(1,n)
}

###############
# week 2
###############
- higher order function
def sum(f:Int=>Int, a:Int, b:Int) = if (a>b) 0 else f(a)+sum(f,a+1,b)	
sum((x:Int)=>x*x*x,a,b)		# sum of cubes between a and b

def sum(f: Int => Int, a: Int, b: Int): Int = {
  def loop(a: Int, acc: Int): Int = {
    if (a>b) acc
    else loop(a+1, f(a)+acc)
  }
  loop(a, 0)
}

- currying
def sum(f: Int => Int): (a: Int, b: Int)=>Int = {
  def sumF(a: Int, b: Int): Int = {
    if (a>b) 0 else f(a)+sumF(a+1,b)
  }
  sumF
}
or
def sum(f: Int => Int)(a: Int, b: Int):Int = if (a>b) 0 else f(a)+sum(f)(a+1,b)
sum((x:Int)=>x*x*x) (a,b)

def mapReduce(f:Int=>Int, combine:(Int,Int)=>Int,zero:Int)(a: Int, b: Int):Int=
	if (a>b) zero else combine(f(a),mapReduce(f,combine,zero)(a+1,b))
def product(f:Int=Int)(a:Int,b:Int):Int = mapReduce(f,(x,y)=>x*y,1)(a,b)

- fixed points (x-fixed point if f(x)=x, example x=1+x/2 (x=2 fixed point))
# sqrt of x = y*y so y = x/y # x is a fixed point of y = x/y 
def isCloseEnough(x:Double, y:Double) = abs((x-y)/x)/x < 0.0001
def fixedPoint(f:Double=>Double)(firstGuess:Double)={
	def iterate(guess:Double):Double={
		val next = f(guess)
		if(isCloseEnough(guess,next)) next else iterate(next)
	}
	iterate(firstGuess)
}
def averageDamp(f:Double=>Double)(x:Double) = (x+f(x))/2
def sqrt(x:Double) = fixedPoint(averageDamp(y=> x/y))(1)


###############
# week 3
###############

- tree
abstract class IntSet{																#incl 3
	def incl(x:Int): IntSet													        ########################################
	def contains(x:Int): Boolean                                                    #					+--+               #
	def union(other: IntSet): IntSet}                                               #					|7 |               #
                                                                                    #		   +--------+--+----+          #
object Empty extends IntSet{                                                        #	       |                |          #
	def contains(x:Int): Boolean = false                                            #		   |          +--+  |          #
	def incl(x:Int): IntSet = new NonEmpty(x, new Empty, new Empty)                 #		   |          |7 |  |          #
	def union(other: IntSet): IntSet = other                                        #		   |          +--+  |          #
}                                                                                   #		+--+     +--+    +--+          #
                                                                                    #		|5 |     |5 |    |12|          #
class NonEmpty(elem: Int, left: IntSet, right: IntSet) extends IntSet{              #		+--+     +--+    +--+          #
	def contains(x:Int): Boolean = {                                                #	+--+        e    e  e    e         #
		if (x<elem) left contains x                                                 #	|3 |                               #
		else if (x>elem) right contains x                                           #	+--+                               #
		else true}                                                                  #	e    e                             #
	def incl(x:Int): IntSet = {                                                     ########################################
		if (x<elem) new NonEmpty(elem, left incl x, right)                  
		if (x>elem) new NonEmpty(elem, left, right incl x)                  
		else this                                                           
		}
	def union(other: IntSet): IntSet = ((left union right) union other) incl elem
}

- scala classes hierarchy

#########################################################################################################
#+---+                                                                                                  #
#|any|                                                                                                  #
#+---+                                                                                                  #
#|    +------+                                                                                  +------+#
#+----+anyVal+-+--------+--------+--------+--------+--------+--------+--------+--------+<-------+Nothng|#
#|    +------+ |        |        |        |        |        |        |        |        |        +------+#
#|             +------+ +------+ +------+ +------+ +------+ +------+ +------+ +------+ +------+         #
#|             |Double| |Float | |Long  | |Int   | |Short | |Byte  | |Char  | |Bolean| |Unit  |         #
#|             +------+ +------+ +------+ +------+ +------+ +------+ +------+ +------+ +------+         #
#|                                                                                                      #
#|                                                                                                      #
#|    +------+                                     +------+                                             #
#+----+anyRef+-+--------+--------+--------+<-------+Null  |                                             #
#     +------+ |        |        |        |        +------+                                             #
#              +------+ +------+ +------+ +------+                                                      #
#              |Itrble+<+Seq   +<+List  | |Option|                                                      #
#              +------+ +------+ +------+ +------+                                                      #
#########################################################################################################

- polymorphism

#List(1,2,3)
#################
# +-+           #
# +-+           #
#1   +-+        #
#    +-+        #
#   2   +-+     #
#       +-+     #
#      3   Nil  #
#################

#Cons-List

trait List[T] {
	def isEmpty: Boolean
	def head: T
	def tail: List[T]}
class Cons[T](val head: T, val tail: List[T]) extends List[T]{
	def isEmpty: = false}	
class Nil[T] extends IntList[T] {
	def isEmpty: = true
	def head: Nothing = throw new Exception
	def tail: Nothing = throw new Exception}
object List{
	//List(1,2) = List.apply(1,2)
	def apply[T](x1:T,x2:T): List[T] = new Cons(x1, new Cons(x2,new Nil)) 
}
	

- take nth elem
	def nth(n:Int, xs:List[T]):T = if (n==0) xs.head else nth(n-1, xs.tail)
	
###############
# week 4
###############	
-object everywhere

abstract class Nat{					# object Zero extends Nat{																# object Succ(n:Nat) extends Nat{
	def isZero: Boolean             #    	def isZero: true                                                                # 	def isZero: false
	def predecessor: Nat            #    	def predecessor: throw new Error("0.predecessor")                               # 	def predecessor:  n
	def successor: new Succ(this)   #    	def -(that:Nat): that                                                           # 	def -(that:Nat): n-that.predecessor
	def -(that:Nat): Nat            #    	def +(that:Nat): if(this.isZero) this else throw new Error("negative number")}  # 	def +(that:Nat): new Succ(n+that)}
	def +(that:Nat): Nat}           #                                                                                       # 
	

- functions as objects
val f = (x:Int) => x*x*x
f(7)
would be 
val f = new Function[Int,Int]{ def apply(x:Int) = x*x }
f.apply(7)


- subtyping and generics (which are prinicpals of polymorphism)
	upper bounds - s can be only subtype of IntSet
	def assertAllPos (s <: IntSeT): IntSet
	lower bounds - s can be only supertype of IntSet
	def assertAllPos (s >: IntSeT): IntSet
	mix bounds - s can be any type interval between NonEmpty and IntSeT
	[s >: NonEmpty <: IntSet]
	
Arrays in Java are covariant:
	NonEmpty[] <: IntSeT										#################################
problem:														#+----+  +--+     +--+   +----+ #
	NonEmpty[] a = new NonEmpty[](new NonEmpty(1,Empty,Empty))	#|a[N]|  |N | +-> |N |   |b[E]| #
	IntSeT[] b = a                                              #+------>---+     +--+<-------+ #
	b[0] = Empty                                                # a=N                    a=E    #
	NonEmpty s = a[0]                                           #################################
fix:
	so java stores a type of array during runtime and will throw ArrayStoreException
Arrays in Scala arrays are not covariant:
	val a: Array[NonEmpty] = Array(new NonEmpty(1, Empty, Empty))
	val b: Array[IntSeT] = a		# type error during compilation
	
	
- variance
	C[A] <: C[B]	covariant		class C[+A]
	C[A] >: C[B]	contravariant	class C[-A]

question: what is the relation:
	type A = IntSet => NonEmpty		(you can do same here)
	type B = NonEmpty => IntSet		(you can pass NonEmpty and get IntSet)
answer: A < B
...


- pattern matching (for decomposition)
	trait Expr{...}
	case class Numbber(n: Int) extends Expr
	case class Sum(e1: Expr, e2: Expr) extends Expr
case class adds companion object
	object Number{
		def apply(n:Int) = new Numbber(n)}
pattern matching:
	def eval (e: Expr): Int = e match{
		case Number(n) => n
		case Sum(e1,e2) => eval(e1) + eval(e2)
	}


- lists
	List(1,2,3,4)
all lists are constructed Nil and :: (pronounced cons)
	x::xs					gives a new list with first elem x followed by elements of xs
	1::(2::(3::(4::Nil)))
	or
	1::2::3::4::Nil			operators ending with : are method caals of right operand
	is equivalent to:
	Nil.::4.::3.::2.::1.::
list patterns:
	1::2::xs		starts with 1 and 2
	x::Nil			one element
	List(x)			one element
	List()			empty
	Nil				empty
	List(2::xs)		contains another list as onlu element and inner list starts with 2
sort list(insertion sort):
	def isort(xs: List[Int]) = xs match {	# def insert(x:Int, xs: List[Int]): List[Int] = xs match {
		case List() => List()               # 	case List() => List(x)
		case y::ys => insert(y, isort(ys))  # 	case y::ys => if(x<=y) x::xs else y::insert(x,ys)
	}                                       # }	


	
	
