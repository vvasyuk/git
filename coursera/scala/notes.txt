###############
# week 1
###############

- call by value(default)
def callByValue(x: Int) = {}	# evaluated once when entering method
- call by name
def callByName(x: => Int) = {}	# evaluated each time when called

- conditionals
def and(x:Boolean, y:Boolean) = if (x) y else false

- square root
def sqrt(x:Int) = srtIter(1.0,x)
def srtIter(guess: Double, x:Double):Double = if (isGoodEnough(guess,x)) guess else sqrtIter(improve(guess,x)x)
def isGoodEnough(guess:Double, x:Double) = abs(guess*guess-x)/x < 0.001
def improve(guess:Double, x:Double) = abs(guess+x/guess)/2

- greatest common divisor
def gcd(a:Int, b:Int) = if (b==0) a else gcd(b, a%b)

- factorial
def factorial(n:Int) = if (n==0) 1 else n*factorial(n-1)
- factorial (tail)
def factorialTail(n:Int):Int = {
	def loop(acc:Int, n:Int) = if (n==0) acc else loop(acc*n, n-1)
	loop(1,n)
}

###############
# week 2
###############
- higher order function
def sum(f:Int=>Int, a:Int, b:Int) = if (a>b) 0 else f(a)+sum(f,a+1,b)	
sum((x:Int)=>x*x*x,a,b)		# sum of cubes between a and b

def sum(f: Int => Int, a: Int, b: Int): Int = {
  def loop(a: Int, acc: Int): Int = {
    if (a>b) acc
    else loop(a+1, f(a)+acc)
  }
  loop(a, 0)
}

- currying
def sum(f: Int => Int): (a: Int, b: Int)=>Int = {
  def sumF(a: Int, b: Int): Int = {
    if (a>b) 0 else f(a)+sumF(a+1,b)
  }
  sumF
}
or
def sum(f: Int => Int)(a: Int, b: Int):Int = if (a>b) 0 else f(a)+sum(f)(a+1,b)
sum((x:Int)=>x*x*x) (a,b)

def mapReduce(f:Int=>Int, combine:(Int,Int)=>Int,zero:Int)(a: Int, b: Int):Int=
	if (a>b) zero else combine(f(a),mapReduce(f,combine,zero)(a+1,b))
def product(f:Int=Int)(a:Int,b:Int):Int = mapReduce(f,(x,y)=>x*y,1)(a,b)

- fixed points (x-fixed point if f(x)=x, example x=1+x/2 (x=2 fixed point))
# sqrt of x = y*y so y = x/y # x is a fixed point of y = x/y 
def isCloseEnough(x:Double, y:Double) = abs((x-y)/x)/x < 0.0001
def fixedPoint(f:Double=>Double)(firstGuess:Double)={
	def iterate(guess:Double):Double={
		val next = f(guess)
		if(isCloseEnough(guess,next)) next else iterate(next)
	}
	iterate(firstGuess)
}
def averageDamp(f:Double=>Double)(x:Double) = (x+f(x))/2
def sqrt(x:Double) = fixedPoint(averageDamp(y=> x/y))(1)


###############
# week 3
###############

- tree
abstract class IntSet{																#incl 3
	def incl(x:Int): IntSet													        ########################################
	def contains(x:Int): Boolean                                                    #					+--+               #
	def union(other: IntSet): IntSet}                                               #					|7 |               #
                                                                                    #		   +--------+--+----+          #
object Empty extends IntSet{                                                        #	       |                |          #
	def contains(x:Int): Boolean = false                                            #		   |          +--+  |          #
	def incl(x:Int): IntSet = new NonEmpty(x, new Empty, new Empty)                 #		   |          |7 |  |          #
	def union(other: IntSet): IntSet = other                                        #		   |          +--+  |          #
}                                                                                   #		+--+     +--+    +--+          #
                                                                                    #		|5 |     |5 |    |12|          #
class NonEmpty(elem: Int, left: IntSet, right: IntSet) extends IntSet{              #		+--+     +--+    +--+          #
	def contains(x:Int): Boolean = {                                                #	+--+        e    e  e    e         #
		if (x<elem) left contains x                                                 #	|3 |                               #
		else if (x>elem) right contains x                                           #	+--+                               #
		else true}                                                                  #	e    e                             #
	def incl(x:Int): IntSet = {                                                     ########################################
		if (x<elem) new NonEmpty(elem, left incl x, right)                  
		if (x>elem) new NonEmpty(elem, left, right incl x)                  
		else this                                                           
		}
	def union(other: IntSet): IntSet = ((left union right) union other) incl elem
}

- scala classes hierarchy

#########################################################################################################
#+---+                                                                                                  #
#|any|                                                                                                  #
#+---+                                                                                                  #
#|    +------+                                                                                  +------+#
#+----+anyVal+-+--------+--------+--------+--------+--------+--------+--------+--------+<-------+Nothng|#
#|    +------+ |        |        |        |        |        |        |        |        |        +------+#
#|             +------+ +------+ +------+ +------+ +------+ +------+ +------+ +------+ +------+         #
#|             |Double| |Float | |Long  | |Int   | |Short | |Byte  | |Char  | |Bolean| |Unit  |         #
#|             +------+ +------+ +------+ +------+ +------+ +------+ +------+ +------+ +------+         #
#|                                                                                                      #
#|                                                                                                      #
#|    +------+                                     +------+                                             #
#+----+anyRef+-+--------+--------+--------+<-------+Null  |                                             #
#     +------+ |        |        |        |        +------+                                             #
#              +------+ +------+ +------+ +------+                                                      #
#              |Itrble+<+Seq   +<+List  | |Option|                                                      #
#              +------+ +------+ +------+ +------+                                                      #
#########################################################################################################

- polymorphism

#List(1,2,3)
#################
# +-+           #
# +-+           #
#1   +-+        #
#    +-+        #
#   2   +-+     #
#       +-+     #
#      3   Nil  #
#################

#Cons-List

trait List[T] {
	def isEmpty: Boolean
	def head: T
	def tail: List[T]
}

class Cons[T](val head: T, val tail: List[T]) extends List[T]{
	def isEmpty: = false}
	
class Nil[T] extends IntList[T] {
	def isEmpty: = true
	def head: Nothing = throw new Exception
	def tail: Nothing = throw new Exception}

- take nth elem
	def nth(n:Int, xs:List[T]):T = if (n==0) xs.head else nth(n-1, xs.tail)
	
###############
# week 4
###############	
-object everywhere

abstract class Nat{					# object Zero extends Nat{																# object Succ(n:Nat) extends Nat{
	def isZero: Boolean             #    	def isZero: true                                                                # 	def isZero: false
	def predecessor: Nat            #    	def predecessor: throw new Error("0.predecessor")                               # 	def predecessor:  n
	def successor: new Succ(this)   #    	def -(that:Nat): that                                                           # 	def -(that:Nat): n-that.predecessor
	def -(that:Nat): Nat            #    	def +(that:Nat): if(this.isZero) this else throw new Error("negative number")}  # 	def +(that:Nat): new Succ(n+that)}
	def +(that:Nat): Nat}           #                                                                                       # 
	











