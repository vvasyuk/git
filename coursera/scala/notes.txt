###############
# week 1
###############

- call by value(default)
def callByValue(x: Int) = {}	# evaluated once when entering method
- call by name
def callByName(x: => Int) = {}	# evaluated each time when called

- conditionals
def and(x:Boolean, y:Boolean) = if (x) y else false

- square root
def sqrt(x:Int) = srtIter(1.0,x)
def srtIter(guess: Double, x:Double):Double = if (isGoodEnough(guess,x)) guess else sqrtIter(improve(guess,x)x)
def isGoodEnough(guess:Double, x:Double) = abs(guess*guess-x)/x < 0.001
def improve(guess:Double, x:Double) = abs(guess+x/guess)/2

- greatest common divisor
def gcd(a:Int, b:Int) = if (b==0) a else gcd(b, a%b)

- factorial
def factorial(n:Int) = if (n==0) 1 else n*factorial(n-1)
- factorial (tail)
def factorialTail(n:Int):Int = {
	def loop(acc:Int, n:Int) = if (n==0) acc else loop(acc*n, n-1)
	loop(1,n)
}

###############
# week 2
###############
- higher order function
def sum(f:Int=>Int, a:Int, b:Int) = if (a>b) 0 else f(a)+sum(f,a+1,b)	
sum((x:Int)=>x*x*x,a,b)		# sum of cubes between a and b

def sum(f: Int => Int, a: Int, b: Int): Int = {
  def loop(a: Int, acc: Int): Int = {
    if (a>b) acc
    else loop(a+1, f(a)+acc)
  }
  loop(a, 0)
}

- currying
def sum(f: Int => Int): (a: Int, b: Int)=>Int = {
  def sumF(a: Int, b: Int): Int = {
    if (a>b) 0 else f(a)+sumF(a+1,b)
  }
  sumF
}
or
def sum(f: Int => Int)(a: Int, b: Int):Int = if (a>b) 0 else f(a)+sum(f)(a+1,b)
sum((x:Int)=>x*x*x) (a,b)

def mapReduce(f:Int=>Int, combine:(Int,Int)=>Int,zero:Int)(a: Int, b: Int):Int=
	if (a>b) zero else combine(f(a),mapReduce(f,combine,zero)(a+1,b))
def product(f:Int=Int)(a:Int,b:Int):Int = mapReduce(f,(x,y)=>x*y,1)(a,b)

- fixed points (x-fixed point if f(x)=x, example x=1+x/2 (x=2 fixed point))
# sqrt of x = y*y so y = x/y # x is a fixed point of y = x/y 
def isCloseEnough(x:Double, y:Double) = abs((x-y)/x)/x < 0.0001
def fixedPoint(f:Double=>Double)(firstGuess:Double)={
	def iterate(guess:Double):Double={
		val next = f(guess)
		if(isCloseEnough(guess,next)) next else iterate(next)
	}
	iterate(firstGuess)
}
def averageDamp(f:Double=>Double)(x:Double) = (x+f(x))/2
def sqrt(x:Double) = fixedPoint(averageDamp(y=> x/y))(1)


###############
# week 3
###############

- tree
abstract class IntSet{																#incl 3
	def incl(x:Int): IntSet													        ########################################
	def contains(x:Int): Boolean                                                    #					+--+               #
	def union(other: IntSet): IntSet}                                               #					|7 |               #
                                                                                    #		   +--------+--+----+          #
object Empty extends IntSet{                                                        #	       |                |          #
	def contains(x:Int): Boolean = false                                            #		   |          +--+  |          #
	def incl(x:Int): IntSet = new NonEmpty(x, new Empty, new Empty)                 #		   |          |7 |  |          #
	def union(other: IntSet): IntSet = other                                        #		   |          +--+  |          #
}                                                                                   #		+--+     +--+    +--+          #
                                                                                    #		|5 |     |5 |    |12|          #
class NonEmpty(elem: Int, left: IntSet, right: IntSet) extends IntSet{              #		+--+     +--+    +--+          #
	def contains(x:Int): Boolean = {                                                #	+--+        e    e  e    e         #
		if (x<elem) left contains x                                                 #	|3 |                               #
		else if (x>elem) right contains x                                           #	+--+                               #
		else true}                                                                  #	e    e                             #
	def incl(x:Int): IntSet = {                                                     ########################################
		if (x<elem) new NonEmpty(elem, left incl x, right)                  
		if (x>elem) new NonEmpty(elem, left, right incl x)                  
		else this                                                           
		}
	def union(other: IntSet): IntSet = ((left union right) union other) incl elem
}

- scala classes hierarchy

#########################################################################################################
#+---+                                                                                                  #
#|any|                                                                                                  #
#+---+                                                                                                  #
#|    +------+                                                                                  +------+#
#+----+anyVal+-+--------+--------+--------+--------+--------+--------+--------+--------+<-------+Nothng|#
#|    +------+ |        |        |        |        |        |        |        |        |        +------+#
#|             +------+ +------+ +------+ +------+ +------+ +------+ +------+ +------+ +------+         #
#|             |Double| |Float | |Long  | |Int   | |Short | |Byte  | |Char  | |Bolean| |Unit  |         #
#|             +------+ +------+ +------+ +------+ +------+ +------+ +------+ +------+ +------+         #
#|                                                                                                      #
#|                                                                                                      #
#|    +------+                                     +------+                                             #
#+----+anyRef+-+--------+--------+--------+<-------+Null  |                                             #
#     +------+ |        |        |        |        +------+                                             #
#              +------+ +------+ +------+ +------+                                                      #
#              |Itrble+<+Seq   +<+List  | |Option|                                                      #
#              +------+ +------+ +------+ +------+                                                      #
#########################################################################################################

- polymorphism

#List(1,2,3)
#################
# +-+           #
# +-+           #
#1   +-+        #
#    +-+        #
#   2   +-+     #
#       +-+     #
#      3   Nil  #
#################

#Cons-List

trait List[T] {
	def isEmpty: Boolean
	def head: T
	def tail: List[T]}
class Cons[T](val head: T, val tail: List[T]) extends List[T]{
	def isEmpty: = false}	
class Nil[T] extends IntList[T] {
	def isEmpty: = true
	def head: Nothing = throw new Exception
	def tail: Nothing = throw new Exception}
object List{
	//List(1,2) = List.apply(1,2)
	def apply[T](x1:T,x2:T): List[T] = new Cons(x1, new Cons(x2,new Nil)) 
}
	

- take nth elem
	def nth(n:Int, xs:List[T]):T = if (n==0) xs.head else nth(n-1, xs.tail)
	
###############
# week 4
###############	
-object everywhere

abstract class Nat{					# object Zero extends Nat{																# object Succ(n:Nat) extends Nat{
	def isZero: Boolean             #    	def isZero: true                                                                # 	def isZero: false
	def predecessor: Nat            #    	def predecessor: throw new Error("0.predecessor")                               # 	def predecessor:  n
	def successor: new Succ(this)   #    	def -(that:Nat): that                                                           # 	def -(that:Nat): n-that.predecessor
	def -(that:Nat): Nat            #    	def +(that:Nat): if(this.isZero) this else throw new Error("negative number")}  # 	def +(that:Nat): new Succ(n+that)}
	def +(that:Nat): Nat}           #                                                                                       # 
	

- functions as objects
val f = (x:Int) => x*x*x
f(7)
would be 
val f = new Function[Int,Int]{ def apply(x:Int) = x*x }
f.apply(7)


- subtyping and generics (which are prinicpals of polymorphism)
	upper bounds - s can be only subtype of IntSet
	def assertAllPos (s <: IntSeT): IntSet
	lower bounds - s can be only supertype of IntSet
	def assertAllPos (s >: IntSeT): IntSet
	mix bounds - s can be any type interval between NonEmpty and IntSeT
	[s >: NonEmpty <: IntSet]
	
Arrays in Java are covariant:
	NonEmpty[] <: IntSeT										#################################
problem:														#+----+  +--+     +--+   +----+ #
	NonEmpty[] a = new NonEmpty[](new NonEmpty(1,Empty,Empty))	#|a[N]|  |N | +-> |N |   |b[E]| #
	IntSeT[] b = a                                              #+------>---+     +--+<-------+ #
	b[0] = Empty                                                # a=N                    a=E    #
	NonEmpty s = a[0]                                           #################################
fix:
	so java stores a type of array during runtime and will throw ArrayStoreException
Arrays in Scala arrays are not covariant:
	val a: Array[NonEmpty] = Array(new NonEmpty(1, Empty, Empty))
	val b: Array[IntSeT] = a		# type error during compilation
	
	
- variance
	C[A] <: C[B]	covariant		class C[+A]
	C[A] >: C[B]	contravariant	class C[-A]

question: what is the relation:
	type A = IntSet => NonEmpty		(you can do same here)
	type B = NonEmpty => IntSet		(you can pass NonEmpty and get IntSet)
answer: A < B
...


- pattern matching (for decomposition)
	trait Expr{...}
	case class Numbber(n: Int) extends Expr
	case class Sum(e1: Expr, e2: Expr) extends Expr
case class adds companion object
	object Number{
		def apply(n:Int) = new Numbber(n)}
pattern matching:
	def eval (e: Expr): Int = e match{
		case Number(n) => n
		case Sum(e1,e2) => eval(e1) + eval(e2)
	}


- lists
	List(1,2,3,4)
all lists are constructed Nil and :: (pronounced cons)
	x::xs					gives a new list with first elem x followed by elements of xs
	1::(2::(3::(4::Nil)))
	or
	1::2::3::4::Nil			operators ending with : are method caals of right operand
	is equivalent to:
	Nil.::4.::3.::2.::1.::
list patterns:
	1::2::xs		starts with 1 and 2
	x::Nil			one element
	List(x)			one element
	List()			empty
	Nil				empty
	List(2::xs)		contains another list as onlu element and inner list starts with 2
sort list(insertion sort):
	def isort(xs: List[Int]) = xs match {	# def insert(x:Int, xs: List[Int]): List[Int] = xs match {
		case List() => List()               # 	case List() => List(x)
		case y::ys => insert(y, isort(ys))  # 	case y::ys => if(x<=y) x::xs else y::insert(x,ys)
	}                                       # }	


###############
# week5
###############	

- more functions on list
	xs.last				last element
	xs.init				all except for last element
	xs.take				list of first n elements
	xs.drop				rest of list after taking n
	xs ++ ys 			concats - cxs will be in the start
	xs updated (n,x)	returns new list updating n element

	def last[T](xs: List[T]):T = xs match{	# def init[T](xs: List[T]):List[T] = xs match{
		case List() => throw new Error("")  # 	case List() => throw new Error("")
		case List(x) => x                   # 	case List(x) => List()
		case y::ys => last(ys)}             # 	case y::ys => y::init(ys)}
											#########################
	def concat[T](xs: List[T], ys: List[T]):List[T] =xs match{		#def reverse[T](xs: List[T]):List[T] = xs match{
		case List() => ys                                           #	case List() => xs
		case z::zs => z::concat(zs, ys)}                            #	case y::ys => reverse(ys) ++ List(y)}
	
	def removeAt[T](n: Int, xs: List[T]) = (xs take n) ::: (xs drop n+1)


- tuples
	non-Parametrized														# Parametrized
	def msort(xs: List[Int]): List[Int] = {									# def msort[T](xs: List[T])(lt:(T,T) => Boolean): List[T] = {
		val n = xs.length/2                                                 # 	val n = xs.length/2
		if(n==0) xs                                                         # 	if(n==0) xs
		else{                                                               # 	else{
			def merge (xs: List[Int], ys: List[Int]) = (xs, ys) match{      # 		def merge (xs: List[T], ys: List[T]) = (xs, ys) match{
				case (Nil, ys) => ys                                        # 			case (Nil, ys) => ys
				case (xs, Nil) => xs                                        # 			case (xs, Nil) => xs
				case (x :: xs1, y::ys1) => if (x<y) x::merge(xs1,ys)        # 			case (x :: xs1, y::ys1) => if (lt(x,y)) x::merge(xs1,ys)
				else y::merge(xs, ys1)                                      # 			else y::merge(xs, ys1)
			}                                                               # 		}
			val (fst, snd) = xs.splitAt(n)                                  # 		val (fst, snd) = xs.splitAt(n)
			merge(msort(fst), msort(snd))}}                                 # 		merge(msort(fst)(lt), msort(snd)(lt))}}
																			#  msort(nums)(x,y)=>x<y)

- implicit parameters

	import scala.math.Ordering                                              # using implicit
	def msort[T](xs: List[T])(ord: Ordering[T]): List[T] = {                # def msort[T](xs: List[T])(implicit ord: Ordering[T]): List[T] = {                
		val n = xs.length/2                                                 # 	val n = xs.length/2                                                 
		if(n==0) xs                                                         # 	if(n==0) xs                                                         
		else{                                                               # 	else{                                                               
			def merge (xs: List[T], ys: List[T]) = (xs, ys) match{          # 		def merge (xs: List[T], ys: List[T]) = (xs, ys) match{          
				case (Nil, ys) => ys                                        # 			case (Nil, ys) => ys                                        
				case (xs, Nil) => xs                                        # 			case (xs, Nil) => xs                                        
				case (x :: xs1, y::ys1) => if (ord.lt(x,y)) x::merge(xs1,ys)# 			case (x :: xs1, y::ys1) => if (ord.lt(x,y)) x::merge(xs1,ys)
				else y::merge(xs, ys1)                                      # 			else y::merge(xs, ys1)                                      
			}                                                               # 		}                                                               
			val (fst, snd) = xs.splitAt(n)                                  # 		val (fst, snd) = xs.splitAt(n)                                  
			merge(msort(fst)(ord), msort(snd)(ord))}}                       # 		merge(msort(fst), msort(snd))}}
	msort(nums)(Ordering.Int)                                               # msort(nums)

- higher order functions
map,filter
	abstract class List[T]{...                  # 
	def map[U](f: T=>U):List[U] = this match{	# def filter(p: T=>Boolean): List[T] = this match{
		case Nil => this                        # 	case Nil => this
		case x::xs => f(x)::xs.map(f)}}         # 	case x::xs => if(p(x)) x :: xs.filter(p) else xs.filter(p)}
	xs.map(x=>x*x)                              # xs.filter(x=>x>0)
	
	val xs = List(2,-4,5,7,1)
	xs.span(x=>x>0)				# (List(2), List(-4,5,7,1))
	
task: pack consecutive duplocates into sublists
	pack(List(a,a,a,b,c,c,a))	=>	List(List(a,a,a),List(b),List(c,c),List(a))
solution
	def pack[T](xs:List[T]): List[List[T]] = xs match{
		case Nil => Nil
		case xs :: xs1 => 
			val(first,rest) = xs.span(y=> y==y)
			first::pack(rest)}
task: using pack produce lenght of lists like List((a,3),(b,1)...)
solution:
	def encode[T](xs:List[T]): List[(T,Int)] = xs match{
		pack(xs) map (ys => (ys.head, ys.length))}


- reduction
can be implemented using usual recursive schema:
	def sum(xs:List[Int]):Int = xs match{
		case Nil => 0
		case y::ys => y+sum(ys)}
reduceLeft (can be applied to non empty lists)					###############	    #	foldLeft (can be applied to empty lists)						###############
                                                                #     +--+    #     #   	def sum (xs:List[Int]) = (xs foldLeft 0)(_+_)               #     +--+    #
	abstract class List[T]{                                     #     |op|    #     #   	                                                            #     |op|:U  #
	def reduceLeft(op: (T,T)=>T):T = this match{                #     +--+    #     #   	abstract class List[T]{                                     #     +--+    #
		case Nil => throw new Error("")                         # +--+    xn  #     #   	def foldLeft[U](z:U)(op: (U,T)=>U):U = this match{          # +--+    xn:T#
		case x::xs => (xs foldLeft x)(op)}}                     # |op|        #     #   		case Nil => z                                           # |op|:U      #
                                                                # +--+        #     #   		case x::xs => (xs foldLeft op(z,x))(op)}}               # +--+        #
	def sum (xs:List[Int]) = (0::xs) reduceLeft ((x,y) => x+y)	#0    x1      #		#	                                                                #z:U  x1:T    #
	                                                            ###############     #   	                                                            ###############

																					#
foldRight														############		#	to concat two lists only foldRight would work					##############
	abstract class List[T]{                                     # +--+     #        #   	def concat[T](xs: List[T], ys: List[T]): List[T] =          # +--+       #
	def foldRight[U](z:U)(op: (T,U)=>U):U = this match{         # |op|     #        #   		(xs foldRight ys)(_ :: _)                               # |::|       #
		case Nil => z                                           # +--+     #        #   because you can call :: on Nil and not on any T                 # +--+       #
		case x::xs => op(x, (xs foldRight z)(op))               #x1   +--+ #        #   		                                                        #x1   +--+   #
                                                                #     |op| #        #                                                                   #     |::|   #
                                                                #     +--+ #        #                                                                   #     +--+   #
                                                                #    xn   z#        #                                                                   #    y1   Nil#
                                                                ############        #                                                                   ##############

asdfg