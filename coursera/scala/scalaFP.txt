--------------------
| functional programming
--------------------
    - removing side effect
      +------------------------------------------------------+    +--------------------------------------------------------------------+  +-----------------------------------------------------------------------+
      | class Cafe {                                         |    | case class Charge(cc: CreditCard, amount: Double) {                |  | def buyCoffees(cc: CreditCard, n: Int): (List[Coffee], Charge) = {    |
      |   def buyCoffee(cc: CreditCard): (Coffee, Charge) = {|    |   def combine(other: Charge): Charge =                             |  |   val purchases: List[(Coffee, Charge)] = List.fill(n)(buyCoffee(cc)) |
      |     val cup = new Coffee(                            |    |     if (cc == other.cc)                                            |  |   val (coffees, charges) = purchases.unzip                            |
      |     (cup, Charge(cc, cup.price)                      |    |       Charge(cc, amount plus other.amount)                         |  |   (coffees, charges.reduce((c1,c2) => c1.combine(c2)))                |
      |   }                                                  |    |     else                                                           |  | }                                                                     |
      | }                                                    |    |       throw new Exception(Cant combine charges to different cards) |  +-----------------------------------------------------------------------+
      +------------------------------------------------------+    | }                                                                  |
                                                                  +--------------------------------------------------------------------+

    - functional programming in Scala
      - writing loops functionally                - higher-order function
      +-------------------------------------+     +-----------------------------------------------------------+
      |   def factorial(n: Int): Int = {    |     | def formatResult(name: String, n: Int, f: Int => Int) = { |
      |     def go(n: Int, acc: Int): Int = |     |   val msg = "The %s of %d is %d."                         |
      |       if (n <= 0) acc               |     |   msg.format(name, n, f(n))                               |
      |       else go(n-1, n*acc)           |     | }                                                         |
      |     go(n, 1)                        |     +-----------------------------------------------------------+
      |   }                                 |
      +-------------------------------------+
    - polymorphic functions: abstracting over types
      +----------------------------------------------------------+
      | def findFirst[A](as: Array[A], p: A => Boolean): Int = { |
      |   @annotation.tailrec                                    |
      |   def loop(n: Int): Int =                                |
      |     if (n >= as.length) -1                               |
      |     else if (p(as(n))) n                                 |
      |     else loop(n + 1)                                     |
      |   loop(0)                                                |
      | }                                                        |
      +----------------------------------------------------------+
    - isSorted
      +-----------------------------------------------------------------------+
      | def isSorted[A](as: Array[A], ordered: (A,A) => Boolean): Boolean = { |
      |   def loop(a: Int, b: Int, as: Array[A]): Boolean = {                 |
      |     b match {                                                         |
      |       case i if i == as.size => true                                  |
      |       case i if ordered(as(a), as(b)) => loop(b, b+1, as)             |
      |       case _ => false                                                 |
      |     }                                                                 |
      |   }                                                                   |
      |   loop(0, 1, as)                                                      |
      | }                                                                     |
      +-----------------------------------------------------------------------+
    - partial function
      +----------------------------------------------------+
      | def partial1[A,B,C](a: A, f: (A,B) => C): B => C = |  // value returned by partial1 will be a function, of type B => C
      |   (b: B) => f(a, b)                                |  // B = we have it; to return C = we need to call teh function
      +----------------------------------------------------+
    - curry                                                     - example usage
      +-----------------------------------------------------+   +----------------------------------+
      | def curry[A,B,C](f: (A, B) => C): A => (B => C) = { |   | val fSum = (a:Int, b:Int) => a+b |
      |   (a:A) => (b:B) => f(a,b)                          |   | val partial1 = curry(fSum)       |
      | }                                                   |   | assert(fSum(1,1) == 2)           |
      +-----------------------------------------------------+   | assert(partial1(1)(1) == 2)      |
                                                                | val partial2 = partial1(1)       |
                                                                | assert(partial2(1) == 2)         |
                                                                +----------------------------------+
    - uncurry                                                   - example usage
      +----------------------------------------------------+    +-----------------------------------------+
      | def uncurry[A,B,C](f: A => B => C): (A, B) => C ={ |    |   val fSum = (a:Int) => (b:Int) => a+b  |
      |   (a: A, b: B) => f(a)(b)                          |    |   assert(fSum(1)(1)==2)                 |   
      | }                                                  |    |   val fSumUncurry = uncurry(fSum)       |
      +----------------------------------------------------+    |   assert(fSumUncurry(1, 1)==2)          |
                                                                +-----------------------------------------+
    - compose                                                   - example usage
      +-----------------------------------------------------+   +-------------------------------+
      | def compose[A,B,C](f: B => C, g: A => B): A => C ={ |   | val f1 = (a:Int) => a+1       |
      |   (a: A) => f(g(a))                                 |   | val f2 = (b:Int) => b+2       |
      | }                                                   |   | val composed = compose(f1,f2) |
      +-----------------------------------------------------+   | assert(composed(1)==4)        |
                                                                +-------------------------------+

--------------------
| functional data structures
--------------------
  -singly linked lists
    +-------------------------------------------------------------+
    | sealed trait List[+A]                                       |   // sealed means that all implementations of the trait must be declared in this file
    | case object Nil extends List[Nothing]                       |   // [+A] - covariant or positive (List[Dog] subtype of List[Animal] if Dog subtype of Animal)
    | case class Cons[+A](head: A, tail: List[A]) extends List[A] |   // Nil extends List[Nothing]. Nothing subtype of all types Nil can be considered a List[Int], a List[Double]
    | object List {                                               |   
    |   def sum(ints: List[Int]): Int = ints match {              |   List("a","b")   
    |     case Nil => 0                                           |   Cons(a,cons(b,Nil))
    |     case Cons(x,xs) => x + sum(xs)                          |   cons    cons
    |   }                                                         |   +---+   +---+
    |   def product(ds: List[Double]): Double = ds match {        |   |a|.+-->+b|.|
    |     case Nil => 1.0                                         |   +---+   +---+
    |     case Cons(0.0, _) => 0.0                                |
    |     case Cons(x,xs) => x * product(xs)                      |
    |   }                                                         |
    |   def apply[A](as: A*): List[A] =                           |   // Variadic function syntax.
    |     if (as.isEmpty) Nil                                     |
    |     else Cons(as.head, apply(as.tail: _*))                  |
    | }                                                           |
    +-------------------------------------------------------------+

  -pattern matching
    List(1,2,3) match { case _ => 42 }          // _ matches any expression
    List(1,2,3) match { case Cons(h,_) => h }   // 1
    List(1,2,3) match { case Cons(_,t) => t }   // 2,3
    List(1,2,3) match { case Nil => 42 }        // MatchError

  - data sharing in functional data structures
    - when we add element to fron of list - we return new list - initial list is unharmed
      we do not copy elements - we reuse them as they are immutable
    +--------------------------------------------------+    +------------------------------------------------------------------+
    | def tail[A](l: myList[A]): myList[A] = l match { |    | def setHeader[A](l: myList[A], header: A): myList[A] = l match { |
    |     case Nil => sys.error("tail of empty list")  |    |   case Nil => Cons(header, Nil)                                  |
    |     case Cons(_,t) => t                          |    |   case Cons(_,t) => Cons(header, t)                              |
    | }                                                |    | }                                                                |
    +--------------------------------------------------+    +------------------------------------------------------------------+

  - efficiency of data sharing
    +--------------------------------------------------+  +------------------------------------------------------------------------+
    | def drop[A](l: myList[A], n: Int): myList[A] = { |  | def dropWhile[A](l: myList[A], f: A => Boolean): myList[A] = l match { |
    |   if (n <= 0) l                                  |  |   case Cons(h,t) if f(h) => dropWhile(t, f)                            |
    |   else l match {                                 |  |   case _ => l                                                          |
    |     case Nil => Nil                              |  | }                                                                      |
    |     case Cons(_,t) => drop(t, n-1)               |  +------------------------------------------------------------------------+
    |   }                                              |
    | }                                                |
    +--------------------------------------------------+

    +---------------------------------------------------------------------+
    | def append[A](a1: myList[A], a2: myList[A]): myList[A] = a1 match { |
    |   case Nil => a2                                                    |
    |   case Cons(h,t) => Cons(h, append(t, a2))                          |
    | }                                                                   |
    +---------------------------------------------------------------------+
  - bad performance
    +-------------------------------------------------+   +--------------------------------------------------+
    | def init2[A](l: List[A]): List[A] = {           |   | def init[A](l: myList[A]): myList[A] = l match { |
    |   import collection.mutable.ListBuffer          |   |   case Nil => sys.error("init of empty list")    |
    |   val buf = new ListBuffer[A]                   |   |   case Cons(_,Nil) => Nil                        |
    |   @annotation.tailrec                           |   |   case Cons(h,t) => Cons(h,init(t))              |
    |   def go(cur: List[A]): List[A] = cur match {   |   | }                                                |
    |     case Nil => sys.error("init of empty list") |   +--------------------------------------------------+
    |     case Cons(_,Nil) => List(buf.toList: _*)    |
    |     case Cons(h,t) => buf += h; go(t)           |
    |   }                                             |
    |   go(l)                                         |
    | }                                               |
    +-------------------------------------------------+
  - Vector - purely functional sequence structure, supports constant time access, head,tail,init,addition to front or rear.

  - Recursion over lists and generalizing to higher-order functions
    +----------------------------------------------------------------------+  +------------------------------------------------------------+
    | def foldRight[A,B](as: List[A], z: B)(f: (A, B) => B): B =as match { |  | def sum2(ns: List[Int]) = foldRight(ns, 0)((x,y) => x + y) |
    |   case Nil => z                                                      |  +------------------------------------------------------------+
    |   case Cons(x, xs) => f(x, foldRight(xs, z)(f))                      |  +------------------------------------------------------------+
    | }                                                                    |  | def product2(ns: List[Double]) = foldRight(ns, 1.0)(_ * _) |
    +----------------------------------------------------------------------+  +------------------------------------------------------------+
    - trace foldRight foldRight must traverse all the way to the end of the list (pushing frames onto the call)
      foldRight(Cons(1, Cons(2, Cons(3, Nil))), 0)((x,y) => x + y)
      1 + foldRight(Cons(2, Cons(3, Nil)), 0)((x,y) => x + y)
      1 + (2 + foldRight(Cons(3, Nil), 0)((x,y) => x + y))
      1 + (2 + (3 + (foldRight(Nil, 0)((x,y) => x + y))))
      1 + (2 + (3 + (0)))
      6

  - product                                                   -length
    +------------------------------------------------------+  +-------------------------------------------+
    | def product(ds: myList[Double]): Double = ds match { |  | def length(as: myList[Int]): Int = {      |
    |   case Nil => 1.0                                    |  |   myList.foldRight(as, 0)((x,y) => 1 + y) |
    |   case Cons(0.0, _) => 0.0                           |  | }                                         |
    |   case Cons(x,xs) => x * product(xs)                 |  +-------------------------------------------+
    | }                                                    |
    |                                                      |
    +------------------------------------------------------+

  - foldLeft (tailrec - no stackoverflow)
    +----------------------------------------------------------------------+
    | def foldLeft[A,B](l: myList[A], z: B)(f: (B, A) => B): B = l match { |
    |   case Nil => z                                                      |
    |   case Cons(h,t) => foldLeft(t, f(z,h))(f)                           |
    | }                                                                    |
    +----------------------------------------------------------------------+

  - foldRightViaFoldLeft                                                    - foldLeftViaFoldRight
    +----------------------------------------------------------------------+  +----------------------------------------------------------------------+
    | def foldRightViaFoldLeft[A,B](l: List[A], z: B)(f: (A,B) => B): B =  |  | def foldLeftViaFoldRight[A,B](l: List[A], z: B)(f: (B,A) => B): B =  |
    |   foldLeft(reverse(l), z)((b,a) => f(a,b))                           |  |   foldRight(l, (b:B) => b)((a,g) => b => g(f(b,a)))(z)               |
    +----------------------------------------------------------------------+  +----------------------------------------------------------------------+
  - appendViaFoldRight
    +-----------------------------------------------------------------------------------------------+
    | def appendViaFoldRight[A](l: myList[A], r: myList[A]): myList[A] = foldRight(l, r)(Cons(_,_)) |
    +-----------------------------------------------------------------------------------------------+
  - concat (3.15)
    +---------------------------------------------+
    | def concat[A](l: List[List[A]]): List[A] =  |
    |   foldRight(l, Nil:List[A])(append)         |
    +---------------------------------------------+
  - transform list (3.16)                                               - with foldRight
    +---------------------------------------------------------------+   +---------------------------------------------------------------+
    | def addOne(l: myList[Int], res: myList[Int]): myList[Int] = { |   | myList.foldRight(list, myList[Int]())((l,acc)=>Cons(l+1,acc)) |
    |   l match{                                                    |   +---------------------------------------------------------------+
    |     case Nil => res                                           |
    |     case Cons(a, _) => addOne(l.tail, Cons(a+1, res))         |
    |   }                                                           |
    | }                                                             |
    +---------------------------------------------------------------+
  = convert to list os strings
    +-------------------------------------------------------------------------+
    | myList.foldRight(list, myList[String]())((l,acc)=>Cons(l.toString,acc)) |
    +-------------------------------------------------------------------------+

  - map function                                                - not stack-safe with foldRight
    +------------------------------------------------------+      +------------------------------------------------------------+
    | def map_2[A,B](l: myList[A])(f: A => B): List[B] = { |      | myList.foldRight(as, myList[B]())((l,acc)=>Cons(f(l),acc)) |
    |   val buf = new collection.mutable.ListBuffer[B]     |      +------------------------------------------------------------+
    |   def go(l: myList[A]): Unit = l match {             |
    |     case Nil => ()                                   |
    |     case Cons(h,t) => buf += f(h); go(t)             |
    |   }                                                  |
    |   go(l)                                              |
    |   List(buf.toList: _*)                               |
    | }                                                    |
    +------------------------------------------------------+
  -filter                                                               - filter with flatMap
    +----------------------------------------------------------------+  +--------------------------------------------------------------+
    | def filter[A](as: myList[A])(f: A => Boolean): myList[A] = {   |  | def filter[A](as: myList[A])(f: A => Boolean): myList[A] = { |
    |   val buf = new collection.mutable.ListBuffer[A]               |  |   myList.flatMap(as)(x=>if (f(x)) myList(x) else Nil)        |
    |   def go(l: myList[A]): Unit = l match {                       |  | }                                                            |
    |     case Nil => ()                                             |  +--------------------------------------------------------------+
    |     case Cons(h,t) => {if (f(h)) {buf += h; go(t)} else go(t)} |
    |   }                                                            |
    |   go(as)                                                       |
    |   myList(buf.toList: _*)                                       |
    | }                                                              |
    +----------------------------------------------------------------+
  - flatMap
    +-------------------------------------------------------------------+
    | def flatMap[A,B](as: myList[A])(f: A => myList[B]): myList[B] = { |
    |   myList.concat(myList.map(as)(f))                                |
    | }                                                                 |
    +-------------------------------------------------------------------+
  - zipWith                                                                               - zipWith general
    +----------------------------------------------------------------------------------+  +----------------------------------------------------------------------------------------------+
    | def addPairwise(l1: myList[Int], l2: myList[Int]): myList[Int] = (l1,l2) match { |  | def zipWith[A,B,C](l1: myList[A], l2: myList[B])(f: (A,B) => C): myList[C] = (l1,l2) match { |
    |   case (Nil, _) => Nil                                                           |  |   case (Nil, _) => Nil                                                                       |
    |   case (_, Nil) => Nil                                                           |  |   case (_, Nil) => Nil                                                                       |
    |   case (Cons(h1,t1), Cons(h2,t2)) => Cons(h1+h2, addPairwise(t1,t2))             |  |   case (Cons(h1,t1), Cons(h2,t2)) => Cons(f(h1,h2), zipWith(t1,t2)(f))                       |
    | }                                                                                |  | }                                                                                            |
    +----------------------------------------------------------------------------------+  +----------------------------------------------------------------------------------------------+

  - trees
    List is and ADT - data type defined by one or more data constructors, each of which may contain zero or more arguments

    - tuple
      tuple is an ADT as well
      +-----------------------------------+
      | val p = ("Bob", 42)               |
      | p._1                              |
      | p._2                              |
      | p match { case (a,b) => b }       |
      +-----------------------------------+

    - binary tree
      bTree is an ADT as well
      +---------------------------------------------------------------------+
      | sealed trait Tree[+A]                                               |
      | case class Leaf[A](value: A) extends Tree[A]                        |
      | case class Branch[A](left: Tree[A], right: Tree[A]) extends Tree[A] |
      +---------------------------------------------------------------------+
    -size
      +----------------------------------------------+
      |   def size[A](t: myTree[A]): Int = t match { |
      |     case Leaf(_) => 1                        |
      |     case Branch(l,r) => 1+size(l)+size(r)    |
      |   }                                          |
      +----------------------------------------------+
    -max
      +---------------------------------------------+
      |   def maxi(t: myTree[Int]): Int = t match { |
      |     case Leaf(n) => n                       |
      |     case Branch(l,r) => maxi(l) max maxi(r) |
      |   }                                         |
      +---------------------------------------------+
    -depth
      +-------------------------------------------------------------------------------+
      |   def depth[A](t: myTree[A], currentDepth: Int): Int = t match {              |
      |     case Leaf(_) => currentDepth+1                                            |
      |     case Branch(l,r) => depth(l, currentDepth+1) max depth(r, currentDepth+1) |
      |   }                                                                           |
      +-------------------------------------------------------------------------------+
    -map
      +----------------------------------------------------------------+
      |   def map[A,B](t: myTree[A])(f: A => B): myTree[B] = t match { |
      |     case Leaf(n) => Leaf(f(n))                                 |
      |     case Branch(l,r) => Branch(map(l)(f), map(r)(f))           |
      |   }                                                            |
      +----------------------------------------------------------------+
    -fold                                                                         - size,max,depth with fold
      +------------------------------------------------------------------------+  +------------------------------------------------------------------------------------------+
      |   def fold[A,B](t: myTree[A])(f: A => B)(g: (B,B) => B): B = t match { |  |   def sizeViaFold[A](t: myTree[A]): Int = fold(t)(a => 1)(1 + _ + _)                     |
      |     case Leaf(a) => f(a)                                               |  |   def maximumViaFold(t: myTree[Int]): Int = fold(t)(a => a)(_ max _)                     |
      |     case Branch(l,r) => g(fold(l)(f)(g), fold(r)(f)(g))                |  |   def depthViaFold[A](t: myTree[A]): Int = fold(t)(a => 0)((d1,d2) => 1 + (d1 max d2))   |
      |   }                                                                    |  +------------------------------------------------------------------------------------------+
      +------------------------------------------------------------------------+

--------------------
| Handling errors without exceptions
--------------------
  Referential transparency - an expression is said to be referentially transparent if it can be replaced by its value and not change the program’s behaviour.
  Meaning of the expression throw new Exception("fail") is very context-dependent—as we just demonstrated, it takes on different meanings depending on which try block (if any) it’s nested within

  -Option
    -map - think of it as proceeding with a computation on the assumption that an error hasn’t occurred
    +---------------------------------------------------+
    | def map[B](f: A => B): myOption[B] = this match { |
    |   case None => None                               |
    |   case Some(x) => Some(f(x))                      |
    | }                                                 |
    +---------------------------------------------------+
    -getOrElse
    +--------------------------------------------------------+
    | def getOrElse[B >: A](default: => B): B = this match { |    to convert option back to exception
    |   case None => default                                 |    o.getOrElse(throw new Exception("FAIL"))
    |   case Some(x) => x                                    |
    | }                                                      |
    +--------------------------------------------------------+
    -flatMap                                                                  - map vs flatMap 
    +-------------------------------------------------------------------+     +-------------------------------------------------------------------------------------------------------------------------------+
    | def flatMap[B](f: A => myOption[B]): myOption[B] = {              |     |     val o1:myOption[Int] = Some(1)                                                                                            |
    |   map(f).getOrElse(None)                                          |     |     val o2:myOption[Int] = Some(3)                                                                                            |
    | }                                                                 |     |                                                                                                                               |
    | def flatMap_1[B](f: A => myOption[B]): myOption[B] = this match { |     |     val res = for{                                                                                                            |
    |   case None => None                                               |     |       a <- o1                                                                                                                 |
    |   case Some(a) => f(a)                                            |     |       b <- o2                                                                                                                 |
    | }                                                                 |     |       c <- o3                                                                                                                 |
    +-------------------------------------------------------------------+     |     } yield (a,b,c)                                                                                                           |
    if you nest flatMaps and last call is map - it will wrap res into Option  |                                                                                                                               |
    if you replace each flatMap with map - it will wrap in additional Options |     val res = o1.flatMap(a => o2.flatMap(b => o3.map(c => (a, b, c))))  // val res: myOption[(Int, Int, Int)]                 |
                                                                              |     val res = o1.map(a => o2.map(b => o3.map(c => (a, b, c))))          // res: myOption[myOption[myOption[(Int, Int, Int)]]] |
                                                                              +-------------------------------------------------------------------------------------------------------------------------------+
    -orElse
    +--------------------------------------------------------------------+  
    | def orElse[B>:A](ob: => myOption[B]): myOption[B] =                |  
    |   this map (Some(_)) getOrElse ob                                  |
    | def orElse_1[B>:A](ob: => myOption[B]): myOption[B] = this match { |
    |   case None => ob                                                  |
    |   case _ => this                                                   |
    | }                                                                  |
    +--------------------------------------------------------------------+
    -filter
    +---------------------------------------------------------+
    | def filter_1(f: A => Boolean): myOption[A] =            |
    |   flatMap(a => if (f(a)) Some(a) else None)             |
    | def filter(f: A => Boolean): myOption[A] = this match { |
    |   case Some(a) if f(a) => this                          |
    |   case _ => None                                        |
    | }                                                       |
    +---------------------------------------------------------+
    -variance
    +---------------------------------------------------------------------+
    | def variance(xs: Seq[Double]): Option[Double] =                     |
    |   mean(xs) flatMap (m => mean(xs.map(x => math.pow(x - m, 2))))     |
    +---------------------------------------------------------------------+

    -lift
      option map turns a function of type a=>b to a function Option[a]=>Option[b]
      +----------------------------------------------------------------------------------------+  +--------------------------------------------------+
      | def lift[A,B](f: A => B): myOption[A] => myOption[B] =  _ map f                        |  | def f(in:String):String=in + "a"                 |
      | or                                                                                     |  | val res: myOption[String] = fLifted(present)     |
      | def lift[A,B](f: A => B): myOption[A] => myOption[B] = (opt: myOption[A]) => opt map f |  +--------------------------------------------------+
      +----------------------------------------------------------------------------------------+

    -lift method with two parameters
      +------------------------------------------------------------------------+
      | def insuranceRateQuote(age: Int, numberOfSpeedingTickets: Int): Double |
      +------------------------------------------------------------------------+            - using for compehension
      +---------------------------------------------------------------------------------+   +-----------------------------------------------------------------------------------+
      | def map2[A,B,C](a: myOption[A], b: myOption[B])(f: (A, B) => C): myOption[C] ={ |   | def map2_2[A,B,C](a: myOption[A], b: myOption[B])(f: (A, B) => C): myOption[C] ={ |
      |   a flatMap (aa => b map (bb => f(aa, bb)))                                     |   |   for {                                                                           |
      | }                                                                               |   |     aa <- a                                                                       |
      | def insuranceRateQuote(age: Int, numberOfSpeedingTickets: Int): Double = {      |   |     bb <- b                                                                       |
      |   age+numberOfSpeedingTickets                                                   |   |   } yield f(aa, bb)                                                               |
      | }                                                                               |   | }                                                                                 |
      | val res = map2(a,b)(insuranceRateQuote)                                         |   +-----------------------------------------------------------------------------------+
      +---------------------------------------------------------------------------------+
    -traverse lift
      +----------------------------------------------------------------------+
      | def traverse[A, B](a: List[A])(f: A => Option[B]): Option[List[B]] = |
      |   a match {                                                          |
      |     case Nil => Some(Nil)                                            |
      |     case h::t => map2(f(h), traverse(t)(f))(_ :: _)                  |
      |   }                                                                  |
      +----------------------------------------------------------------------+

  -Either
    +-----------------------------------------------------------+
    | sealed trait Either[+E, +A]                               |
    | case class Left[+E](value: E) extends Either[E, Nothing]  |
    | case class Right[+A](value: A) extends Either[Nothing, A] |
    +-----------------------------------------------------------+

    +-------------------------------------------------------+
    | def safeDiv(x: Int, y: Int): Either[Exception, Int] = |
    |   try Right(x / y)                                    |
    |   catch { case e: Exception => Left(e) }              |
    +-------------------------------------------------------+
                                                                                              - validate data
    +-------------------------------------------------------------------------------------+   +----------------------------------------------------------------+
    |   def map[B](f: A => B): myEither[E, B] = this match {                              |   | def mkName(name: String): Either[String, Name] =               |
    |     case Left(e) => Left(e)                                                         |   |   if (name == "" || name == null) Left("Name is empty.")       |
    |     case Right(r) => Right(f(r))                                                    |   |   else Right(new Name(name))                                   |
    |   }                                                                                 |   | def mkAge(age: Int): Either[String, Age] =                     |
    |                                                                                     |   |   if (age < 0) Left("Age is out of range.")                    |
    |   def flatMap[EE >: E, B](f: A => myEither[EE, B]): myEither[EE, B] = this match {  |   |   else Right(new Age(age))                                     |
    |     case Left(e) => Left(e)                                                         |   | def mkPerson(name: String, age: Int): Either[String, Person] = |
    |     case Right(r) => f(r)                                                           |   |   mkName(name).map2(mkAge(age))(Person(_, _))                  |
    |   }                                                                                 |   +----------------------------------------------------------------+
    |                                                                                     |
    |   def orElse[EE >: E,B >: A](b: => myEither[EE, B]): myEither[EE, B] = this match { |
    |     case Left(_) => b                                                               |
    |     case Right(a) => Right(a)                                                       |
    |   }                                                                                 |
    |   def map2[EE >: E, B, C](b: myEither[EE, B])(f: (A, B) => C): myEither[EE, C] = {  |
    |     for { a <- this; b1 <- b } yield f(a,b1)                                        |
    |   }                                                                                 |
    +-------------------------------------------------------------------------------------+

--------------------
| Strictness and laziness
--------------------
  intermidiate lists will be produced by each function and passed to next function
  +---------------------------------------------------------+ square(41.0 + 1.0)
  | List(1,2,3,4).map(_ + 10).filter(_ % 2 == 0).map(_ * 3) | square will receive the evaluated value of 42.0
  +---------------------------------------------------------+

  -Strict and non-strict functions
    unless we tell it otherwise, any function definition in Scala will be strict
    +---------------------------------------+
    | def square(x: Double): Double = x * x |
    +---------------------------------------+
    
    Boolean functions && and || - are non-strict
    if is non-strict as well
    non-strict if function takes its arguments by name rather than by value
      +-------------------------------------------------------------------+
      | def if2[A](cond: Boolean, onTrue: () => A, onFalse: () => A): A = |  arguments we’d like to pass unevaluated have a () => immediately before their type
      |   if (cond) onTrue() else onFalse()                               |  argument that’s passed unevaluated to a function will be evaluated once for each place it’s referenced in the body of the function
      +-------------------------------------------------------------------+
      or
      +-------------------------------------------------------------+
      | def if2[A](cond: Boolean, onTrue: => A, onFalse: => A): A = |
      |   if (cond) onTrue else onFalse                             |
      +-------------------------------------------------------------+
      lazy keyword to a val declaration will cause Scala to delay evaluation of the right-hand side of that lazy val declaration until it’s first referenced
      will also cache the result so that subsequent references to it don’t trigger repeated evaluation

  - An extended example: lazy lists
    +-------------------------------------------------------------------------+
    | sealed trait Stream[+A]                                                 |
    | case class Cons[+A](h: () => A, t: () => Stream[A]) extends Stream[A]   |
    |                                                                         |
    | object Stream {                                                         |
    |   def cons[A](hd: => A, tl: => Stream[A]): Stream[A] = {                |
    |     lazy val head = hd                                                  |
    |     lazy val tail = tl                                                  |
    |     Cons(() => head, () => tail)                                        | 
    |   }                                                                     |   +------------------------------------------+
    |   def empty[A]: Stream[A] = Empty                                       |   | def headOption: Option[A] = this match { |
    |   def apply[A](as: A*): Stream[A] =                                     |   |   case Empty => None                     |
    |     if (as.isEmpty) empty else cons(as.head, apply(as.tail: _*))        |   |   case Cons(h, t) => Some(h())           |
    | }                                                                       |   | }                                        |
    +-------------------------------------------------------------------------+   +------------------------------------------+

  -stream to list                                           - take, drop                                                      - takeWhile
    +----------------------------------------------------+  +---------------------------------------------------------------+ +-----------------------------------------------------------+
    |   def toListFast: List[A] = {                      |  |   def take(n: Int): myStream[A] = this match {                | | def takeWhile(f: A => Boolean): Stream[A] = this match {  |
    |     val buf = new collection.mutable.ListBuffer[A] |  |     case StrCons(h, t) if n > 1 => cons(h(), t().take(n - 1)) | |   case Cons(h,t) if f(h()) => cons(h(), t() takeWhile f)  |
    |     @annotation.tailrec                            |  |     case StrCons(h, _) if n == 1 => cons(h(), myStream.empty) | |   case _ => empty                                         |
    |     def go(s: myStream[A]): List[A] = s match {    |  |     case _ => myStream.empty                                  | | }                                                         |
    |       case StrCons(h,t) =>                         |  |   }                                                           | +-----------------------------------------------------------+
    |         buf += h()                                 |  |                                                               |
    |         go(t())                                    |  |   @annotation.tailrec                                         |
    |       case _ => buf.toList                         |  |   final def drop(n: Int): myStream[A] = this match {          |
    |     }                                              |  |     case StrCons(_, t) if n > 0 => t().drop(n - 1)            |
    |     go(this)                                       |  |     case _ => this                                            |
    |   }                                                |  |   }                                                           |
    +----------------------------------------------------+   +---------------------------------------------------------------+
  - exists                                                                    - exists with foldRight
    +-----------------------------------------------------+                   +---------------------------------------------+
    | def exists(p: A => Boolean): Boolean = this match { |                   |   def exists2(p: A => Boolean): Boolean =   |
    |   case StrCons(h, t) => p(h()) || t().exists(p)     | // || is lazy     |     foldRight(false)((a, b) => p(a) || b)   |
    |   case _ => false                                   |                   +---------------------------------------------+
    | }                                                   |
    +-----------------------------------------------------+
  - foldRight
    +------------------------------------------------------------------+
    |   def foldRight[B](z: => B)(f: (A, => B) => B): B = this match { |
    |       case StrCons(h,t) => f(h(), t().foldRight(z)(f))           |
    |       case _ => z                                                |
    |   }                                                              |
    +------------------------------------------------------------------+

+----------------------------------------------------+    +-------------------------------------------------+
| def forAll(f: A => Boolean): Boolean =             |    |  def map[B](f: A => B): Stream[B] =             |
|   foldRight(true)((a,b) => f(a) && b)              |    |   foldRight(empty[B])((h,t) => cons(f(h), t))   |
|                                                    |    |                                                 |
| def takeWhile_1(f: A => Boolean): Stream[A] =      |    | def filter(f: A => Boolean): Stream[A] =        |
|   foldRight(empty[A])((h,t) =>                     |    |   foldRight(empty[A])((h,t) =>                  |
|     if (f(h)) cons(h,t)                            |    |     if (f(h)) cons(h, t)                        |
|     else      empty)                               |    |     else t)                                     |
|                                                    |    |                                                 |
| def headOption: Option[A] =                        |    | def append[B>:A](s: => Stream[B]): Stream[B] =  |
|   foldRight(None: Option[A])((h,_) => Some(h))     |    |   foldRight(s)((h,t) => cons(h,t))              |
+----------------------------------------------------+    |                                                 |
                                                          | def flatMap[B](f: A => Stream[B]): Stream[B] =  |
                                                          |   foldRight(empty[B])((h,t) => f(h) append t)   |
                                                          +-------------------------------------------------+












