--------------------
| functional programming
--------------------
    - removing side effect
      +------------------------------------------------------+    +--------------------------------------------------------------------+  +-----------------------------------------------------------------------+
      | class Cafe {                                         |    | case class Charge(cc: CreditCard, amount: Double) {                |  | def buyCoffees(cc: CreditCard, n: Int): (List[Coffee], Charge) = {    |
      |   def buyCoffee(cc: CreditCard): (Coffee, Charge) = {|    |   def combine(other: Charge): Charge =                             |  |   val purchases: List[(Coffee, Charge)] = List.fill(n)(buyCoffee(cc)) |
      |     val cup = new Coffee(                            |    |     if (cc == other.cc)                                            |  |   val (coffees, charges) = purchases.unzip                            |
      |     (cup, Charge(cc, cup.price)                      |    |       Charge(cc, amount plus other.amount)                         |  |   (coffees, charges.reduce((c1,c2) => c1.combine(c2)))                |
      |   }                                                  |    |     else                                                           |  | }                                                                     |
      | }                                                    |    |       throw new Exception(Cant combine charges to different cards) |  +-----------------------------------------------------------------------+
      +------------------------------------------------------+    | }                                                                  |
                                                                  +--------------------------------------------------------------------+

    - functional programming in Scala
      - writing loops functionally                - higher-order function
      +-------------------------------------+     +-----------------------------------------------------------+
      |   def factorial(n: Int): Int = {    |     | def formatResult(name: String, n: Int, f: Int => Int) = { |
      |     def go(n: Int, acc: Int): Int = |     |   val msg = "The %s of %d is %d."                         |
      |       if (n <= 0) acc               |     |   msg.format(name, n, f(n))                               |
      |       else go(n-1, n*acc)           |     | }                                                         |
      |     go(n, 1)                        |     +-----------------------------------------------------------+
      |   }                                 |
      +-------------------------------------+
    - polymorphic functions: abstracting over types
      +----------------------------------------------------------+
      | def findFirst[A](as: Array[A], p: A => Boolean): Int = { |
      |   @annotation.tailrec                                    |
      |   def loop(n: Int): Int =                                |
      |     if (n >= as.length) -1                               |
      |     else if (p(as(n))) n                                 |
      |     else loop(n + 1)                                     |
      |   loop(0)                                                |
      | }                                                        |
      +----------------------------------------------------------+
    - isSorted
      +-----------------------------------------------------------------------+
      | def isSorted[A](as: Array[A], ordered: (A,A) => Boolean): Boolean = { |
      |   def loop(a: Int, b: Int, as: Array[A]): Boolean = {                 |
      |     b match {                                                         |
      |       case i if i == as.size => true                                  |
      |       case i if ordered(as(a), as(b)) => loop(b, b+1, as)             |
      |       case _ => false                                                 |
      |     }                                                                 |
      |   }                                                                   |
      |   loop(0, 1, as)                                                      |
      | }                                                                     |
      +-----------------------------------------------------------------------+
    - partial function
      +----------------------------------------------------+
      | def partial1[A,B,C](a: A, f: (A,B) => C): B => C = |  // value returned by partial1 will be a function, of type B => C
      |   (b: B) => f(a, b)                                |  // B = we have it; to return C = we need to call teh function
      +----------------------------------------------------+
    - curry                                                     - example usage
      +-----------------------------------------------------+   +----------------------------------+
      | def curry[A,B,C](f: (A, B) => C): A => (B => C) = { |   | val fSum = (a:Int, b:Int) => a+b |
      |   (a:A) => (b:B) => f(a,b)                          |   | val partial1 = curry(fSum)       |
      | }                                                   |   | assert(fSum(1,1) == 2)           |
      +-----------------------------------------------------+   | assert(partial1(1)(1) == 2)      |
                                                                | val partial2 = partial1(1)       |
                                                                | assert(partial2(1) == 2)         |
                                                                +----------------------------------+
    - uncurry                                                   - example usage
      +----------------------------------------------------+    +-----------------------------------------+
      | def uncurry[A,B,C](f: A => B => C): (A, B) => C ={ |    |   val fSum = (a:Int) => (b:Int) => a+b  |
      |   (a: A, b: B) => f(a)(b)                          |    |   assert(fSum(1)(1)==2)                 |   
      | }                                                  |    |   val fSumUncurry = uncurry(fSum)       |
      +----------------------------------------------------+    |   assert(fSumUncurry(1, 1)==2)          |
                                                                +-----------------------------------------+
    - compose                                                   - example usage
      +-----------------------------------------------------+   +-------------------------------+
      | def compose[A,B,C](f: B => C, g: A => B): A => C ={ |   | val f1 = (a:Int) => a+1       |
      |   (a: A) => f(g(a))                                 |   | val f2 = (b:Int) => b+2       |
      | }                                                   |   | val composed = compose(f1,f2) |
      +-----------------------------------------------------+   | assert(composed(1)==4)        |
                                                                +-------------------------------+

--------------------
| functional data structures
--------------------
  -singly linked lists
    +-------------------------------------------------------------+
    | sealed trait List[+A]                                       |   // sealed means that all implementations of the trait must be declared in this file
    | case object Nil extends List[Nothing]                       |   // [+A] - covariant or positive (List[Dog] subtype of List[Animal] if Dog subtype of Animal)
    | case class Cons[+A](head: A, tail: List[A]) extends List[A] |   // Nil extends List[Nothing]. Nothing subtype of all types Nil can be considered a List[Int], a List[Double]
    | object List {                                               |   
    |   def sum(ints: List[Int]): Int = ints match {              |   List("a","b")   
    |     case Nil => 0                                           |   Cons(a,cons(b,Nil))
    |     case Cons(x,xs) => x + sum(xs)                          |   cons    cons
    |   }                                                         |   +---+   +---+
    |   def product(ds: List[Double]): Double = ds match {        |   |a|.+-->+b|.|
    |     case Nil => 1.0                                         |   +---+   +---+
    |     case Cons(0.0, _) => 0.0                                |
    |     case Cons(x,xs) => x * product(xs)                      |
    |   }                                                         |
    |   def apply[A](as: A*): List[A] =                           |   // Variadic function syntax.
    |     if (as.isEmpty) Nil                                     |
    |     else Cons(as.head, apply(as.tail: _*))                  |
    | }                                                           |
    +-------------------------------------------------------------+

  -pattern matching
    List(1,2,3) match { case _ => 42 }          // _ matches any expression
    List(1,2,3) match { case Cons(h,_) => h }   // 1
    List(1,2,3) match { case Cons(_,t) => t }   // 2,3
    List(1,2,3) match { case Nil => 42 }        // MatchError

  - data sharing in functional data structures
    - when we add element to fron of list - we return new list - initial list is unharmed
      we do not copy elements - we reuse them as they are immutable
    +--------------------------------------------------+    +------------------------------------------------------------------+
    | def tail[A](l: myList[A]): myList[A] = l match { |    | def setHeader[A](l: myList[A], header: A): myList[A] = l match { |
    |     case Nil => sys.error("tail of empty list")  |    |   case Nil => Cons(header, Nil)                                  |
    |     case Cons(_,t) => t                          |    |   case Cons(_,t) => Cons(header, t)                              |
    | }                                                |    | }                                                                |
    +--------------------------------------------------+    +------------------------------------------------------------------+

  - efficiency of data sharing
    +--------------------------------------------------+  +------------------------------------------------------------------------+
    | def drop[A](l: myList[A], n: Int): myList[A] = { |  | def dropWhile[A](l: myList[A], f: A => Boolean): myList[A] = l match { |
    |   if (n <= 0) l                                  |  |   case Cons(h,t) if f(h) => dropWhile(t, f)                            |
    |   else l match {                                 |  |   case _ => l                                                          |
    |     case Nil => Nil                              |  | }                                                                      |
    |     case Cons(_,t) => drop(t, n-1)               |  +------------------------------------------------------------------------+
    |   }                                              |
    | }                                                |
    +--------------------------------------------------+

    +---------------------------------------------------------------------+
    | def append[A](a1: myList[A], a2: myList[A]): myList[A] = a1 match { |
    |   case Nil => a2                                                    |
    |   case Cons(h,t) => Cons(h, append(t, a2))                          |
    | }                                                                   |
    +---------------------------------------------------------------------+
  - bad performance
    +-------------------------------------------------+   +--------------------------------------------------+
    | def init2[A](l: List[A]): List[A] = {           |   | def init[A](l: myList[A]): myList[A] = l match { |
    |   import collection.mutable.ListBuffer          |   |   case Nil => sys.error("init of empty list")    |
    |   val buf = new ListBuffer[A]                   |   |   case Cons(_,Nil) => Nil                        |
    |   @annotation.tailrec                           |   |   case Cons(h,t) => Cons(h,init(t))              |
    |   def go(cur: List[A]): List[A] = cur match {   |   | }                                                |
    |     case Nil => sys.error("init of empty list") |   +--------------------------------------------------+
    |     case Cons(_,Nil) => List(buf.toList: _*)    |
    |     case Cons(h,t) => buf += h; go(t)           |
    |   }                                             |
    |   go(l)                                         |
    | }                                               |
    +-------------------------------------------------+
  - Vector - purely functional sequence structure, supports constant time access, head,tail,init,addition to front or rear.

  - Recursion over lists and generalizing to higher-order functions
    +----------------------------------------------------------------------+  +------------------------------------------------------------+
    | def foldRight[A,B](as: List[A], z: B)(f: (A, B) => B): B =as match { |  | def sum2(ns: List[Int]) = foldRight(ns, 0)((x,y) => x + y) |
    |   case Nil => z                                                      |  +------------------------------------------------------------+
    |   case Cons(x, xs) => f(x, foldRight(xs, z)(f))                      |  +------------------------------------------------------------+
    | }                                                                    |  | def product2(ns: List[Double]) = foldRight(ns, 1.0)(_ * _) |
    +----------------------------------------------------------------------+  +------------------------------------------------------------+
    - trace foldRight foldRight must traverse all the way to the end of the list (pushing frames onto the call)
      foldRight(Cons(1, Cons(2, Cons(3, Nil))), 0)((x,y) => x + y)
      1 + foldRight(Cons(2, Cons(3, Nil)), 0)((x,y) => x + y)
      1 + (2 + foldRight(Cons(3, Nil), 0)((x,y) => x + y))
      1 + (2 + (3 + (foldRight(Nil, 0)((x,y) => x + y))))
      1 + (2 + (3 + (0)))
      6

  - product                                                   -length
    +------------------------------------------------------+  +-------------------------------------------+
    | def product(ds: myList[Double]): Double = ds match { |  | def length(as: myList[Int]): Int = {      |
    |   case Nil => 1.0                                    |  |   myList.foldRight(as, 0)((x,y) => 1 + y) |
    |   case Cons(0.0, _) => 0.0                           |  | }                                         |
    |   case Cons(x,xs) => x * product(xs)                 |  +-------------------------------------------+
    | }                                                    |
    |                                                      |
    +------------------------------------------------------+

  - foldLeft (tailrec - no stackoverflow)
    +----------------------------------------------------------------------+
    | def foldLeft[A,B](l: myList[A], z: B)(f: (B, A) => B): B = l match { |
    |   case Nil => z                                                      |
    |   case Cons(h,t) => foldLeft(t, f(z,h))(f)                           |
    | }                                                                    |
    +----------------------------------------------------------------------+

  - foldRightViaFoldLeft                                                    - foldLeftViaFoldRight
    +----------------------------------------------------------------------+  +----------------------------------------------------------------------+
    | def foldRightViaFoldLeft[A,B](l: List[A], z: B)(f: (A,B) => B): B =  |  | def foldLeftViaFoldRight[A,B](l: List[A], z: B)(f: (B,A) => B): B =  |
    |   foldLeft(reverse(l), z)((b,a) => f(a,b))                           |  |   foldRight(l, (b:B) => b)((a,g) => b => g(f(b,a)))(z)               |
    +----------------------------------------------------------------------+  +----------------------------------------------------------------------+
  - appendViaFoldRight
    +-----------------------------------------------------------------------------------------------+
    | def appendViaFoldRight[A](l: myList[A], r: myList[A]): myList[A] = foldRight(l, r)(Cons(_,_)) |
    +-----------------------------------------------------------------------------------------------+
  - concat (3.15)
    +---------------------------------------------+
    | def concat[A](l: List[List[A]]): List[A] =  |
    |   foldRight(l, Nil:List[A])(append)         |
    +---------------------------------------------+
  - transform list (3.16)                                               - with foldRight
    +---------------------------------------------------------------+   +---------------------------------------------------------------+
    | def addOne(l: myList[Int], res: myList[Int]): myList[Int] = { |   | myList.foldRight(list, myList[Int]())((l,acc)=>Cons(l+1,acc)) |
    |   l match{                                                    |   +---------------------------------------------------------------+
    |     case Nil => res                                           |
    |     case Cons(a, _) => addOne(l.tail, Cons(a+1, res))         |
    |   }                                                           |
    | }                                                             |
    +---------------------------------------------------------------+
  = convert to list os strings
    +-------------------------------------------------------------------------+
    | myList.foldRight(list, myList[String]())((l,acc)=>Cons(l.toString,acc)) |
    +-------------------------------------------------------------------------+

  - map function                                                - not stack-safe with foldRight
    +------------------------------------------------------+      +------------------------------------------------------------+
    | def map_2[A,B](l: myList[A])(f: A => B): List[B] = { |      | myList.foldRight(as, myList[B]())((l,acc)=>Cons(f(l),acc)) |
    |   val buf = new collection.mutable.ListBuffer[B]     |      +------------------------------------------------------------+
    |   def go(l: myList[A]): Unit = l match {             |
    |     case Nil => ()                                   |
    |     case Cons(h,t) => buf += f(h); go(t)             |
    |   }                                                  |
    |   go(l)                                              |
    |   List(buf.toList: _*)                               |
    | }                                                    |
    +------------------------------------------------------+
  -filter                                                               - filter with flatMap
    +----------------------------------------------------------------+  +--------------------------------------------------------------+
    | def filter[A](as: myList[A])(f: A => Boolean): myList[A] = {   |  | def filter[A](as: myList[A])(f: A => Boolean): myList[A] = { |
    |   val buf = new collection.mutable.ListBuffer[A]               |  |   myList.flatMap(as)(x=>if (f(x)) myList(x) else Nil)        |
    |   def go(l: myList[A]): Unit = l match {                       |  | }                                                            |
    |     case Nil => ()                                             |  +--------------------------------------------------------------+
    |     case Cons(h,t) => {if (f(h)) {buf += h; go(t)} else go(t)} |
    |   }                                                            |
    |   go(as)                                                       |
    |   myList(buf.toList: _*)                                       |
    | }                                                              |
    +----------------------------------------------------------------+
  - flatMap
    +-------------------------------------------------------------------+
    | def flatMap[A,B](as: myList[A])(f: A => myList[B]): myList[B] = { |
    |   myList.concat(myList.map(as)(f))                                |
    | }                                                                 |
    +-------------------------------------------------------------------+
  - zipWith                                                                               - zipWith general
    +----------------------------------------------------------------------------------+  +----------------------------------------------------------------------------------------------+
    | def addPairwise(l1: myList[Int], l2: myList[Int]): myList[Int] = (l1,l2) match { |  | def zipWith[A,B,C](l1: myList[A], l2: myList[B])(f: (A,B) => C): myList[C] = (l1,l2) match { |
    |   case (Nil, _) => Nil                                                           |  |   case (Nil, _) => Nil                                                                       |
    |   case (_, Nil) => Nil                                                           |  |   case (_, Nil) => Nil                                                                       |
    |   case (Cons(h1,t1), Cons(h2,t2)) => Cons(h1+h2, addPairwise(t1,t2))             |  |   case (Cons(h1,t1), Cons(h2,t2)) => Cons(f(h1,h2), zipWith(t1,t2)(f))                       |
    | }                                                                                |  | }                                                                                            |
    +----------------------------------------------------------------------------------+  +----------------------------------------------------------------------------------------------+

  - trees
    List is and ADT - data type defined by one or more data constructors, each of which may contain zero or more arguments

    - tuple
      tuple is an ADT as well
      +-----------------------------------+
      | val p = ("Bob", 42)               |
      | p._1                              |
      | p._2                              |
      | p match { case (a,b) => b }       |
      +-----------------------------------+

    - binary tree
      bTree is an ADT as well
      +---------------------------------------------------------------------+
      | sealed trait Tree[+A]                                               |
      | case class Leaf[A](value: A) extends Tree[A]                        |
      | case class Branch[A](left: Tree[A], right: Tree[A]) extends Tree[A] |
      +---------------------------------------------------------------------+
    -size
      +----------------------------------------------+
      |   def size[A](t: myTree[A]): Int = t match { |
      |     case Leaf(_) => 1                        |
      |     case Branch(l,r) => 1+size(l)+size(r)    |
      |   }                                          |
      +----------------------------------------------+
    -max
      +---------------------------------------------+
      |   def maxi(t: myTree[Int]): Int = t match { |
      |     case Leaf(n) => n                       |
      |     case Branch(l,r) => maxi(l) max maxi(r) |
      |   }                                         |
      +---------------------------------------------+
    -depth
      +-------------------------------------------------------------------------------+
      |   def depth[A](t: myTree[A], currentDepth: Int): Int = t match {              |
      |     case Leaf(_) => currentDepth+1                                            |
      |     case Branch(l,r) => depth(l, currentDepth+1) max depth(r, currentDepth+1) |
      |   }                                                                           |
      +-------------------------------------------------------------------------------+
    -map
      +----------------------------------------------------------------+
      |   def map[A,B](t: myTree[A])(f: A => B): myTree[B] = t match { |
      |     case Leaf(n) => Leaf(f(n))                                 |
      |     case Branch(l,r) => Branch(map(l)(f), map(r)(f))           |
      |   }                                                            |
      +----------------------------------------------------------------+
    -fold                                                                         - size,max,depth with fold
      +------------------------------------------------------------------------+  +------------------------------------------------------------------------------------------+
      |   def fold[A,B](t: myTree[A])(f: A => B)(g: (B,B) => B): B = t match { |  |   def sizeViaFold[A](t: myTree[A]): Int = fold(t)(a => 1)(1 + _ + _)                     |
      |     case Leaf(a) => f(a)                                               |  |   def maximumViaFold(t: myTree[Int]): Int = fold(t)(a => a)(_ max _)                     |
      |     case Branch(l,r) => g(fold(l)(f)(g), fold(r)(f)(g))                |  |   def depthViaFold[A](t: myTree[A]): Int = fold(t)(a => 0)((d1,d2) => 1 + (d1 max d2))   |
      |   }                                                                    |  +------------------------------------------------------------------------------------------+
      +------------------------------------------------------------------------+

--------------------
| Handling errors without exceptions
--------------------
  Referential transparency - an expression is said to be referentially transparent if it can be replaced by its value and not change the program’s behaviour.
  Meaning of the expression throw new Exception("fail") is very context-dependent—as we just demonstrated, it takes on different meanings depending on which try block (if any) it’s nested within

  -Option