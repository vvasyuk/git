###############
# Getting started
###############
-Basic types
Byte        8 bit  (-127 +128)          val i2: Byte = 1
Short       16 bit (32767)
Int         32 bit (2 147 483 647)      val decimal = 11235     hex -- val hexa = 0x23      octa -- val octa = 023
Long        64 bit                      val decimal = 11235L
Float       32 bit                      val f = 0.0f
Double      64 bit                      val d = 0.0
Boolean
Char        16 bit

-CHARACTER LITERALS
val capB = '\102'               // capB: Char = B
val capB = 'B'                  // capB: Char = B
val \u0061\u006e\u0073 = 42     // ans: Int = 42
-Defining variables
var willKnowLater:String = _    // willKnowLater: String = null (default value for String is null)
-lazy
lazy val forLater = someTimeConsumingOperation()    // forLater: Unit = <lazy>
var a = 1
lazy val b = a + 1
a = 5
b                               // 6

-Defining functions
def myFirstMethod():String = { "exciting times ahead" }     // myFirstMethod: ()String
def myFirstMethod() = { "exciting times ahead" }            // myFirstMethod: ()java.lang.String
def myFirstMethod(){ "exciting times ahead" }               // myFirstMethod: ()Unit  -  without "=" - scala wont infer return type
def myFirstMethod() = "exciting times ahead"                // myFirstMethod: ()java.lang.String
def myFirstMethod = "exciting times ahead"                  // myFirstMethod: java.lang.String
myFirstMethod                                               // res17: java.lang.String = exciting times ahead
def max(a: Int, b: Int) = if(a > b) a else b                // max: (a: Int,b: Int)Int
def toList[A](value:A) = List(value)                        // toList: [A](value: A)List[A]

-FUNCTION LITERALS
val evenNumbers = List(2, 4, 6, 8, 10)
evenNumbers.foldLeft(0) { (a: Int, b:Int) => a + b }        // res19: Int = 30
evenNumbers.foldLeft(0) { (a, b) => a + b }
evenNumbers.foldLeft(0) { _ + _ }
val hasUpperCase = name.exists(_.isUpper)

-USING SCALA CLOSURE AND FIRST-CLASS FUNCTIONS: AN EXAMPLE
// closure will keep track of any variable changes outside the function that are being referred to inside the function
def breakable(op: => Unit) {
    try {
        op
    } catch { case _ => }
}
breakable {                                                 // code passed as closure
    val env = System.getenv("SCALA_HOME")
    if(env == null) break
    println("found scala home lets do the real work")
}
// if last argument of function is of functional type - you can pass it as closure

-Working with Array and List
val array = new Array[String](3)                            // array: Array[String] = Array(null, null, null)
scala> array(0) = "This"
scala> array(1) = "is"
scala> array(2) = "mutable"
scala> array                                                // res37: Array[String] = Array(This, is, mutable)
array.foreach(println)

val myList = List("This", "is", "immutable")                // myList: List[java.lang.String] = List(This, is, immutable)
val myList = "This" :: "is" :: "immutable" :: Nil
val oldList = List(1, 2)
val newList = 3 :: oldList                                  // newList: List[Int] = List(3, 1, 2)
val newList = oldList :+ 3                                  // newList: List[Int] = List(1, 2, 3)
val afterDelete = newList.filterNot(_ == 3)                 // afterDelete: List[Int] = List(1, 2)

-Controlling flow with loops and ifs
val configFile = if(useDefault) "custom.txt" else "default.txt"

-For-comprehensions
val files = new java.io.File(".").listFiles
for(
    file <- files;
    fileName = file.getName;
    if(fileName.endsWith(".scala"))
) println(file)
val aList = List(1, 2, 3)
val bList = List(4, 5, 6)
for { a <- aList; b <- bList } println(a + b)               // 5 6 7  6 7 8  7 8 9
for { a <- aList; b <- bList } yield a + b                  // res27: List[Int] = List(5, 6, 7, 6, 7, 8, 7, 8, 9)
for { a <- aList; b <- bList } yield { println(a+b)}        // res is collection of units 5 6 7  6 7 8  7 8 9

-Pattern matching
def printType(obj: AnyRef) = obj match {
    case s: String => println("This is string")
    case l: List[_] => println("This is List")
    case a: Array[_] => println("This is an array")
    case d: java.util.Date => println("This is a date")
}
List(1, 2, 3, 4) match {                                    // res7: List[Int] = List(1, 2)
    case f :: s :: rest => List(f, s)
    case _ => Nil
}
// guard clause
def rangeMatcher(num:Int) = num match {
    case within10 if within10 <= 10 => println("with in 0 to 10")
    case within100 if within100 <= 100 => println("with in 11 to 100")
    case beyond100 if beyond100 < Integer.MAX_VALUE => println("beyond 100")
}

-Exception handling
def rangeMatcher(num:Int) = num match {
    case within10 if within10 <= 10 => println("with in 0 to 10")
    case within100 if within100 <= 100 => println("with in 11 to 100")
    case _ => throw new IllegalArgumentException(
                "Only values between 0 and 100 are allowed")
}
try {                                                       // res19: Any = Only values between 0 and 100 are allowed
    rangeMatcher1(1000)
} catch { case e: IllegalArgumentException => e.getMessage }    


###############
# OOP in Scala
###############
-Classes and constructors
class MongoClient(val host:String, val port:Int)            // constructor takes two parameters: host and port
val client = new MongoClient("127.0.0.1", 123)
client.port
client.host
class MongoClient(var host:String, var port:Int)            // with mutable
class MongoClient(host:String, port:Int)                    // if var or val is missing - variables are private
client.host                                                 // error: value host is not a member of MongoClient client.host
// scala creates accessors for variables. above is rewritten by scala to
class MongoClient(private val _host:String, private val _port:Int) {
    def host = _host
    def port = _port
}
// How do you add a setter method to a class?
class Person(var firstName:String, var lastName:String, private var _age:Int) {
    def age = _age
    def age_=(newAge: Int) = _age = newAge                  // age_ is a function that gets one parame and assinges it to _age
}
// when scala encounters x = e - it checks whether there’s any method defined like x_= and if so, it invokes the method
// f(args) = e is interpreted as f.update(args)
class MongoClient(val host:String, val port:Int) {
    def this() = this("127.0.0.1", 27017)                   // default values, zero-argument constructor
}                                                           // first statement in the overloaded constructors has to invoke either other overloaded constructors or the primary constructor
// how do some operation before you can invoke the other constructor? (companion objects or write code in class as below)
class MyScript(host:String) {                               // write code inside the class like a script, which will get executed when the instance of the class is created
    require(host != null, "Have to provide host name")      // Scala puts any inline code defined inside the class into the primary constructor of the class
    if(host == "127.0.0.1") println("host = localhost")
    else println("host = " + host)
}
val s = new MyScript("127.0.0.1")                           // host = localhost; s: MyScript = MyScript@401e9c3f
class MongoClient(val host:String, val port:Int) {
    require(host != null, "You have to provide a host name")// class. If you want to validate constructor parameters, you could do that inside the class (usually at the top of the class)
    private val underlying = new Mongo(host, port)
    def this() = this("127.0.0.1", 27017)
}
// you can extend
class MongoClientV2(val host:String, val port:Int) extends Mongo(host, port){
    require(host != null, "You have to provide a host name")
    def this() = this("127.0.0.1", 27017)
}

-Packaging
1.
package com.scalainaction.mongo
import com.mongodb.Mongo
class MongoClient(val host:String, val port:Int) {
    require(host != null, "You have to provide a host name")
    private val underlying = new Mongo(host, port)
    def this() = this("127.0.0.1", 27017)
}
2.
package com.scalainaction.mongo {
    import com.mongodb.Mongo
    class MongoClient(val host:String, val port:Int) {
        require(host != null, "You have to provide a host name")
        private val underlying = new Mongo(host, port)
        def this() = this("127.0.0.1", 27017)
    }
}
3.
package com.persistence {
    package mongo {
        class MongoClient
    }
    package riak {
        class RiakClient
    }
    package hadoop {
        class HadoopClient
    }
}

-Scala imports
import com.mongodb._                                        // importing all the classes under the com.mongodb package
val randomValue = { import scala.util.Random
    new Random().nextInt
}
import java.lang.System._
nanoTime                                                    // res0: Long = 1268518636387441000
import java.util.Date
import java.sql.{Date => SqlDate}                           // rename
val now = new Date
val sqlDate = new SqlDate(now.getTime)
import java.sql.{Date => _ }                                // Date class from the java.sql package is no longer visible for use
// Completed MongoClient
package com.scalainaction.mongo
class MongoClient(val host:String, val port:Int) {
    require(host != null, "You have to provide a host name")
    private val underlying = new Mongo(host, port)
    def this() = this("127.0.0.1", 27017)
    def version = underlying.getVersion
    def dropDB(name:String) = underlying.dropDatabase(name)
    def createDB(name:String) = DB(underlying.getDB(name))
    def db(name:String) = DB(underlying.getDB(name))
}

-Objects and companion objects
object RichConsole {
    def p(x: Any) = println(x)
}
RichConsole.p("rich console")
// can import
import RichConsole._
p("this is cool")
// factory to create DB instance
object DB {
    def apply(underlying: MongDB) = new DB(underlying)
}
DB(underlying.getDB(name))
// factory pattern
abstract class Role { def canAccess(page: String): Boolean }
class Root extends Role {
    override def canAccess(page:String) = true
}
class SuperAnalyst extends Role {
    override def canAccess(page:String) = page != "Admin"
}
class Analyst extends Role {
    override def canAccess(page:String) = false }
object Role {
    def apply(roleName:String) = roleName match {
        case "root" => new Root
        case "superAnalyst" => new SuperAnalyst
        case "analyst" => new Analyst
    }
}
val root = Role("root")
val analyst = Role("analyst")
// DB.scala file
package com.scalainaction.mongo
import com.mongodb.{DB => MongoDB}                              // Because of the name conflict, you’re remapping the DB class
class DB private(val underlying: MongoDB) {}                    // othing other than a companion object can use it (private)
object DB {
    def apply(underlying: MongoDB) = new DB(underlying)
}
// only things you can put in a package are classes, traits, and objects
// with package object (called package.scala) - can put any kind of definition in a package
package object bar {                                            // will be available to all members of the package bar
    val minimumAge = 18
    def verifyAge = {}                                          // helper method in a package object that will be available to all members of the package
}
package bar
class BarTender {
    def serveDrinks = { verifyAge; ... }
}
// Completed MongoClient.scala
package com.scalainaction.mongo
import com.mongodb._
class MongoClient(val host:String, val port:Int) {
    require(host != null, "You have to provide a host name")
    private val underlying = new Mongo(host, port)
    def this() = this("127.0.0.1", 27017)
    def version = underlying.getVersion
    def dropDB(name:String) = underlying.dropDatabase(name)
    def createDB(name:String) = DB(underlying.getDB(name))
    def db(name:String) = DB(underlying.getDB(name))
}
// Completed DB.scala
package com.scalainaction.mongo
import com.mongodb.{DB => MongoDB}
import scala.collection.convert.Wrappers._
class DB private(val underlying: MongoDB) {
    def collectionNames = for(name <- new
        JSetWrapper(underlying.getCollectionNames)) yield name
    }
object DB {
    def apply(underlying: MongoDB) = new DB(underlying)
}

-Mixin with Scala traits
// Completed DB.scala
package com.scalainaction.mongo
import com.mongodb.{DB => MongoDB}
import scala.collection.convert.Wrappers._
class DB private(val underlying: MongoDB) {
    private def collection(name: String) = underlying.getCollection(name)
    def readOnlyCollection(name: String) = new DBCollection(collection(name))
    def administrableCollection(name: String) = new
        DBCollection(collection(name)) with Administrable
    def updatableCollection(name: String) = new
        DBCollection(collection(name)) with Updatable
    def collectionNames = for(name <- new
        JSetWrapper(underlying.getCollectionNames)) yield name
}
object DB {
    def apply(underlying: MongoDB) = new DB(underlying)
}
// DBCollection.scala
package com.scalainaction.mongo
import com.mongodb.{DBCollection => MongoDBCollection }
import com.mongodb.DBObject
class DBCollection(override val underlying: MongoDBCollection)  // overriding the underlying abstract value with whatever value will be passed to the primary constructor
    extends ReadOnly
trait ReadOnly {
    val underlying: MongoDBCollection                           // abstract value (need to be inherited by subclasses)
    def name = underlying getName
    def fullName = underlying getFullName
    def find(doc: DBObject) = underlying find doc
    def findOne(doc: DBObject) = underlying findOne doc
    def findOne = underlying findOne
    def getCount(doc: DBObject) = underlying getCount doc
}
trait Administrable extends ReadOnly {                          // If your trait extends another trait or class
    def drop: Unit = underlying drop                            // then that trait can only be mixed into a class that also extends the same superclass or trait
    def dropIndexes: Unit = underlying dropIndexes
}
trait Updatable extends ReadOnly {
    def -=(doc: DBObject): Unit = underlying remove doc
    def +=(doc: DBObject): Unit = underlying save doc
}
// Test client for driver QuickTour.scala
import com.scalainaction.mongo._
import com.mongodb.BasicDBObject
def client = new MongoClient
def db = client.db("mydb")
for(name <- db.collectionNames) println(name)

val col = db.readOnlyCollection("test")
println(col.name)

val adminCol = db.administrableCollection("test")
adminCol.drop

val updatableCol = db.updatableCollection("test")
val doc = new BasicDBObject()
doc.put("name", "MongoDB")
doc.put("type", "database")
doc.put("count", 1)

val info = new BasicDBObject()
info.put("x", 203)
info.put("y", 102)
doc.put("info", info)
updatableCol += doc

println(updatableCol.findOne)

updatableCol -= doc
println(updatableCol.findOne)

for(i <- 1 to 100) updatableCol += new BasicDBObject("i", i)
val query = new BasicDBObject
query.put("i", 71);
val cursor = col.find(query)
while(cursor.hasNext()) {
    println(cursor.next());
}
// memoization
trait Memoizer extends ReadOnly {
    val history = scala.collection.mutable.Map[Int, DBObject]()             // keeping track of all the resulting DBObjects
    override def findOne = {
        history.getOrElseUpdate(-1, { super.findOne })
    }
    override def findOne(doc: DBObject) = {
        history.getOrElseUpdate(doc.hashCode, { super.findOne(doc) })
    }
}
// use this memoizer trait
def readOnlyCollection(name: String) =
    new DBCollection(collection(name)) with Memoizer
def administrableCollection(name: String) =
    new DBCollection(collection(name)) with Administrable with Memoizer
def updatableCollection(name: String) =
    new DBCollection(collection(name)) with Updatable with Memoizer

-Class linearization
Class UpdatableCollection extends DBCollection(collection(name)) with Updatable
// all classes in Scala extend scala.AnyRef, which in turn inherits from the scala.Any class
// linearization of the ReadOnly trait is simple because it doesn’t involve multiple inheritance
ReadOnly –> AnyRef –> Any
// Similarly, Updatable and DBCollection also don’t have that issue
Updatable –> ReadOnly –> AnyRef –> Any
DBCollection –> ReadOnly –> AnyRef –> Any
// After linearization, your UpdatableCollection looks like the following
UpdatableCollection –> Updatable –> DBCollection –> ReadOnly –> AnyRef –> Any
// if you add the Memoizer trait into the mix, it will show up before Updatable because it’s the rightmost element
UpdatableCollection –> Memoizer –> Updatable –> DBCollection –> ReadOnly –> AnyRef –> Any

-Stackable traits
trait LocaleAware extends ReadOnly {
    override def findOne(doc: DBObject) = {
        doc.put("locale", java.util.Locale.getDefault.getLanguage)
        super.findOne(doc)
    }
    override def find(doc: DBObject) = {
        doc.put("locale", java.util.Locale.getDefault.getLanguage)
        super.find(doc)
    }
}
// Now when creating a new Collection, you could mix in this trait:
new DBCollection(collection(name)) with Memoizer with LocaleAware

-Case class
case class Person(firstName:String, lastName:String)
1. prefixes all the parameters with val
2. adds equals, hashcode, toString, copy
3. companion object
4. adds unapply
//case objects that are singleton and serializable
trait Boolean
case object Yes extends Boolean
case object No extends Boolean
//
sealed trait QueryOption
case object NoOption extends QueryOption
case class Sort(sorting: DBObject, anotherOption: QueryOption) extends QueryOption
case class Skip(number: Int, anotherOption: QueryOption) extends QueryOption
case class Limit(limit: Int, anotherOption: QueryOption) extends QueryOption
case class Query(q: DBObject, option: QueryOption = NoOption) {                     // default value to the parameter
    def sort(sorting: DBObject) = Query(q, Sort(sorting, option))
    def skip(skip: Int) = Query(q, Skip(skip, option))
    def limit(limit: Int) = Query(q, Limit(limit, option))
}
var rangeQuery = new BasicDBObject("i", new BasicDBObject("$gt", 20))               // searching documents for which the i > 20 condition is true
var richQuery = Query(rangeQuery).skip(20).limit(10)                                // From the result set you skip 20 documents and limit your result set to 10 documents
// pattern matching
case class Person(firstName:String, lastName: String)
val p = Person("Matt", "vanvleet")
p match {
    case Person(first, last) => println(">>>> " + first + ", " + last)              // >>>> Matt, vanvleet
}
object Person {
    def apply(firstName:String, lastName:String) = {
        new Person(firstName, lastName)
    }
    def unapply(p:Person): Option[(String, String)] =
        Some((p.firstName, p.lastName))
}
// ReadOnly trait
trait ReadOnly {
    val underlying: MongoDBCollection
    def name = underlying getName
    def fullName = underlying getFullName
    def find(query: Query): DBCursor = {                                            // Find method takes query object
        def applyOptions(cursor:DBCursor, option: QueryOption): DBCursor = {
            option match {
                case Skip(skip, next) => applyOptions(cursor.skip(skip), next)
                case Sort(sorting, next)=> applyOptions(cursor.sort(sorting), next)
                case Limit(limit, next) => applyOptions(cursor.limit(limit), next)
                case NoOption => cursor
            }
        }
        applyOptions(find(query.q), query.option)
    }
    def find(doc: DBObject): DBCursor = underlying find doc
    def findOne(doc: DBObject) = underlying findOne doc
    def findOne = underlying findOne
    def getCount(doc: DBObject) = underlying getCount doc
}
// TestFindByQuery.scala
import com.scalainaction.mongo._
import com.mongodb.BasicDBObject
def client = new MongoClient
def db = client.db("mydb")
val col = db.readOnlyCollection("test")
val updatableCol = db.updatableCollection("test")
for(i <- 1 to 100) updatableCol += new BasicDBObject("i", i)
val rangeQuery = new BasicDBObject("i", new BasicDBObject("$gt", 20))               // Search for where i > 20
val richQuery = Query(rangeQuery).skip(20).limit(10)                                // Skip first 20 docs, return 10 docs
val cursor = col.find(richQuery)
while(cursor.hasNext()) {
    println(cursor.next());
}

-Named and default arguments and copy constructors
case class Person(firstName:String, lastName:String)
val p = Person("lastname", "firstname")
val p = Person(lastName = "lastname", firstName = "firstname")

//SalesPerson overriding the grade method and changing the parameter name in the process from years to yrs
trait Person { def grade(years: Int): String }
class SalesPerson extends Person { def grade(yrs: Int) = "Senior" }
val s = new SalesPerson
s.grade(yrs=1)                                                                      // res17: java.lang.String = Senior
s.grade(years=1)                                                                    // <console>:12: error: not found: value years s.grade(years=1)

-Modifiers
package outerpkg.innerpkg
class Outer {
    class Inner {
        private[Outer] def f() = "This is f"                                        // can appear anywhere within the Outer class
        private[innerpkg] def g() = "This is g"                                     // accessible anywhere within outerpkg.innerpkg
        private[outerpkg] def h() = "This is h"                                     // can appear anywhere within outerpkg and its subpackages
    }
}

-Value classes: objects on a diet
// Value classes allow you to add extension methods to a type without the runtime overhead of creating instances
class Wrapper(val name: String) extends AnyVal {
    def up() = name.toUpperCase
}
val w = new Wrapper("hey")                                                          // At runtime the expression will be optimized to the equivalent of a method class on a static object: Wrapper.up$extension("hey")
w.up()

-Implicit conversion with implicit classes
val someInt: Int = 2.3                                                              // error: type mismatch; found : Double(2.3) required: Int val someInt: Int = 2.3
def double2Int(d: Double): Int = d.toInt
val someInt: Int = double2Int(2.3)
// make it implicit
implicit double2Int(d: Double): Int = d.toInt
val someInt: Int = 2.3                                                              // someInt: Int = 2
// add extension methods to existing types
val oneTo10 = 1 to 10
// if we want to create a range of numbers using the --> method
val oneTo10 = 1 --> 10
// Create a type that has a --> method defined for the Int type
class RangeMaker(left: Int) {
    def -->(right: Int) = left to right
}
val range: Range = new RangeMaker(1).-->(10)
implicit def int2RangeMaker(left: Int): Range = new RangeMaker(left)
// combine
implicit class RangeMaker(left: Int) {                                              // only runtime cost comes from creating an additional instance of RangeMaker for each implicit conversion
    def -->(right: Int): Range = left to right
}
implicit class RangeMaker(val left: Int) extends AnyVal {                           // avoid the runtime cost by turning our implicit classes into value classes
    def -->(right: Int): Range = left to right
}

-Scala class hierarchy
#########################################################################################################
#+---+                                                                                                  #
#|any|                                                                                                  #
#+---+                                                                                                  #
#|    +------+                                                                                  +------+#
#+----+anyVal+-+--------+--------+--------+--------+--------+--------+--------+--------+<-------+Nothng|#
#|    +------+ |        |        |        |        |        |        |        |        |        +------+#
#|             +------+ +------+ +------+ +------+ +------+ +------+ +------+ +------+ +------+         #
#|             |Double| |Float | |Long  | |Int   | |Short | |Byte  | |Char  | |Bolean| |Unit  |         #
#|             +------+ +------+ +------+ +------+ +------+ +------+ +------+ +------+ +------+         #
#|                                                                                                      #
#|                                                                                                      #
#|    +------+                                     +------+                                             #
#+----+anyRef+-+--------+--------+--------+<-------+Null  |                                             #
#     +------+ |        |        |        |        +------+                                             #
#              +------+ +------+ +------+ +------+                                                      #
#              |Itrble+<+Seq   +<+List  | |Option|                                                      #
#              +------+ +------+ +------+ +------+                                                      #
#########################################################################################################


###############
# Having fun with functional data structures
###############

-Introducing type parameterization
def position[A](xs: List[A], value: A): Int = {
    xs.indexOf(value)
}
val xs = List("one", "two", "three")
position(xs, "two")
val ys = List(20, 30, 40)
position(ys, 40)
position[Int](ys, 300)                                                              // res11: Int = -1 instead of returning the Int result, you’ll return a new type that clearly expresses the behavior of the method
// Maybe
def position[A](xs: List[A], value: A): Maybe[Int] = {
    val index = xs.indexOf(value)
    if(index != -1) Just(index) else Nil
}
// Version 1 of Maybe.scala
sealed abstract class Maybe[+A] {
    def isEmpty: Boolean
    def get: A
}
final case class Just[A](value: A) extends Maybe[A] {
    def isEmpty = false
    def get = value
}
case object Nil extends Maybe[Nothing] {
    def isEmpty = true
    def get = throw new NoSuchElementException("Nil.get")
}

-Type variance with covariance and contravariance
// how do two types with a subtype relationship relate in type parameterization with each other
// + sign along with the type parameter to make it covariant
// Covariance allows subclasses to override and use narrower types than their superclass in covariant positions such as the return value
// Nil object is a subclass of Maybe with scala.Nothing as a type parameter. Because the A type of Maybe is covariant, you can return a narrower type from its subclasses. There’s no narrower type than Nothing
// immutable List is covariant in its type parameter, so List[String] is a subtype of List[Any]
// opposite of covariance is contravariance. In the case of covariance, subtyping can go downward, but in contravariance subtypes go upward. Contravariance comes in handy when you have a mutable data structure

// Mutable objects need to be invariant
val mxs: ListBuffer[String] = ListBuffer("pants")
val everything: ListBuffer[Any] = mxs                                               // error: type mismatch; found : scala.collection.mutable.ListBuffer[String] required: scala.collection.mutable.ListBuffer[Any]
// assume ListBuffer is covariant
val mxs: ListBuffer[String] = ListBuffer("pants")
val everything: ListBuffer[Any] = mxs
everything += 1                                                                     // res4: everything.type = ListBuffer(1, pants). this is a problem same as in Java Array
// not an issue for immutable
val xs: List[String] = List("pants")                                                // xs: List[String] = List(pants)
val everything: List[Any] = xs                                                      // everything: List[Any] = List(pants)
// You can add 1 to xs List, and it will return a new List of type Any
1 :: xs                                                                             // res5: List[Any] = List(1, pants)

// in Java
Object[] arr = new int[1];
arr[0] = "Hello, there!";

// A good example of contravariance in action is the Function1
trait Function1[-P, +R] { ... }                                                     // Function1 is contravariant in P and covariant in R. Function1 trait is contravariant for the parameter and covariant for the return type
// consider what will happen when the opposite is the case—for instance, covariant for parameter and contravariant for return value
val addOne: Function1[Any, Int] = { x: Int => x + 1 }
// Function1[-A,+B] means that a function that takes superclasses of A can be viewed as a subclass of the original function.
// example
class A
class B extends A
val printB: B => Unit = { b => println("Blah blah") }
val printA: A => Unit = { a => println("Blah blah blah") }
// suppose you require a function that knows how to print a B
def needsB(f: B => Unit, b: B) = f(b)                                               // you could also pass in printA, since it also knows how to print Bs (and more!), just as if A => Unit was a subclass of B => Unit. This is exactly what contravariance means. It doesn't mean you can pass Option[Double] into printB and get anything but a compile-time error!  (Covariance is the other case: M[B] <: M[A] if B <: A.)
// You should be able to do with a SubFoo everything that you can do with a Foo, and maybe more
// we have Calico <: Cat <: Animal, and Husky <: Dog <: Animal
// Suppose we have Calico <: Cat <: Animal, and Husky <: Dog <: Animal. Let's look at a Function[Cat, Dog]
Function[Cat, Dog]                                                                  // 
1. You can pass in any Cat (so any subclass of Cat)
2. You can call any Dog method on the returned value
Function[Calico, Dog] <: Function[Cat, Dog]                                         // No, statements that are true of the superclass are not true of the subclass, namely statement (1). You can't pass in any Cat to a Function that only takes Calico cats.
Function[Animal, Dog] <: Function[Cat, Dog]                                         // Yes, all statements about the superclass are true of the subclass. I can still pass in any Cat -- in fact I can do even more than that, I can pass in any Animal -- and I can call all Dog methods on the returned value
// So A <: B implies Function[B, _] <: Function[A, _]
Function[Cat, Husky] <: Function[Cat, Dog]                                          // Yes, all statements about the superclass are true of the subclass; I can still pass in a Cat, and I can still call all Dog methods on the returned value -- in fact I can do even more than that, I can call all Husky methods on the returned value
Function[Cat, Animal] <: Function[Cat, Dog]                                         // No, statements that are true of the superclass are not true of the subclass, namely statement (2). I can't call all methods available on Dog on the returned value, only the ones available on Animal.
// So with a Function[Animal, Husky] I can do everything I can do with a Function[Cat, Dog]: I can pass in any Cat, and I can call all of the Dog methods on the returned value. 
// And I can do even more: I can pass in other animals, and I can call of the methods available on Husky that aren't available on Dog. So it makes sense: Function[Animal, Husky] <: Function[Cat, Dog]. 
// The first type parameter can be replaced with a superclass, the second with a subclass.

-Lower and upper type bounds
sealed abstract class Maybe[+A] {
    def isEmpty: Boolean
    def get: A
    def getOrElse(default: A): A = {                                                // added method
        if(isEmpty) default else get                                                // covariant type A occurs in contravariant position in type => A of value default
    }
}
//
def defaultToNull[A <: Maybe[_]](p: A) = {                                          // take subclasses of Maybe
    p.getOrElse(null)
}
// Complete Maybe.scala
sealed abstract class Maybe[+A] {                                                   // Maybe class defined with a covariant parameter type A
    def isEmpty: Boolean
    def get: A
    def getOrElse[B >: A](default: B): B = {
        if(isEmpty) default else get
    }
}
final case class Just[A](value: A) extends Maybe[A] {                               // The Just subclass holds the success value of an operation
    def isEmpty = false
    def get = value
}
case object Nil extends Maybe[scala.Nothing] {                                      // Nil is opposite of Just and denotes an error condition
    def isEmpty = true
    def get = throw new NoSuchElementException("Nil.get")
}

-Higher-order functions, including map, flatMap, and friends
def addOne(num:Int) = num + 1
List(1, 2, 3) map addOne
def log(m: => String) = if(logEnabled) println(m)                                   // call-by-name will pass the parameter as a function that will be evaluated every time the parameter is accessed. If the log isn’t enabled, the parameter will never be evaluated
def ++ = (x:Int) => x + 1                                                           // $plus$plus: (Int) => Int
// implement a function like map
def map[A, B](xs: List[A], f: A => B): List[B] = {
    xs match {
        case List() => Nil
        case head :: tail => f(head) :: map(tail, f)
    }
}
// map function using a for-comprehension
def map1[A, B](f: A => B, xs: List[A]): List[B] = for(x <- xs) yield f(x)

// flatMap - appies function to all elements of list and concatenating the result
class List[+A] { ...
    def flatMap[B](f: A => GenTraversableOnce[B]): List[B]
}
List("one","two", "three", "") flatMap { _.toList }                                 // res5: List[Char] = List(o, n, e, t, w, o, t, h, r, e, e)
// flatMap takes the result of the map and flattens it to a single list
def flatten[B](xss: List[List[B]]): List[B] = {                                     // flatten takes a List of List and flattens it to a single List
    xss match {
        case List() => Nil
        case head :: tail => head ::: flatten(tail)
    }
}
def flatMap[A, B](xs: List[A])(f: A => List[B]) : List[B] = {                       // Currying allows you to chain functions one after another with a single parameter
    flatten(map(xs, f))
}
// difference between a lambda and a closure?
// lambda is an anonymous function—a function without a name
// Closure is any function that closes over the environment in which it’s defined
List(100, 200, 300) map { _ * 10/100 }                                              // lambda
var percentage = 10
val applyPercentage = (amount: Int) => amount * percentage/100                      // closure applyPercentage: (Int) => Int = <function1>
percentage = 20
List(100, 200, 300) map applyPercentage                                             // res33: List[Int] = List(20, 40, 60)
// In tail recursion you perform your calculation first and then execute the recursive call by passing the result of the current step to the next step
def flatten3[B](xss: List[List[B]]): List[B] = {
    def _flatten3(oldList: List[List[B]], newList: List[B]): List[B] =
        oldList match {
        case List() => newList
        case head :: tail => _flatten3(tail, newList ::: head)                      // tail recursion pattern
    }
    _flatten3(xss, Nil)
}

-Using foldLeft and foldRight
def foldLeft[B](z: B)(f: (B, A) => B): B                                            // z represents the start value, and it’s passed as the first parameter to f
def foldRight[B](z: B)(f: (A, B) => B): B                                           // start value is passed as the second parameter
// map with fold
def map2[A, B](xs: List[A])(f: A => B): List[B] = {
    val startValue = List.empty[B]
    xs.foldRight(startValue) { f(_) :: _ }                                          // second param is a accum list and first one is list element
}
def flatten2[B](xss: List[List[B]]): List[B] = {
    val startValue = List.empty[B]
    xss.foldRight(startValue) { _ ::: _ }
}
// foldRight can throw stackOverflow, map using foldLeft
def map3[A, B](xs: List[A])(f: A => B): List[B] = {
    val startValue = List.empty[B]
    xs.foldLeft(startValue)((a, x) => f(x) :: a).reverse                            // starting from first element - you add them to the end of accum and then reverse
}
List(1, 2, 3, 4).foldLeft(0) { _ + _ }                                              // list sum; res25: Int = 10
List(1, 2, 3, 4).foldLeft(0) { (a, b) => a + 1 }                                    // length of list; res27: Int = 4
// exists implementation
def exists[A](xs: List[A], e: A) =
    xs.foldLeft(false)((a, x) => a || (x == e))
 
-Building your own function objects
// function object is an object that you can use as a function
object foldl {
    def apply[A, B](xs: Traversable[A], defaultValue: B)(op: (B, A) => B) = (defaultValue /: xs)(op)
}
foldl(List("1", "2", "3"), "0") { _ + _ }
// alt impl
object ++ extends Function1[Int, Int]{
    def apply(p: Int): Int = p + 1
}
val ++ = (x: Int) => x + 1 
// or
object ++ extends (Int => Int) {
    def apply(p: Int): Int = p + 1
}
// compose
val addOne: Int => Int = x => x + 1
val addTwo: Int => Int = x => x + 2
val addThree = addOne compose addTwo
val addThree: Int => Int = x => addOne(addTwo(x))

-Scala collection hierarchy
###################################################################
#               +--------+  +--------+     +--------+             #
#               +  set   +--+sortSet +  +--+  buffer+             #
#               +--------+  +--------+  |  +--------+             #
#                   |                   |                         #
#                   |                   |                         #
#+-----------+  +--------+  +--------+  |  +--------+             #
#|traversable|--+iterable+--+  seq   +--+--+  vector+             #
#+-----------+  +--------+  +--------+  |  +--------+             #
#                   |                   |                         #
#                   |                   |                         #
#               +--------+  +--------+  |  +---------+  +--------+#
#               +  set   +--+sortSet +  +--+linearSeq+--+  list  +#
#               +--------+  +--------+     +---------+  +--------+#
###################################################################    

-Mutable and immutable collections

-Working with List and ListBuffer
val languages = Seq("Scala", "Haskell", "OCaml", "ML")
languages(1)                                                                            // res11: java.lang.String = Haskell
val buf = ListBuffer(1.2, 3.4, 5.6)
buf(2) = 10                                                                             // 10 as 3rd elem
buf                                                                                     // res30: scala.collection.mutable.ListBuffer[Double] = ListBuffer(1.2, 3.4, 10.0)

-Working with Set and SortedSet
val frameworks = Set("Lift", "Akka", "Playframework", "Scalaz")
frameworks("Lift")                                                                      // res38: Boolean = true
val frameworks = Set() + "Akka" + "Lift" + "Scalaz"
val mFrameworks = collection.mutable.Set[String]()
mFrameworks += "Akka" += "Lift"

-Working with Map and Tuple
val m = Map((1, "1st"), (2, "2nd"))
val m = Map(1 -> "1st", 2 -> "2nd")
m(1)                                                                                    // res20: java.lang.String = 1st
m.get(1)                                                                                // res22: Option[java.lang.String] = Some(1st)
m filter { (t) => t._2 == "1st" }

-Under the hood of for-comprehension
case class Artist(name: String, genre: String)
val artists = List(Artist("Pink Floyd", "Rock"),
                   Artist("Led Zeppelin", "Rock"),
                   Artist("Michael Jackson", "Pop"),
                   Artist("Above & Beyond", "trance")
                   )
for(Artist(name, genre) <- artists; if(genre == "Rock"))
    yield name
// Under the hood
artists withFilter {case Artist(name, genre) => genre == "Rock"} map { case Artist(name, genre) => name}
// without yield
for(Artist(name, genre) <- artists) println(name + "," + genre)
artists withFilter {case Artist(name, genre) => true; case _ => false} foreach { case Artist(name, genre) => println(name + "," + genre)}
// When you have multiple generators, Scala uses flatMap
artistsWithAlbums flatMap {
    case ArtistWithAlbums(artist, albums) => albums withFilter {
    album => artist.genre == "Rock"
    } map { case album => album }
}

-Use Option not Null
// When should you use Either rather than Option?
def throwableToLeft[T](block: => T):Either[Throwable, T] =
    try {
    Right(block)
    } catch {
    case ex Throwable => Left(ex)
    }
val r = throwableToLeft {new java.net.Socket("localhost", 4444)}
r match {
    case Left(e) => e.printStackTrace
    case Right(e) => println(e)
}

-Working with lazy collections: views and streams
List(1, 2, 3, 4, 5).map( _ + 1).head                                                // you’re still processing all the elements from 1 to 5 in the List

-Convert a strict collection to a nonstrict collection with views
List(1, 2, 3, 4, 5).view.map( _ + 1).head                                           // calculation is deferred until you invoke head 
def strictProcessing = List(-2, -1, 0, 1, 2) map { 2 / _ }
strictProcessing(0)                                                                 // java.lang.ArithmeticException: / by zero
// fix
def nonStrictProcessing = List(-2, -1, 0, 1, 2).view map { 2 / _ }                 // nonStrictProcessing: scala.collection.SeqView[Int,Seq[_]]
nonStrictProcessing(0)                                                             // res50: Int = -1
// force strict processing
nonStrictProcessing.force                                                          // java.lang.ArithmeticException: / by zero

// call-by-name functions 
def tweets(handle: String) = {
    println("processing tweets for " + handle)
    val source = Source.fromURL(new java.net.URL("http://search.twitter.com/search.atom?q=" + handle))
    val iterator = source.getLines()
    val builder = new StringBuilder
    for(line <- iterator) builder.append(line)
    XML.loadString(builder.toString)
} 
// suppose source takes a lot of time
val allTweets = Map("nraychaudhuri" -> tweets("nraychaudhuri"),
                    "ManningBooks" -> tweets("ManningBooks"),
                    "bubbl_scala" -> tweets("bubbl_scala")
                    )
processing tweets for nraychaudhuri
processing tweets for ManningBooks
processing tweets for bubbl_scala
// while creating a map you invoke tweet function for all users
// how to call function when you need it
val allTweets = Map("nraychaudhuri" -> tweets _ , "ManningBooks" -> tweets _, "bubbl_scala" -> tweets _)        // map using a partial function
// function becomes a partial function when you don’t specify all the arguments it needs
tweets("ManningBooks")                                                              // processing tweets for ManningBooks
tweets _                                                                            // res73: (String) => scala.xml.Elem = <function1>                    
allTweets.view.map{ t => t._2(t._1)}.head                                           // processing tweets for nraychaudhuri
for(t <- allTweets; if(t._1 == "ManningBooks")) t._2(t._1)

-Working with Streams
List("zero", "one", "two", "three", "four", "five").zip(Stream.from(0))             // List((zero,0), (one,1), (two,2)...
// fib
def fib(n: Int): Int = n match {
    case 0 => 0
    case 1 => 1
    case n => fib(n - 1) + fib(n - 2)                                               // steps are computed repeatedly
}
// If you take a Fibonacci sequence starting from 0 (0, 1, 1, 2, 3...) and 
// zip with its tail, you get a sequence of pairs (tuples): ((0, 1), (1,2), (2, 3)...). 
// If you use map to sum the two parts of the pair, you get a number in the Fibonacci series
val fib: Stream[Int] = Stream.cons(0, Stream.cons(1,
    fib.zip(fib.tail).map(t => t._1 + t._2)))

-Divide and conquer with parallel collections

-Parallel collection hierarchy

-Switching between sequential and parallel collections


###############
# Functional programming
###############
-What is functional programming

-The benefits of referential transparency

-A pure functional program

-Moving from OOP to functional programming

-Pure vs. impure programming

-Object-oriented patterns in functional programming

-Modeling purely functional programs

-Functions in all shapes and forms

-Methods vs. functions

-Higher-order functions

-Function currying

-Function composition and partial functions

-Recursion

-Thinking recursively

-Tail recursion

-Algebraic data types

-Why does functional programming matter

-Building higher abstractions with monads

-Managing state using monads

-Building blocks for monads

































