####################
# Basic Scala
####################

    ### Values
    - tuples
        +---------------------------------------------------------------------------+
        | val t: (Int, Boolean, String) = (1, true, "hello")                        |
        | val (a, b, c) = t   // a: Int = 1; b: Boolean = true; c: String = "hello" |
        +---------------------------------------------------------------------------+
    - arrays (fixed length)
        +--------------------------------+
        | val a = Array[Int](1, 2, 3, 4) |
        | a(0) = 11 // (11, 2, 3, 4)     |
        +--------------------------------+
    - option
        +----------------------------------------------------------------+  +--------------------------------------------------+
        | lastNameOpt match {                                            |  | Some("Li").getOrElse("<unknown>")   // "Li"      |
        |     case Some(lastName) => println(s"Hello $title. $lastName") |  | None.getOrElse("<unknown>")         // "unknown" |
        |     case None => println(s"Hello $firstName")                  |  +--------------------------------------------------+
        | }                                                              |
        +----------------------------------------------------------------+

        +--------------------------------------------------+
        | val os1: Option[String] = Some("name")           |
        | val os2: Option[String] = None                   |
        | val o1 = os1.map(_.length).getOrElse(-1)    //4  |
        | val o2 = os2.map(_.length).getOrElse(-1)    //-1 |
        +--------------------------------------------------+
    
    ### Loops, Conditionals, Comprehensions
    - for                                                                                   - multi
        +--------------------------------------------+  +------------------------------+    +--------------------------------------------------------+
        | var total = 0                              |  | var total = 0                |    | val multi = Array(Array(1, 2, 3), Array(4, 5, 6))      |
        | val items = Array(1, 10, 100, 1000)        |  | for (i <- Range(0, 5)) {     |    | for (arr <- multi; i <- arr) println(i) // 1,2,3,4,5,6 |
        | for (item <- items) total += item   //1111 |  |     total = total + i   //10 |    +--------------------------------------------------------+
        +--------------------------------------------+  | }                            |
                                                        +------------------------------+
    - if
        +----------------------------------------------+
        | var total = 0                                |
        | for (i <- Range(0, 10)) {                    |
        |     total += (if (i % 2 == 0) i else 2) //30 |
        | }                                            |
        +----------------------------------------------+
    - Comprehensions
        +-----------------------------------------------------------+   +-----------------------------------------------------------------------------------------------------+
        | val a = Array(1, 2, 3, 4)                                 |   | val a = Array(1, 2); val b = Array("hello", "world")                                                |
        | val a2 = for (i <- a) yield i * i   //Array(1, 4, 9, 16)  |   | val flattened = for (i <- a; s <- b) yield s + i    //Array("hello1", "world1", "hello2", "world2") |
        +-----------------------------------------------------------+   +-----------------------------------------------------------------------------------------------------+
        +------------------------+
        | val flattened2 = for { |  // use {} for multiline
        |   i <- a1              |
        |   s <- a2              |
        | } yield s + i          |
        +------------------------+
    
    ### Methods and Functions
        +---------------------------+
        | def hello(i: Int = 0) = { |
        |     "hello " + i          |
        | }                         |
        +---------------------------+
        - functions
        +--------------------------------+
        | var g: Int => Int = i => i + 1 |  // cannot have optional arguments (i.e. with default values) 
        | g = i => i * 2                 |  // cannot take type parameters via the [T] syntax
        | g(10)   // 20                  |
        +--------------------------------+
        - methods taking Functions
        +------------------------------------------+    +-----------------------------------+               +-------------------------------+
        | class Box(var x: Int) {                  |    | val b = new Box(1)                |               | def increment(i: Int) = i + 1 |
        |     def update(f: Int => Int) = x = f(x) |    | b.printMsg("Hello")     //Hello1  |               | b.update(increment)           |
        |     def printMsg(msg: String) = {        |    | b.update(i => i + 5)              |   // _ + 5    | b.update(x => increment(x))   |
        |         println(msg + x)                 |    | b.printMsg("Hello")     // Hello6 |               | b.update(increment(_))        |
        |     }                                    |    |                                   |               +-------------------------------+
        | }                                        |    +-----------------------------------+
        +------------------------------------------+
        - multiple Parameter Lists
        +----------------------------------------+  +------------------------------------+
        | def myLoop(start: Int, end: Int)       |  | myLoop(start = 5, end = 10) { i => |
        |     (callback: Int => Unit) = {        |  |     println(s"i has value ")       |
        |         for (i <- Range(start, end)) { |  | }                                  |
        |             callback(i)                |  +------------------------------------+
        |         }                              |
        | }                                      |
        +----------------------------------------+

    ### Classes and Traits
        +-----------------------------------+
        | class Foo(x: Int) {               |   // x is private -> "val x: Int" - public - "f.x"
        |     val bar = "bar"               |   // added to constructor
        |     def printMsg(msg: String) = { |   
        |         println(msg + x)          |   // val f = new Foo(1)
        |     }                             |   // f.printMsg("hello")  // hello1
        | }                                 |
        +-----------------------------------+
        - Traits
        +---------------------------------------------------------------+
        | trait Point{ def hypotenuse: Double }                         |
        | class Point2D(x: Double, y: Double) extends Point{            |
        |     def hypotenuse = math.sqrt(x * x + y * y)                 |
        | }                                                             |
        | class Point3D(x: Double, y: Double, z: Double) extends Point{ |
        |     def hypotenuse = math.sqrt(x * x + y * y + z * z)         |
        | }                                                             |
        +---------------------------------------------------------------+

    - flexibleFizzBuzz
    // flexibleFizzBuzz(s => ())    
    +-------------------------------------------------+ +-------------------------------------+
    | def flexibleFizzBuzz(f: String => Unit) = {     | | var i = 0                           |
    |   for (i<-Range(0,100)){                        | | val output = new Array[String](100) |
    |     if (i % 3 == 0 && i % 5 == 0) f("FizzBuzz") | | flexibleFizzBuzz{s =>               |
    |     else if (i % 3 == 0) f("Fizz")              | |   output(i) = s                     |
    |     else if (i % 5 == 0) f("Buzz")              | |   i += 1                            |
    |     else f(i.toString)                          | | }                                   |
    |   }                                             | +-------------------------------------+
    | }                                               |
    +-------------------------------------------------+ 
    - printMessages
    +----------------------------------------------------------------+  +----------------------------------------------------------------+
    | def printMessages(messages: Array[Msg]): Unit = {              |  | def printMessages(messages: Array[Msg]): Unit = {              |
    |   def loop(par: Option[Int], spacesNumber: Int): Int = {       |  |   def printFrag(parent: Option[Int], indent: String): Unit = { |
    |     par match{                                                 |  |     for (msg <- messages if msg.parent == parent) {            |
    |       case Some(p) => loop(messages(p).parent, spacesNumber+1) |  |       println(s"#${msg.id} ${msg.txt}")                        |
    |       case None => spacesNumber                                |  |       printFrag(Some(msg.id), indent + "    ")                 |
    |     }                                                          |  |     }                                                          |
    |   }                                                            |  |   }                                                            |
    |   for (m<-messages){ println(" "*loop(m.parent, 0) + m.txt)}   |  |   printFrag(None, "")                                          |
    | }                                                              |  | }                                                              |
    +----------------------------------------------------------------+  +----------------------------------------------------------------+
    - contextManager
    +---------------------------------------------------------------------------+
    |   def withFileWriter(str: String)(f: BufferedWriter => Unit) = {          |   // withFileWriter("File.txt") { writer => writer.write("Hello\n"); writer.write("World!")}
    |     val bw = new BufferedWriter(new FileWriter(str))                      |
    |     f(bw)                                                                 |
    |     bw.close()}                                                           |
    |                                                                           |
    |   def withFileReader(str: String)(f: BufferedReader => String):String = { |   // val result = withFileReader("File.txt") { reader =>reader.readLine() + "\n" + reader.readLine()}
    |     val fr = new BufferedReader(new FileReader(str))                      |   // assert(result == "Hello\nWorld!")
    |     val res =f(fr)                                                        |
    |     fr.close()                                                            |
    |     res}                                                                  |
    +---------------------------------------------------------------------------+

####################
# Scala Collections
####################

    ### Operations
        - Builders
        +-----------------------------------------------+
        | val b = Array.newBuilder[Int]                 |   // construct a collection of unknown length
        | b += 1                                        |
        | b += 2                                        |
        | b.result()  // res3: Array[Int] = Array(1, 2) |
        +-----------------------------------------------+

        - Factory Methods
        +---------------------------------------------------------------------------------------------------------+
        | Array.fill(5)("hello")                  // Array("hello", "hello", "hello", "hello", "hello")           |
        | Array.tabulate(5)(n => s"hello $n")     // Array("hello 0", "hello 1", "hello 2", "hello 3", "hello 4") |
        | Array(1, 2, 3) ++ Array(4, 5, 6)        // Array(1, 2, 3, 4, 5, 6)                                      |
        +---------------------------------------------------------------------------------------------------------+

        - Transforms
        +--------------------------------------------------------------------------+
        | Array(1, 2, 3, 4, 5).map(i => i * 2)            // Array(2, 4, 6, 8, 10) |    // transform creates new collection, creates copies of collection
        | Array(1, 2, 3, 4, 5).filter(i => i % 2 == 1)    // Array(1, 3, 5)        |    // copying has an overhead - to improve you can convert to mutable collection
        | Array(1, 2, 3, 4, 5).take(2)                    // Array(1, 2)           |
        | Array(1, 2, 3, 4, 5).drop(2)                    // Array(3, 4, 5)        |
        | Array(1, 2, 3, 4, 5).slice(1, 4)                // Array(2, 3, 4)        |
        | Array(1, 1, 2, 3, 4).distinct                   // Array(1, 2, 3, 4)     |
        +--------------------------------------------------------------------------+

        - Queries
        +------------------------------------------------------------------------------------------------------------+
        | Array(1, 2, 3, 4, 5, 6, 7).find(i => i % 2 == 0 && i > 4)       // Some(6)                                 |
        | Array(1, 2, 3, 4, 5, 6, 7).find(i => i % 2 == 0 && i > 10)      // None                                    |
        | Array(1, 2, 3, 4, 5, 6, 7).exists(x => x > 1)                   // are any elements greater than 1? - true |
        | Array(1, 2, 3, 4, 5, 6, 7).exists(_ < 0) // same as a.exists(x => x < 0)    // false                       |
        +------------------------------------------------------------------------------------------------------------+

        - Aggregations
            -mkString
            +-----------------------------------------------------------------------------------+
            | Array(1, 2, 3, 4, 5, 6, 7).mkString(",")            // String = "1,2,3,4,5,6,7"   |
            | Array(1, 2, 3, 4, 5, 6, 7).mkString("[", ",", "]")  // String = "[1,2,3,4,5,6,7]" |
            +-----------------------------------------------------------------------------------+

            -foldLeft
            +---------------------------------------------------------------------------+   +--------------------------------------------------+
            | Array(1, 2, 3, 4, 5, 6, 7).foldLeft(0)((x, y) => x + y)     // Int = 28   |   | {var total = 0                                   |
            | Array(1, 2, 3, 4, 5, 6, 7).foldLeft(1)((x, y) => x * y)     // Int = 5040 |   | for (i <- Array(1, 2, 3, 4, 5, 6, 7)) total += i |
            | Array(1, 2, 3, 4, 5, 6, 7).foldLeft(1)(_ * _)               // Int = 5040 |   | total}                                           |
            +---------------------------------------------------------------------------+   +--------------------------------------------------+

            -groupBy
            +-----------------------------------------------------------------------------------------------------------------+
            | val grouped = Array(1, 2, 3, 4, 5, 6, 7).groupBy(_ % 2)     // Map(0 -> Array(2, 4, 6), 1 -> Array(1, 3, 5, 7)) |
            | grouped(0)  // Array(2, 4, 6)                                                                                   |
            | grouped(1)  // Array(1, 3, 5, 7)                                                                                |
            +-----------------------------------------------------------------------------------------------------------------+

        - Combining Operations
            +----------------------------------------------------------------+
            | def stdDev(a: Array[Double]): Double = {                       |
            |     val mean = a.foldLeft(0.0)(_ + _) / a.length               |  // val mean = a.sum / a.length
            |     val squareErrors = a.map(_ - mean).map(x => x * x)         |
            |     math.sqrt(squareErrors.foldLeft(0.0)(_ + _) / a.length)    |
            | }                                                              |
            | stdDev(Array(1, 2, 3, 4, 5))    // Double = 1.4142135623730951 |
            | stdDev(Array(3, 3, 3))          // Double = 0.0                |
            +----------------------------------------------------------------+

            -
            +-------------------------------------------------------------------------------------------+
            | def isValidSudoku(grid: Array[Array[Int]]): Boolean = {                                   |
            |     !Range(0, 9).exists{i =>                                                              |
            |         val row = Range(0, 9).map(grid(i)(_))                                             |
            |         val col = Range(0, 9).map(grid(_)(i))                                             |
            |         val square = Range(0, 9).map(j => grid((i % 3) * 3 + j % 3)((i / 3) * 3 + j / 3)) |
            |         row.distinct.length != row.length ||                                              |
            |         col.distinct.length != col.length ||                                              |
            |         square.distinct.length != square.length                                           |
            |     }                                                                                     |
            | }                                                                                         |
            +-------------------------------------------------------------------------------------------+

        - Converters
            +----------------------------------------------------+
            | Array(1, 2, 3).to(Vector)       // Vector(1, 2, 3) |
            | Vector(1, 2, 3).to(Array)       // Array(1, 2, 3)  |
            | Array(1, 1, 2, 2, 3, 4).to(Set) // Set(1, 2, 3, 4) |
            +----------------------------------------------------+

        - Views
            +------------------------------------------------------------------------------+
            | val myArray = Array(1, 2, 3, 4, 5, 6, 7, 8, 9)                               |    // When you chain multiple transformations we are creating many intermediate collections that are immediately thrown away
            | val myNewArray = myArray.map(x => x + 1).filter(x => x % 2 == 0).slice(1, 3) |    // ends up traversing the collection three times (its wasteful)
            +------------------------------------------------------------------------------+

            +----------------------------------------------------------------------------------------------------+
            | val myNewArray = myArray.view.map(_ + 1).filter(_ % 2 == 0).slice(1, 3).to(Array)   // Array(4, 6) |  //  perform this chain of map/filter/slice transformations with only a single traversal
            +----------------------------------------------------------------------------------------------------+

    ### Immutable Collections
            - useful in multi-threaded scenarios
            - immutable collections use Structural Sharing (4.2.2) to make creating updated copies cheap, allowing you to use them in all but the most performance critical code
        - Immutable Vectors (O(log n))
            -fixed-size, general-purpose, immutable linear sequences (provide efficient O(log n) performance for most operations.)
            -unlike Arrays where a(...) = ... mutates it in place, a Vector's .updated method returns a new Vector
            -support same operations as arrays (builders, factory methods, transforms)
            -good for sequence that will not change
            -trre structure makes operations efficient
            -for updates - not as fast as arrays or lists of adding to front
            +-------------------------------------------------------------------------+     +-----------------------------------------+
            | val v = Vector(1, 2, 3, 4, 5)                                           |     | val v = Vector[Int]()   // Vector()     |
            | v(0)                        // Int = 1                                  |     | val v1 = v :+ 1         // Vector(1)    |
            | val v2 = v.updated(2, 10)   //Vector(1, 2, 10, 4, 5) (v did not change) |     | val v2 = 4 +: v1        // Vector(4, 1) |
            +-------------------------------------------------------------------------+     | val v3 = v2.tail        // Vector(1)    |
                                                                                            +-----------------------------------------+

        - Structural Sharing
            +-----------------------------------------------------------------------+   +-----------------------------------------------------------------------+
            | val v1 = Vector(1, 2, 0, 9, 7, 2, 9, 6, ..., 3, 2, 5, 5, 4, 8, 4, 6)  |   | val v2 = v1.updated(4, 8)                                             |
            |                   V1                                                  |   |                   V1 copied                                           |
            |                +-+-+-+-+                                              |   |                +-+-+-+-+                                              |
            |            ----+ | | | +----                                          |   |            ----+ | | | +----                                          |
            |           /    +-+-+-+-+    \                                         |   |           /    +-+-+-+-+    \                                         |
            |          /        / \        \                                        |   |          /        / \        \                                        |
            |         /        /   \        \                                       |   |         / copied /   \        \                                       |
            | +-------+ +-+-+-+-+ +-+-+-+-+ +-+-+-+-+                               |   | +-------+ +-+-+-+-+ +-+-+-+-+ +-+-+-+-+                               |
            | |1|2|0|9| | | | | | | | | | | | | | | |                               |   | |1|2|0|9| | | | | | | | | | | | | | | |                               |
            | +-------+ +-+-+-+-+ +-+-+-+-+ +-+-+-+-+                               |   | +-------+ +-+-+-+-+ +-+-+-+-+ +-+-+-+-+                               |
            |          /         /                                                  |   | copied   /         /                                                  |
            | +-------+ +-------+                                                   |   | +-------+ +-------+                                                   |
            | |7|2|9|6| |7|2|9|6|                                                   |   | |8|2|9|6| |7|2|9|6|                                                   |
            | +-------+ +-------+                                                   |   | +-------+ +-------+                                                   |
            +-----------------------------------------------------------------------+   +-----------------------------------------------------------------------+
            -for update - 3 nodes needed to be copied, in large vector number of nodes needed to copy is porportional to the height of tree
            -never be as fast as update in place (if performance needed consider ArrayDeque which has O(1) update/prepend/append or Artray if size will not change) 
            -similar tree-shaped data structure is also used to implement Immutable Sets and Immutable Maps 

        - Immutable Sets
            - unordered collections of elements without duplicates
            - O(log n) .contains method
            - Set operations take time O(log n) in the size of the Set
            - in cases where it isn't you can always fall back to Mutable Sets for better performance
            +-----------------------------------------+ +--------------------------------------------------+
            | val s = Set(1, 2, 3)    // Set(1, 2, 3) | | Set(1, 2, 3) + 4 + 5  // HashSet(5, 1, 2, 3, 4)  |
            | s.contains(2)           // true         | | Set(1, 2, 3) - 2      // Set(1, 3)               |
            | s.contains(4)           // false        | | Set(1, 2, 3) ++ Set(2, 3, 4)  // Set(1, 2, 3, 4) |
            +-----------------------------------------+ +--------------------------------------------------+
            +------------------------------------------+
            | for (i <- Set(1, 2, 3, 4, 5)) println(i) |
            +------------------------------------------+

        - Immutable Maps
            -unordered collections of keys and values, allowing efficient lookup by key
            -most immutable Map operations take time O(log n)
            +---------------------------------------------------+   +--------------------------------------------+
            | val m = Map("one" -> 1, "two" -> 2, "three" -> 3) |   | m.get("one")      // Option[Int] = Some(1) |  // use .get if you're not sure whether a map contains a key or not
            | m.contains("two")   // true                       |   | m.get("four")     // Option[Int] = None    |
            | m("two")            // Int = 2                    |   +--------------------------------------------+
            +---------------------------------------------------+
            +-------------------------------------------------------------------------------------------+
            | Vector(("one", 1), ("two", 2), ("three", 3)).to(Map)                                      |
            | Map[String, Int]() + ("one" -> 1) + ("three" -> 3)      //  Map("one" -> 1, "three" -> 3) |
            | for ((k, v) <- m) println(k + " " + v)                                                    |
            |     one 1                                                                                 |
            |     two 2                                                                                 |
            |     three 3                                                                               |
            +-------------------------------------------------------------------------------------------+

        - Immutable Lists
            - singly-linked list
            - O(1) to .head, .tail, :: (to create new list with new element in front)
            - indexed lookup via myList(i) is a slow O(n)
            - Appending/removing elements on the right hand side of the list is also a slow O(n)
            - want fast indexed lookup or fast appends/removes on the right, you should consider using Vectors or mutable ArrayDeques
            +------------------------------------------------------------+  +------------------------------------------------------+
            | val myList = List(1, 2, 3, 4, 5)                           |  |                   +------+                           |
            | myList.head                     // Int = 1                 |  |                   |myList|                           |
            | val myTail = myList.tail        // List(2, 3, 4, 5)        |  |            +-+    +------+                           |
            | val myOtherList = 0 :: myList   // List(0, 1, 2, 3, 4, 5)  |  | myOtherList|1|            \                          |
            | val myThirdList = -1 :: myList  // List(-1, 1, 2, 3, 4, 5) |  |            +-------------->+-+ +-+ +-+ +-+ +-+ +---+ |
            +------------------------------------------------------------+  |                            |1|>|2|>|3|>|4|>|5|>|Nil| |
                                                                            |            +--+----------->+-+ +-+ +-+ +-+ +-+ +---+ |
                                                                            | myThirdList|-1|               /                      |
                                                                            |            +--+       +------+                       |
                                                                            |                       |myTail|                       |
                                                                            |                       +------+                       |
                                                                            +------------------------------------------------------+

    ### Mutable Collections
        - Mutable ArrayDeques
            - efficient O(1) indexed lookups/updates/inserts/removal of left & right ends
            - reuses array as much as possible moving start/end
            - if number of elements exceeds array size - it gets reallocated
            - faster than immu8table Vector
            - good for fifo, filo with .append/.removeHead-.removeLast
            +--------------------------------------------------+
            |             removeHead() append(6)  removeHead() |
            |         end         end  end         end         |
            |  start   +     start +   + start     +   start   |
            |  +       |     +     |   | +         |   +       |
            | ++-------++ +--+-----++ ++-+------+ ++---+----+  |
            | |1|2|3|4|5| | |2|3|4|5| |6|2|3|4|5| |6| |3|4|5|  |
            | +---------+ +---------+ +---------+ +---------+  |
            +--------------------------------------------------+
            +-------------------------+
            | myArrayDeque.to(Vector) | // "freeze" a mutable ArrayDeque 
            +-------------------------+

        - Mutable Sets
            - .contains checks (O(1))
            - instead of constructing new copies of the Set via + and -, you instead add and remove elements from the Set via .add and .remove
            +-----------------------------------------------------------------+     +---------------------------------+
            | val s = collection.mutable.Set(1, 2, 3)     // HashSet(1, 2, 3) |     | s.add(4)                        |
            | s.contains(2)       // true                                     |     | s.remove(1)                     |
            | s.contains(4)       // false                                    |     | s           // HashSet(2, 3, 4) |
            +-----------------------------------------------------------------+     +---------------------------------+

        - Mutable Maps
            +--------------------------------------------------------------------------------------------------------------------------+
            | val m = collection.mutable.Map("one" -> 1, "two" -> 2, "three" -> 3)    // HashMap("two" -> 2, "three" -> 3, "one" -> 1) |
            | m.remove("two")     // Some(2)                                                                                           |
            | m("five") = 5                                                                                                            |
            | m                   // HashMap("five" -> 5, "three" -> 3, "one" -> 1)                                                    |
            +--------------------------------------------------------------------------------------------------------------------------+
            -getOrElseUpdate - look up a value by key, and compute/store the value if there isn't one already present:
            +-----------------------------------------------------------------------------------------------------+
            | val m = collection.mutable.Map("one" -> 1, "two" -> 2, "three" -> 3)                                |
            | m.getOrElseUpdate("three", -1)      // Int = 3                                                      |
            | m                                   // HashMap("two" -> 2, "three" -> 3, "one" -> 1)                |
            | m.getOrElseUpdate("four", -1)       // Int = -1                                                     |
            | m                                   // HashMap( "two" -> 2, "three" -> 3, "four" -> -1, "one" -> 1) |
            +-----------------------------------------------------------------------------------------------------+

        - In-Place Operations
            - All mutable collections, including Arrays, have in-place versions of many common collection operations
            +-----------------------------------------------------------+
            | val a = collection.mutable.ArrayDeque(1, 2, 3, 4)         |
            | a.mapInPlace(_ + 1)             // ArrayDeque(2, 3, 4, 5) |
            | a.filterInPlace(_ % 2 == 0)     // ArrayDeque(2, 4)       |
            | a                               // ArrayDeque(2, 4)       |
            +-----------------------------------------------------------+

    ### Common Interfaces
        - code that needs something that can be iterated over
            +--------------------------------------------------------------------------------------------------------+
            | def iterateOverSomething[T](items: Seq[T]) = {                                                         |
            |     for (i <- items) println(i)                                                                        |
            | }                                                                                                      |
            | iterateOverSomething(Vector(1, 2, 3))       // 1 2 3                                                   |
            | iterateOverSomething(List(("one", 1), ("two", 2), ("three", 3)))    // (one,1) \n (two,2) \n (three,3) |
            +--------------------------------------------------------------------------------------------------------+
        - code that needs something that provides indexed lookup (Array/Vector), but cannot work with list
            +------------------------------------------------------------------------+
            | def getIndexTwoAndFour[T](items: IndexedSeq[T]) = (items(2), items(4)) |
            | getIndexTwoAndFour(Vector(1, 2, 3, 4, 5))   // (Int, Int) = (3, 5)     |
            | getIndexTwoAndFour(Array(2, 4, 6, 8, 10))   // (Int, Int) = (6, 10)    |
            +------------------------------------------------------------------------+
        - hierarchy
            -immutable
            +------------------------------------------------------------------------------+    // val s = Seq(1, 2, 3 -> delegate is a list(s: Seq[Int] = List(1, 2, 3));
            |                                                       +---------+            |    // Seq    - idxAccess O(n); prepend O(1);
            |                                            (HashMap)  |HashMap  |            |    // Vector - idxAccess O(1); update O(1)
            |                                                +---+  +---------+            |    // val x = IndexedSeq(1,2,3) // x: IndexedSeq[Int] = Vector(1, 2, 3)
            |                            +-------------------+Map+->+ListMap  |            |    // val ar = Array(1,2,3)
            |                            |                   +---+  +---------+  +-------+ |    // can be generic Array[T] (in Java not)
            |                            |                          |SortedMap+->+TreeMap| |
            |                            |                          +---------+  +-------+ |
            |                            |                                                 |
            |                            |                          +------+               |
            |                            |            (Vector)      |Vector|               |
            |                            |            +----------+  +------+               |
            |                            |         +--+IndexedSeq+->+String|               |
            |                            |         |  +----------+  +------+               |
            |                            |         |                |Range |               |
            | (foreach)      (iterator)  |  (List) |                +------+               |
            | +-----------+  +--------+  |  +---+  |                                       |
            | |Traversable+->+Iterable+->-->+Seq+->+                +------+               |
            | +-----------+  +--------+  |  +---+  |                |List  |               |
            |                            |         |   (List)       +------+               |
            |                            |         |   +---------+  |Stack |               |
            |                            |         +---+LinearSeq+->-------+               |
            |                            |             +---------+  |Stream|               |
            |                            |                          +------+               |
            |                            |                          |Queue |               |
            |                            |                          +------+               |
            |                            |                                                 |
            |                            |                          +---------+            |
            |                            |               (HashSet)  |HashSet  |            |
            |                            |                   +---+  +---------+            |
            |                            +-------------------+Set+->+ListSet  |  +-------+ |
            |                                                +---+  +---------+  |TreeSet| |
            |                                                       |SortedSet+->--------+ |
            |                                                       +---------+  |BitSet | |
            |                                                                    +-------+ |
            |                                                                              |
            +------------------------------------------------------------------------------+
            -mutable
            +-----------------------------------------------------------------------------------------------------------------------------------------------------------------------+
            |                                   +----------+  +------------------+                                                                                                  |
            |                                +->+Stack     +->+SynchronizedStack |                                                                                                  |
            |                                |  +----------+  +------------------+                                                                                                  |
            |                                |                                                                                                                                      |
            |                                |  +----------+                                                                                                                        |
            |                                +-->ArrayStack|                                                                                                                        |
            |                                |  +----------+                                                                                                                        |
            |                                |                                                                                                                                      |
            |                                |                +------------------+  +-----+  +-----------------+                                                                    |
            |                                |  (MutableList) |MutableList       +->+Queue+->+SynchronizedQueue|                                                                    |
            |                                |  +----------+  +------------------+  +-----+  +-----------------+                                                                    |
            |                                +->+LinearSeq +->+LinkedList        |                                                                                                  |
            |                                |  +----------+  +------------------+                                                                                                  |
            |                   (ArrayBuffer)|                |DoubleLinkedList  |                                                                                                  |
            |                            +---+                +------------------+                                                                                                  |
            |                         +->+Seq|                                                                                                                                      |
            |                         |  +---+                +------------------+                                                                                                  |
            |                         |      | (ArrayBuffer)  |ArraySeq          |                                                                                                  |
            |                         |      |  +----------+  +------------------+                                                                                                  |
            |                         |      +->+IndexedSeq+->+StringBuilder     |                                                                                                  |
            |                         |      |  +----------+  +------------------+                                                                                                  |
            |                         |      |                |ArrayBuffer       |                                                                                                  |
            |                         |      |             +->+------------------+                                                                                                  |
            |                         |      |             |                                                                                                                        |
            | +-----------+  +--------+      |             |  +------------------+                                                                                                  |
            | |Traversable+->+Iterable|      |(ArrayBuffer)|  |ListBuffer        |                                                                                                  |
            | +-----------+  +--------+      |  +----------+  +------------------+                                                                                                  |
            |                         |      +->+Buffer    +->+ObservableBuffer  |                                                                                                  |
            |                         |         +----------+  +------------------+                                                                                                  |
            |                         |                       |SynchronizedBuffer|                                                                                                  |
            |                         |                       +------------------+                                                                                                  |
            |                         | (HashSet)                                                                                                                                   |
            |                         |  +---+  +----------------------------------------------------------------------------------------------+                                    |
            |                         +->+Set+->+HashSet| LinkedHashSet| ImmutableSetAdaptor| ObservableSet| SynchronizedSet| SortedSet, BitSet|                                    |
            |                         |  +---+  +----------------------------------------------------------------------------------------------+                                    |
            |                         | (HashMap)                                                                                                                                   |
            |                         |  +---+  +---------------------------------------------------------------------------------------------------------------------------------+ |
            |                         +->+Map+->+HashMap| ListMap| TreeMap| OpenHashMap| WeakHashMap| LinkedHashMap| ImmutableMapAdaptor| SynchronizedMap| MultiMap| ObservableMap| |
            |                         |  +---+  +---------------------------------------------------------------------------------------------------------------------------------+ |
            |                         |                                                                                                                                             |
            |                         |  +----------------------------------------+                                                                                                 |
            |                         +->+PriorityQueue| SynchronizedPriorityQueue|                                                                                                 |
            |                            +----------------------------------------+                                                                                                 |
            +-----------------------------------------------------------------------------------------------------------------------------------------------------------------------+


####################
# Notable Scala Features
####################
        +------------------------------------------------------------------------------------------+
        | def getDayMonthYear(s: String) = s match {                                               |
        |     case s"$day-$month-$year" => println(s"found day: $day, month: $month, year: $year") |
        |     case _ => println("not a date")                                                      |
        | }                                                                                        |
        | getDayMonthYear("9-8-1965")     // found day: 9, month: 8, year: 1965                    |
        | getDayMonthYear("9-8")          // not a date                                            |
        +------------------------------------------------------------------------------------------+
    
    ### Case Classes and Sealed Traits
        -Case Classes
            - classes which are "just data" data is immutable and public, without any mutable state or encapsulation
            +----------------------------------------+
            | case class Point(x: Int, y: Int)       |  // p.x     // Int = 1
            | val p = Point(1, 2)     // Point(1, 2) |  // p.y     // Int = 2
            +----------------------------------------+
            - provide .toString, ==, .copy
            +--------------------------------------------------+    +----------------------------------------------+
            | p.toString              // String = "Point(1,2)" |    | val p = Point(1, 2)                          |
            | p2 = Point(1, 2)                                 |    | val p3 = p.copy(y = 10)     // Point(1, 10)  |
            | p == p2                 // Boolean = true        |    | val p4 = p3.copy(x = 20)    // Point(20, 10) |
            +--------------------------------------------------+    +----------------------------------------------+
            - define methods
            +------------------------------------+
            | case class Point(x: Int, y: Int) { |
            |     def z = x + y                  |
            | }                                  |
            | p = Point(1, 2); p.z    // Int = 3 |
            +------------------------------------+
        - Sealed Traits
            - can be extended by a fixed set of case classes in same file
            +-----------------------------------------------------------------------+
            | {                                                                     |
            |     sealed trait Point                                                |
            |     case class Point2D(x: Double, y: Double) extends Point            |
            |     case class Point3D(x: Double, y: Double, z: Double) extends Point |
            | }                                                                     |
            | def hypotenuse(p: Point) = p match {                                  |
            |     case Point2D(x, y) => math.sqrt(x * x + y * y)                    |
            |     case Point3D(x, y, z) => math.sqrt(x * x + y * y + z * z)         |
            | }                                                                     |
            | val points: Array[Point] = Array(Point2D(1, 2), Point3D(4, 5, 6))     |
            | for (p <- points) println(hypotenuse(p))                              |
            +-----------------------------------------------------------------------+
        - Use Cases for Normal v.s. Sealed Traits
            - normal trait - define class & implement methods; new method needs to be added to all subclasses
            - sealed trait - easy to add new method - simply pattern match on each subclass; adding new class is difficult - go to all pattern matches and add new sub-class;
            - sealed traits good to model hierarchies when you dont expect number of subclasses to grow
            +------------------------------------------------------------+
            | {                                                          |
            |     sealed trait Json                                      |
            |     case class Null() extends Json                         |
            |     case class Bool(value: Boolean) extends Json           |
            |     case class Str(value: String) extends Json             |
            |     case class Num(value: Double) extends Json             |
            |     case class Arr(value: Seq[Json]) extends Json          |
            |     case class Dict(value: Map[String, Json]) extends Json |
            | }                                                          |
            +------------------------------------------------------------+

    ### Pattern Matching
        - Match
            match ints                                      match tuples
            +------------------------------------------+    +--------------------------------------+    // 1 2
            | def dayOfWeek(x: Int) = x match {        |    | for (i <- Range.inclusive(1, 100)) { |    // Fizz
            |     case 1 => "Mon"; case 2 => "Tue"     |    |     val s = (i % 3, i % 5) match {   |    // 4
            |     case 3 => "Wed"; case 4 => "Thu"     |    |         case (0, 0) => "FizzBuzz"    |    // Buzz
            |     case 5 => "Fri"; case 6 => "Sat"     |    |         case (0, _) => "Fizz"        |
            |     case 7 => "Sun"; case _ => "Unknown" |    |         case (_, 0) => "Buzz"        |
            | }                                        |    |         case _ => i                  |
            | dayOfWeek(5)    // String = "Fri"        |    |     }                                |
            | dayOfWeek(-1)   // String = "Unknown"    |    |     println(s)                       |
            +------------------------------------------+    | }                                    |
                                                            +--------------------------------------+
            matching on Case Classes                                matching on String Patterns
            +--------------------------------------------------+    +-----------------------------------------------------------------------+
            | case class Point(x: Int, y: Int)                 |    | def splitDate(s: String) = s match {                                  |
            | def direction(p: Point) = p match {              |    |     case s"--" => s"day: , mon: , yr: " |
            |     case Point(0, 0) => "origin"                 |    |     case _ => "not a date"                                            |
            |     case Point(_, 0) => "horizontal"             |    | }                                                                     |
            |     case Point(0, _) => "vertical"               |    | splitDate("9-8-1965")   // String = "day: 9, mon: 8, yr: 1965"        |
            |     case _ => "diagonal"                         |    | splitDate("9-8")        // String = "not a date"                      |
            | }                                                |    +-----------------------------------------------------------------------+
            | direction(Point(0, 0))  // String = "origin"     |
            | direction(Point(1, 1))  // String = "diagonal"   |
            | direction(Point(10, 0)) // String = "horizontal" |
            +--------------------------------------------------+            

        - Nested Matches
            +---------------------------------------------------------------------------------------+   +-------------------------------------------------------------------------------------------------------------------------------+
            | case class Person(name: String, title: String)                                        |   | def greet2(husband: Person, wife: Person) = (husband, wife) match {                                                           |
            | def greet(p: Person) = p match {                                                      |   |     case (Person(s" ", _), Person(s" ", _)) if last1 == last2 => println(s"Hello Mr and Ms ") |
            |     case Person(s"$firstName $lastName", title) => println(s"Hello $title $lastName") |   |     case (Person(name1, _), Person(name2, _)) => println(s"Hello  and ")                                          |
            |     case Person(name, title) => println(s"Hello $title $name")                        |   | }                                                                                                                             |
            | }                                                                                     |   | greet2(Person("James Bond", "Mr"), Person("Jane Bond", "Ms"))   // Hello Mr and Ms Bond                                       |
            | greet(Person("Haoyi Li", "Mr")) //Hello Mr Li                                         |   +-------------------------------------------------------------------------------------------------------------------------------+
            +---------------------------------------------------------------------------------------+

        - Loops and Vals
            inside loops
            +--------------------------------------------------------------------+
            | val a = Array[(Int, String)]((1, "one"), (2, "two"), (3, "three")) |
            | for ((i, s) <- a) println(s + i)                                   |
            | one1                                                               |
            | two2                                                               |
            | three3                                                             |
            +--------------------------------------------------------------------+
            in val statements
            +----------------------------------+    +------------------------------------------+
            | case class Point(x: Int, y: Int) |    | val s" " = "Hello World"    |
            | val p = Point(123, 456)          |    | first: String = "Hello"                  |
            | val Point(x, y) = p              |    | second: String = "World"                 |
            | x: Int = 123                     |    | val flipped = s" "          |
            | y: Int = 456                     |    | flipped: String = "World Hello"          |
            +----------------------------------+    +------------------------------------------+

        - Pattern Matching on Sealed Traits and Case Classes
            +--------------------------------------------------------------------+
            | {                                                                  |
            | sealed trait Expr                                                  |  x + 1        // BinOp(Variable("x"), "+", Literal(1))
            | case class BinOp(left: Expr, op: String, right: Expr) extends Expr |  x * (y - 1)  // BinOp(Variable("x"), "*", BinOp(Variable("y"), "-", Literal(1)))
            | case class Literal(value: Int) extends Expr                        |  x * (y - 1)  // BinOp( BinOp(Variable("x"), "+", Literal(1)), "*", BinOp(Variable("y"), "-", Literal(1)) )
            | case class Variable(name: String) extends Expr                     |
            | }                                                                  |
            +--------------------------------------------------------------------+
            Stringifying Our Expressions
            +------------------------------------------------------------------------------------+
            | def stringify(expr: Expr): String = expr match {                                   |  // val smallExpr = BinOp( Variable("x"), "+", Literal(1) )
            |     case BinOp(left, op, right) => s"(${stringify(left)} $op ${stringify(right)})" |  // stringify(smallExpr)    // String = "(x + 1)"
            |     case Literal(value) => value.toString                                          |
            |     case Variable(name) => name                                                    |
            | }                                                                                  |
            +------------------------------------------------------------------------------------+
            evaluate
            +--------------------------------------------------------------------------------------+
            | def evaluate(expr: Expr, values: Map[String, Int]): Int = expr match {               |    // evaluate(smallExpr, Map("x" -> 10)) // Int = 11
            |     case BinOp(left, "+", right) => evaluate(left, values) + evaluate(right, values) |
            |     case BinOp(left, "-", right) => evaluate(left, values) - evaluate(right, values) |
            |     case BinOp(left, "*", right) => evaluate(left, values) * evaluate(right, values) |
            |     case Literal(value) => value                                                     |
            |     case Variable(name) => values(name)                                              |
            | }                                                                                    |
            +--------------------------------------------------------------------------------------+

    ### By-Name Parameters
        +----------------------------+
        | def func(arg: => String) = |
        +----------------------------+

        - Avoiding Evaluation
            +-----------------------------------------+
            | var logLevel = 1                        | // log(2, "Hello " + 123 + " World")    // Hello 123 World
            | def log(level: Int, msg: => String) = { | // above is not computing log message
            |     if (level > logLevel) println(msg)  | // getOrElse and getOrElseUpdate are similiar - not use the argument for default value if the value we looking for is present
            | }                                       |
            +-----------------------------------------+

        - Wrapping Evaluation
            defers evaluation of f: => Unit, allowing us to run System.currentTimeMillis() before and after
            +-------------------------------------------------------------------+
            | def measureTime(f: => Unit) = {                                   |   // measureTime(new Array[String](10 * 1000 * 1000).hashCode()) // Evaluation took 24 milliseconds
            |     val start = System.currentTimeMillis()                        |
            |     f                                                             |
            |     val end = System.currentTimeMillis()                          |
            |     println("Evaluation took " + (end - start) + " milliseconds") |
            | }                                                                 |
            +-------------------------------------------------------------------+

        - Repeating Evaluation
            +---------------------------------------------------+
            | def retry[T](max: Int)(f: => T): T = {            |   // val httpbin = "https://httpbin.org"
            |     var tries = 0                                 |   // retry(max = 5) {
            |     var result: Option[T] = None                  |   // // Only succeeds with a 200 response
            |     while (result == None) {                      |   // // code 1/3 of the time
            |         try { result = Some(f) }                  |   //     requests.get(
            |         catch {case e: Throwable =>               |   //     s"/status/200,400,500"
            |             tries += 1                            |   //     )
            |             if (tries > max) throw e              |   // }
            |             else {                                |   // call failed, retry #1
            |                 println(s"failed, retry #$tries") |   // call failed, retry #2
            |             }                                     |   // res68: requests.Response = Response(
            |         }                                         |   // "https://httpbin.org/status/200,400,500",
            |     }                                             |   // 200,
            |     result.get                                    |
            | }                                                 |
            +---------------------------------------------------+

    ### Implicit Parameters
        implicit parameter is automatically filled when calling function
        +--------------------------------------------------------+
        | class Foo(val value: Int)                              |
        | def bar(implicit foo: Foo) = foo.value + 10            |
        | implicit val foo: Foo = new Foo(1)                     |
        | bar // `foo` is resolved implicitly // res72: Int = 11 |
        +--------------------------------------------------------+
        - Passing ExecutionContext to Futures                                           - Dependency Injection via Implicits
            passing this ExecutionContext everywhere                                    +------------------------------------------------------------------------------------+
        +---------------------------------------------------------------------------+   | def getEmployee(id: Int)(implicit ec: ExecutionContext): Future[Employee] = ...    |
        | def getEmployee(ec: ExecutionContext, id: Int): Future[Employee] = ...    |   | def getRole(employee: Employee)(implicit ec: ExecutionContext): Future[Role] = ... |
        | def getRole(ec: ExecutionContext, employee: Employee): Future[Role] = ... |   | implicit val executionContext: ExecutionContext = ...                              |
        | val executionContext: ExecutionContext = ...                              |   |                                                                                    |
        |                                                                           |   | val bigEmployee: Future[EmployeeWithRole] = {                                      |
        | val bigEmployee: Future[EmployeeWithRole] = {                             |   |     getEmployee(100).flatMap(e =>                                                  |
        |     getEmployee(executionContext, 100).flatMap(                           |   |         getRole(e).map(r =>                                                        |
        |         executionContext, e =>                                            |   |             EmployeeWithRole(e, r)                                                 |
        |             getRole(executionContext, e)                                  |   |         )                                                                          |
        |                 .map(executionContext, r => EmployeeWithRole(e, r))       |   |     )                                                                              |
        |     )                                                                     |   | }                                                                                  |
        | }                                                                         |   +------------------------------------------------------------------------------------+
        +---------------------------------------------------------------------------+

    ### Typeclass Inference
        - Problem Statement: Parsing Command Line Arguments
        +---------------------------------------------------+
        | def parseFromString[T](s: String): T = ...        |
        |                                                   |
        | val args = Seq("123", "true", "7.5")              |
        | val myInt = parseFromString[Int](args(0))         |   // How does the parseCliArgument know how to convert 
        | val myBoolean = parseFromString[Boolean](args(1)) |   // the given String into an arbitrary T
        | val myDouble = parseFromString[Double](args(2))   |
        +---------------------------------------------------+

        - Separate Parser Objects
            +--------------------------------------------------------------------------------------+     +---------------------------------------------+
            | trait StrParser[T]{ def parse(s: String): T }                                        |     | val args = Seq("123", "true", "7.5")        |
            | object ParseInt extends StrParser[Int]{ def parse(s: String) = s.toInt }             |     | val myInt = ParseInt.parse(args(0))         |
            | object ParseBoolean extends StrParser[Boolean]{ def parse(s: String) = s.toBoolean } |     | val myBoolean = ParseBoolean.parse(args(1)) |
            | object ParseDouble extends StrParser[Double]{ def parse(s: String) = s.toDouble }    |     | val myDouble = ParseDouble.parse(args(2))   |
            +--------------------------------------------------------------------------------------+     +---------------------------------------------+
            - write a method that didn't parse a String directly, but parsed a value from the console
            - option 1                                                      - option 2
            +------------------------------------------------------------+  +-------------------------------------------------------------------------------------------+
            | trait ConsoleParser[T]{ def parse(): T }                   |  | def parseFromConsole[T](parser: StrParser[T]) = parser.parse(scala.Console.in.readLine()) |
            | object ConsoleParseInt extends ConsoleParser[Int]{         |  | val myInt = parseFromConsole[Int](ParseInt)                                               |
            |     def parse() = scala.Console.in.readLine().toInt        |  | val myBoolean = parseFromConsole[Boolean](ParseBoolean)                                   |
            | }                                                          |  | val myDouble = parseFromConsole[Double](ParseDouble)                                      |
            | object ConsoleParseBoolean extends ConsoleParser[Boolean]{ |  +-------------------------------------------------------------------------------------------+
            |     def parse() = scala.Console.in.readLine().toBoolean    |
            | }                                                          |
            | object ConsoleParseDouble extends ConsoleParser[Double]{   |
            |     def parse() = scala.Console.in.readLine().toDouble     |
            | }                                                          |
            | val myInt = ConsoleParseInt.parse()                        |
            | val myBoolean = ConsoleParseBoolean.parse()                |
            | val myDouble = ConsoleParseDouble.parse()                  |
            +------------------------------------------------------------+     

        - Solution: Implicit StrParser
            -  solution to the problems above is to make the instances of StrParser implicit
             put the implicit object ParseInt, ParseBoolean, etc. in an object StrParser with the same name as the trait StrParser next to it
            +--------------------------------------------------------------+
            | trait StrParser[T]{ def parse(s: String): T }                |
            | object StrParser{                                            |    // companion object
            |     implicit object ParseInt extends StrParser[Int]{         |    // often used to group together implicits, static methods, factory methods, and other functionality that is related to a trait or class but does not belong to any specific instance.
            |         def parse(s: String) = s.toInt                       |    // Implicits in the companion object are also treated specially, and do not need 
            |     }                                                        |    // to be imported into scope in order to be used as an implicit parameter
            |     implicit object ParseBoolean extends StrParser[Boolean]{ |
            |         def parse(s: String) = s.toBoolean                   |
            |     }                                                        |
            |     implicit object ParseDouble extends StrParser[Double]{   |
            |         def parse(s: String) = s.toDouble                    |
            |     }                                                        |
            | }                                                            |
            +--------------------------------------------------------------+
            - we can now write a generic function that automatically uses the correct instance of StrParser depending on what type we asked it to parse
            +----------------------------------------------------------------------+
            | def parseFromString[T](s: String)(implicit parser: StrParser[T]) = { |    // function can now automatically infer the correct StrParser for each type it is trying to parse
            |     parser.parse(s)                                                  |
            | }                                                                    |
            | val args = Seq("123", "true", "7.5")                                 |
            | val myInt = parseFromString[Int](args(0))                            |
            | val myBoolean = parseFromString[Boolean](args(1))                    |
            | val myDouble = parseFromString[Double](args(2))                      |
            +----------------------------------------------------------------------+
            - Re-Using Our Implicit StrParsers                              - Context-Bound Syntax
            +------------------------------------------------------------+  technique of taking an implicit parameter with a generic type is common enough that the Scala language provides dedicated syntax for it. The following method signature
            | def parseFromConsole[T](implicit parser: StrParser[T]) = { |  +------------------------------------------------------------------------+
            |     parser.parse(scala.Console.in.readLine())              |  | def parseFromString[T](s: String)(implicit parser: StrParser[T]) = ... |
            | }                                                          |  +------------------------------------------------------------------------+
            | val myInt = parseFromConsole[Int]                          |  Can be written more concisely as:
            +------------------------------------------------------------+  +----------------------------------------------------+  // context bound
                                                                            | def parseFromString[T: StrParser](s: String) = ... |  // equivalent to the (implicit parser: StrParser[T])
                                                                            +----------------------------------------------------+  // esolve the implicit values via the implicitly function, e.g. implicitly[StrParser[T]].parse

        - Recursive Typeclass Inference
            Parsing Sequences
            teaching the compiler how to produce a StrParser[Seq[T]] for any type T as long as it has an implicit StrParser[T] available
            +-----------------------------------------------------------------------------+ // implicit def ParseSeq would thus return a different StrParser each time it is called with a different type T
            | implicit def ParseSeq[T](implicit p: StrParser[T]) = new StrParser[Seq[T]]{ | +-------------------------------------------------------------------------------------------------------+
            |    def parse(s: String) = s.split(',').toSeq.map(p.parse)                   | | parseFromString[Seq[Boolean]]("true,false,true") // res99: Seq[Boolean] = ArraySeq(true, false, true) |
            | }                                                                           | | parseFromString[Seq[Int]]("1,2,3,4")    // res100: Seq[Int] = ArraySeq(1, 2, 3, 4)                    |
            +-----------------------------------------------------------------------------+ +-------------------------------------------------------------------------------------------------------+
            Parsing Tuples
            +------------------------------------------------------------------------------+    +-------------------------------------------------------------------------------------------+
            | implicit def ParseTuple[T, V](implicit p1: StrParser[T], p2: StrParser[V]) = |    | parseFromString[(Int, Boolean)]("123=true")     // res102: (Int, Boolean) = (123, true)   |
            |     new StrParser[(T, V)]{                                                   |    | parseFromString[(Boolean, Double)]("true=1.5")  //res103: (Boolean, Double) = (true, 1.5) |
            |         def parse(s: String) = {                                             |    +-------------------------------------------------------------------------------------------+
            |             val Array(left, right) = s.split('=')                            |
            |             (p1.parse(left), p2.parse(right))                                |
            |         }                                                                    |
            |     }                                                                        |
            +------------------------------------------------------------------------------+
            Parsing Nested Structures
            +-----------------------------------------------------------------------------------------------------------------------------------+
            | parseFromString[Seq[(Int, Boolean)]]("1=true,2=false,3=true,4=false")   // ArraySeq((1, true), (2, false), (3, true), (4, false)) |
            | parseFromString[(Seq[Int], Seq[Boolean])]("1,2,3,4,5=true,false,true")  // (ArraySeq(1, 2, 3, 4, 5), ArraySeq(true, false, true)) |
            +-----------------------------------------------------------------------------------------------------------------------------------+


####################
# Implementing Algorithms in Scala
####################

    ### Merge Sort
                                                                                                                - Generic Merge Sort
        +-------------------------------------------------------------------------------------------------+    // T: Ordering
        | def mergeSort(items: Array[Int]): Array[Int] = { MergeSort.sc                                   |    // context bound
        |     if (items.length <= 1) items                                                                |    // equivalent to the (implicit parser: StrParser[T])
        |     else {                                                                                      |    // esolve the implicit values via the implicitly function, e.g. implicitly[StrParser[T]].parse
        |         val (left, right) = items.splitAt(items.length / 2)                                     |     +-------------------------------------------------------------------------------------------------+ +--------------------------------------------------------------------------------+
        |         val (sortedLeft, sortedRight) = (mergeSort(left), mergeSort(right))                     |     | def mergeSort[T: Ordering](items: IndexedSeq[T]): IndexedSeq[T] = {                             | | case class Person(name:String, age:Int)                                        |
        |         var (leftIdx, rightIdx) = (0, 0)                                                        |     |     if (items.length <= 1) items                                                                | | implicit object AgeOrdering extends Ordering[Person] {                         |
        |         val output = Array.newBuilder[Int]                                                      |     |     else {                                                                                      | |   def compare(a:Person, b:Person) = a.age compare b.age}                       |
        |         while (leftIdx < sortedLeft.length || rightIdx < sortedRight.length) {                  |     |         val (left, right) = items.splitAt(items.length / 2)                                     | | def main(args: Array[String]): Unit = {                                        |
        |             val takeLeft = (leftIdx < sortedLeft.length, rightIdx < sortedRight.length) match { |     |         val (sortedLeft, sortedRight) = (mergeSort(left), mergeSort(right))                     | |   val people = Array(Person("bob", 30), Person("ann", 32), Person("carl", 19)) |
        |                 case (true, false) => true                                                      |     |         var (leftIdx, rightIdx) = (0, 0)                                                        | |   val res = mergeSort(people)                                                  |
        |                 case (false, true) => false                                                     |     |         val output = IndexedSeq.newBuilder[T]                                                   | |   print(res)                                                                   |
        |                 case (true, true) => sortedLeft(leftIdx) < sortedRight(rightIdx)                |     |         while (leftIdx < sortedLeft.length || rightIdx < sortedRight.length) {                  | | }                                                                              |
        |             }                                                                                   |     |             val takeLeft = (leftIdx < sortedLeft.length, rightIdx < sortedRight.length) match { | +--------------------------------------------------------------------------------+
        |             if (takeLeft) {                                                                     |     |                 case (true, false) => true                                                      |
        |                 output += sortedLeft(leftIdx)                                                   |     |                 case (false, true) => false                                                     |
        |                 leftIdx += 1                                                                    |     |                 case (true, true) => Ordering[T].lt(sortedLeft(leftIdx), sortedRight(rightIdx)) |
        |             } else {                                                                            |     |             }                                                                                   |
        |             output += sortedRight(rightIdx)                                                     |     |             if (takeLeft) {                                                                     |
        |             rightIdx += 1                                                                       |     |                 output += sortedLeft(leftIdx)                                                   |
        |             }                                                                                   |     |                 leftIdx += 1                                                                    |
        |         }                                                                                       |     |             } else {                                                                            |
        |         output.result()                                                                         |     |                 output += sortedRight(rightIdx)                                                 |
        |     }                                                                                           |     |                 rightIdx += 1                                                                   |
        | }                                                                                               |     |             }                                                                                   |
        +-------------------------------------------------------------------------------------------------+     |         }                                                                                       |
                                                                                                                |     output.result()}}         
                                                                                                                +-------------------------------------------------------------------------------------------------+
        
    ### Prefix Tries
        +-------------------------------------------------------------------------------------------------------------------+
        | class Trie() { Trie.sc                                                                                            |
        |     class Node(var hasValue: Boolean,val children: collection.mutable.Map[Char, Node] = collection.mutable.Map()) |
        |     val root = new Node(false)                                                                                    |
        |     def add(s: String) = {                                                                                        |
        |         var current = root                                                                                        |
        |         for (c <- s) current = current.children.getOrElseUpdate(c, new Node(false))                               |
        |         current.hasValue = true                                                                                   |
        |     }                                                                                                             |
        |     def contains(s: String): Boolean = {                                                                          |
        |         var current = Option(root)                                                                                |
        |         for (c <- s if current.nonEmpty) current = current.get.children.get(c)                                    |
        |         current.exists(_.hasValue)                                                                                |
        |     }                                                                                                             |
        |     def prefixesMatchingString0(s: String): Set[Int] = {                                                          |
        |         var current = Option(root)                                                                                |
        |         val output = Set.newBuilder[Int]                                                                          |
        |         for ((c, i) <- s.zipWithIndex if current.nonEmpty) {                                                      |
        |             if (current.get.hasValue) output += i                                                                 |
        |             current = current.get.children.get(c)                                                                 |
        |         }                                                                                                         |
        |         if (current.exists(_.hasValue)) output += s.length                                                        |
        |         output.result()                                                                                           |
        |     }                                                                                                             |
        |     def prefixesMatchingString(s: String): Set[String] = {                                                        |
        |         prefixesMatchingString0(s).map(s.substring(0, _))                                                         |
        |     }                                                                                                             |
        |     def stringsMatchingPrefix(s: String): Set[String] = {                                                         |
        |         var current = Option(root)                                                                                |
        |             for (c <- s if current.nonEmpty) current = current.get.children.get(c) // initial walk                |
        |         if (current.isEmpty) Set()                                                                                |
        |         else {                                                                                                    |
        |             val output = Set.newBuilder[String]                                                                   |
        |             def recurse(current: Node, path: List[Char]): Unit = {                                                |
        |                 if (current.hasValue) output += (s + path.reverse.mkString)                                       |
        |                 for ((c, n) <- current.children) recurse(n, c :: path)                                            |
        |             }                                                                                                     |
        |             recurse(current.get, Nil) // recursive walk                                                           |
        |             output.result()                                                                                       |
        |         }                                                                                                         |
        |     }                                                                                                             |
        | }                                                                                                                 |
        +-------------------------------------------------------------------------------------------------------------------+
        

    ### Breadth First Search
        - cyclic                        - acyclic
        +---------------------------+   +---------------------------+
        | val graph = Map(          |   | val graph = Map(          |
        |     "a" -> Seq("b", "c"), |   |     "a" -> Seq("b", "c"), |
        |     "b" -> Seq("a"),      |   |     "b" -> Seq("c", "d"), |
        |     "c" -> Seq("b")       |   |     "c" -> Seq("d"),      |
        | )                         |   |     "d" -> Seq())         |
        +---------------------------+   +---------------------------+
        - with bfs you can:
            Find all nodes which are reachable from a particular starting node
            Find the shortest distance between a starting node and all other nodes
            Find the shortest path between two specific nodes
        
        - Implementing Breadth First Search
            Keep a seen set of all nodes you have seen so far, and a queue of nodes waiting to be processed
            Start with your starting node in both the seen set and queue
            While the queue is not empty, pull a node off the queue
            For every node which is reachable from the node you just pulled off the queue, if it isn't present in the seen set, add it to both the seen set and queue
            When the queue is empty, we have searched the entire graph
        
            +----------------------------------------------------------------------+    +----------------------------------------+  +---------------------------------------------+ +-----------------------------------+
            | def search[T](start: T, graph: Map[T, Seq[T]]): Set[T] = {           |    | search(                                |  | search(                                     | | search(                           |
            |     val seen = collection.mutable.Set(start)                         |    |     start = "c",                       |  |     start = "a",                            | |     start = "c",                  |
            |     val queue = collection.mutable.ArrayDeque(start)                 |    |     graph = Map(                       |  |     graph = Map(                            | |     graph = Map(                  |
            |     while (queue.nonEmpty) {                                         |    |         "a" -> Seq("b", "c"),          |  |         "a" -> Seq("b", "c"),               | |         "a" -> Seq("b", "c"),     |
            |         val current = queue.removeHead()                             |    |         "b" -> Seq("a"),               |  |         "b" -> Seq("c", "d"),               | |         "b" -> Seq("c", "d"),     |
            |         for (next <- graph(current) if !seen.contains(next)) {       |    |         "c" -> Seq("b")                |  |         "c" -> Seq("d"),                    | |         "c" -> Seq("d"),          |
            |             seen.add(next)                                           |    |     )                                  |  |         "d" -> Seq()                        | |         "d" -> Seq()              |
            |             queue.append(next)                                       |    | )                                      |  |     )                                       | |     )                             |
            |         }                                                            |    | res0: Set[String] = Set("a", "b", "c") |  | )                                           | | )                                 |
            |     }                                                                |    +----------------------------------------+  | res1: Set[String] = Set("a", "b", "c", "d") | | res2: Set[String] = Set("c", "d") |
            |     seen.to(Set)                                                     |                                                +---------------------------------------------+ +-----------------------------------+
            | }                                                                    |
            +----------------------------------------------------------------------+    
        
        - Shortest Paths
            -first path we find from our start node to our destination will be a shortest path between the two nodes
            -Rather than keeping a seen Set[T], we instead maintain a Map[T, List[T]]

        +---------------------------------------------------------------------------+   +----------------------------------------+  +-----------------------------------------+ +------------------------------------+
        | def searchPaths[T](start: T, graph: Map[T, Seq[T]]): Map[T, List[T]] = {  |   | searchPaths(                           |  | shortestPath(                           | | shortestPath(                      |
        |     val seen = collection.mutable.Map(start -> List(start))               |   |     graph = Map(                       |  |     start = "a",                        | |     start = "a",                   |
        |     val queue = collection.mutable.ArrayDeque(start -> List(start))       |   |         "a" -> Seq("b", "c"),          |  |     dest = "d",                         | |     dest = "c",                    |
        |     while (queue.nonEmpty) {                                              |   |         "b" -> Seq("c", "d"),          |  |     graph = Map(                        | |     graph = Map(                   |
        |         val (current, path) = queue.removeHead()                          |   |         "c" -> Seq("d"),               |  |         "a" -> Seq("b", "c"),           | |         "a" -> Seq("b", "c"),      |
        |         for (next <- graph(current) if !seen.contains(next)) {            |   |         "d" -> Seq()                   |  |         "b" -> Seq("c", "d"),           | |         "b" -> Seq("c", "d"),      |
        |             val newPath = next :: path                                    |   |     )                                  |  |         "c" -> Seq("d"),                | |         "c" -> Seq("d"),           |
        |             seen(next) = newPath                                          |   | )                                      |  |         "d" -> Seq()                    | |         "d" -> Seq()               |
        |             queue.append((next, newPath))                                 |   | res0: Map[String, List[String]] = Map( |  |     )                                   | |     )                              |
        |         }                                                                 |   |     "a" -> List("a"),                  |  | )                                       | | )                                  |
        |     }                                                                     |   |     "b" -> List("b", "a"),             |  | res1: Seq[String] = List("a", "b", "d") | | res2: Seq[String] = List("a", "c") |
        |     seen.toMap                                                            |   |     "c" -> List("c", "a"),             |  +-----------------------------------------+ +------------------------------------+
        | }                                                                         |   |     "d" -> List("d", "b", "a")         |
        |                                                                           |   | )                                      |
        | def shortestPath[T](start: T, dest: T, graph: Map[T, Seq[T]]): Seq[T] = { |   +----------------------------------------+
        |     val shortestReversedPaths = searchPaths(start, graph)                 |
        |     shortestReversedPaths(dest).reverse                                   |
        | }                                                                         |
        +---------------------------------------------------------------------------+

        
        
        
        
        
        
        