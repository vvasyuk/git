####################
# Basic Scala
####################

    ### Values
    - tuples
        +---------------------------------------------------------------------------+
        | val t: (Int, Boolean, String) = (1, true, "hello")                        |
        | val (a, b, c) = t   // a: Int = 1; b: Boolean = true; c: String = "hello" |
        +---------------------------------------------------------------------------+
    - arrays (fixed length)
        +--------------------------------+
        | val a = Array[Int](1, 2, 3, 4) |
        | a(0) = 11 // (11, 2, 3, 4)     |
        +--------------------------------+
    - option
        +----------------------------------------------------------------+  +--------------------------------------------------+
        | lastNameOpt match {                                            |  | Some("Li").getOrElse("<unknown>")   // "Li"      |
        |     case Some(lastName) => println(s"Hello $title. $lastName") |  | None.getOrElse("<unknown>")         // "unknown" |
        |     case None => println(s"Hello $firstName")                  |  +--------------------------------------------------+
        | }                                                              |
        +----------------------------------------------------------------+

        +--------------------------------------------------+
        | val os1: Option[String] = Some("name")           |
        | val os2: Option[String] = None                   |
        | val o1 = os1.map(_.length).getOrElse(-1)    //4  |
        | val o2 = os2.map(_.length).getOrElse(-1)    //-1 |
        +--------------------------------------------------+
    
    ### Loops, Conditionals, Comprehensions
    - for                                                                                   - multi
        +--------------------------------------------+  +------------------------------+    +--------------------------------------------------------+
        | var total = 0                              |  | var total = 0                |    | val multi = Array(Array(1, 2, 3), Array(4, 5, 6))      |
        | val items = Array(1, 10, 100, 1000)        |  | for (i <- Range(0, 5)) {     |    | for (arr <- multi; i <- arr) println(i) // 1,2,3,4,5,6 |
        | for (item <- items) total += item   //1111 |  |     total = total + i   //10 |    +--------------------------------------------------------+
        +--------------------------------------------+  | }                            |
                                                        +------------------------------+
    - if
        +----------------------------------------------+
        | var total = 0                                |
        | for (i <- Range(0, 10)) {                    |
        |     total += (if (i % 2 == 0) i else 2) //30 |
        | }                                            |
        +----------------------------------------------+
    - Comprehensions
        +-----------------------------------------------------------+   +-----------------------------------------------------------------------------------------------------+
        | val a = Array(1, 2, 3, 4)                                 |   | val a = Array(1, 2); val b = Array("hello", "world")                                                |
        | val a2 = for (i <- a) yield i * i   //Array(1, 4, 9, 16)  |   | val flattened = for (i <- a; s <- b) yield s + i    //Array("hello1", "world1", "hello2", "world2") |
        +-----------------------------------------------------------+   +-----------------------------------------------------------------------------------------------------+
        +------------------------+
        | val flattened2 = for { |  // use {} for multiline
        |   i <- a1              |
        |   s <- a2              |
        | } yield s + i          |
        +------------------------+
    
    ### Methods and Functions
        +---------------------------+
        | def hello(i: Int = 0) = { |
        |     "hello " + i          |
        | }                         |
        +---------------------------+
        - functions
        +--------------------------------+
        | var g: Int => Int = i => i + 1 |  // cannot have optional arguments (i.e. with default values) 
        | g = i => i * 2                 |  // cannot take type parameters via the [T] syntax
        | g(10)   // 20                  |
        +--------------------------------+
        - methods taking Functions
        +------------------------------------------+    +-----------------------------------+               +-------------------------------+
        | class Box(var x: Int) {                  |    | val b = new Box(1)                |               | def increment(i: Int) = i + 1 |
        |     def update(f: Int => Int) = x = f(x) |    | b.printMsg("Hello")     //Hello1  |               | b.update(increment)           |
        |     def printMsg(msg: String) = {        |    | b.update(i => i + 5)              |   // _ + 5    | b.update(x => increment(x))   |
        |         println(msg + x)                 |    | b.printMsg("Hello")     // Hello6 |               | b.update(increment(_))        |
        |     }                                    |    |                                   |               +-------------------------------+
        | }                                        |    +-----------------------------------+
        +------------------------------------------+
        - multiple Parameter Lists
        +----------------------------------------+  +------------------------------------+
        | def myLoop(start: Int, end: Int)       |  | myLoop(start = 5, end = 10) { i => |
        |     (callback: Int => Unit) = {        |  |     println(s"i has value ")       |
        |         for (i <- Range(start, end)) { |  | }                                  |
        |             callback(i)                |  +------------------------------------+
        |         }                              |
        | }                                      |
        +----------------------------------------+

    ### Classes and Traits
        +-----------------------------------+
        | class Foo(x: Int) {               |   // x is private -> "val x: Int" - public - "f.x"
        |     val bar = "bar"               |   // added to constructor
        |     def printMsg(msg: String) = { |   
        |         println(msg + x)          |   // val f = new Foo(1)
        |     }                             |   // f.printMsg("hello")  // hello1
        | }                                 |
        +-----------------------------------+
        - Traits
        +---------------------------------------------------------------+
        | trait Point{ def hypotenuse: Double }                         |
        | class Point2D(x: Double, y: Double) extends Point{            |
        |     def hypotenuse = math.sqrt(x * x + y * y)                 |
        | }                                                             |
        | class Point3D(x: Double, y: Double, z: Double) extends Point{ |
        |     def hypotenuse = math.sqrt(x * x + y * y + z * z)         |
        | }                                                             |
        +---------------------------------------------------------------+

    - flexibleFizzBuzz
    // flexibleFizzBuzz(s => ())    
    +-------------------------------------------------+ +-------------------------------------+
    | def flexibleFizzBuzz(f: String => Unit) = {     | | var i = 0                           |
    |   for (i<-Range(0,100)){                        | | val output = new Array[String](100) |
    |     if (i % 3 == 0 && i % 5 == 0) f("FizzBuzz") | | flexibleFizzBuzz{s =>               |
    |     else if (i % 3 == 0) f("Fizz")              | |   output(i) = s                     |
    |     else if (i % 5 == 0) f("Buzz")              | |   i += 1                            |
    |     else f(i.toString)                          | | }                                   |
    |   }                                             | +-------------------------------------+
    | }                                               |
    +-------------------------------------------------+ 
    - printMessages
    +----------------------------------------------------------------+  +----------------------------------------------------------------+
    | def printMessages(messages: Array[Msg]): Unit = {              |  | def printMessages(messages: Array[Msg]): Unit = {              |
    |   def loop(par: Option[Int], spacesNumber: Int): Int = {       |  |   def printFrag(parent: Option[Int], indent: String): Unit = { |
    |     par match{                                                 |  |     for (msg <- messages if msg.parent == parent) {            |
    |       case Some(p) => loop(messages(p).parent, spacesNumber+1) |  |       println(s"#${msg.id} ${msg.txt}")                        |
    |       case None => spacesNumber                                |  |       printFrag(Some(msg.id), indent + "    ")                 |
    |     }                                                          |  |     }                                                          |
    |   }                                                            |  |   }                                                            |
    |   for (m<-messages){ println(" "*loop(m.parent, 0) + m.txt)}   |  |   printFrag(None, "")                                          |
    | }                                                              |  | }                                                              |
    +----------------------------------------------------------------+  +----------------------------------------------------------------+
    - contextManager
    +---------------------------------------------------------------------------+
    |   def withFileWriter(str: String)(f: BufferedWriter => Unit) = {          |   // withFileWriter("File.txt") { writer => writer.write("Hello\n"); writer.write("World!")}
    |     val bw = new BufferedWriter(new FileWriter(str))                      |
    |     f(bw)                                                                 |
    |     bw.close()}                                                           |
    |                                                                           |
    |   def withFileReader(str: String)(f: BufferedReader => String):String = { |   // val result = withFileReader("File.txt") { reader =>reader.readLine() + "\n" + reader.readLine()}
    |     val fr = new BufferedReader(new FileReader(str))                      |   // assert(result == "Hello\nWorld!")
    |     val res =f(fr)                                                        |
    |     fr.close()                                                            |
    |     res}                                                                  |
    +---------------------------------------------------------------------------+

####################
# Scala Collections
####################

    ### Operations
        - Builders
        +-----------------------------------------------+
        | val b = Array.newBuilder[Int]                 |   // construct a collection of unknown length
        | b += 1                                        |
        | b += 2                                        |
        | b.result()  // res3: Array[Int] = Array(1, 2) |
        +-----------------------------------------------+

        - Factory Methods
        +---------------------------------------------------------------------------------------------------------+
        | Array.fill(5)("hello")                  // Array("hello", "hello", "hello", "hello", "hello")           |
        | Array.tabulate(5)(n => s"hello $n")     // Array("hello 0", "hello 1", "hello 2", "hello 3", "hello 4") |
        | Array(1, 2, 3) ++ Array(4, 5, 6)        // Array(1, 2, 3, 4, 5, 6)                                      |
        +---------------------------------------------------------------------------------------------------------+

        - Transforms
        +--------------------------------------------------------------------------+
        | Array(1, 2, 3, 4, 5).map(i => i * 2)            // Array(2, 4, 6, 8, 10) |    // transform creates new collection, creates copies of collection
        | Array(1, 2, 3, 4, 5).filter(i => i % 2 == 1)    // Array(1, 3, 5)        |    // copying has an overhead - to improve you can convert to mutable collection
        | Array(1, 2, 3, 4, 5).take(2)                    // Array(1, 2)           |
        | Array(1, 2, 3, 4, 5).drop(2)                    // Array(3, 4, 5)        |
        | Array(1, 2, 3, 4, 5).slice(1, 4)                // Array(2, 3, 4)        |
        | Array(1, 1, 2, 3, 4).distinct                   // Array(1, 2, 3, 4)     |
        +--------------------------------------------------------------------------+

        - Queries
        +------------------------------------------------------------------------------------------------------------+
        | Array(1, 2, 3, 4, 5, 6, 7).find(i => i % 2 == 0 && i > 4)       // Some(6)                                 |
        | Array(1, 2, 3, 4, 5, 6, 7).find(i => i % 2 == 0 && i > 10)      // None                                    |
        | Array(1, 2, 3, 4, 5, 6, 7).exists(x => x > 1)                   // are any elements greater than 1? - true |
        | Array(1, 2, 3, 4, 5, 6, 7).exists(_ < 0) // same as a.exists(x => x < 0)    // false                       |
        +------------------------------------------------------------------------------------------------------------+

        - Aggregations
            -mkString
            +-----------------------------------------------------------------------------------+
            | Array(1, 2, 3, 4, 5, 6, 7).mkString(",")            // String = "1,2,3,4,5,6,7"   |
            | Array(1, 2, 3, 4, 5, 6, 7).mkString("[", ",", "]")  // String = "[1,2,3,4,5,6,7]" |
            +-----------------------------------------------------------------------------------+

            -foldLeft
            +---------------------------------------------------------------------------+   +--------------------------------------------------+
            | Array(1, 2, 3, 4, 5, 6, 7).foldLeft(0)((x, y) => x + y)     // Int = 28   |   | {var total = 0                                   |
            | Array(1, 2, 3, 4, 5, 6, 7).foldLeft(1)((x, y) => x * y)     // Int = 5040 |   | for (i <- Array(1, 2, 3, 4, 5, 6, 7)) total += i |
            | Array(1, 2, 3, 4, 5, 6, 7).foldLeft(1)(_ * _)               // Int = 5040 |   | total}                                           |
            +---------------------------------------------------------------------------+   +--------------------------------------------------+

            -groupBy
            +-----------------------------------------------------------------------------------------------------------------+
            | val grouped = Array(1, 2, 3, 4, 5, 6, 7).groupBy(_ % 2)     // Map(0 -> Array(2, 4, 6), 1 -> Array(1, 3, 5, 7)) |
            | grouped(0)  // Array(2, 4, 6)                                                                                   |
            | grouped(1)  // Array(1, 3, 5, 7)                                                                                |
            +-----------------------------------------------------------------------------------------------------------------+

        - Combining Operations
            +----------------------------------------------------------------+
            | def stdDev(a: Array[Double]): Double = {                       |
            |     val mean = a.foldLeft(0.0)(_ + _) / a.length               |  // val mean = a.sum / a.length
            |     val squareErrors = a.map(_ - mean).map(x => x * x)         |
            |     math.sqrt(squareErrors.foldLeft(0.0)(_ + _) / a.length)    |
            | }                                                              |
            | stdDev(Array(1, 2, 3, 4, 5))    // Double = 1.4142135623730951 |
            | stdDev(Array(3, 3, 3))          // Double = 0.0                |
            +----------------------------------------------------------------+

            -
            +-------------------------------------------------------------------------------------------+
            | def isValidSudoku(grid: Array[Array[Int]]): Boolean = {                                   |
            |     !Range(0, 9).exists{i =>                                                              |
            |         val row = Range(0, 9).map(grid(i)(_))                                             |
            |         val col = Range(0, 9).map(grid(_)(i))                                             |
            |         val square = Range(0, 9).map(j => grid((i % 3) * 3 + j % 3)((i / 3) * 3 + j / 3)) |
            |         row.distinct.length != row.length ||                                              |
            |         col.distinct.length != col.length ||                                              |
            |         square.distinct.length != square.length                                           |
            |     }                                                                                     |
            | }                                                                                         |
            +-------------------------------------------------------------------------------------------+

        - Converters
            +----------------------------------------------------+
            | Array(1, 2, 3).to(Vector)       // Vector(1, 2, 3) |
            | Vector(1, 2, 3).to(Array)       // Array(1, 2, 3)  |
            | Array(1, 1, 2, 2, 3, 4).to(Set) // Set(1, 2, 3, 4) |
            +----------------------------------------------------+

        - Views
            +------------------------------------------------------------------------------+
            | val myArray = Array(1, 2, 3, 4, 5, 6, 7, 8, 9)                               |    // When you chain multiple transformations we are creating many intermediate collections that are immediately thrown away
            | val myNewArray = myArray.map(x => x + 1).filter(x => x % 2 == 0).slice(1, 3) |    // ends up traversing the collection three times (its wasteful)
            +------------------------------------------------------------------------------+

            +----------------------------------------------------------------------------------------------------+
            | val myNewArray = myArray.view.map(_ + 1).filter(_ % 2 == 0).slice(1, 3).to(Array)   // Array(4, 6) |  //  perform this chain of map/filter/slice transformations with only a single traversal
            +----------------------------------------------------------------------------------------------------+

    ### Immutable Collections
            - useful in multi-threaded scenarios
            - immutable collections use Structural Sharing (4.2.2) to make creating updated copies cheap, allowing you to use them in all but the most performance critical code
        - Immutable Vectors (O(log n))
            -fixed-size, general-purpose, immutable linear sequences (provide efficient O(log n) performance for most operations.)
            -unlike Arrays where a(...) = ... mutates it in place, a Vector's .updated method returns a new Vector
            -support same operations as arrays (builders, factory methods, transforms)
            -good for sequence that will not change
            -trre structure makes operations efficient
            -for updates - not as fast as arrays or lists of adding to front
            +-------------------------------------------------------------------------+     +-----------------------------------------+
            | val v = Vector(1, 2, 3, 4, 5)                                           |     | val v = Vector[Int]()   // Vector()     |
            | v(0)                        // Int = 1                                  |     | val v1 = v :+ 1         // Vector(1)    |
            | val v2 = v.updated(2, 10)   //Vector(1, 2, 10, 4, 5) (v did not change) |     | val v2 = 4 +: v1        // Vector(4, 1) |
            +-------------------------------------------------------------------------+     | val v3 = v2.tail        // Vector(1)    |
                                                                                            +-----------------------------------------+

        - Structural Sharing
            +-----------------------------------------------------------------------+   +-----------------------------------------------------------------------+
            | val v1 = Vector(1, 2, 0, 9, 7, 2, 9, 6, ..., 3, 2, 5, 5, 4, 8, 4, 6)  |   | val v2 = v1.updated(4, 8)                                             |
            |                   V1                                                  |   |                   V1 copied                                           |
            |                +-+-+-+-+                                              |   |                +-+-+-+-+                                              |
            |            ----+ | | | +----                                          |   |            ----+ | | | +----                                          |
            |           /    +-+-+-+-+    \                                         |   |           /    +-+-+-+-+    \                                         |
            |          /        / \        \                                        |   |          /        / \        \                                        |
            |         /        /   \        \                                       |   |         / copied /   \        \                                       |
            | +-------+ +-+-+-+-+ +-+-+-+-+ +-+-+-+-+                               |   | +-------+ +-+-+-+-+ +-+-+-+-+ +-+-+-+-+                               |
            | |1|2|0|9| | | | | | | | | | | | | | | |                               |   | |1|2|0|9| | | | | | | | | | | | | | | |                               |
            | +-------+ +-+-+-+-+ +-+-+-+-+ +-+-+-+-+                               |   | +-------+ +-+-+-+-+ +-+-+-+-+ +-+-+-+-+                               |
            |          /         /                                                  |   | copied   /         /                                                  |
            | +-------+ +-------+                                                   |   | +-------+ +-------+                                                   |
            | |7|2|9|6| |7|2|9|6|                                                   |   | |8|2|9|6| |7|2|9|6|                                                   |
            | +-------+ +-------+                                                   |   | +-------+ +-------+                                                   |
            +-----------------------------------------------------------------------+   +-----------------------------------------------------------------------+
            -for update - 3 nodes needed to be copied, in large vector number of nodes needed to copy is porportional to the height of tree
            -never be as fast as update in place (if performance needed consider ArrayDeque which has O(1) update/prepend/append or Artray if size will not change) 
            -similar tree-shaped data structure is also used to implement Immutable Sets and Immutable Maps 

        - Immutable Sets
            - unordered collections of elements without duplicates
            - O(log n) .contains method
            - Set operations take time O(log n) in the size of the Set
            - in cases where it isn't you can always fall back to Mutable Sets for better performance
            +-----------------------------------------+ +--------------------------------------------------+
            | val s = Set(1, 2, 3)    // Set(1, 2, 3) | | Set(1, 2, 3) + 4 + 5  // HashSet(5, 1, 2, 3, 4)  |
            | s.contains(2)           // true         | | Set(1, 2, 3) - 2      // Set(1, 3)               |
            | s.contains(4)           // false        | | Set(1, 2, 3) ++ Set(2, 3, 4)  // Set(1, 2, 3, 4) |
            +-----------------------------------------+ +--------------------------------------------------+
            +------------------------------------------+
            | for (i <- Set(1, 2, 3, 4, 5)) println(i) |
            +------------------------------------------+

        - Immutable Maps
            -unordered collections of keys and values, allowing efficient lookup by key
            -most immutable Map operations take time O(log n)
            +---------------------------------------------------+   +--------------------------------------------+
            | val m = Map("one" -> 1, "two" -> 2, "three" -> 3) |   | m.get("one")      // Option[Int] = Some(1) |  // use .get if you're not sure whether a map contains a key or not
            | m.contains("two")   // true                       |   | m.get("four")     // Option[Int] = None    |
            | m("two")            // Int = 2                    |   +--------------------------------------------+
            +---------------------------------------------------+
            +-------------------------------------------------------------------------------------------+
            | Vector(("one", 1), ("two", 2), ("three", 3)).to(Map)                                      |
            | Map[String, Int]() + ("one" -> 1) + ("three" -> 3)      //  Map("one" -> 1, "three" -> 3) |
            | for ((k, v) <- m) println(k + " " + v)                                                    |
            |     one 1                                                                                 |
            |     two 2                                                                                 |
            |     three 3                                                                               |
            +-------------------------------------------------------------------------------------------+

        - Immutable Lists
            - singly-linked list
            - O(1) to .head, .tail, :: (to create new list with new element in front)
            - indexed lookup via myList(i) is a slow O(n)
            - Appending/removing elements on the right hand side of the list is also a slow O(n)
            - want fast indexed lookup or fast appends/removes on the right, you should consider using Vectors or mutable ArrayDeques
            +------------------------------------------------------------+  +------------------------------------------------------+
            | val myList = List(1, 2, 3, 4, 5)                           |  |                   +------+                           |
            | myList.head                     // Int = 1                 |  |                   |myList|                           |
            | val myTail = myList.tail        // List(2, 3, 4, 5)        |  |            +-+    +------+                           |
            | val myOtherList = 0 :: myList   // List(0, 1, 2, 3, 4, 5)  |  | myOtherList|1|            \                          |
            | val myThirdList = -1 :: myList  // List(-1, 1, 2, 3, 4, 5) |  |            +-------------->+-+ +-+ +-+ +-+ +-+ +---+ |
            +------------------------------------------------------------+  |                            |1|>|2|>|3|>|4|>|5|>|Nil| |
                                                                            |            +--+----------->+-+ +-+ +-+ +-+ +-+ +---+ |
                                                                            | myThirdList|-1|               /                      |
                                                                            |            +--+       +------+                       |
                                                                            |                       |myTail|                       |
                                                                            |                       +------+                       |
                                                                            +------------------------------------------------------+

    ### Mutable Collections
        - Mutable ArrayDeques
            - efficient O(1) indexed lookups/updates/inserts/removal of left & right ends
            - reuses array as much as possible moving start/end
            - if number of elements exceeds array size - it gets reallocated
            - faster than immu8table Vector
            - good for fifo, filo with .append/.removeHead-.removeLast
            +--------------------------------------------------+
            |             removeHead() append(6)  removeHead() |
            |         end         end  end         end         |
            |  start   +     start +   + start     +   start   |
            |  +       |     +     |   | +         |   +       |
            | ++-------++ +--+-----++ ++-+------+ ++---+----+  |
            | |1|2|3|4|5| | |2|3|4|5| |6|2|3|4|5| |6| |3|4|5|  |
            | +---------+ +---------+ +---------+ +---------+  |
            +--------------------------------------------------+
            +-------------------------+
            | myArrayDeque.to(Vector) | // "freeze" a mutable ArrayDeque 
            +-------------------------+

        - Mutable Sets
            - .contains checks (O(1))
            - instead of constructing new copies of the Set via + and -, you instead add and remove elements from the Set via .add and .remove
            +-----------------------------------------------------------------+     +---------------------------------+
            | val s = collection.mutable.Set(1, 2, 3)     // HashSet(1, 2, 3) |     | s.add(4)                        |
            | s.contains(2)       // true                                     |     | s.remove(1)                     |
            | s.contains(4)       // false                                    |     | s           // HashSet(2, 3, 4) |
            +-----------------------------------------------------------------+     +---------------------------------+

        - Mutable Maps
            +--------------------------------------------------------------------------------------------------------------------------+
            | val m = collection.mutable.Map("one" -> 1, "two" -> 2, "three" -> 3)    // HashMap("two" -> 2, "three" -> 3, "one" -> 1) |
            | m.remove("two")     // Some(2)                                                                                           |
            | m("five") = 5                                                                                                            |
            | m                   // HashMap("five" -> 5, "three" -> 3, "one" -> 1)                                                    |
            +--------------------------------------------------------------------------------------------------------------------------+
            -getOrElseUpdate - look up a value by key, and compute/store the value if there isn't one already present:
            +-----------------------------------------------------------------------------------------------------+
            | val m = collection.mutable.Map("one" -> 1, "two" -> 2, "three" -> 3)                                |
            | m.getOrElseUpdate("three", -1)      // Int = 3                                                      |
            | m                                   // HashMap("two" -> 2, "three" -> 3, "one" -> 1)                |
            | m.getOrElseUpdate("four", -1)       // Int = -1                                                     |
            | m                                   // HashMap( "two" -> 2, "three" -> 3, "four" -> -1, "one" -> 1) |
            +-----------------------------------------------------------------------------------------------------+

        - In-Place Operations
            - All mutable collections, including Arrays, have in-place versions of many common collection operations
            +-----------------------------------------------------------+
            | val a = collection.mutable.ArrayDeque(1, 2, 3, 4)         |
            | a.mapInPlace(_ + 1)             // ArrayDeque(2, 3, 4, 5) |
            | a.filterInPlace(_ % 2 == 0)     // ArrayDeque(2, 4)       |
            | a                               // ArrayDeque(2, 4)       |
            +-----------------------------------------------------------+

    ### Common Interfaces
        - code that needs something that can be iterated over
            +--------------------------------------------------------------------------------------------------------+
            | def iterateOverSomething[T](items: Seq[T]) = {                                                         |
            |     for (i <- items) println(i)                                                                        |
            | }                                                                                                      |
            | iterateOverSomething(Vector(1, 2, 3))       // 1 2 3                                                   |
            | iterateOverSomething(List(("one", 1), ("two", 2), ("three", 3)))    // (one,1) \n (two,2) \n (three,3) |
            +--------------------------------------------------------------------------------------------------------+
        - code that needs something that provides indexed lookup (Array/Vector), but cannot work with list
            +------------------------------------------------------------------------+
            | def getIndexTwoAndFour[T](items: IndexedSeq[T]) = (items(2), items(4)) |
            | getIndexTwoAndFour(Vector(1, 2, 3, 4, 5))   // (Int, Int) = (3, 5)     |
            | getIndexTwoAndFour(Array(2, 4, 6, 8, 10))   // (Int, Int) = (6, 10)    |
            +------------------------------------------------------------------------+
        - hierarchy
            -immutable
            +------------------------------------------------------------------------------+    // val s = Seq(1, 2, 3 -> delegate is a list(s: Seq[Int] = List(1, 2, 3));
            |                                                       +---------+            |    // Seq    - idxAccess O(n); prepend O(1);
            |                                            (HashMap)  |HashMap  |            |    // Vector - idxAccess O(1); update O(1)
            |                                                +---+  +---------+            |    // val x = IndexedSeq(1,2,3) // x: IndexedSeq[Int] = Vector(1, 2, 3)
            |                            +-------------------+Map+->+ListMap  |            |    // val ar = Array(1,2,3)
            |                            |                   +---+  +---------+  +-------+ |    // can be generic Array[T] (in Java not)
            |                            |                          |SortedMap+->+TreeMap| |
            |                            |                          +---------+  +-------+ |
            |                            |                                                 |
            |                            |                          +------+               |
            |                            |            (Vector)      |Vector|               |
            |                            |            +----------+  +------+               |
            |                            |         +--+IndexedSeq+->+String|               |
            |                            |         |  +----------+  +------+               |
            |                            |         |                |Range |               |
            | (foreach)      (iterator)  |  (List) |                +------+               |
            | +-----------+  +--------+  |  +---+  |                                       |
            | |Traversable+->+Iterable+->-->+Seq+->+                +------+               |
            | +-----------+  +--------+  |  +---+  |                |List  |               |
            |                            |         |   (List)       +------+               |
            |                            |         |   +---------+  |Stack |               |
            |                            |         +---+LinearSeq+->-------+               |
            |                            |             +---------+  |Stream|               |
            |                            |                          +------+               |
            |                            |                          |Queue |               |
            |                            |                          +------+               |
            |                            |                                                 |
            |                            |                          +---------+            |
            |                            |               (HashSet)  |HashSet  |            |
            |                            |                   +---+  +---------+            |
            |                            +-------------------+Set+->+ListSet  |  +-------+ |
            |                                                +---+  +---------+  |TreeSet| |
            |                                                       |SortedSet+->--------+ |
            |                                                       +---------+  |BitSet | |
            |                                                                    +-------+ |
            |                                                                              |
            +------------------------------------------------------------------------------+
            -mutable
            +-----------------------------------------------------------------------------------------------------------------------------------------------------------------------+
            |                                   +----------+  +------------------+                                                                                                  |
            |                                +->+Stack     +->+SynchronizedStack |                                                                                                  |
            |                                |  +----------+  +------------------+                                                                                                  |
            |                                |                                                                                                                                      |
            |                                |  +----------+                                                                                                                        |
            |                                +-->ArrayStack|                                                                                                                        |
            |                                |  +----------+                                                                                                                        |
            |                                |                                                                                                                                      |
            |                                |                +------------------+  +-----+  +-----------------+                                                                    |
            |                                |  (MutableList) |MutableList       +->+Queue+->+SynchronizedQueue|                                                                    |
            |                                |  +----------+  +------------------+  +-----+  +-----------------+                                                                    |
            |                                +->+LinearSeq +->+LinkedList        |                                                                                                  |
            |                                |  +----------+  +------------------+                                                                                                  |
            |                   (ArrayBuffer)|                |DoubleLinkedList  |                                                                                                  |
            |                            +---+                +------------------+                                                                                                  |
            |                         +->+Seq|                                                                                                                                      |
            |                         |  +---+                +------------------+                                                                                                  |
            |                         |      | (ArrayBuffer)  |ArraySeq          |                                                                                                  |
            |                         |      |  +----------+  +------------------+                                                                                                  |
            |                         |      +->+IndexedSeq+->+StringBuilder     |                                                                                                  |
            |                         |      |  +----------+  +------------------+                                                                                                  |
            |                         |      |                |ArrayBuffer       |                                                                                                  |
            |                         |      |             +->+------------------+                                                                                                  |
            |                         |      |             |                                                                                                                        |
            | +-----------+  +--------+      |             |  +------------------+                                                                                                  |
            | |Traversable+->+Iterable|      |(ArrayBuffer)|  |ListBuffer        |                                                                                                  |
            | +-----------+  +--------+      |  +----------+  +------------------+                                                                                                  |
            |                         |      +->+Buffer    +->+ObservableBuffer  |                                                                                                  |
            |                         |         +----------+  +------------------+                                                                                                  |
            |                         |                       |SynchronizedBuffer|                                                                                                  |
            |                         |                       +------------------+                                                                                                  |
            |                         | (HashSet)                                                                                                                                   |
            |                         |  +---+  +----------------------------------------------------------------------------------------------+                                    |
            |                         +->+Set+->+HashSet| LinkedHashSet| ImmutableSetAdaptor| ObservableSet| SynchronizedSet| SortedSet, BitSet|                                    |
            |                         |  +---+  +----------------------------------------------------------------------------------------------+                                    |
            |                         | (HashMap)                                                                                                                                   |
            |                         |  +---+  +---------------------------------------------------------------------------------------------------------------------------------+ |
            |                         +->+Map+->+HashMap| ListMap| TreeMap| OpenHashMap| WeakHashMap| LinkedHashMap| ImmutableMapAdaptor| SynchronizedMap| MultiMap| ObservableMap| |
            |                         |  +---+  +---------------------------------------------------------------------------------------------------------------------------------+ |
            |                         |                                                                                                                                             |
            |                         |  +----------------------------------------+                                                                                                 |
            |                         +->+PriorityQueue| SynchronizedPriorityQueue|                                                                                                 |
            |                            +----------------------------------------+                                                                                                 |
            +-----------------------------------------------------------------------------------------------------------------------------------------------------------------------+


####################
# Notable Scala Features
####################
        +------------------------------------------------------------------------------------------+
        | def getDayMonthYear(s: String) = s match {                                               |
        |     case s"$day-$month-$year" => println(s"found day: $day, month: $month, year: $year") |
        |     case _ => println("not a date")                                                      |
        | }                                                                                        |
        | getDayMonthYear("9-8-1965")     // found day: 9, month: 8, year: 1965                    |
        | getDayMonthYear("9-8")          // not a date                                            |
        +------------------------------------------------------------------------------------------+
    
    ### Case Classes and Sealed Traits
        -Case Classes
            - classes which are "just data" data is immutable and public, without any mutable state or encapsulation
            +----------------------------------------+
            | case class Point(x: Int, y: Int)       |  // p.x     // Int = 1
            | val p = Point(1, 2)     // Point(1, 2) |  // p.y     // Int = 2
            +----------------------------------------+
            - provide .toString, ==, .copy
            +--------------------------------------------------+    +----------------------------------------------+
            | p.toString              // String = "Point(1,2)" |    | val p = Point(1, 2)                          |
            | p2 = Point(1, 2)                                 |    | val p3 = p.copy(y = 10)     // Point(1, 10)  |
            | p == p2                 // Boolean = true        |    | val p4 = p3.copy(x = 20)    // Point(20, 10) |
            +--------------------------------------------------+    +----------------------------------------------+
            - define methods
            +------------------------------------+
            | case class Point(x: Int, y: Int) { |
            |     def z = x + y                  |
            | }                                  |
            | p = Point(1, 2); p.z    // Int = 3 |
            +------------------------------------+
        - Sealed Traits
            - can be extended by a fixed set of case classes in same file
            +-----------------------------------------------------------------------+
            | {                                                                     |
            |     sealed trait Point                                                |
            |     case class Point2D(x: Double, y: Double) extends Point            |
            |     case class Point3D(x: Double, y: Double, z: Double) extends Point |
            | }                                                                     |
            | def hypotenuse(p: Point) = p match {                                  |
            |     case Point2D(x, y) => math.sqrt(x * x + y * y)                    |
            |     case Point3D(x, y, z) => math.sqrt(x * x + y * y + z * z)         |
            | }                                                                     |
            | val points: Array[Point] = Array(Point2D(1, 2), Point3D(4, 5, 6))     |
            | for (p <- points) println(hypotenuse(p))                              |
            +-----------------------------------------------------------------------+
        - Use Cases for Normal v.s. Sealed Traits
            - normal trait - define class & implement methods; new method needs to be added to all subclasses
            - sealed trait - easy to add new method - simply pattern match on each subclass; adding new class is difficult - go to all pattern matches and add new sub-class;
            - sealed traits good to model hierarchies when you dont expect number of subclasses to grow
            +------------------------------------------------------------+
            | {                                                          |
            |     sealed trait Json                                      |
            |     case class Null() extends Json                         |
            |     case class Bool(value: Boolean) extends Json           |
            |     case class Str(value: String) extends Json             |
            |     case class Num(value: Double) extends Json             |
            |     case class Arr(value: Seq[Json]) extends Json          |
            |     case class Dict(value: Map[String, Json]) extends Json |
            | }                                                          |
            +------------------------------------------------------------+

    ### Pattern Matching
        - Match
            match ints                                      match tuples
            +------------------------------------------+    +--------------------------------------+    // 1 2
            | def dayOfWeek(x: Int) = x match {        |    | for (i <- Range.inclusive(1, 100)) { |    // Fizz
            |     case 1 => "Mon"; case 2 => "Tue"     |    |     val s = (i % 3, i % 5) match {   |    // 4
            |     case 3 => "Wed"; case 4 => "Thu"     |    |         case (0, 0) => "FizzBuzz"    |    // Buzz
            |     case 5 => "Fri"; case 6 => "Sat"     |    |         case (0, _) => "Fizz"        |
            |     case 7 => "Sun"; case _ => "Unknown" |    |         case (_, 0) => "Buzz"        |
            | }                                        |    |         case _ => i                  |
            | dayOfWeek(5)    // String = "Fri"        |    |     }                                |
            | dayOfWeek(-1)   // String = "Unknown"    |    |     println(s)                       |
            +------------------------------------------+    | }                                    |
                                                            +--------------------------------------+
            matching on Case Classes                                matching on String Patterns
            +--------------------------------------------------+    +-----------------------------------------------------------------------+
            | case class Point(x: Int, y: Int)                 |    | def splitDate(s: String) = s match {                                  |
            | def direction(p: Point) = p match {              |    |     case s"--" => s"day: , mon: , yr: " |
            |     case Point(0, 0) => "origin"                 |    |     case _ => "not a date"                                            |
            |     case Point(_, 0) => "horizontal"             |    | }                                                                     |
            |     case Point(0, _) => "vertical"               |    | splitDate("9-8-1965")   // String = "day: 9, mon: 8, yr: 1965"        |
            |     case _ => "diagonal"                         |    | splitDate("9-8")        // String = "not a date"                      |
            | }                                                |    +-----------------------------------------------------------------------+
            | direction(Point(0, 0))  // String = "origin"     |
            | direction(Point(1, 1))  // String = "diagonal"   |
            | direction(Point(10, 0)) // String = "horizontal" |
            +--------------------------------------------------+            

        - Nested Matches
            +---------------------------------------------------------------------------------------+   +-------------------------------------------------------------------------------------------------------------------------------+
            | case class Person(name: String, title: String)                                        |   | def greet2(husband: Person, wife: Person) = (husband, wife) match {                                                           |
            | def greet(p: Person) = p match {                                                      |   |     case (Person(s" ", _), Person(s" ", _)) if last1 == last2 => println(s"Hello Mr and Ms ") |
            |     case Person(s"$firstName $lastName", title) => println(s"Hello $title $lastName") |   |     case (Person(name1, _), Person(name2, _)) => println(s"Hello  and ")                                          |
            |     case Person(name, title) => println(s"Hello $title $name")                        |   | }                                                                                                                             |
            | }                                                                                     |   | greet2(Person("James Bond", "Mr"), Person("Jane Bond", "Ms"))   // Hello Mr and Ms Bond                                       |
            | greet(Person("Haoyi Li", "Mr")) //Hello Mr Li                                         |   +-------------------------------------------------------------------------------------------------------------------------------+
            +---------------------------------------------------------------------------------------+

        - Loops and Vals
            inside loops
            +--------------------------------------------------------------------+
            | val a = Array[(Int, String)]((1, "one"), (2, "two"), (3, "three")) |
            | for ((i, s) <- a) println(s + i)                                   |
            | one1                                                               |
            | two2                                                               |
            | three3                                                             |
            +--------------------------------------------------------------------+
            in val statements
            +----------------------------------+    +------------------------------------------+
            | case class Point(x: Int, y: Int) |    | val s" " = "Hello World"    |
            | val p = Point(123, 456)          |    | first: String = "Hello"                  |
            | val Point(x, y) = p              |    | second: String = "World"                 |
            | x: Int = 123                     |    | val flipped = s" "          |
            | y: Int = 456                     |    | flipped: String = "World Hello"          |
            +----------------------------------+    +------------------------------------------+

        - Pattern Matching on Sealed Traits and Case Classes
            +--------------------------------------------------------------------+
            | {                                                                  |
            | sealed trait Expr                                                  |  x + 1        // BinOp(Variable("x"), "+", Literal(1))
            | case class BinOp(left: Expr, op: String, right: Expr) extends Expr |  x * (y - 1)  // BinOp(Variable("x"), "*", BinOp(Variable("y"), "-", Literal(1)))
            | case class Literal(value: Int) extends Expr                        |  x * (y - 1)  // BinOp( BinOp(Variable("x"), "+", Literal(1)), "*", BinOp(Variable("y"), "-", Literal(1)) )
            | case class Variable(name: String) extends Expr                     |
            | }                                                                  |
            +--------------------------------------------------------------------+
            Stringifying Our Expressions
            +------------------------------------------------------------------------------------+
            | def stringify(expr: Expr): String = expr match {                                   |  // val smallExpr = BinOp( Variable("x"), "+", Literal(1) )
            |     case BinOp(left, op, right) => s"(${stringify(left)} $op ${stringify(right)})" |  // stringify(smallExpr)    // String = "(x + 1)"
            |     case Literal(value) => value.toString                                          |
            |     case Variable(name) => name                                                    |
            | }                                                                                  |
            +------------------------------------------------------------------------------------+
            evaluate
            +--------------------------------------------------------------------------------------+
            | def evaluate(expr: Expr, values: Map[String, Int]): Int = expr match {               |    // evaluate(smallExpr, Map("x" -> 10)) // Int = 11
            |     case BinOp(left, "+", right) => evaluate(left, values) + evaluate(right, values) |
            |     case BinOp(left, "-", right) => evaluate(left, values) - evaluate(right, values) |
            |     case BinOp(left, "*", right) => evaluate(left, values) * evaluate(right, values) |
            |     case Literal(value) => value                                                     |
            |     case Variable(name) => values(name)                                              |
            | }                                                                                    |
            +--------------------------------------------------------------------------------------+

    ### By-Name Parameters
    ### Implicit Parameters
    ### Typeclass Inference