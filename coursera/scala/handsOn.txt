####################
# Basic Scala
####################

    ### Values
    - tuples
        +---------------------------------------------------------------------------+
        | val t: (Int, Boolean, String) = (1, true, "hello")                        |
        | val (a, b, c) = t   // a: Int = 1; b: Boolean = true; c: String = "hello" |
        +---------------------------------------------------------------------------+
    - arrays (fixed length)
        +--------------------------------+
        | val a = Array[Int](1, 2, 3, 4) |
        | a(0) = 11 // (11, 2, 3, 4)     |
        +--------------------------------+
    - option
        +----------------------------------------------------------------+  +--------------------------------------------------+
        | lastNameOpt match {                                            |  | Some("Li").getOrElse("<unknown>")   // "Li"      |
        |     case Some(lastName) => println(s"Hello $title. $lastName") |  | None.getOrElse("<unknown>")         // "unknown" |
        |     case None => println(s"Hello $firstName")                  |  +--------------------------------------------------+
        | }                                                              |
        +----------------------------------------------------------------+

        +--------------------------------------------------+
        | val os1: Option[String] = Some("name")           |
        | val os2: Option[String] = None                   |
        | val o1 = os1.map(_.length).getOrElse(-1)    //4  |
        | val o2 = os2.map(_.length).getOrElse(-1)    //-1 |
        +--------------------------------------------------+
    
    ### Loops, Conditionals, Comprehensions
    - for                                                                                   - multi
        +--------------------------------------------+  +------------------------------+    +--------------------------------------------------------+
        | var total = 0                              |  | var total = 0                |    | val multi = Array(Array(1, 2, 3), Array(4, 5, 6))      |
        | val items = Array(1, 10, 100, 1000)        |  | for (i <- Range(0, 5)) {     |    | for (arr <- multi; i <- arr) println(i) // 1,2,3,4,5,6 |
        | for (item <- items) total += item   //1111 |  |     total = total + i   //10 |    +--------------------------------------------------------+
        +--------------------------------------------+  | }                            |
                                                        +------------------------------+
    - if
        +----------------------------------------------+
        | var total = 0                                |
        | for (i <- Range(0, 10)) {                    |
        |     total += (if (i % 2 == 0) i else 2) //30 |
        | }                                            |
        +----------------------------------------------+
    - Comprehensions
        +-----------------------------------------------------------+   +-----------------------------------------------------------------------------------------------------+
        | val a = Array(1, 2, 3, 4)                                 |   | val a = Array(1, 2); val b = Array("hello", "world")                                                |
        | val a2 = for (i <- a) yield i * i   //Array(1, 4, 9, 16)  |   | val flattened = for (i <- a; s <- b) yield s + i    //Array("hello1", "world1", "hello2", "world2") |
        +-----------------------------------------------------------+   +-----------------------------------------------------------------------------------------------------+
        +------------------------+
        | val flattened2 = for { |  // use {} for multiline
        |   i <- a1              |
        |   s <- a2              |
        | } yield s + i          |
        +------------------------+
    
    ### Methods and Functions
        +---------------------------+
        | def hello(i: Int = 0) = { |
        |     "hello " + i          |
        | }                         |
        +---------------------------+
        - functions
        +--------------------------------+
        | var g: Int => Int = i => i + 1 |  // cannot have optional arguments (i.e. with default values) 
        | g = i => i * 2                 |  // cannot take type parameters via the [T] syntax
        | g(10)   // 20                  |
        +--------------------------------+
        - methods taking Functions
        +------------------------------------------+    +-----------------------------------+               +-------------------------------+
        | class Box(var x: Int) {                  |    | val b = new Box(1)                |               | def increment(i: Int) = i + 1 |
        |     def update(f: Int => Int) = x = f(x) |    | b.printMsg("Hello")     //Hello1  |               | b.update(increment)           |
        |     def printMsg(msg: String) = {        |    | b.update(i => i + 5)              |   // _ + 5    | b.update(x => increment(x))   |
        |         println(msg + x)                 |    | b.printMsg("Hello")     // Hello6 |               | b.update(increment(_))        |
        |     }                                    |    |                                   |               +-------------------------------+
        | }                                        |    +-----------------------------------+
        +------------------------------------------+
        - multiple Parameter Lists
        +----------------------------------------+  +------------------------------------+
        | def myLoop(start: Int, end: Int)       |  | myLoop(start = 5, end = 10) { i => |
        |     (callback: Int => Unit) = {        |  |     println(s"i has value ")       |
        |         for (i <- Range(start, end)) { |  | }                                  |
        |             callback(i)                |  +------------------------------------+
        |         }                              |
        | }                                      |
        +----------------------------------------+

    ### Classes and Traits
        +-----------------------------------+
        | class Foo(x: Int) {               |   // x is private -> "val x: Int" - public - "f.x"
        |     val bar = "bar"               |   // added to constructor
        |     def printMsg(msg: String) = { |   
        |         println(msg + x)          |   // val f = new Foo(1)
        |     }                             |   // f.printMsg("hello")  // hello1
        | }                                 |
        +-----------------------------------+
        - Traits
        +---------------------------------------------------------------+
        | trait Point{ def hypotenuse: Double }                         |
        | class Point2D(x: Double, y: Double) extends Point{            |
        |     def hypotenuse = math.sqrt(x * x + y * y)                 |
        | }                                                             |
        | class Point3D(x: Double, y: Double, z: Double) extends Point{ |
        |     def hypotenuse = math.sqrt(x * x + y * y + z * z)         |
        | }                                                             |
        +---------------------------------------------------------------+

    - flexibleFizzBuzz
    // flexibleFizzBuzz(s => ())    
    +-------------------------------------------------+ +-------------------------------------+
    | def flexibleFizzBuzz(f: String => Unit) = {     | | var i = 0                           |
    |   for (i<-Range(0,100)){                        | | val output = new Array[String](100) |
    |     if (i % 3 == 0 && i % 5 == 0) f("FizzBuzz") | | flexibleFizzBuzz{s =>               |
    |     else if (i % 3 == 0) f("Fizz")              | |   output(i) = s                     |
    |     else if (i % 5 == 0) f("Buzz")              | |   i += 1                            |
    |     else f(i.toString)                          | | }                                   |
    |   }                                             | +-------------------------------------+
    | }                                               |
    +-------------------------------------------------+ 
    - printMessages
    +----------------------------------------------------------------+  +----------------------------------------------------------------+
    | def printMessages(messages: Array[Msg]): Unit = {              |  | def printMessages(messages: Array[Msg]): Unit = {              |
    |   def loop(par: Option[Int], spacesNumber: Int): Int = {       |  |   def printFrag(parent: Option[Int], indent: String): Unit = { |
    |     par match{                                                 |  |     for (msg <- messages if msg.parent == parent) {            |
    |       case Some(p) => loop(messages(p).parent, spacesNumber+1) |  |       println(s"#${msg.id} ${msg.txt}")                        |
    |       case None => spacesNumber                                |  |       printFrag(Some(msg.id), indent + "    ")                 |
    |     }                                                          |  |     }                                                          |
    |   }                                                            |  |   }                                                            |
    |   for (m<-messages){ println(" "*loop(m.parent, 0) + m.txt)}   |  |   printFrag(None, "")                                          |
    | }                                                              |  | }                                                              |
    +----------------------------------------------------------------+  +----------------------------------------------------------------+
    - contextManager
    +---------------------------------------------------------------------------+
    |   def withFileWriter(str: String)(f: BufferedWriter => Unit) = {          |   // withFileWriter("File.txt") { writer => writer.write("Hello\n"); writer.write("World!")}
    |     val bw = new BufferedWriter(new FileWriter(str))                      |
    |     f(bw)                                                                 |
    |     bw.close()}                                                           |
    |                                                                           |
    |   def withFileReader(str: String)(f: BufferedReader => String):String = { |   // val result = withFileReader("File.txt") { reader =>reader.readLine() + "\n" + reader.readLine()}
    |     val fr = new BufferedReader(new FileReader(str))                      |   // assert(result == "Hello\nWorld!")
    |     val res =f(fr)                                                        |
    |     fr.close()                                                            |
    |     res}                                                                  |
    +---------------------------------------------------------------------------+

####################
# Scala Collections
####################

    ### Operations
        - Builders
        +-----------------------------------------------+
        | val b = Array.newBuilder[Int]                 |   // construct a collection of unknown length
        | b += 1                                        |
        | b += 2                                        |
        | b.result()  // res3: Array[Int] = Array(1, 2) |
        +-----------------------------------------------+

        - Factory Methods
        +---------------------------------------------------------------------------------------------------------+
        | Array.fill(5)("hello")                  // Array("hello", "hello", "hello", "hello", "hello")           |
        | Array.tabulate(5)(n => s"hello $n")     // Array("hello 0", "hello 1", "hello 2", "hello 3", "hello 4") |
        | Array(1, 2, 3) ++ Array(4, 5, 6)        // Array(1, 2, 3, 4, 5, 6)                                      |
        +---------------------------------------------------------------------------------------------------------+

        - Transforms
        +--------------------------------------------------------------------------+
        | Array(1, 2, 3, 4, 5).map(i => i * 2)            // Array(2, 4, 6, 8, 10) |    // transform creates new collection, creates copies of collection
        | Array(1, 2, 3, 4, 5).filter(i => i % 2 == 1)    // Array(1, 3, 5)        |    // copying has an overhead - to improve you can convert to mutable collection
        | Array(1, 2, 3, 4, 5).take(2)                    // Array(1, 2)           |
        | Array(1, 2, 3, 4, 5).drop(2)                    // Array(3, 4, 5)        |
        | Array(1, 2, 3, 4, 5).slice(1, 4)                // Array(2, 3, 4)        |
        | Array(1, 1, 2, 3, 4).distinct                   // Array(1, 2, 3, 4)     |
        +--------------------------------------------------------------------------+

        - Queries
        +------------------------------------------------------------------------------------------------------------+
        | Array(1, 2, 3, 4, 5, 6, 7).find(i => i % 2 == 0 && i > 4)       // Some(6)                                 |
        | Array(1, 2, 3, 4, 5, 6, 7).find(i => i % 2 == 0 && i > 10)      // None                                    |
        | Array(1, 2, 3, 4, 5, 6, 7).exists(x => x > 1)                   // are any elements greater than 1? - true |
        | Array(1, 2, 3, 4, 5, 6, 7).exists(_ < 0) // same as a.exists(x => x < 0)    // false                       |
        +------------------------------------------------------------------------------------------------------------+

        - Aggregations
            -mkString
            +-----------------------------------------------------------------------------------+
            | Array(1, 2, 3, 4, 5, 6, 7).mkString(",")            // String = "1,2,3,4,5,6,7"   |
            | Array(1, 2, 3, 4, 5, 6, 7).mkString("[", ",", "]")  // String = "[1,2,3,4,5,6,7]" |
            +-----------------------------------------------------------------------------------+

            -foldLeft
            +---------------------------------------------------------------------------+   +--------------------------------------------------+
            | Array(1, 2, 3, 4, 5, 6, 7).foldLeft(0)((x, y) => x + y)     // Int = 28   |   | {var total = 0                                   |
            | Array(1, 2, 3, 4, 5, 6, 7).foldLeft(1)((x, y) => x * y)     // Int = 5040 |   | for (i <- Array(1, 2, 3, 4, 5, 6, 7)) total += i |
            | Array(1, 2, 3, 4, 5, 6, 7).foldLeft(1)(_ * _)               // Int = 5040 |   | total}                                           |
            +---------------------------------------------------------------------------+   +--------------------------------------------------+

            -groupBy
            +-----------------------------------------------------------------------------------------------------------------+
            | val grouped = Array(1, 2, 3, 4, 5, 6, 7).groupBy(_ % 2)     // Map(0 -> Array(2, 4, 6), 1 -> Array(1, 3, 5, 7)) |
            | grouped(0)  // Array(2, 4, 6)                                                                                   |
            | grouped(1)  // Array(1, 3, 5, 7)                                                                                |
            +-----------------------------------------------------------------------------------------------------------------+

        - Combining Operations
            +----------------------------------------------------------------+
            | def stdDev(a: Array[Double]): Double = {                       |
            |     val mean = a.foldLeft(0.0)(_ + _) / a.length               |  // val mean = a.sum / a.length
            |     val squareErrors = a.map(_ - mean).map(x => x * x)         |
            |     math.sqrt(squareErrors.foldLeft(0.0)(_ + _) / a.length)    |
            | }                                                              |
            | stdDev(Array(1, 2, 3, 4, 5))    // Double = 1.4142135623730951 |
            | stdDev(Array(3, 3, 3))          // Double = 0.0                |
            +----------------------------------------------------------------+

            -
            +-------------------------------------------------------------------------------------------+
            | def isValidSudoku(grid: Array[Array[Int]]): Boolean = {                                   |
            |     !Range(0, 9).exists{i =>                                                              |
            |         val row = Range(0, 9).map(grid(i)(_))                                             |
            |         val col = Range(0, 9).map(grid(_)(i))                                             |
            |         val square = Range(0, 9).map(j => grid((i % 3) * 3 + j % 3)((i / 3) * 3 + j / 3)) |
            |         row.distinct.length != row.length ||                                              |
            |         col.distinct.length != col.length ||                                              |
            |         square.distinct.length != square.length                                           |
            |     }                                                                                     |
            | }                                                                                         |
            +-------------------------------------------------------------------------------------------+

        - Converters
            +----------------------------------------------------+
            | Array(1, 2, 3).to(Vector)       // Vector(1, 2, 3) |
            | Vector(1, 2, 3).to(Array)       // Array(1, 2, 3)  |
            | Array(1, 1, 2, 2, 3, 4).to(Set) // Set(1, 2, 3, 4) |
            +----------------------------------------------------+

        - Views
            +------------------------------------------------------------------------------+
            | val myArray = Array(1, 2, 3, 4, 5, 6, 7, 8, 9)                               |    // When you chain multiple transformations we are creating many intermediate collections that are immediately thrown away
            | val myNewArray = myArray.map(x => x + 1).filter(x => x % 2 == 0).slice(1, 3) |    // ends up traversing the collection three times (its wasteful)
            +------------------------------------------------------------------------------+

            +----------------------------------------------------------------------------------------------------+
            | val myNewArray = myArray.view.map(_ + 1).filter(_ % 2 == 0).slice(1, 3).to(Array)   // Array(4, 6) |  //  perform this chain of map/filter/slice transformations with only a single traversal
            +----------------------------------------------------------------------------------------------------+

    ### Immutable Collections
            - useful in multi-threaded scenarios
            - immutable collections use Structural Sharing (4.2.2) to make creating updated copies cheap, allowing you to use them in all but the most performance critical code
        - Immutable Vectors (O(log n))
            -fixed-size, general-purpose, immutable linear sequences (provide efficient O(log n) performance for most operations.)
            -unlike Arrays where a(...) = ... mutates it in place, a Vector's .updated method returns a new Vector
            -support same operations as arrays (builders, factory methods, transforms)
            -good for sequence that will not change
            -trre structure makes operations efficient
            -for updates - not as fast as arrays or lists of adding to front
            +-------------------------------------------------------------------------+     +-----------------------------------------+
            | val v = Vector(1, 2, 3, 4, 5)                                           |     | val v = Vector[Int]()   // Vector()     |
            | v(0)                        // Int = 1                                  |     | val v1 = v :+ 1         // Vector(1)    |
            | val v2 = v.updated(2, 10)   //Vector(1, 2, 10, 4, 5) (v did not change) |     | val v2 = 4 +: v1        // Vector(4, 1) |
            +-------------------------------------------------------------------------+     | val v3 = v2.tail        // Vector(1)    |
                                                                                            +-----------------------------------------+

        - Structural Sharing
            +-----------------------------------------------------------------------+   +-----------------------------------------------------------------------+
            | val v1 = Vector(1, 2, 0, 9, 7, 2, 9, 6, ..., 3, 2, 5, 5, 4, 8, 4, 6)  |   | val v2 = v1.updated(4, 8)                                             |
            |                   V1                                                  |   |                   V1 copied                                           |
            |                +-+-+-+-+                                              |   |                +-+-+-+-+                                              |
            |            ----+ | | | +----                                          |   |            ----+ | | | +----                                          |
            |           /    +-+-+-+-+    \                                         |   |           /    +-+-+-+-+    \                                         |
            |          /        / \        \                                        |   |          /        / \        \                                        |
            |         /        /   \        \                                       |   |         / copied /   \        \                                       |
            | +-------+ +-+-+-+-+ +-+-+-+-+ +-+-+-+-+                               |   | +-------+ +-+-+-+-+ +-+-+-+-+ +-+-+-+-+                               |
            | |1|2|0|9| | | | | | | | | | | | | | | |                               |   | |1|2|0|9| | | | | | | | | | | | | | | |                               |
            | +-------+ +-+-+-+-+ +-+-+-+-+ +-+-+-+-+                               |   | +-------+ +-+-+-+-+ +-+-+-+-+ +-+-+-+-+                               |
            |          /         /                                                  |   | copied   /         /                                                  |
            | +-------+ +-------+                                                   |   | +-------+ +-------+                                                   |
            | |7|2|9|6| |7|2|9|6|                                                   |   | |8|2|9|6| |7|2|9|6|                                                   |
            | +-------+ +-------+                                                   |   | +-------+ +-------+                                                   |
            +-----------------------------------------------------------------------+   +-----------------------------------------------------------------------+
            -for update - 3 nodes needed to be copied, in large vector number of nodes needed to copy is porportional to the height of tree
            -never be as fast as update in place (if performance needed consider ArrayDeque which has O(1) update/prepend/append or Artray if size will not change) 
            -similar tree-shaped data structure is also used to implement Immutable Sets and Immutable Maps 

        - Immutable Sets
            - unordered collections of elements without duplicates
            - O(log n) .contains method
            - Set operations take time O(log n) in the size of the Set
            - in cases where it isn't you can always fall back to Mutable Sets for better performance
            +-----------------------------------------+ +--------------------------------------------------+
            | val s = Set(1, 2, 3)    // Set(1, 2, 3) | | Set(1, 2, 3) + 4 + 5  // HashSet(5, 1, 2, 3, 4)  |
            | s.contains(2)           // true         | | Set(1, 2, 3) - 2      // Set(1, 3)               |
            | s.contains(4)           // false        | | Set(1, 2, 3) ++ Set(2, 3, 4)  // Set(1, 2, 3, 4) |
            +-----------------------------------------+ +--------------------------------------------------+
            +------------------------------------------+
            | for (i <- Set(1, 2, 3, 4, 5)) println(i) |
            +------------------------------------------+

        - Immutable Maps
            -unordered collections of keys and values, allowing efficient lookup by key
            -most immutable Map operations take time O(log n)
            +---------------------------------------------------+   +--------------------------------------------+
            | val m = Map("one" -> 1, "two" -> 2, "three" -> 3) |   | m.get("one")      // Option[Int] = Some(1) |  // use .get if you're not sure whether a map contains a key or not
            | m.contains("two")   // true                       |   | m.get("four")     // Option[Int] = None    |
            | m("two")            // Int = 2                    |   +--------------------------------------------+
            +---------------------------------------------------+
            +-------------------------------------------------------------------------------------------+
            | Vector(("one", 1), ("two", 2), ("three", 3)).to(Map)                                      |
            | Map[String, Int]() + ("one" -> 1) + ("three" -> 3)      //  Map("one" -> 1, "three" -> 3) |
            | for ((k, v) <- m) println(k + " " + v)                                                    |
            |     one 1                                                                                 |
            |     two 2                                                                                 |
            |     three 3                                                                               |
            +-------------------------------------------------------------------------------------------+

        - Immutable Lists
            - singly-linked list
            - O(1) to .head, .tail, :: (to create new list with new element in front)
            - indexed lookup via myList(i) is a slow O(n)
            - Appending/removing elements on the right hand side of the list is also a slow O(n)
            - want fast indexed lookup or fast appends/removes on the right, you should consider using Vectors or mutable ArrayDeques
            +------------------------------------------------------------+  +------------------------------------------------------+
            | val myList = List(1, 2, 3, 4, 5)                           |  |                   +------+                           |
            | myList.head                     // Int = 1                 |  |                   |myList|                           |
            | val myTail = myList.tail        // List(2, 3, 4, 5)        |  |            +-+    +------+                           |
            | val myOtherList = 0 :: myList   // List(0, 1, 2, 3, 4, 5)  |  | myOtherList|1|            \                          |
            | val myThirdList = -1 :: myList  // List(-1, 1, 2, 3, 4, 5) |  |            +-------------->+-+ +-+ +-+ +-+ +-+ +---+ |
            +------------------------------------------------------------+  |                            |1|>|2|>|3|>|4|>|5|>|Nil| |
                                                                            |            +--+----------->+-+ +-+ +-+ +-+ +-+ +---+ |
                                                                            | myThirdList|-1|               /                      |
                                                                            |            +--+       +------+                       |
                                                                            |                       |myTail|                       |
                                                                            |                       +------+                       |
                                                                            +------------------------------------------------------+

    ### Mutable Collections
        - Mutable ArrayDeques
            - efficient O(1) indexed lookups/updates/inserts/removal of left & right ends
            - reuses array as much as possible moving start/end
            - if number of elements exceeds array size - it gets reallocated
            - faster than immu8table Vector
            - good for fifo, filo with .append/.removeHead-.removeLast
            +--------------------------------------------------+
            |             removeHead() append(6)  removeHead() |
            |         end         end  end         end         |
            |  start   +     start +   + start     +   start   |
            |  +       |     +     |   | +         |   +       |
            | ++-------++ +--+-----++ ++-+------+ ++---+----+  |
            | |1|2|3|4|5| | |2|3|4|5| |6|2|3|4|5| |6| |3|4|5|  |
            | +---------+ +---------+ +---------+ +---------+  |
            +--------------------------------------------------+
            +-------------------------+
            | myArrayDeque.to(Vector) | // "freeze" a mutable ArrayDeque 
            +-------------------------+

        - Mutable Sets
            - .contains checks (O(1))
            - instead of constructing new copies of the Set via + and -, you instead add and remove elements from the Set via .add and .remove
            +-----------------------------------------------------------------+     +---------------------------------+
            | val s = collection.mutable.Set(1, 2, 3)     // HashSet(1, 2, 3) |     | s.add(4)                        |
            | s.contains(2)       // true                                     |     | s.remove(1)                     |
            | s.contains(4)       // false                                    |     | s           // HashSet(2, 3, 4) |
            +-----------------------------------------------------------------+     +---------------------------------+

        - Mutable Maps
            +--------------------------------------------------------------------------------------------------------------------------+
            | val m = collection.mutable.Map("one" -> 1, "two" -> 2, "three" -> 3)    // HashMap("two" -> 2, "three" -> 3, "one" -> 1) |
            | m.remove("two")     // Some(2)                                                                                           |
            | m("five") = 5                                                                                                            |
            | m                   // HashMap("five" -> 5, "three" -> 3, "one" -> 1)                                                    |
            +--------------------------------------------------------------------------------------------------------------------------+
            -getOrElseUpdate - look up a value by key, and compute/store the value if there isn't one already present:
            +-----------------------------------------------------------------------------------------------------+
            | val m = collection.mutable.Map("one" -> 1, "two" -> 2, "three" -> 3)                                |
            | m.getOrElseUpdate("three", -1)      // Int = 3                                                      |
            | m                                   // HashMap("two" -> 2, "three" -> 3, "one" -> 1)                |
            | m.getOrElseUpdate("four", -1)       // Int = -1                                                     |
            | m                                   // HashMap( "two" -> 2, "three" -> 3, "four" -> -1, "one" -> 1) |
            +-----------------------------------------------------------------------------------------------------+

        - In-Place Operations
            - All mutable collections, including Arrays, have in-place versions of many common collection operations
            +-----------------------------------------------------------+
            | val a = collection.mutable.ArrayDeque(1, 2, 3, 4)         |
            | a.mapInPlace(_ + 1)             // ArrayDeque(2, 3, 4, 5) |
            | a.filterInPlace(_ % 2 == 0)     // ArrayDeque(2, 4)       |
            | a                               // ArrayDeque(2, 4)       |
            +-----------------------------------------------------------+

    ### Common Interfaces
        - code that needs something that can be iterated over
            +--------------------------------------------------------------------------------------------------------+
            | def iterateOverSomething[T](items: Seq[T]) = {                                                         |
            |     for (i <- items) println(i)                                                                        |
            | }                                                                                                      |
            | iterateOverSomething(Vector(1, 2, 3))       // 1 2 3                                                   |
            | iterateOverSomething(List(("one", 1), ("two", 2), ("three", 3)))    // (one,1) \n (two,2) \n (three,3) |
            +--------------------------------------------------------------------------------------------------------+
        - code that needs something that provides indexed lookup (Array/Vector), but cannot work with list
            +------------------------------------------------------------------------+
            | def getIndexTwoAndFour[T](items: IndexedSeq[T]) = (items(2), items(4)) |
            | getIndexTwoAndFour(Vector(1, 2, 3, 4, 5))   // (Int, Int) = (3, 5)     |
            | getIndexTwoAndFour(Array(2, 4, 6, 8, 10))   // (Int, Int) = (6, 10)    |
            +------------------------------------------------------------------------+
        - hierarchy
            -immutable
            +------------------------------------------------------------------------------+    // val s = Seq(1, 2, 3 -> delegate is a list(s: Seq[Int] = List(1, 2, 3));
            |                                                       +---------+            |    // Seq    - idxAccess O(n); prepend O(1);
            |                                            (HashMap)  |HashMap  |            |    // Vector - idxAccess O(1); update O(1)
            |                                                +---+  +---------+            |    // val x = IndexedSeq(1,2,3) // x: IndexedSeq[Int] = Vector(1, 2, 3)
            |                            +-------------------+Map+->+ListMap  |            |    // val ar = Array(1,2,3)
            |                            |                   +---+  +---------+  +-------+ |    // can be generic Array[T] (in Java not)
            |                            |                          |SortedMap+->+TreeMap| |
            |                            |                          +---------+  +-------+ |
            |                            |                                                 |
            |                            |                          +------+               |
            |                            |            (Vector)      |Vector|               |
            |                            |            +----------+  +------+               |
            |                            |         +--+IndexedSeq+->+String|               |
            |                            |         |  +----------+  +------+               |
            |                            |         |                |Range |               |
            | (foreach)      (iterator)  |  (List) |                +------+               |
            | +-----------+  +--------+  |  +---+  |                                       |
            | |Traversable+->+Iterable+->-->+Seq+->+                +------+               |
            | +-----------+  +--------+  |  +---+  |                |List  |               |
            |                            |         |   (List)       +------+               |
            |                            |         |   +---------+  |Stack |               |
            |                            |         +---+LinearSeq+->-------+               |
            |                            |             +---------+  |Stream|               |
            |                            |                          +------+               |
            |                            |                          |Queue |               |
            |                            |                          +------+               |
            |                            |                                                 |
            |                            |                          +---------+            |
            |                            |               (HashSet)  |HashSet  |            |
            |                            |                   +---+  +---------+            |
            |                            +-------------------+Set+->+ListSet  |  +-------+ |
            |                                                +---+  +---------+  |TreeSet| |
            |                                                       |SortedSet+->--------+ |
            |                                                       +---------+  |BitSet | |
            |                                                                    +-------+ |
            |                                                                              |
            +------------------------------------------------------------------------------+
            -mutable
            +-----------------------------------------------------------------------------------------------------------------------------------------------------------------------+
            |                                   +----------+  +------------------+                                                                                                  |
            |                                +->+Stack     +->+SynchronizedStack |                                                                                                  |
            |                                |  +----------+  +------------------+                                                                                                  |
            |                                |                                                                                                                                      |
            |                                |  +----------+                                                                                                                        |
            |                                +-->ArrayStack|                                                                                                                        |
            |                                |  +----------+                                                                                                                        |
            |                                |                                                                                                                                      |
            |                                |                +------------------+  +-----+  +-----------------+                                                                    |
            |                                |  (MutableList) |MutableList       +->+Queue+->+SynchronizedQueue|                                                                    |
            |                                |  +----------+  +------------------+  +-----+  +-----------------+                                                                    |
            |                                +->+LinearSeq +->+LinkedList        |                                                                                                  |
            |                                |  +----------+  +------------------+                                                                                                  |
            |                   (ArrayBuffer)|                |DoubleLinkedList  |                                                                                                  |
            |                            +---+                +------------------+                                                                                                  |
            |                         +->+Seq|                                                                                                                                      |
            |                         |  +---+                +------------------+                                                                                                  |
            |                         |      | (ArrayBuffer)  |ArraySeq          |                                                                                                  |
            |                         |      |  +----------+  +------------------+                                                                                                  |
            |                         |      +->+IndexedSeq+->+StringBuilder     |                                                                                                  |
            |                         |      |  +----------+  +------------------+                                                                                                  |
            |                         |      |                |ArrayBuffer       |                                                                                                  |
            |                         |      |             +->+------------------+                                                                                                  |
            |                         |      |             |                                                                                                                        |
            | +-----------+  +--------+      |             |  +------------------+                                                                                                  |
            | |Traversable+->+Iterable|      |(ArrayBuffer)|  |ListBuffer        |                                                                                                  |
            | +-----------+  +--------+      |  +----------+  +------------------+                                                                                                  |
            |                         |      +->+Buffer    +->+ObservableBuffer  |                                                                                                  |
            |                         |         +----------+  +------------------+                                                                                                  |
            |                         |                       |SynchronizedBuffer|                                                                                                  |
            |                         |                       +------------------+                                                                                                  |
            |                         | (HashSet)                                                                                                                                   |
            |                         |  +---+  +----------------------------------------------------------------------------------------------+                                    |
            |                         +->+Set+->+HashSet| LinkedHashSet| ImmutableSetAdaptor| ObservableSet| SynchronizedSet| SortedSet, BitSet|                                    |
            |                         |  +---+  +----------------------------------------------------------------------------------------------+                                    |
            |                         | (HashMap)                                                                                                                                   |
            |                         |  +---+  +---------------------------------------------------------------------------------------------------------------------------------+ |
            |                         +->+Map+->+HashMap| ListMap| TreeMap| OpenHashMap| WeakHashMap| LinkedHashMap| ImmutableMapAdaptor| SynchronizedMap| MultiMap| ObservableMap| |
            |                         |  +---+  +---------------------------------------------------------------------------------------------------------------------------------+ |
            |                         |                                                                                                                                             |
            |                         |  +----------------------------------------+                                                                                                 |
            |                         +->+PriorityQueue| SynchronizedPriorityQueue|                                                                                                 |
            |                            +----------------------------------------+                                                                                                 |
            +-----------------------------------------------------------------------------------------------------------------------------------------------------------------------+


####################
# Notable Scala Features
####################
        +------------------------------------------------------------------------------------------+
        | def getDayMonthYear(s: String) = s match {                                               |
        |     case s"$day-$month-$year" => println(s"found day: $day, month: $month, year: $year") |
        |     case _ => println("not a date")                                                      |
        | }                                                                                        |
        | getDayMonthYear("9-8-1965")     // found day: 9, month: 8, year: 1965                    |
        | getDayMonthYear("9-8")          // not a date                                            |
        +------------------------------------------------------------------------------------------+
    
    ### Case Classes and Sealed Traits
        -Case Classes
            - classes which are "just data" data is immutable and public, without any mutable state or encapsulation
            +----------------------------------------+
            | case class Point(x: Int, y: Int)       |  // p.x     // Int = 1
            | val p = Point(1, 2)     // Point(1, 2) |  // p.y     // Int = 2
            +----------------------------------------+
            - provide .toString, ==, .copy
            +--------------------------------------------------+    +----------------------------------------------+
            | p.toString              // String = "Point(1,2)" |    | val p = Point(1, 2)                          |
            | p2 = Point(1, 2)                                 |    | val p3 = p.copy(y = 10)     // Point(1, 10)  |
            | p == p2                 // Boolean = true        |    | val p4 = p3.copy(x = 20)    // Point(20, 10) |
            +--------------------------------------------------+    +----------------------------------------------+
            - define methods
            +------------------------------------+
            | case class Point(x: Int, y: Int) { |
            |     def z = x + y                  |
            | }                                  |
            | p = Point(1, 2); p.z    // Int = 3 |
            +------------------------------------+
        - Sealed Traits
            - can be extended by a fixed set of case classes in same file
            +-----------------------------------------------------------------------+
            | {                                                                     |
            |     sealed trait Point                                                |
            |     case class Point2D(x: Double, y: Double) extends Point            |
            |     case class Point3D(x: Double, y: Double, z: Double) extends Point |
            | }                                                                     |
            | def hypotenuse(p: Point) = p match {                                  |
            |     case Point2D(x, y) => math.sqrt(x * x + y * y)                    |
            |     case Point3D(x, y, z) => math.sqrt(x * x + y * y + z * z)         |
            | }                                                                     |
            | val points: Array[Point] = Array(Point2D(1, 2), Point3D(4, 5, 6))     |
            | for (p <- points) println(hypotenuse(p))                              |
            +-----------------------------------------------------------------------+
        - Use Cases for Normal v.s. Sealed Traits
            - normal trait - define class & implement methods; new method needs to be added to all subclasses
            - sealed trait - easy to add new method - simply pattern match on each subclass; adding new class is difficult - go to all pattern matches and add new sub-class;
            - sealed traits good to model hierarchies when you dont expect number of subclasses to grow
            +------------------------------------------------------------+
            | {                                                          |
            |     sealed trait Json                                      |
            |     case class Null() extends Json                         |
            |     case class Bool(value: Boolean) extends Json           |
            |     case class Str(value: String) extends Json             |
            |     case class Num(value: Double) extends Json             |
            |     case class Arr(value: Seq[Json]) extends Json          |
            |     case class Dict(value: Map[String, Json]) extends Json |
            | }                                                          |
            +------------------------------------------------------------+

    ### Pattern Matching
        - Match
            match ints                                      match tuples
            +------------------------------------------+    +--------------------------------------+    // 1 2
            | def dayOfWeek(x: Int) = x match {        |    | for (i <- Range.inclusive(1, 100)) { |    // Fizz
            |     case 1 => "Mon"; case 2 => "Tue"     |    |     val s = (i % 3, i % 5) match {   |    // 4
            |     case 3 => "Wed"; case 4 => "Thu"     |    |         case (0, 0) => "FizzBuzz"    |    // Buzz
            |     case 5 => "Fri"; case 6 => "Sat"     |    |         case (0, _) => "Fizz"        |
            |     case 7 => "Sun"; case _ => "Unknown" |    |         case (_, 0) => "Buzz"        |
            | }                                        |    |         case _ => i                  |
            | dayOfWeek(5)    // String = "Fri"        |    |     }                                |
            | dayOfWeek(-1)   // String = "Unknown"    |    |     println(s)                       |
            +------------------------------------------+    | }                                    |
                                                            +--------------------------------------+
            matching on Case Classes                                matching on String Patterns
            +--------------------------------------------------+    +-----------------------------------------------------------------------+
            | case class Point(x: Int, y: Int)                 |    | def splitDate(s: String) = s match {                                  |
            | def direction(p: Point) = p match {              |    |     case s"--" => s"day: , mon: , yr: " |
            |     case Point(0, 0) => "origin"                 |    |     case _ => "not a date"                                            |
            |     case Point(_, 0) => "horizontal"             |    | }                                                                     |
            |     case Point(0, _) => "vertical"               |    | splitDate("9-8-1965")   // String = "day: 9, mon: 8, yr: 1965"        |
            |     case _ => "diagonal"                         |    | splitDate("9-8")        // String = "not a date"                      |
            | }                                                |    +-----------------------------------------------------------------------+
            | direction(Point(0, 0))  // String = "origin"     |
            | direction(Point(1, 1))  // String = "diagonal"   |
            | direction(Point(10, 0)) // String = "horizontal" |
            +--------------------------------------------------+            

        - Nested Matches
            +---------------------------------------------------------------------------------------+   +-------------------------------------------------------------------------------------------------------------------------------+
            | case class Person(name: String, title: String)                                        |   | def greet2(husband: Person, wife: Person) = (husband, wife) match {                                                           |
            | def greet(p: Person) = p match {                                                      |   |     case (Person(s" ", _), Person(s" ", _)) if last1 == last2 => println(s"Hello Mr and Ms ") |
            |     case Person(s"$firstName $lastName", title) => println(s"Hello $title $lastName") |   |     case (Person(name1, _), Person(name2, _)) => println(s"Hello  and ")                                          |
            |     case Person(name, title) => println(s"Hello $title $name")                        |   | }                                                                                                                             |
            | }                                                                                     |   | greet2(Person("James Bond", "Mr"), Person("Jane Bond", "Ms"))   // Hello Mr and Ms Bond                                       |
            | greet(Person("Haoyi Li", "Mr")) //Hello Mr Li                                         |   +-------------------------------------------------------------------------------------------------------------------------------+
            +---------------------------------------------------------------------------------------+

        - Loops and Vals
            inside loops
            +--------------------------------------------------------------------+
            | val a = Array[(Int, String)]((1, "one"), (2, "two"), (3, "three")) |
            | for ((i, s) <- a) println(s + i)                                   |
            | one1                                                               |
            | two2                                                               |
            | three3                                                             |
            +--------------------------------------------------------------------+
            in val statements
            +----------------------------------+    +------------------------------------------+
            | case class Point(x: Int, y: Int) |    | val s" " = "Hello World"    |
            | val p = Point(123, 456)          |    | first: String = "Hello"                  |
            | val Point(x, y) = p              |    | second: String = "World"                 |
            | x: Int = 123                     |    | val flipped = s" "          |
            | y: Int = 456                     |    | flipped: String = "World Hello"          |
            +----------------------------------+    +------------------------------------------+

        - Pattern Matching on Sealed Traits and Case Classes
            +--------------------------------------------------------------------+
            | {                                                                  |
            | sealed trait Expr                                                  |  x + 1        // BinOp(Variable("x"), "+", Literal(1))
            | case class BinOp(left: Expr, op: String, right: Expr) extends Expr |  x * (y - 1)  // BinOp(Variable("x"), "*", BinOp(Variable("y"), "-", Literal(1)))
            | case class Literal(value: Int) extends Expr                        |  x * (y - 1)  // BinOp( BinOp(Variable("x"), "+", Literal(1)), "*", BinOp(Variable("y"), "-", Literal(1)) )
            | case class Variable(name: String) extends Expr                     |
            | }                                                                  |
            +--------------------------------------------------------------------+
            Stringifying Our Expressions
            +------------------------------------------------------------------------------------+
            | def stringify(expr: Expr): String = expr match {                                   |  // val smallExpr = BinOp( Variable("x"), "+", Literal(1) )
            |     case BinOp(left, op, right) => s"(${stringify(left)} $op ${stringify(right)})" |  // stringify(smallExpr)    // String = "(x + 1)"
            |     case Literal(value) => value.toString                                          |
            |     case Variable(name) => name                                                    |
            | }                                                                                  |
            +------------------------------------------------------------------------------------+
            evaluate
            +--------------------------------------------------------------------------------------+
            | def evaluate(expr: Expr, values: Map[String, Int]): Int = expr match {               |    // evaluate(smallExpr, Map("x" -> 10)) // Int = 11
            |     case BinOp(left, "+", right) => evaluate(left, values) + evaluate(right, values) |
            |     case BinOp(left, "-", right) => evaluate(left, values) - evaluate(right, values) |
            |     case BinOp(left, "*", right) => evaluate(left, values) * evaluate(right, values) |
            |     case Literal(value) => value                                                     |
            |     case Variable(name) => values(name)                                              |
            | }                                                                                    |
            +--------------------------------------------------------------------------------------+

    ### By-Name Parameters
        +----------------------------+
        | def func(arg: => String) = |
        +----------------------------+

        - Avoiding Evaluation
            +-----------------------------------------+
            | var logLevel = 1                        | // log(2, "Hello " + 123 + " World")    // Hello 123 World
            | def log(level: Int, msg: => String) = { | // above is not computing log message
            |     if (level > logLevel) println(msg)  | // getOrElse and getOrElseUpdate are similiar - not use the argument for default value if the value we looking for is present
            | }                                       |
            +-----------------------------------------+

        - Wrapping Evaluation
            defers evaluation of f: => Unit, allowing us to run System.currentTimeMillis() before and after
            +-------------------------------------------------------------------+
            | def measureTime(f: => Unit) = {                                   |   // measureTime(new Array[String](10 * 1000 * 1000).hashCode()) // Evaluation took 24 milliseconds
            |     val start = System.currentTimeMillis()                        |
            |     f                                                             |
            |     val end = System.currentTimeMillis()                          |
            |     println("Evaluation took " + (end - start) + " milliseconds") |
            | }                                                                 |
            +-------------------------------------------------------------------+

        - Repeating Evaluation
            +---------------------------------------------------+
            | def retry[T](max: Int)(f: => T): T = {            |   // val httpbin = "https://httpbin.org"
            |     var tries = 0                                 |   // retry(max = 5) {
            |     var result: Option[T] = None                  |   // // Only succeeds with a 200 response
            |     while (result == None) {                      |   // // code 1/3 of the time
            |         try { result = Some(f) }                  |   //     requests.get(
            |         catch {case e: Throwable =>               |   //     s"/status/200,400,500"
            |             tries += 1                            |   //     )
            |             if (tries > max) throw e              |   // }
            |             else {                                |   // call failed, retry #1
            |                 println(s"failed, retry #$tries") |   // call failed, retry #2
            |             }                                     |   // res68: requests.Response = Response(
            |         }                                         |   // "https://httpbin.org/status/200,400,500",
            |     }                                             |   // 200,
            |     result.get                                    |
            | }                                                 |
            +---------------------------------------------------+

    ### Implicit Parameters
        implicit parameter is automatically filled when calling function
        +--------------------------------------------------------+
        | class Foo(val value: Int)                              |
        | def bar(implicit foo: Foo) = foo.value + 10            |
        | implicit val foo: Foo = new Foo(1)                     |
        | bar // `foo` is resolved implicitly // res72: Int = 11 |
        +--------------------------------------------------------+
        - Passing ExecutionContext to Futures                                           - Dependency Injection via Implicits
            passing this ExecutionContext everywhere                                    +------------------------------------------------------------------------------------+
        +---------------------------------------------------------------------------+   | def getEmployee(id: Int)(implicit ec: ExecutionContext): Future[Employee] = ...    |
        | def getEmployee(ec: ExecutionContext, id: Int): Future[Employee] = ...    |   | def getRole(employee: Employee)(implicit ec: ExecutionContext): Future[Role] = ... |
        | def getRole(ec: ExecutionContext, employee: Employee): Future[Role] = ... |   | implicit val executionContext: ExecutionContext = ...                              |
        | val executionContext: ExecutionContext = ...                              |   |                                                                                    |
        |                                                                           |   | val bigEmployee: Future[EmployeeWithRole] = {                                      |
        | val bigEmployee: Future[EmployeeWithRole] = {                             |   |     getEmployee(100).flatMap(e =>                                                  |
        |     getEmployee(executionContext, 100).flatMap(                           |   |         getRole(e).map(r =>                                                        |
        |         executionContext, e =>                                            |   |             EmployeeWithRole(e, r)                                                 |
        |             getRole(executionContext, e)                                  |   |         )                                                                          |
        |                 .map(executionContext, r => EmployeeWithRole(e, r))       |   |     )                                                                              |
        |     )                                                                     |   | }                                                                                  |
        | }                                                                         |   +------------------------------------------------------------------------------------+
        +---------------------------------------------------------------------------+

    ### Typeclass Inference
        - Problem Statement: Parsing Command Line Arguments
        +---------------------------------------------------+
        | def parseFromString[T](s: String): T = ...        |
        |                                                   |
        | val args = Seq("123", "true", "7.5")              |
        | val myInt = parseFromString[Int](args(0))         |   // How does the parseCliArgument know how to convert 
        | val myBoolean = parseFromString[Boolean](args(1)) |   // the given String into an arbitrary T
        | val myDouble = parseFromString[Double](args(2))   |
        +---------------------------------------------------+

        - Separate Parser Objects
            +--------------------------------------------------------------------------------------+     +---------------------------------------------+
            | trait StrParser[T]{ def parse(s: String): T }                                        |     | val args = Seq("123", "true", "7.5")        |
            | object ParseInt extends StrParser[Int]{ def parse(s: String) = s.toInt }             |     | val myInt = ParseInt.parse(args(0))         |
            | object ParseBoolean extends StrParser[Boolean]{ def parse(s: String) = s.toBoolean } |     | val myBoolean = ParseBoolean.parse(args(1)) |
            | object ParseDouble extends StrParser[Double]{ def parse(s: String) = s.toDouble }    |     | val myDouble = ParseDouble.parse(args(2))   |
            +--------------------------------------------------------------------------------------+     +---------------------------------------------+
            - write a method that didn't parse a String directly, but parsed a value from the console
            - option 1                                                      - option 2
            +------------------------------------------------------------+  +-------------------------------------------------------------------------------------------+
            | trait ConsoleParser[T]{ def parse(): T }                   |  | def parseFromConsole[T](parser: StrParser[T]) = parser.parse(scala.Console.in.readLine()) |
            | object ConsoleParseInt extends ConsoleParser[Int]{         |  | val myInt = parseFromConsole[Int](ParseInt)                                               |
            |     def parse() = scala.Console.in.readLine().toInt        |  | val myBoolean = parseFromConsole[Boolean](ParseBoolean)                                   |
            | }                                                          |  | val myDouble = parseFromConsole[Double](ParseDouble)                                      |
            | object ConsoleParseBoolean extends ConsoleParser[Boolean]{ |  +-------------------------------------------------------------------------------------------+
            |     def parse() = scala.Console.in.readLine().toBoolean    |
            | }                                                          |
            | object ConsoleParseDouble extends ConsoleParser[Double]{   |
            |     def parse() = scala.Console.in.readLine().toDouble     |
            | }                                                          |
            | val myInt = ConsoleParseInt.parse()                        |
            | val myBoolean = ConsoleParseBoolean.parse()                |
            | val myDouble = ConsoleParseDouble.parse()                  |
            +------------------------------------------------------------+     

        - Solution: Implicit StrParser
            -  solution to the problems above is to make the instances of StrParser implicit
             put the implicit object ParseInt, ParseBoolean, etc. in an object StrParser with the same name as the trait StrParser next to it
            +--------------------------------------------------------------+
            | trait StrParser[T]{ def parse(s: String): T }                |
            | object StrParser{                                            |    // companion object
            |     implicit object ParseInt extends StrParser[Int]{         |    // often used to group together implicits, static methods, factory methods, and other functionality that is related to a trait or class but does not belong to any specific instance.
            |         def parse(s: String) = s.toInt                       |    // Implicits in the companion object are also treated specially, and do not need 
            |     }                                                        |    // to be imported into scope in order to be used as an implicit parameter
            |     implicit object ParseBoolean extends StrParser[Boolean]{ |
            |         def parse(s: String) = s.toBoolean                   |
            |     }                                                        |
            |     implicit object ParseDouble extends StrParser[Double]{   |
            |         def parse(s: String) = s.toDouble                    |
            |     }                                                        |
            | }                                                            |
            +--------------------------------------------------------------+
            - we can now write a generic function that automatically uses the correct instance of StrParser depending on what type we asked it to parse
            +----------------------------------------------------------------------+
            | def parseFromString[T](s: String)(implicit parser: StrParser[T]) = { |    // function can now automatically infer the correct StrParser for each type it is trying to parse
            |     parser.parse(s)                                                  |
            | }                                                                    |
            | val args = Seq("123", "true", "7.5")                                 |
            | val myInt = parseFromString[Int](args(0))                            |
            | val myBoolean = parseFromString[Boolean](args(1))                    |
            | val myDouble = parseFromString[Double](args(2))                      |
            +----------------------------------------------------------------------+
            - Re-Using Our Implicit StrParsers                              - Context-Bound Syntax
            +------------------------------------------------------------+  technique of taking an implicit parameter with a generic type is common enough that the Scala language provides dedicated syntax for it. The following method signature
            | def parseFromConsole[T](implicit parser: StrParser[T]) = { |  +------------------------------------------------------------------------+
            |     parser.parse(scala.Console.in.readLine())              |  | def parseFromString[T](s: String)(implicit parser: StrParser[T]) = ... |
            | }                                                          |  +------------------------------------------------------------------------+
            | val myInt = parseFromConsole[Int]                          |  Can be written more concisely as:
            +------------------------------------------------------------+  +----------------------------------------------------+  // context bound
                                                                            | def parseFromString[T: StrParser](s: String) = ... |  // equivalent to the (implicit parser: StrParser[T])
                                                                            +----------------------------------------------------+  // esolve the implicit values via the implicitly function, e.g. implicitly[StrParser[T]].parse

        - Recursive Typeclass Inference
            Parsing Sequences
            teaching the compiler how to produce a StrParser[Seq[T]] for any type T as long as it has an implicit StrParser[T] available
            +-----------------------------------------------------------------------------+ // implicit def ParseSeq would thus return a different StrParser each time it is called with a different type T
            | implicit def ParseSeq[T](implicit p: StrParser[T]) = new StrParser[Seq[T]]{ | +-------------------------------------------------------------------------------------------------------+
            |    def parse(s: String) = s.split(',').toSeq.map(p.parse)                   | | parseFromString[Seq[Boolean]]("true,false,true") // res99: Seq[Boolean] = ArraySeq(true, false, true) |
            | }                                                                           | | parseFromString[Seq[Int]]("1,2,3,4")    // res100: Seq[Int] = ArraySeq(1, 2, 3, 4)                    |
            +-----------------------------------------------------------------------------+ +-------------------------------------------------------------------------------------------------------+
            Parsing Tuples
            +------------------------------------------------------------------------------+    +-------------------------------------------------------------------------------------------+
            | implicit def ParseTuple[T, V](implicit p1: StrParser[T], p2: StrParser[V]) = |    | parseFromString[(Int, Boolean)]("123=true")     // res102: (Int, Boolean) = (123, true)   |
            |     new StrParser[(T, V)]{                                                   |    | parseFromString[(Boolean, Double)]("true=1.5")  //res103: (Boolean, Double) = (true, 1.5) |
            |         def parse(s: String) = {                                             |    +-------------------------------------------------------------------------------------------+
            |             val Array(left, right) = s.split('=')                            |
            |             (p1.parse(left), p2.parse(right))                                |
            |         }                                                                    |
            |     }                                                                        |
            +------------------------------------------------------------------------------+
            Parsing Nested Structures
            +-----------------------------------------------------------------------------------------------------------------------------------+
            | parseFromString[Seq[(Int, Boolean)]]("1=true,2=false,3=true,4=false")   // ArraySeq((1, true), (2, false), (3, true), (4, false)) |
            | parseFromString[(Seq[Int], Seq[Boolean])]("1,2,3,4,5=true,false,true")  // (ArraySeq(1, 2, 3, 4, 5), ArraySeq(true, false, true)) |
            +-----------------------------------------------------------------------------------------------------------------------------------+


####################
# Implementing Algorithms in Scala
####################

    ### Merge Sort
                                                                                                                - Generic Merge Sort
        +-------------------------------------------------------------------------------------------------+    // T: Ordering
        | def mergeSort(items: Array[Int]): Array[Int] = { MergeSort.sc                                   |    // context bound
        |     if (items.length <= 1) items                                                                |    // equivalent to the (implicit parser: StrParser[T])
        |     else {                                                                                      |    // esolve the implicit values via the implicitly function, e.g. implicitly[StrParser[T]].parse
        |         val (left, right) = items.splitAt(items.length / 2)                                     |     +-------------------------------------------------------------------------------------------------+ +--------------------------------------------------------------------------------+
        |         val (sortedLeft, sortedRight) = (mergeSort(left), mergeSort(right))                     |     | def mergeSort[T: Ordering](items: IndexedSeq[T]): IndexedSeq[T] = {                             | | case class Person(name:String, age:Int)                                        |
        |         var (leftIdx, rightIdx) = (0, 0)                                                        |     |     if (items.length <= 1) items                                                                | | implicit object AgeOrdering extends Ordering[Person] {                         |
        |         val output = Array.newBuilder[Int]                                                      |     |     else {                                                                                      | |   def compare(a:Person, b:Person) = a.age compare b.age}                       |
        |         while (leftIdx < sortedLeft.length || rightIdx < sortedRight.length) {                  |     |         val (left, right) = items.splitAt(items.length / 2)                                     | | def main(args: Array[String]): Unit = {                                        |
        |             val takeLeft = (leftIdx < sortedLeft.length, rightIdx < sortedRight.length) match { |     |         val (sortedLeft, sortedRight) = (mergeSort(left), mergeSort(right))                     | |   val people = Array(Person("bob", 30), Person("ann", 32), Person("carl", 19)) |
        |                 case (true, false) => true                                                      |     |         var (leftIdx, rightIdx) = (0, 0)                                                        | |   val res = mergeSort(people)                                                  |
        |                 case (false, true) => false                                                     |     |         val output = IndexedSeq.newBuilder[T]                                                   | |   print(res)                                                                   |
        |                 case (true, true) => sortedLeft(leftIdx) < sortedRight(rightIdx)                |     |         while (leftIdx < sortedLeft.length || rightIdx < sortedRight.length) {                  | | }                                                                              |
        |             }                                                                                   |     |             val takeLeft = (leftIdx < sortedLeft.length, rightIdx < sortedRight.length) match { | +--------------------------------------------------------------------------------+
        |             if (takeLeft) {                                                                     |     |                 case (true, false) => true                                                      |
        |                 output += sortedLeft(leftIdx)                                                   |     |                 case (false, true) => false                                                     |
        |                 leftIdx += 1                                                                    |     |                 case (true, true) => Ordering[T].lt(sortedLeft(leftIdx), sortedRight(rightIdx)) |
        |             } else {                                                                            |     |             }                                                                                   |
        |             output += sortedRight(rightIdx)                                                     |     |             if (takeLeft) {                                                                     |
        |             rightIdx += 1                                                                       |     |                 output += sortedLeft(leftIdx)                                                   |
        |             }                                                                                   |     |                 leftIdx += 1                                                                    |
        |         }                                                                                       |     |             } else {                                                                            |
        |         output.result()                                                                         |     |                 output += sortedRight(rightIdx)                                                 |
        |     }                                                                                           |     |                 rightIdx += 1                                                                   |
        | }                                                                                               |     |             }                                                                                   |
        +-------------------------------------------------------------------------------------------------+     |         }                                                                                       |
                                                                                                                |     output.result()}}         
                                                                                                                +-------------------------------------------------------------------------------------------------+
        
    ### Prefix Tries
        +-------------------------------------------------------------------------------------------------------------------+   +--------------------------------------------------------------------------------------------+
        | class Trie() {                                                                                                    |   | class ImmutableTrie(inputs: Seq[String]) {                                                 |
        |     class Node(var hasValue: Boolean,val children: collection.mutable.Map[Char, Node] = collection.mutable.Map()) |   |   class Node(index: Int, inputs: Seq[String]) {                                            |
        |     val root = new Node(false)                                                                                    |   |     val hasValue = inputs.exists(_.length == index)                                        |
        |     def add(s: String) = {                                                                                        |   |     val children = {                                                                       |
        |         var current = root                                                                                        |   |       val filteredInputs = inputs.filter(_.length > index)                                 |
        |         for (c <- s) current = current.children.getOrElseUpdate(c, new Node(false))                               |   |       for((childChar, childInputs) <- filteredInputs.groupBy(_.charAt(index)))             |
        |         current.hasValue = true                                                                                   |   |         yield (childChar, new Node(index + 1, childInputs))                                |
        |     }                                                                                                             |   |     }                                                                                      |
        |     def contains(s: String): Boolean = {                                                                          |   |   }                                                                                        |
        |         var current = Option(root)                                                                                |   |                                                                                            |
        |         for (c <- s if current.nonEmpty) current = current.get.children.get(c)                                    |   |   val root = new Node(0, inputs)                                                           |
        |         current.exists(_.hasValue)                                                                                |   |                                                                                            |
        |     }                                                                                                             |   |   def contains(s: String): Boolean = {                                                     |
        |     def prefixesMatchingString0(s: String): Set[Int] = {                                                          |   |     var current = Option(root)                                                             |
        |         var current = Option(root)                                                                                |   |     for (c <- s if current.nonEmpty) current = current.get.children.get(c)                 |
        |         val output = Set.newBuilder[Int]                                                                          |   |     current.exists(_.hasValue)                                                             |
        |         for ((c, i) <- s.zipWithIndex if current.nonEmpty) {                                                      |   |   }                                                                                        |
        |             if (current.get.hasValue) output += i                                                                 |   |   def prefixesMatchingString0(s: String): Set[Int] = {                                     |
        |             current = current.get.children.get(c)                                                                 |   |     var current = Option(root)                                                             |
        |         }                                                                                                         |   |     val output = Set.newBuilder[Int]                                                       |
        |         if (current.exists(_.hasValue)) output += s.length                                                        |   |     for ((c, i) <- s.zipWithIndex if current.nonEmpty) {                                   |
        |         output.result()                                                                                           |   |       if (current.get.hasValue) output += i                                                |
        |     }                                                                                                             |   |       current = current.get.children.get(c)                                                |
        |     def prefixesMatchingString(s: String): Set[String] = {                                                        |   |     }                                                                                      |
        |         prefixesMatchingString0(s).map(s.substring(0, _))                                                         |   |     if (current.exists(_.hasValue)) output += s.length                                     |
        |     }                                                                                                             |   |     output.result()                                                                        |
        |     def stringsMatchingPrefix(s: String): Set[String] = {                                                         |   |   }                                                                                        |
        |         var current = Option(root)                                                                                |   |   def prefixesMatchingString(s: String): Set[String] = {                                   |
        |             for (c <- s if current.nonEmpty) current = current.get.children.get(c) // initial walk                |   |     prefixesMatchingString0(s).map(s.substring(0, _))                                      |
        |         if (current.isEmpty) Set()                                                                                |   |   }                                                                                        |
        |         else {                                                                                                    |   |   def stringsMatchingPrefix(s: String): Set[String] = {                                    |
        |             val output = Set.newBuilder[String]                                                                   |   |     var current = Option(root)                                                             |
        |             def recurse(current: Node, path: List[Char]): Unit = {                                                |   |     for (c <- s if current.nonEmpty) current = current.get.children.get(c) // initial walk |
        |                 if (current.hasValue) output += (s + path.reverse.mkString)                                       |   |     if (current.isEmpty) Set()                                                             |
        |                 for ((c, n) <- current.children) recurse(n, c :: path)                                            |   |     else {                                                                                 |
        |             }                                                                                                     |   |       val output = Set.newBuilder[String]                                                  |
        |             recurse(current.get, Nil) // recursive walk                                                           |   |       def recurse(current: Node, path: List[Char]): Unit = {                               |
        |             output.result()                                                                                       |   |         if (current.hasValue) output += (s + path.reverse.mkString)                        |
        |         }                                                                                                         |   |         for ((c, n) <- current.children) recurse(n, c :: path)                             |
        |     }                                                                                                             |   |       }                                                                                    |
        | }                                                                                                                 |   |       recurse(current.get, Nil) // recursive walk                                          |
        +-------------------------------------------------------------------------------------------------------------------+   |       output.result()                                                                      |
                                                                                                                                |     }                                                                                      |
                                                                                                                                |   }                                                                                        |
                                                                                                                                | }                                                                                          |
                                                                                                                                +--------------------------------------------------------------------------------------------+

    ### Breadth First Search
        - cyclic                        - acyclic
        +---------------------------+   +---------------------------+
        | val graph = Map(          |   | val graph = Map(          |
        |     "a" -> Seq("b", "c"), |   |     "a" -> Seq("b", "c"), |
        |     "b" -> Seq("a"),      |   |     "b" -> Seq("c", "d"), |
        |     "c" -> Seq("b")       |   |     "c" -> Seq("d"),      |
        | )                         |   |     "d" -> Seq())         |
        +---------------------------+   +---------------------------+
        - with bfs you can:
            Find all nodes which are reachable from a particular starting node
            Find the shortest distance between a starting node and all other nodes
            Find the shortest path between two specific nodes
        
        - Implementing Breadth First Search
            Keep a seen set of all nodes you have seen so far, and a queue of nodes waiting to be processed
            Start with your starting node in both the seen set and queue
            While the queue is not empty, pull a node off the queue
            For every node which is reachable from the node you just pulled off the queue, if it isn't present in the seen set, add it to both the seen set and queue
            When the queue is empty, we have searched the entire graph
        
            +----------------------------------------------------------------------+    +----------------------------------------+  +---------------------------------------------+ +-----------------------------------+
            | def search[T](start: T, graph: Map[T, Seq[T]]): Set[T] = {           |    | search(                                |  | search(                                     | | search(                           |
            |     val seen = collection.mutable.Set(start)                         |    |     start = "c",                       |  |     start = "a",                            | |     start = "c",                  |
            |     val queue = collection.mutable.ArrayDeque(start)                 |    |     graph = Map(                       |  |     graph = Map(                            | |     graph = Map(                  |
            |     while (queue.nonEmpty) {                                         |    |         "a" -> Seq("b", "c"),          |  |         "a" -> Seq("b", "c"),               | |         "a" -> Seq("b", "c"),     |
            |         val current = queue.removeHead()                             |    |         "b" -> Seq("a"),               |  |         "b" -> Seq("c", "d"),               | |         "b" -> Seq("c", "d"),     |
            |         for (next <- graph(current) if !seen.contains(next)) {       |    |         "c" -> Seq("b")                |  |         "c" -> Seq("d"),                    | |         "c" -> Seq("d"),          |
            |             seen.add(next)                                           |    |     )                                  |  |         "d" -> Seq()                        | |         "d" -> Seq()              |
            |             queue.append(next)                                       |    | )                                      |  |     )                                       | |     )                             |
            |         }                                                            |    | res0: Set[String] = Set("a", "b", "c") |  | )                                           | | )                                 |
            |     }                                                                |    +----------------------------------------+  | res1: Set[String] = Set("a", "b", "c", "d") | | res2: Set[String] = Set("c", "d") |
            |     seen.to(Set)                                                     |                                                +---------------------------------------------+ +-----------------------------------+
            | }                                                                    |
            +----------------------------------------------------------------------+    
        
        - Shortest Paths
            -first path we find from our start node to our destination will be a shortest path between the two nodes
            -Rather than keeping a seen Set[T], we instead maintain a Map[T, List[T]]

        +---------------------------------------------------------------------------+   +----------------------------------------+  +-----------------------------------------+ +------------------------------------+
        | def searchPaths[T](start: T, graph: Map[T, Seq[T]]): Map[T, List[T]] = {  |   | searchPaths(                           |  | shortestPath(                           | | shortestPath(                      |
        |     val seen = collection.mutable.Map(start -> List(start))               |   |     graph = Map(                       |  |     start = "a",                        | |     start = "a",                   |
        |     val queue = collection.mutable.ArrayDeque(start -> List(start))       |   |         "a" -> Seq("b", "c"),          |  |     dest = "d",                         | |     dest = "c",                    |
        |     while (queue.nonEmpty) {                                              |   |         "b" -> Seq("c", "d"),          |  |     graph = Map(                        | |     graph = Map(                   |
        |         val (current, path) = queue.removeHead()                          |   |         "c" -> Seq("d"),               |  |         "a" -> Seq("b", "c"),           | |         "a" -> Seq("b", "c"),      |
        |         for (next <- graph(current) if !seen.contains(next)) {            |   |         "d" -> Seq()                   |  |         "b" -> Seq("c", "d"),           | |         "b" -> Seq("c", "d"),      |
        |             val newPath = next :: path                                    |   |     )                                  |  |         "c" -> Seq("d"),                | |         "c" -> Seq("d"),           |
        |             seen(next) = newPath                                          |   | )                                      |  |         "d" -> Seq()                    | |         "d" -> Seq()               |
        |             queue.append((next, newPath))                                 |   | res0: Map[String, List[String]] = Map( |  |     )                                   | |     )                              |
        |         }                                                                 |   |     "a" -> List("a"),                  |  | )                                       | | )                                  |
        |     }                                                                     |   |     "b" -> List("b", "a"),             |  | res1: Seq[String] = List("a", "b", "d") | | res2: Seq[String] = List("a", "c") |
        |     seen.toMap                                                            |   |     "c" -> List("c", "a"),             |  +-----------------------------------------+ +------------------------------------+
        | }                                                                         |   |     "d" -> List("d", "b", "a")         |      +-+
        |                                                                           |   | )                                      |      |a|
        | def shortestPath[T](start: T, dest: T, graph: Map[T, Seq[T]]): Seq[T] = { |   +----------------------------------------+      +-+
        |     val shortestReversedPaths = searchPaths(start, graph)                 |                                                  /   \
        |     shortestReversedPaths(dest).reverse                                   |                                               +-+     +-+     +-+
        | }                                                                         |                                               |c+<----+b+---->+d|
        +---------------------------------------------------------------------------+                                               +-+     +-+     +-+


####################
# Files and Subprocesses
####################
    ### Paths
        +-----------------------------------------------------+
        | os.pwd  // /Users/lihaoyi/test                      |
        | os.root // /                                        |
        | os.home // /Users/lihaoyi                           |
        | os.home.segments.toList // List("Users","lihaoyi",) |
        | os.home.last    // "lihaoyi"                        |
        +-----------------------------------------------------+

        - Constructing Paths
        +---------------------------------------------------------------+   +---------------------------------------------------------------------+
        | os.home / "Github" / "blog"     // /Users/lihaoyi/Github/blog |   | os.Path("/Users/lihaoyi")               // /Users/lihaoyi           |
        | os.pwd / os.up                  // /Users/lihaoyi             |   | os.Path("post", base = os.pwd)          // /Users/lihaoyi/test/post |
        | os.pwd / os.up / os.up          // /Users                     |   | os.Path("../Ammonite", base = os.pwd)   // /Users/lihaoyi/Ammonite  |
        +---------------------------------------------------------------+   +---------------------------------------------------------------------+

        - Relative Paths
        +-------------------------------------------------------------------+
        | val helloRelPath = os.RelPath("../hello")                         |
        | os.home / helloRelPath              // /Users/hello               |
        | helloRelPath / os.RelPath("post")   // os.RelPath = ../hello/post |
        +-------------------------------------------------------------------+

        - Sub Paths
        +------------------------------------------------------------+
        | val p1 = os.Path("/Users/lihaoyi/Github")                  |
        | val p2 = os.Path("/Users")                                 |
        | p1.subRelativeTo(p2)        // os.SubPath = lihaoyi/Github |
        +------------------------------------------------------------+

    ### Filesystem Operations
        - Queries
            list ()
            +------------------------------------------------------------------------------------------------------------+ ()
            | os.list(os.pwd) // IndexedSeq[os.Path] = ArraySeq(/Users/lihaoyi/test/.gitignore,/Users/lihaoyi/test/post) | ()
            +------------------------------------------------------------------------------------------------------------+
            walk (list recursively, you can use os.walk.stream)
            +--------------------------------------------------------------------------------------------------------------+
            | os.walk(os.pwd)   // IndexedSeq[os.Path] = ArraySeq(/Users/lihaoyi/test/.gitignore,/Users/lihaoyi/test/post) |
            +--------------------------------------------------------------------------------------------------------------+
            stat (metadata, one can use os.isFile/isDir/mtime/size)
            +-----------------------------------------------------------------------------------------------------------------------------------------------------+
            | os.stat(os.pwd / ".gitignore")    // os.StatInfo = StatInfo(129L,2019-09-27T08:04:35.292056Z,2019-12-15T22:23:01.462598Z,2019-09-27T08:04:35Z,File) |
            +-----------------------------------------------------------------------------------------------------------------------------------------------------+

        - Actions
            read/wrote
            +---------------------------------------------------------------------------------+
            | os.write(os.pwd / "new.txt", "Hello")                                           | // can write anything that implements writable
            | os.list(os.pwd) // IndexedSeq[os.Path] = ArraySeq(/Users/lihaoyi/test/new.txt,) |
            | os.read(os.pwd / "new.txt")   // String = "Hello"                               | // reads file as string, os.readLines reads as IndexedSeq[String], os.readBytes - Array[Byte]
            +---------------------------------------------------------------------------------+
            move                                                    copy
            +--------------------------------------------------+    +------------------------------------------------------+
            | os.move(os.pwd / "new.txt",os.pwd / "newer.txt") |    | os.copy(os.pwd / "newer.txt",os.pwd / "newer-2.txt") |
            +--------------------------------------------------+    +------------------------------------------------------+
            remove                              makeDir
            +---------------------------------+ +-----------------------------------+
            | os.remove(os.pwd / "newer.txt") | | os.makeDir(os.pwd / "new-folder") |
            +---------------------------------+ +-----------------------------------+

        - Combining Operations
            - all files will be loaded into memory to avoid it use .stream methods
            +-----------------------------------------------------------------------------------+
            | os.walk(os.pwd).filter(os.isFile).map(p => (os.size(p), p)).sortBy(-_._1).take(5) |
            +-----------------------------------------------------------------------------------+

        - Streaming
            +-----------------------------------------------------------------------------------------------------+
            | os.read.lines.stream(os.pwd / ".gitignore").foreach(println)    // target/,*.iml,.idea,.settings... |
            | os.walk.stream(os.pwd).foreach(println)                                                             |
            +-----------------------------------------------------------------------------------------------------+

        - Transforming Streams
            filter and map are combined
            +----------------------------------------------------------------------------------------------------------------------------------------------------------+
            | { os.read.lines.stream(os.pwd / ".gitignore").filter(_.startsWith(".")).map(_.drop(1)).toList } // List[String] = List("idea","settings","classpath",... |
            +----------------------------------------------------------------------------------------------------------------------------------------------------------+
            because of stream - read/filter/map occur one line at a time
            +----------------------------------------------------------------------------------------------------------------------------------------------+
            | os.read.lines.stream(os.pwd / ".gitignore").collect{case s".$str" => str}.toList    // List[String] = List("idea","settings","classpath",... |
            +----------------------------------------------------------------------------------------------------------------------------------------------+

    ### Folder Syncing
        - Walking the Filesystem
            +------------------------------------------------------------+
            | def sync(src: os.Path, dest: os.Path) = {                  |
            |     for (srcSubPath <- os.walk(src)) {                     |
            |     val subPath = srcSubPath.subRelativeTo(src)            |
            |     val destSubPath = dest / subPath                       |
            |     println((os.isDir(srcSubPath), os.isDir(destSubPath))) |
            |     }                                                      |
            | }                                                          |
            +------------------------------------------------------------+

        - Copying New Files Over
            +-----------------------------------------------------------------------------------------------------------+
            | def sync(src: os.Path, dest: os.Path) = {                                                                 |
            |     for (srcSubPath <- os.walk(src)) {                                                                    |
            |     val subPath = srcSubPath.subRelativeTo(src)                                                           |
            |     val destSubPath = dest / subPath                                                                      |
            |     (os.isDir(srcSubPath), os.isDir(destSubPath)) match {                                                 |
            |         case (false, true) | (true, false) => os.copy.over(srcSubPath, destSubPath, createFolders = true) |
            |         case _ => // do nothing                                                                           |
            |     }                                                                                                     |
            |     }                                                                                                     |
            | }                                                                                                         |
            +-----------------------------------------------------------------------------------------------------------+

        - Updating Files
            +--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
            | def sync(src: os.Path, dest: os.Path) = {                                                                                                                                                        |
            |     for (srcSubPath <- os.walk(src)) {                                                                                                                                                           |
            |         val subPath = srcSubPath.subRelativeTo(src)                                                                                                                                              |
            |         val destSubPath = dest / subPath                                                                                                                                                         |
            |         (os.isDir(srcSubPath), os.isDir(destSubPath)) match {                                                                                                                                    |
            |             case (false, true) | (true, false) => os.copy.over(srcSubPath, destSubPath, createFolders = true)                                                                                    |
            |             case (false, false) if !os.exists(destSubPath) || !os.read.bytes(srcSubPath).sameElements(os.read.bytes(destSubPath)) => os.copy.over(srcSubPath, destSubPath, createFolders = true) |
            |             case _ => // do nothing                                                                                                                                                              |
            |         }                                                                                                                                                                                        |
            |     }                                                                                                                                                                                            |
            | }                                                                                                                                                                                                |
            +--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

        - Testing Our File Syncer
            +------------------------------------------------------+
            | os.write(os.pwd / "post" / "ABC.txt", "Hello World") |
            | sync(os.pwd / "post", os.pwd / "post-copy")          |
            +------------------------------------------------------+

    ### Simple Subprocess Invocations
        +---------------------------------------------------------+
        | os.proc(command: os.Shellable*)                         |
        |     .call(cwd: Path = null,                             | // cwd to set the location of the subprocess's current working directory
        |         env: Map[String, String] = null,                |
        |         stdin: ProcessInput = os.Pipe,                  |
        |         stdout: ProcessOutput = os.Pipe,                |
        |         stderr: ProcessOutput = os.Inherit,             |
        |         mergeErrIntoOut: Boolean = false,               |     +--------------------------------------------------------------------------------------------------------+
        |         timeout: Long = Long.MaxValue,                  |     | val gitStatus = os.proc("git", "status").call() // gitStatus: os.CommandResult = CommandResult( 0, ... |
        |         check: Boolean = true,                          |     | gitStatus.exitCode  // res1: Int = 0                                                                   |
        |         propagateEnv: Boolean = true): os.CommandResult |     | gitStatus.out.text()    // "On branch master Your branch is up to date with origin/master.             |
        +---------------------------------------------------------+     +--------------------------------------------------------------------------------------------------------+

        - Use Case: remove non-current branches from a Git repo
            +------------------------------------------------------------------------------------+
            | def gitBranchLines = os.proc("git", "branch").call().out.lines()                   |
            | pprint.log(gitBranchLines)                                                         |
            | val otherBranches = gitBranchLines.collect{case s" $branchName" => branchName}     |
            | for (branch <- otherBranches) os.proc("git", "branch", "-D", branch).call()        |
            | pprint.log(otherBranches)                                                          |
            +------------------------------------------------------------------------------------+

        - Use Case: Curl to a local file
            +----------------------------------------------------------------+
            | val url = "https://api.github.com/repos/lihaoyi/mill/releases" |
            | os.proc("curl", url).call(stdout = os.pwd / "github.json")     |
            | os.proc("ls", "-lh", "github.json").call().out.text()          |  // res8: String = """-rw-r--r-- 1 lihaoyi staff 607K Jun 3 13:16 github.json
            +----------------------------------------------------------------+

        - Streaming Gzip
            +------------------------------------------------------------------------------------------+
            | os.proc("gzip").call(stdin = os.pwd / "github.json", stdout = os.pwd / "github.json.gz") |
            | os.proc("ls", "-lh", "github.json.gz").call().out.text()                                 |    // res10: String = """-rw-r--r-- 1 lihaoyi staff 23K Jun 3 13:30 github.json.gz
            +------------------------------------------------------------------------------------------+

    ### Interactive and Streaming Subprocesses

         os.proc.spawn is to spawn a long-lived worker process running concurrently with the host process
         one can interact with and preserve between interactions
        +-----------------------------------------------------------------------------------------+
        | val sub = os.proc("python", "-u", "-c", "while True: print(eval(raw_input()))").spawn() |
        +-----------------------------------------------------------------------------------------+
        +----------------------------------------------------+  +------------------------------------------------------+
        | sub.stdin.writeLine("1 + 2 + 4")                   |  | sub.stdin.writeLine("1 + 2 + 4")                     |
        | sub.stdin.flush()                                  |  | sub.stdin.flush()                                    |
        | sub.stdout.readLine()       // res14: String = "7" |  | sub.stdout.readLine()       // res17: String = "124" |
        +----------------------------------------------------+  +------------------------------------------------------+
        +------------------------------------------+
        | sub.isAlive()   //res18: Boolean = true  |
        | sub.destroy()                            |
        | sub.isAlive()   //res20: Boolean = false |
        +------------------------------------------+

        - Streaming distinct contributors in a Git repo history
        +---------------------------------------------------------------------------+
        | val gitLog = os.proc("git", "log").spawn()                                |
        | val grepAuthor = os.proc("grep", "Author: ").spawn(stdin = gitLog.stdout) |
        | val output = grepAuthor.stdout.lines().distinct                           |   // Vector[String] = Vector("Author: Li Haoyi","Author: Guillaume Galy","Author: Nik Vanderhoof",    
        +---------------------------------------------------------------------------+

        - Streaming Subprocess Pipelines
        +----------------------------------------------------------------------------------------------------------------------+
        | val download = os.proc("curl", "https://api.github.com/repos/lihaoyi/mill/releases").spawn()                         |
        | val upload = os.proc("curl", "-X", "PUT", "-d", "@-", "https://httpbin.org/anything").spawn(stdin = download.stdout) |
        | val contentLength = upload.stdout.lines().filter(_.contains("Content-Length"))                                       |    // contentLength: Vector[String] = Vector(" \"Content-Length\": \"609216\"
        +----------------------------------------------------------------------------------------------------------------------+
        with gzip
        +------------------------------------------------------------------------------------------------------------------+
        | val download = os.proc("curl", "https://api.github.com/repos/lihaoyi/mill/releases").spawn()                     |
        | val base64 = os.proc("base64").spawn(stdin = download.stdout)                                                    |
        | val gzip = os.proc("gzip").spawn(stdin = base64.stdout)                                                          |
        | val upload = os.proc("curl", "-X", "PUT", "-d", "@-", "https://httpbin.org/anything").spawn(stdin = gzip.stdout) |
        | val contentLength = upload.stdout.lines().filter(_.contains("Content-Length"))                                   |
        +------------------------------------------------------------------------------------------------------------------+
        
        com.lihaoyi::os-lib:0.7.1


####################
# JSON and Binary Data Serialization
####################
    ### Manipulating JSON
        +-------------------------------------------------------------+     // Arr(ArrayBuffer(Obj(LinkedHashMap(
        | val jsonString = os.read(os.pwd / "ammonite-releases.json") |     // "url" -> Str("https://api.github.com/repos/.../releases/17991367"),
        | val data = ujson.read(jsonString)                           |     // "assets_url" -> Str("https://api.github.com/repos/.../releases/17991367/assets"),
        +-------------------------------------------------------------+

        +-------------------------------------------------------------------------------------------------------------+
        | val small = ujson.Arr(ujson.Obj("hello" -> ujson.Str("world"), "answer" -> ujson.Num(42)),ujson.Bool(true)) |
        | val small = ujson.Arr(ujson.Obj("hello" -> "world", "answer" -> 42),true)                                   |
        | println(ujson.write(small))             // [{"hello":"world","answer":42},true]                             |
        | os.write(os.pwd / "out.json", small)                                                                        |
        | os.read(os.pwd / "out.json")            // "[{\hello\:\world\,\answer\:42},true]"                           |
        +-------------------------------------------------------------------------------------------------------------+

        - The ujson.Value Data Type
        +---------------------------------------------------------------------------+
        | sealed trait Value                                                        |
        | case class Str(value: String) extends Value                               |
        | case class Obj(value: mutable.LinkedHashMap[String, Value]) extends Value |
        | case class Arr(value: mutable.ArrayBuffer[Value]) extends Value           |
        | case class Num(value: Double) extends Value                               |
        | sealed trait Bool extends Value                                           |
        | case object False extends Bool                                            |
        | case object True extends Bool                                             |
        | case object Null extends Value                                            |
        +---------------------------------------------------------------------------+
        - Querying and Modifying JSON
        +-------------------------------------------------------------------------------------------------------------------------------------+
        | data(0)                 // ujson.Value = Obj(LinkedHashMap("url" -> Str("https://api.github.com/repos/.../releases/17991367"), ...  |
        | data(0)("url")          // ujson.Value = Str("https://api.github.com/repos/.../releases/17991367")                                  |
        | data(0)("author")("id") // ujson.Value = Num(2.0607116E7)                                                                           |
        +-------------------------------------------------------------------------------------------------------------------------------------+
         mutating
        +------------------------------------------------------------------------------------------------+
        | println(small)  // [{"hello":"world","answer":42},true]                                        |
        | small(0)("hello") = "goodbye"                                                                  |
        | small(0)("tags") = ujson.Arr("awesome", "yay", "wonderful")                                    |
        | println(small)  // [{"hello":"goodbye","answer":42,"tags":["awesome","yay","wonderful"]},true] |
        +------------------------------------------------------------------------------------------------+

        - Extracting Typed Values
        +----------------------------------------------------------------------------------+    +----------------------------------------------------------------------------------------------+
        | small(0).obj.remove("hello")                                                     |    | data(0)("url").str          // String = "https://api.github.com/repos/.../releases/17991367" |
        | small.arr.append(123)                                                            |    | data(0)("author")("id").num // Double = 2.0607116E7                                          |
        | println(small)  // [{"answer":42,"tags":["awesome","yay","wonderful"]},true,123] |    | data(0)("author")("id").num.toInt   // Int = 20607116                                        |
        +----------------------------------------------------------------------------------+    +----------------------------------------------------------------------------------------------+

        - Traversing JSON
        +-------------------------------------------------------------+ +------------------------------------------------------------------+
        | def traverse(v: ujson.Value): Iterable[String] = v match {  | | traverse(data)                                                   |
        |     case a: ujson.Arr => a.arr.map(traverse).flatten        | | res21: Iterable[String] = ArrayBuffer(                           |
        |     case o: ujson.Obj => o.obj.values.map(traverse).flatten | | "https://api.github.com/repos/.../releases/17991367",            |
        |     case s: ujson.Str => Seq(s.str)                         | | "https://api.github.com/repos/.../releases/17991367/assets",     |
        |     case _ => Nil                                           | | "https://uploads.github.com/repos/.../releases/17991367/assets", |
        | }                                                           | +------------------------------------------------------------------+
        +-------------------------------------------------------------+

    ### JSON Serialization of Scala Data Types
        - Serializing Scala Builtins
            Serializing values of type T is done by looking up implicit serializers of type ReadWriter[T]
            Implicit ReadWriters are already defined for most common Scala data types
            +------------------------------------------------------------------------------------------------------------------------------------------+
            | val numbers = upickle.default.read[Seq[Int]]("[1, 2, 3, 4]")                        // Seq[Int] = List(1, 2, 3, 4)                       |
            | upickle.default.write(numbers)                                                      // String = "[1,2,3,4]"                              |
            | val tuples = upickle.default.read[Seq[(Int, Boolean)]]("[[1, true], [2, false]]")   // Seq[(Int, Boolean)] = List((1, true), (2, false)) |
            | upickle.default.write(tuples)                                                       // String = "[[1,true],[2,false]]"                   |
            +------------------------------------------------------------------------------------------------------------------------------------------+
            Serialization is done via the Typeclass Inference technique and thus can work for arbitrarily deep nested data structures
            +---------------------------------------------------------------------------------------------------------------------------------------------------------------+
            | val input = """{"weasel": ["i", "am"], "baboon": ["i", "r"]}"""                                                                                               |
            | val parsed = upickle.default.read[Map[String, Seq[String]]](input)  // Map[String, Seq[String]] = Map("weasel" -> List("i", "am"),"baboon" -> List("i", "r")) |
            | upickle.default.write(parsed)                                       // String = "{\weasel\:[\i\,\am\],\baboon\:[\i\,\r\]}"                                    |
            +---------------------------------------------------------------------------------------------------------------------------------------------------------------+

        - Serializing Case Classes
            To convert a JSON structure into a case class           For every case class you want to serialize, you have to define an implicit upickle.default.ReadWriter
            +-----------------------------------------------------+ +-------------------------------------------------------------------------------------+
            | println(ujson.write(data(0)("author"), indent = 4)) | | case class Author(login: String, id: Int, site_admin: Boolean)                      |
            | {                                                   | | implicit val authorRW: upickle.default.ReadWriter[Author] = upickle.default.macroRW |
            |     "login": "Ammonite-Bot",                        | +-------------------------------------------------------------------------------------+
            |     "id": 20607116,                                 |
            |     "node_id": "MDQ6VXNlcjIwNjA3MTE2",              |
            |     "gravatar_id": "",                              |
            |     "type": "User",                                 |
            |     "site_admin": false,                            |
            | }                                                   |
            +-----------------------------------------------------+

            +---------------------------------------------------------------------------------------------------------------------------------------------------------+
            | val author = upickle.default.read[Author](data(0)("author")) // author: Author = Author("Ammonite-Bot", 20607116, false)                                |
            | author.login                                                // String = "Ammonite-Bot"                                                                  |
            | val author2 = upickle.default.read[Author]("""{"login": "lihaoyi", "id": 313373, "site_admin": true}""")    // Author = Author("lihaoyi", 313373, true) |
            | upickle.default.write(author2)                              // String = "{\login\:\lihaoyi\,\id\:313373,\site_admin\:true}"                             |
            +---------------------------------------------------------------------------------------------------------------------------------------------------------+
            Once you have defined a ReadWriter[Author], you can then also serialize and de-serialize Authors as part of any larger data structure:
            +--------------------------------------------------------------------+  // Map[String, Author] = Map(
            | upickle.default.read[Map[String, Author]]("""{                     |  //   "haoyi" -> Author("lihaoyi", 1337, true),
            | "haoyi": {"login": "lihaoyi", "id": 1337, "site_admin": true},     |  //   "bot" -> Author("ammonite-bot", 31337, false)
            | "bot": {"login": "ammonite-bot", "id": 31337, "site_admin": false} |  // )
            | }""")                                                              |
            +--------------------------------------------------------------------+

        - Mapped Serializers
            By default you cannot serialize os.Paths // upickle.default.write(os.pwd)
            - use the bimap function to construct a ReadWriter[os.Path] from the existing ReadWriter[String]
            +--------------------------------------------------------------------------+
            | implicit val pathRw = upickle.default.readwriter[String].bimap[os.Path]( |
            |     p => p.toString, /* convert os.Path to String */,                    |
            |     s => os.Path(s) /* convert String to os.Path */                      |
            | )                                                                        |
            +--------------------------------------------------------------------------+
            With this implicit val pathRw defined, we can now serialize and deserialize os.Paths
            +---------------------------------------------------------------------------------------------------------------------------------------+
            | val str = upickle.default.write(os.pwd) // String = "\/Users/lihaoyi/test\"                                                           |
            | upickle.default.read[os.Path](str)      // os.Path = /Users/lihaoyi/test                                                              |
            | val str2 = upickle.default.write(Array(os.pwd, os.home, os.root))   // String = "[\/Users/lihaoyi/test\,\/Users/lihaoyi\,\/\]"        |
            | upickle.default.read[Array[os.Path]](str2)                          // Array[os.Path] = Array(/Users/lihaoyi/test, /Users/lihaoyi, /) |
            +---------------------------------------------------------------------------------------------------------------------------------------+

    ### Writing your own Generic Serialization Methods
        - uPickle Context Bounds
        define methods that can serialize values of various types by making them generic with a context bound of Reader, Writer, or ReadWriter
        +-----------------------------------------+
        | def foo[T: upickle.default.Reader]:     | // allows use of upickle.default.read[T]
        | def foo[T: upickle.default.Writer]:     | // allows use of upickle.default.write[T]
        | def foo[T: upickle.default.ReadWriter]: | // allows use of both upickle.default.read[T] and upickle.default.write[T]
        +-----------------------------------------+
        equivalent to the
        +--------------------------------------------------------+
        | def foo[T](implicit reader: upickle.default.Reader[T]) |
        +--------------------------------------------------------+
        allows compiler to infer the parameter if it is not explicitly provided, and saves us the inconvenience of having to pass serializers around manually.

        - Generic Serialization Methods
        +--------------------------------------------------------------------------------------+    +--------------------------------------------------------------------------------------------------------------------+
        | case class Asset(id: Int, name: String)                                              |    | myPrintJson(Asset(1, "hello"))                              // {"id":1,"name":"hello"}                             |
        | implicit val assetRw = upickle.default.macroRW[Asset]                                |    | myPrintJson(Seq(1, 2, 3))                                   // [1,2,3]                                             |
        | def myPrintJson[T: upickle.default.Writer](t: T) = println(upickle.default.write(t)) |    | myPrintJson(Seq(Asset(1, "hello"), Asset(2, "goodbye")))    // [{"id":1,"name":"hello"},{"id":2,"name":"goodbye"}] |
        +--------------------------------------------------------------------------------------+    +--------------------------------------------------------------------------------------------------------------------+
        reads from console
        +------------------------------------------------------------------------------------------------------------------------------------------------+
        | def myReadJson[T: upickle.default.Reader](): T = {                                                                                             |
        |     print("Enter some JSON: ")                                                                                                                 |
        |     upickle.default.read[T](Console.in.readLine())                                                                                             |
        | }                                                                                                                                              |
        | myReadJson[Seq[Int]]()  // Enter some JSON: [1, 2, 3, 4, 5] // res49: Seq[Int] = List(1, 2, 3, 4, 5)                                           |
        | myReadJson[Author]()    // Enter some JSON: {"login": "Haoyi", "id": 1337, "site_admin": true}  // res50: Author = Author("Haoyi", 1337, true) |
        +------------------------------------------------------------------------------------------------------------------------------------------------+

        - Why Context Bounds?
        Performance with Convenience
            uPickle's serializers being resolved at compile time using Scala's implicits gives you the convenience of reflection-based frameworks with the performance of hand-written serialization code
        Compile-Time Error Reporting
            compiler is able to reject non-serializable data types early during compilation
        Security
            every upickle.default.read call has a statically-specified type, we will never deserialize a value of unexpected type

    ### Binary Serialization
        - writeBinary and readBinary
        +--------------------------------------------------------------------------------------------------------------------------------+
        | case class Author(login: String, id: Int, site_admin: Boolean)                                                                 |
        | implicit val authorRw = upickle.default.macroRW[Author]                                                                        |
        | val blob = upickle.default.writeBinary(Author("haoyi", 31337, true))    // blob: Array[Byte] = Array(-125, -91, 108, 111, ...) |
        | upickle.default.readBinary[Author](blob)                                // res54: Author = Author("haoyi", 31337, true)        |
        +--------------------------------------------------------------------------------------------------------------------------------+
        map serialization/deserialization
        +--------------------------------------------------------------------------------------------------+
        | val data = Map(                                                                                  |
        |     1 -> Nil,                                                                                    |
        |     2 -> List(Author("haoyi", 1337, true), Author("lihaoyi", 31337, true))                       |
        | )                                                                                                |
        | val blob2 = upickle.default.writeBinary(data)   // Array[Byte] = Array(-110, -110, 1, -112, ...) |
        | upickle.default.readBinary[Map[Int, List[Author]]](blob2)                                        |
        | Map[Int, List[Author]] = Map(                                                                    |
        |     1 -> List(),                                                                                 |
        |     2 -> List(Author("haoyi", 1337, true), Author("lihaoyi", 31337, true))                       |
        | )                                                                                                |
        +--------------------------------------------------------------------------------------------------+

        - MessagePack Structures
        +---------------------------------------+   +-------------------------------------------------------------+ +-------------------------------------------------------------------------------------------------------------------------+
        | @ upack.read(blob)                    |   | upack.read(blob2)                                           | | val msg = upack.Obj(                                                                                                    |
        | res58: upack.Msg = Obj(LinkedHashMap( |   | res59: upack.Msg = Arr(                                     | |     upack.Str("login") -> upack.Str("haoyi"),                                                                           |
        |     Str("login") -> Str("haoyi"),     |   | ArrayBuffer(Arr(ArrayBuffer(Int32(1), Arr(ArrayBuffer()))), | |     upack.Str("id") -> upack.Int32(31337),                                                                              |
        |     Str("id") -> Int32(31337),        |   | Arr(ArrayBuffer(Int32(2),Arr(ArrayBuffer(Obj(               | |     upack.Str("site_admin") -> upack.True                                                                               |
        |     Str("site_admin") -> True         |   | LinkedHashMap(                                              | | )                                                                                                                       |
        |     )                                 |   |     Str("login") -> Str("haoyi"),                           | | val blob3 = upack.write(msg)                                    // blob3: Array[Byte] = Array(-125, -91, 108, 111, ...) |
        | )                                     |   |     Str("id") -> Int32(1337),                               | | val deserialized = upickle.default.readBinary[Author](blob3)    // deserialized: Author = Author("haoyi", 31337, true)  |
        +---------------------------------------+   |     Str("site_admin") -> True                               | +-------------------------------------------------------------------------------------------------------------------------+
                                                    | )),                                                         |
                                                    +-------------------------------------------------------------+


####################
# Self-Contained Scala Scripts
####################
    ### Reading Files Off Disk
        +----------------------------------------------+
        | interp.watch(os.pwd / "post")                |    // optional
        | val postInfo = os                            |
        |     .list(os.pwd / "post")                   |    // list files in post
        |     .map{ p =>                               |
        |         val s"$prefix - $suffix.md" = p.last |    // split names on -
        |         (prefix, suffix, p)                  |    
        |     }                                        |
        |     .sortBy(_._1.toInt)                      |
        | println("POSTS")                             |
        | postInfo.foreach(println)                    |
        +----------------------------------------------+

    ### Rendering HTML with Scalatags
        +------------------------------------------------------------------+
        | import $ivy.`com.lihaoyi::scalatags:0.9.1`, scalatags.Text.all._ |    // $ivy specila REPL syntax to download dependency
        | interp.watch(os.pwd / "post")                                    |
        | val postInfo = os                                                |
        |     .list(os.pwd / "post")                                       |
        |     .map{ p =>                                                   |
        |         val s"$prefix - $suffix.md" = p.last                     |
        |         (prefix, suffix, p)                                      |
        |     }                                                            |
        |     .sortBy(_._1.toInt)                                          |
        | os.remove.all(os.pwd / "out")                                    |
        | os.makeDir.all(os.pwd / "out" / "post")                          |
        | os.write(                                                        |
        |     os.pwd / "out" / "index.html",                               |
        |     doctype("html")(                                             |
        |         html(                                                    |
        |             body(                                                |
        |                 h1("Blog"),                                      |
        |                 for ((_, suffix, _) <- postInfo)                 |
        |                 yield h2(suffix)                                 |
        |             )                                                    |
        |         )                                                        |
        |     )                                                            |
        | )                                                                |
        +------------------------------------------------------------------+

    ### Rendering Markdown with Commonmark-Java
        import $ivy.`com.atlassian.commonmark:commonmark:0.13.1`
        generic markdown texts:
        +------------------------------------+  +-----------------------------------------------------------------------------+ +--------------------------------------------------------------------------------+
        | Sometimes you want numbered lists: |  | # Structured documents                                                      | | There are many different ways to style code with GitHubs markdown. If you have |
        | 1. One                             |  | Sometimes its useful to have different levels of headings to structure your | | inline code blocks, wrap them in backticks: var example = true. If youve got   |
        | 2. Two                             |  | documents. Start lines with a # to create headings. Multiple ## in a row    | | a longer block of code, you can indent with four spaces:                       |
        | 3. Three                           |  | denote smaller heading sizes.                                               | |     if (isAwesome) {                                                           |
        +------------------------------------+  | ### This is a third-tier heading                                            | |         return true                                                            |
        +-----------------------------------+   +-----------------------------------------------------------------------------+ |     }                                                                          |
        | Sometimes you want bullet points: |                                                                                   +--------------------------------------------------------------------------------+
        | * Start a line with a star        |
        | * Profit!                         |
        +-----------------------------------+
        - Translating Java Snippets to Scala
        +------------------------------------------------------------------+        +----------------------------------------------------------------------------+
        | import org.commonmark.node.*;                                    |        | import .`com.atlassian.commonmark:commonmark:0.13.1`                       |
        | import org.commonmark.parser.Parser;                             |        | val parser = org.commonmark.parser.Parser.builder().build()                |
        | import org.commonmark.renderer.html.HtmlRenderer;                |        | val document = parser.parse("This is *Sparta*")                            |
        | Parser parser = Parser.builder().build();                        |    =>  | val renderer = org.commonmark.renderer.html.HtmlRenderer.builder().build() |
        | Node document = parser.parse("This is *Sparta*");                |        | val output = renderer.render(document)                                     |
        | HtmlRenderer renderer = HtmlRenderer.builder().build();          |        | output: String = """<p>This is <em>Sparta</em></p>                         |
        | renderer.render(document); // "<p>This is <em>Sparta</em></p>\n" |        | """                                                                        |
        +------------------------------------------------------------------+        +----------------------------------------------------------------------------+
        reading the .md files, transforming them into HTML and writing them into HTML files
        +--------------------------------------------------------------------------------+
        | import $ivy.`com.atlassian.commonmark:commonmark:0.13.1`                       |
        | def mdNameToHtml(name: String) = name.replace(" ", "-").toLowerCase + ".html"  |
        | for ((_, suffix, path) <- postInfo) {                                          |
        |     val parser = org.commonmark.parser.Parser.builder().build()                |
        |     val document = parser.parse(os.read(path))                                 |
        |     val renderer = org.commonmark.renderer.html.HtmlRenderer.builder().build() |
        |     val output = renderer.render(document)                                     |
        |     os.write(                                                                  |
        |         os.pwd / "out" / "post" / mdNameToHtml(suffix),                        |
        |         doctype("html")(                                                       |
        |             html(                                                              |
        |                 body(                                                          |
        |                     h1("Blog", " / ", suffix),                                 |
        |                     raw(output)                                                |
        |                 )                                                              |
        |             )                                                                  |
        |         )                                                                      |
        |     )                                                                          |
        | }                                                                              |
        +--------------------------------------------------------------------------------+

        - Testing our Java Markdown Parser
        +---------------------------------+
        | amm Blog.sc                     |
        | find out -type f                |
        | cat out/post/my-first-post.html |
        +---------------------------------+

    ### Links and Bootstrap
    ### Optionally Deploying the Static Site