####################
# pure functions
####################
    #rules
    -returns one value
    -calculates the return value based only on the arguments
    -doesn’t mutate any existing values
    
    #referential transparency
    you could substitute the function call, f(20), with its result, 19, without changing the program’s behavior
    
    # ShoppingCart
        v1                                                          v2                                              v3                                                          v4
        items, bookAdded - states                                   add remove method
        cart.getItems().remove("Book") - breaks code                cart.removeItem("Book") - breaks code
        fix: return new ArrayList<>(items)                          if we added 2 and removed 1
        +---------------------------------------------------+   =>  +---------------------------------------+   =>  +--------------------------------------------------+    =>  +--------------------------------------------------------------+
        | public class ShoppingCart {                       |       | public void removeItem(String item) { |       |public class ShoppingCart {                       |        | object ShoppingCartDiscounts {                               |
        |   private List<String> items = new ArrayList<>(); |       |   items.remove(item);                 |       |  private List<String> items = new ArrayList<>(); |        |     def getDiscountPercentage(items: List[String]): Int = {  |
        |   private boolean bookAdded = false;              |       |   if(item.equals(ôBookö)) {           |       |  public int addItem(String item) {               |        |         if (items.contains(Book)) {                          |
        |   public int addItem(String item) {               |       |     bookAdded = false;                |       |    items.add(item);                              |        |             5                                                |
        |     items.add(item);                              |       |   }                                   |       |  }                                               |        |         } else {                                             |
        |     if(item.equals(ôBookö)) {                     |       | }                                     |       |  public int getDiscountPercentage() {            |        |             0                                                |
        |       bookAdded = true;                           |       +---------------------------------------+       |    if(items.contains("Book")) {                  |        |         }                                                    |
        |     }                                             |                                                       |      return 5;                                   |        |     }                                                        |
        |   }                                               |                                                       |    } else {                                      |        | }                                                            |
        |   public int getDiscountPercentage() {            |                                                       |      return 0;                                   |        +--------------------------------------------------------------+
        |     if(bookAdded) {                               |                                                       |    }                                             |
        |       return 5;                                   |                                                       |  }                                               |
        |     } else {                                      |                                                       |  public List<String> getItems() {                |
        |       return 0;                                   |                                                       |    return new ArrayList<>(items);                |
        |     }                                             |                                                       |  }                                               |
        |   }                                               |                                                       |  public void removeItem(String item) {           |
        |   public List<String> getItems() {                |                                                       |    items.remove(item)                            |
        |     return items;                                 |                                                       |  }                                               |
        |   }                                               |                                                       |}                                                 |
        | }                                                 |                                                       +--------------------------------------------------+
        +---------------------------------------------------+
        - refactoring                                               - state as argument, pass copies of data, recalculate instead of storing
        +--------------------------------------------------+    =>  +--------------------------------------------------------------------+
        | class TipCalculator {                            |        | class TipCalculator {                                              |
        |   private val names = new util.ArrayList[AnyRef] |        |   public List<String> addPerson(List<String> names, String name) { |
        |   private var tipPercentage = 0                  |        |     List<String> updated = new ArrayList<>(names);                 |
        |   def addPerson(name: String): Unit = {          |        |     updated.add(name);                                             |
        |     names.add(name)                              |        |     return updated;                                                |
        |     if (names.size > 5) tipPercentage = 20       |        |   }                                                                |
        |     else if (names.size > 0) tipPercentage = 10  |        |   public static int getTipPercentage(List<String> names) {         |
        |   }                                              |        |     if(names.size() > 5) {                                         |
        |   def getNames: Nothing = names                  |        |       return 20;                                                   |
        |   def getTipPercentage: Int = tipPercentage      |        |     } else if(names.size() > 0) {                                  |
        | }                                                |        |       return 10;                                                   |
        +--------------------------------------------------+        |     } else return 0;                                               |
                                                                    |   }                                                                |
                                                                    | }                                                                  |
                                                                    +--------------------------------------------------------------------+


####################
# immutable values
####################
    -fight mutability by working with copies
    -pure function can mutate internal state
    # replan
    +-------------------------------------------------------------------------------------+
    | def replan(plan: List[String], newCity: String,beforeCity: String): List[String] = {|
    |      val beforeCityIndex = plan.indexOf(beforeCity)                                 |
    |      val citiesBefore = plan.slice(0, beforeCityIndex)                              |
    |      val citiesAfter = plan.slice(beforeCityIndex, plan.size)                       |
    |      citiesBefore.appended(newCity).appendedAll(citiesAfter)                        |
    |  }                                                                                  |
    +-------------------------------------------------------------------------------------+

    v1                                                                                          v2                                                                                                  v3
    - is mutable- is not mutating argument                                                      - making functions pure by mutating copies                                                          - encapsulation
    +------------------------------------------------------------------------------------+  =>  +--------------------------------------------------------------------------------------------+  =>  +---------------------------------------------------------+
    | static List<String> replan(List<String> plan, String newCity, String beforeCity) { |      | static List<String> replan(List<String> plan, String splitPoint, List<String> newEnding) { |      | private List<String> plan = new ArrayList<>();          |
    |   int newCityIndex = plan.indexOf(beforeCity);                                     |      |   int newCityIndex = plan.indexOf(beforeCity);                                             |      | public void replan(String newCity, String beforeCity) { |
    |   plan.add(newCityIndex, newCity);                                                 |      |   List<String> replanned = new ArrayList<>(plan);                                          |      |   int newCityIndex = plan.indexOf(beforeCity);          |
    |   return plan;                                                                     |      |   replanned.add(newCityIndex, newCity);                                                    |      |   plan.add(newCityIndex, newCity);                      |
    | }                                                                                  |      |   return replanned;                                                                        |      | }                                                       |
    +------------------------------------------------------------------------------------+      | }                                                                                          |      | public void add(String city) {                          |
                                                                                                +--------------------------------------------------------------------------------------------+      |   plan.add(city);                                       |
                                                                                                                                                                                                    | }                                                       |
                                                                                                                                                                                                    | public List<String> getPlan() {                         |
                                                                                                                                                                                                    |   return Collections.unmodifiableList(plan);            |
                                                                                                                                                                                                    | }                                                       |
####################                                                                                                                                                                                +---------------------------------------------------------+
# functions as values
####################
    # rankedWords -  rank the words by the number of letters different than a
    v1                                                          v2 - with streams, bad - scoreComparator defined elsewhere  v3 - 
    +------------------------------------------------------+    +------------------------------------------------------+    +-------------------------------------------------------------------------------------+
    |static int score(String word) {                       |    |static List<String> rankedWords(List<String> words) { |    |static List<String> rankedWords(Comparator<String> comparator, List<String> words) { |
    |  return word.replaceAll("a", "").length();           |    |  return words.stream()                               |    |  return words.stream()                                                              |
    |}                                                     |    |    .sorted(scoreComparator)                          |    |    .sorted(comparator)                                                              |
    |Comparator<String> scoreComparator =                  |    |    .collect(Collectors.toList());                    |    |    .collect(Collectors.toList());                                                   |
    |  new Comparator<String>() {                          |    |}                                                     |    |}                                                                                    |
    |    public int compare(String w1, String w2) {        |    +------------------------------------------------------+    +-------------------------------------------------------------------------------------+
    |      return Integer.compare(score(w2), score(w1));   |
    |    }                                                 |
    |  };                                                  |
    |static List<String> rankedWords(List<String> words) { |
    |  words.sort(scoreComparator);                        |
    |  return words;                                       |
    |}                                                     |
    +------------------------------------------------------+

    - changing requirments - bonus score of 5 needs to be added to the score if the word contains a 'c'
    v4                                                          v5                                                                  v6
    duplication in scoreWithBonusComparator & scoreComparator   - pass a function, comparator creates inside                        - score,bonus,penalty
    +-----------------------------------------------+           +--------------------------------------------------------------+    +--------------------------------------------------------------+
    |static int scoreWithBonus(String word) {       |           |List<String> rankedWords(Function<String, Integer> wordScore, |    |   static int bonus(String word) {                            |
    |  int base = score(word);                      |           |  List<String> words) {                                       |    |     return word.contains(ôcö) ? 5 : 0;                       |
    |  if (word.contains("c")) return base + 5;     |           |  Comparator<String> wordComparator =                         |    |   }                                                          |
    |  else return base;                            |           |    (w1, w2) -> Integer.compare(                              |    |   static int penalty(String word) {                          |
    |}                                              |           |      wordScore.apply(w2),                                    |    |     return word.contains(ôsö) ? 7 : 0;                       |
    |Comparator<String> scoreWithBonusComparator =  |           |      wordScore.apply(w1)                                     |    |   }                                                          |
    |  new Comparator<String>() {                   |           |    );                                                        |    |   rankedWords(w -> score(w) + bonus(w) - penalty(w), words); |
    |    public int compare(String w1, String w2) { |           |  return words                                                |    +--------------------------------------------------------------+
    |      return Integer.compare(                  |           |    .stream()                                                 |
    |        scoreWithBonus(w2),                    |           |    .sorted(wordComparator)                                   |
    |        scoreWithBonus(w1));                   |           |    .collect(Collectors.toList());                            |
    |    }                                          |           |}                                                             |
    |  };                                           |           |rankedWords(w -> score(w), words);                            |
    |rankedWords(scoreWithBonusComparator, words);  |           |rankedWords(w -> scoreWithBonus(w), words);                   |
    +-----------------------------------------------+           +--------------------------------------------------------------+
    - implemented in Scala                                                                  - passing functions inline
    +----------------------------------------------------------------------------------+    +-----------------------------------------------+
    | def rankedWords(wordScore: String => Int, words: List[String]): List[String] = { |    | def score(word: String): Int =                |
    |     words.sortBy(wordScore).reverse                                              |    |     word.replaceAll(a, ).length               |
    | }                                                                                |    | def bonus(word: String): Int =                |
    | def score(word: String): Int = word.replaceAll(a, ).length                       |    |     if (word.contains(c)) 5 else 0            |
    | rankedWords(score, words)                                                        |    | rankedWords(w => score(w) + bonus(w), words); |
    | List(haskell, rust, scala, java, ada)                                            |    | List(scala, haskell, rust, java, ada)         |
    +----------------------------------------------------------------------------------+    +-----------------------------------------------+

    ----------
    - map
    ----------
    List[A].map(f: A => B): List[B]
    # wordScores using map
    +------------------------------------------------------------------------------+    +--------------------------------------+
    | def wordScores(wordScore: String => Int, words: List[String]): List[Int] = { |    |     def penalty(word: String): Int = |
    |     words.map(wordScore)                                                     |    |         if (word.contains(s)) 7      |
    | }                                                                            |    |     else 0                           |
    | wordScores(w => score(w) + bonus(w) - penalty(w), words)                     |    +--------------------------------------+
    +------------------------------------------------------------------------------+    

    ----------
    - filter
    ----------
    +---------------------------------------------------------------------------------------+
    | def highScoringWords(wordScore: String => Int, words: List[String]): List[String] = { |   // returning only elements that satisfied this condition
    |     words.filter(word => wordScore(word) > 1)                                         |   // how do we parametrize 1 ?
    | }                                                                                     |
    +---------------------------------------------------------------------------------------+

    ----------
    - return functions
    ----------
    +----------------------------------------------------------------------------------------------+
    | def highScoringWords(wordScore: String => Int, words: List[String]): Int => List[String] = { |
    |     higherThan => words.filter(word => wordScore(word) > higherThan)                         |
    | }                                                                                            |
    +----------------------------------------------------------------------------------------------+
    - using return function
    +--------------------------------------------------------------------------------------------------------------------+
    | val wordsWithScoreHigherThan: Int => List[String] = highScoringWords(w => score(w) + bonus(w) - penalty(w), words) |
    | wordsWithScoreHigherThan(1)                                                                                        |
    |   List(java)                                                                                                       |
    | wordsWithScoreHigherThan(0)                                                                                        |
    |   List(ada, scala, java                                                                                            |
    +--------------------------------------------------------------------------------------------------------------------+

    ----------
    - return functions from returned functions
    ----------

    we can replace def 3 param function
        +------------------------------------------------------------------------------------------------+
        | highScoringWords(wordScore: String => Int, words: List[String], higherThan: Int): List[String] |
        +------------------------------------------------------------------------------------------------+
    with 2 param function that returns 1 param function
        +------------------------------------------------------------------------------------------+
        | def highScoringWords(wordScore: String => Int words: List[String]): Int => List[String]  |
        +------------------------------------------------------------------------------------------+    
    then
    we can replace 2 param function
        +------------------------------------------------------------------------------------------+
        | def highScoringWords(wordScore: String => Int words: List[String]): Int => List[String]  |
        +------------------------------------------------------------------------------------------+    
    with 1 param function
        +-----------------------------------------------------------------------------------------+
        | def highScoringWords(wordScore: String => Int): Int => List[String] => List[String] = { | // reutns a function which takes Int and returns a function which takes List[String] and returns List[String]
        |     higherThan => words => words.filter(word => wordScore(word) > higherThan)           |
        | }                                                                                       |
        +-----------------------------------------------------------------------------------------+
    usage:
        +-----------------------------------------------------------------------------------------------------------------------------+
        | val wordsWithScoreHigherThan: Int => List[String] => List[String] = highScoringWords(w => score(w) + bonus(w) - penalty(w)) |
        | wordsWithScoreHigherThan(1)(words)                                                                                          |
        |   List(java)                                                                                                                |
        | wordsWithScoreHigherThan(0)(words2)                                                                                         |
        |   List(football, f1, hockey, basketball)                                                                                    |
        | wordsWithScoreHigherThan(5)(words2)                                                                                         |
        |   List(football, hockey)                                                                                                    |
        +-----------------------------------------------------------------------------------------------------------------------------+

    ----------
    - Currying
    ----------
    Transforming multiple-parameter functions into a series of 1-parameter functions returned from each other is called currying.
    +----------------------------+  +-------------------------------------------------+
    | def f(a: A, b: B, c: C): D |  | def largerThan(n: Int)(i: Int): Boolean = i > n |
    | def f(a: A): B => C => D   |  | List(5, 1, 2, 4, 0).filter(largerThan(4))       |
    | def f(a: A)(b: B)(c: C): D |  +-------------------------------------------------+
    +----------------------------+

    ----------
    - foldLeft
    ----------
    List[A].foldLeft(z: B)(f: (B, A) => B): B
    foldLeft accumulates a value by going through all elements of the list and calling the provided function
    +-----------------------------------------------------------------+
    | words.foldLeft(0)((total, word) => total + wordScore(word))     |
    +-----------------------------------------------------------------+

    ----------
    - case classes
    ----------
    +---------------------------------------------------------+
    | case class ProgrammingLanguage(name: String, year: Int) |
    | ProgrammingLanguage("Java", 1995)                       |
    | java.name                                               |
    +---------------------------------------------------------+



--------------------
| sequential programs
--------------------
                                                                        - how many have word Scala
    +---------------------------------------------------------------+   +-----------------------------------------------------------------------------+
    | case class Book(title: String, authors: List[String])         |   | books.map(book => book.title).filter(title => title.contains("Scala")).size |
    |                                                               |   +-----------------------------------------------------------------------------+
    | val books = List(                                             |
    |     Book(FP in Scala, List(Chiusano, Bjarnason)),             |
    |     Book(The Hobbit, List(Tolkien)),                          |
    |     Book(Java 8 in Action, List(Urma, Fusco, Mycroft)         |
    | )                                                             |
    +---------------------------------------------------------------+

    # book adaptations
        1. for each book take author
        2. for each author run bookAdaptations returning movies
        3. for each movie construct a recommendation feed string
        +-------------------------------------------------------+
        | case class Book(title: String, authors: List[String]) |
        | case class Movie(title: String)                       |
        |                                                       |
        | val books = List(                                     |
        |     Book(FP in Scala, List(Chiusano, Bjarnason)),     |
        |     Book(The Hobbit, List(Tolkien)))                  |
        |                                                       |
        | def bookAdaptations(author: String): List[Movie] =    |
        |     if (author == Tolkien)                            |
        |         List(Movie(An Unexpected Journey),            |
        |             Movie(The Desolation of Smaug))           |
        | else List.empty                                       |
        +-------------------------------------------------------+

        -imperative approach
        bad:
            mutable list return
            nesting for
            statemnts in for instead of expressions
        +-----------------------------------------------------------+
        |static List<String> recommendationFeed(List<Book> books) { |
        |  List<String> result = new ArrayList<>();                 |
        |  for (Book book : books)                                  |
        |    for (String author : book.authors)                     |
        |      for (Movie movie : bookAdaptations(author)) {        |
        |        result.add(movie.title, author, book.title);       |
        |  }                                                        |
        |  return result;                                           |
        |}                                                          |
        +-----------------------------------------------------------+

        +---------
        | flatMap
        +---------
            flatMap not only can change the type of the list (e.g. from Book to String), but also can change the size of the resulting list, which isn’t possible with map
        1. for each book take author
            +----------------------------------------------------+
            | books.map(book => book.authors)                    |
            |     List(List(Chiusano, Bjarnason), List(Tolkien)) |  // need to fix
            +----------------------------------------------------+
            - flatten goes through the list of lists and takes all elements from the first list, then second, and so on...

            +----------------------------------------------------+
            | books.map(book => book.authors).flatten            |  // fix
            |     List(Chiusano, Bjarnason, Tolkien)             |
            +----------------------------------------------------+
            or
            +----------------------------------------------------+
            | books.flatMap(book => book.authors)                |
            |     List(Chiusano, Bjarnason, Tolkien)             |
            +----------------------------------------------------+

        2. for each author run bookAdaptations returning movies
            +---------------------------------------------+
            | books.flatMap(book => book.authors)         |
            | .flatMap(author => bookAdaptations(author)) |
            |                                             |
            | List(Movie(An Unexpected Journey),          |
            |      Movie(The Desolation of Smaug))        |
            +---------------------------------------------+
        - flatMap can change the type and size of returned list                     flatten
            map on 3 elements results in 3 lists                                    goes through each list and extracts elements to new list
            +-----------------------------------------------------------------+     +------------------------------------------+
            | val movieLists = authors.map(author => bookAdaptations(author)) |     | movieLists.flatten                       |
            | List(List.empty,                                                |     |     List(Movie(An Unexpected Journey),   |
            |      List.empty,                                                |     |          Movie(The Desolation of Smaug)) |
            |      List(Movie(An Unexpected Journey),                         |     +------------------------------------------+
            |           Movie(The Desolation of Smaug))))                     |
            +-----------------------------------------------------------------+

            +---------------------------------------------+
            | List(1, 2, 3).flatMap(i => List(i, i + 10)) | // List(1,11,2,12,3,13)
            +---------------------------------------------+

    - List signatures:
        +----------------------------------------------+
        | def map(f: A => B): List[B]                  |
        | def flatten: List[B] // A needs to be a List |
        | def flatMap(f: A => List[B]): List[B]        |
        +----------------------------------------------+

    +---------
    | Chained flatMaps & maps
    +---------
        3. for each movie construct a recommendation feed string
        - use nested flatMap
        - flatMap always returns a List
        - we wouldn’t be able to transform chained maps into nested maps, because we don’t have the guarantee that it returns a List, no matter what function we pass.
        +------------------------------------------------+
        | books.flatMap(book => {                        |
        |     book.authors.flatMap(author => {           |
        |         bookAdaptations(author).map(movie => { |
        |             // access to book, author, movie   |
        |         }                                      |
        |     }                                          |
        | }                                              |
        +------------------------------------------------+

    +---------
    | for comprehension
    +---------
        - or each element x in xs and for each element y in ys, call the function doSomething(x, y)
        - expression after yield defines result of whole expression
        - result is list of type which dictated by yields
            +-------------------------------------------------+
            | for {                                           |
            |     x <- xs                                     |
            |     y <- ys                                     |
            | } yield doSomething(x, y)                       |
            | transormed into                                 |
            | xs.flatMap(x => ys.map(y => doSomething(x, y))) |
            +-------------------------------------------------+

        - full solution
            +-------------------------------------------------+
            | for {                                           |
            |     book <- books                               |
            |     author <- book.authors                      |
            |     movie <- bookAdaptations(author)            |
            | } yield sYou may like ${movie.title},  +        |
            | sbecause you liked $authors ${book.title}       |
            |     -> List(You may like An Unexpected Journey, |
            |     because you liked Tolkiens The Hobbit,      |
            |     You may like The Desolation of Smaug,       |
            |     because you liked Tolkiens The Hobbit))     |
            +-------------------------------------------------+

        - for gurad expressions                             - using filter
            +-------------------------------------------+   +-------------------------------------------------+ +--------------------------------------------+
            | for {                                     |   | for {                                           | | for {                                      |
            |     r <- radiuses                         |   |     r <- radiuses                               | |     r <- radiuses                          |
            |     point <- points if isInside(point, r) |   |     point <- points.filter(p => isInside(p, r)) | |     point <- points                        |
            | } yield s$point is within a radius of $r  |   | } yield s"$point is within a radius of $r"      | |     if isInside(point, r)                  |
            +-------------------------------------------+   +-------------------------------------------------+ | } yield s" $point is within a radius of $r"|
                                                                                                                +--------------------------------------------+


    +---------
    | Comparing map, foldLeft and flatMap
    +---------
        +-------------------------------------------+
        | List[A].map(f: A => B): List[B]           |   // applies function passed as f to each element of the original list, producing a new list with modified elements        
        | List[A].foldLeft(z: B)(f: (B, A) => B): B |   // accumulates a value of type B by applying the function passed as f to each element of the original list (A) and current accumulator value (B).
        | List[A].flatMap(f: A => List[B]): List[B] |   // applies the function passed as f to each element of the original list—producing n lists which are joined in the same order as the elements they originated from.
        +-------------------------------------------+

    +---------
    | parsing as pipeline
    +---------

        +------------------------------------------------------+
        | case class Event(name: String, start: Int, end: Int) |
        +------------------------------------------------------+
        v1                                                          v2
        bad:
            All the concerns are entangled in one line of code
            has nulls
        +--------------------------------------------------------+  +------------------------------------------------------------------+
        | def parse(name: String, start: Int, end: Int): Event = |  | def parse(name: String, start: Int, end: Int): Option[Event] = { |
        |     if (name.size > 0 && end < 3000 & start <= end)    |  |     if (name.size > 0 && end < 3000 & start <= end)              |
        |         Event(name, start, end)                        |  |         Some(Event(name, start, end))                            |
        |     else                                               |  |     else                                                         |
        |         null                                           |  |         None                                                     |
        | parse("Apollo Program", 1961, 1972)                    |  | }                                                                |
        | Event("Apollo Program", 1961, 1972))                   |  +------------------------------------------------------------------+
        | parse("", 1939, 1945)                                  |
        | null                                                   |
        +--------------------------------------------------------+
        v3
        +----------------------------------------------------------------+
        | def validateName(name: String): Option[String] =               |
        |     if (name.size > 0) Some(name) else None                    |
        | def validateEnd(end: Int): Option[Int] =                       |
        |     if (end < 3000) Some(end) else None                        |
        | def validateStart(start: Int, end: Int): Option[Int] =         |
        |     if (start <= end) Some(start) else None                    |
        |                                                                |
        | def parse(name: String, start: Int, end: Int): Option[Event] = |
        |     for {                                                      |
        |     validName <- validateName(name)                            |
        |     validEnd <- validateEnd(end)                               |
        |     validStart <- validateStart(start, end)                    |
        |     } yield Event(validName, validStart, validEnd)             |
        | parse("Apollo Program", 1961, 1972)                            |
        | Some(Event("Apollo Program", 1961, 1972)))                     |
        +----------------------------------------------------------------+

--------------------
| error handling
--------------------
    - Task to sort tv shows which arrive in string as:
        List("Breaking Bad (2008-2013)",
             "The Wire (2002-2008)",
             "Mad Men (2007-2015)")
    +---------------------------------------------------------------+
    | case class TvShow(title: String, start: Int, end: Int)        |
    |                                                               |
    | def sortShows(shows: List[TvShow]): List[TvShow]              |
    |                                                               |
    | def sortShows(shows: List[TvShow]): List[TvShow] = {          |
    |     shows.sortBy(tvShow => tvShow.end - tvShow.start).reverse |
    | }                                                             |
    +---------------------------------------------------------------+

    - need to develop a parse functions
    - parsing all is poarsing one
    +----------------------------------------------------------+
    | def parseShows(rawShows: List[String]): List[TvShow] = { |
    |     rawShows.map(parseShow)                              |
    | }                                                        |
    | def parseShow(rawShow: String): TvShow                   |
    +----------------------------------------------------------+

    - parseShow
    v1                                                                                  v2                                              
    bad:                                                                                catch ex and return null                        
        function lies - "Breaking Bad, 2008-2013" - will give exception
    +--------------------------------------------------------------------------------+  +---------------------------------------+
    | def parseShow(rawShow: String): TvShow = {                                     |  | try {                                 |
    |     val bracketOpen = rawShow.indexOf("(")                                     |  |     return parseShow(invalidRawShow); |
    |     val bracketClose = rawShow.indexOf(")")                                    |  | } catch(Exception e) {                |
    |     val dash = rawShow.indexOf("-")                                            |  |     return null;                      |
    |     val name = rawShow.substring(0, bracketOpen).trim                          |  | }                                     |
    |     val yearStart = Integer.parseInt(rawShow.substring(bracketOpen + 1, dash)) |  +---------------------------------------+
    |     val yearEnd = Integer.parseInt(rawShow.substring(dash + 1, bracketClose))  |  - would need to do this later
    |     TvShow(name, yearStart, yearEnd)                                           |  +------------------------------------------+
    | }                                                                              |  | TvShow show = parseShow(invalidRawShow); |
    +--------------------------------------------------------------------------------+  | if(show != null) {                       |
                                                                                        |     // do more things with the show      |
                                                                                        | }                                        |
                                                                                        +------------------------------------------+

    v3
    use options instead
    Pure functions should not throw exceptions
    - If any step returns None, the whole for comprehension will be None
    +----------------------------------------------------+  +----------------------------------------------------+  +-----------------------------------------------------------------------+   +---------------------------------------------------------------------+
    | def parseShow(rawShow: String): Option[TvShow] = { |  | def extractName(rawShow: String): Option[String]   |  | def extractYearStart(rawShow: String): Option[Int] = {                |   | def extractYearStart(rawShow: String): Option[Int] = {              |
    |     for {                                          |  | def extractYearStart(rawShow: String): Option[Int] |  |     val bracketOpen = rawShow.indexOf(()                              |   |     val bracketOpen = rawShow.indexOf("(")                          |
    |         name <- extractName(rawShow)               |  | def extractYearEnd(rawShow: String): Option[Int]   |  |     val dash = rawShow.indexOf(-)                                     |   |     val dash = rawShow.indexOf("-")                                 |
    |         yearStart <- extractYearStart(rawShow)     |  +----------------------------------------------------+  |     val yearStrOpt = if (bracketOpen != -1 && dash > bracketOpen + 1) |   |     for {                                                           |
    |         yearEnd <- extractYearEnd(rawShow)         |                                                          |         Some(rawShow.substring(bracketOpen + 1, dash))                |   |         yearStr <- if (bracketOpen != -1 && dash > bracketOpen + 1) |
    |     }                                              |  Each functions need to return an Option                 |     else None                                                         |   |                     Some(rawShow.substring(bracketOpen + 1, dash))  |
    |     yield TvShow(name, yearStart, yearEnd)         |                                                          |     yearStrOpt.map(yearStr => yearStr.toIntOption).flatten            |   |                    else None                                        |
    | }                                                  |                                                          | }                                                                     |   |         year <- yearStr.toIntOption                                 |
    +----------------------------------------------------+                                                          | extractYearStart(rawShow).orElse(extractSingleYear(rawShow))          |   |         } yield year}                                               |
                                                                                                                    +-----------------------------------------------------------------------+   +---------------------------------------------------------------------+
                                                            translates to                                                   pass "Mad Men (-2015)", yearsStart is None - whole expression is None
    +----------------------------------------------------+  +----------------------------------------------------------+    +------------------------------------------------------+
    | def parseShow(rawShow: String): Option[TvShow] = { |  | def parseShow(rawShow: String): Option[TvShow] = {       |    | def parseShow(rawShow: String): Option[TvShow] = {   |
    |     for {                                          |  |     extractName(rawShow).flatMap(name => {               |    |     Some(Mad Men).flatMap(name => {                  |
    |         name <- extractName(rawShow)               |  |         extractYearStart(rawShow).flatMap(yearStart => { |    |         None.flatMap(yearStart => {                  |
    |         yearStart <- extractYearStart(rawShow)     |  |             extractYearEnd(rawShow).map(yearEnd => {     |    |             extractYearEnd(rawShow).map(yearEnd => { |
    |         yearEnd <- extractYearEnd(rawShow)         |  |                 TvShow(name, yearStart, yearEnd)}}}}     |    |                 TvShow(name, yearStart, yearEnd)}}}  |
    |     } yield TvShow(name, yearStart, yearEnd)       |  +----------------------------------------------------------+    +------------------------------------------------------+
    | }                                                  |
    +----------------------------------------------------+

    - exception recovery
        Checked exceptions dont compose—Options do                                          vs
    +-----------------------------------------------------------------------------------+   +---------------------------------------------+
    | def parseShow(rawShow: String): Option[TvShow] = {                                |   | Integer yearStart = null;                   |
    |     for {                                                                         |   | try {                                       |
    |         name <- extractName(rawShow)                                              |   |     yearStart = extractYearStart(rawShow);  |
    |         yearStart <- extractYearStart(rawShow).orElse(extractSingleYear(rawShow)) |   | } catch(Exception e) {                      |
    |         yearEnd <- extractYearEnd(rawShow).orElse(extractSingleYear(rawShow))     |   |     yearStart = extractSingleYear(rawShow); |
    |     } yield TvShow(name, yearStart, yearEnd)                                      |   | }                                           |
    | }                                                                                 |   +---------------------------------------------+
    +-----------------------------------------------------------------------------------+

    - Two different error handling strategies                               
        - best-effort error handling                                        - All-or-nothing error handling
        try to parse every show - return only valid ones                    try to parse all TV show only if all are valid
        may be frustrating if we get only some shows from input             val resSome = addOrResign(initialResult, Some("new"))                       // Some(List(new))
        parseShows(List(“Chernobyl [2019]”, “Breaking Bad (2008-2013)”))    val resNone = addOrResign(initialResult, None)                              // None
            -List(TvShow(“Breaking Bad”, 2008, 2013))                       val resNone2 = List(Some("new"), None).foldLeft(initialResult)(addOrResign) // None
        +----------------------------------------------------------+        +------------------------------------------------------------------+    +-------------------------------------------------------------------------------------------------------------+
        | def parseShows(rawShows: List[String]): List[TvShow] = { |        | def parseShows(rawShows: List[String]): Option[List[TvShow]] = { |    | def addOrResign(parsedShows: Option[List[TvShow]], newParsedShow: Option[TvShow]): Option[List[TvShow]] = { |
        |     rawShows // List[String]                             |        |     val initialResult: Option[List[TvShow]] = Some(List.empty)   |    |     for {                                                                                                   |
        |         .map(parseShow) // List[Option[TvShow]]          |        |     rawShows                                                     |    |         shows <- parsedShows                                                                                |
        |         .map(_.toList) // List[List[TvShow]]             |        |     .map(parseShow)                                              |    |         parsedShow <- newParsedShow                                                                         |
        |         .flatten // List[TvShow]                         |        |     .foldLeft(initialResult)(addOrResign)                        |    |     } yield shows.appended(parsedShow)                                                                      |
        | }                                                        |        | }                                                                |    | }                                                                                                           |
        +----------------------------------------------------------+        +------------------------------------------------------------------+    +-------------------------------------------------------------------------------------------------------------+

    +---------
    | Either
    +---------    

    +----------------------------------------------------+  +-----------------------------------------------------------------------------------+
    | def f(rawShow: String): Either[String, String] = { |  | def parseShow(rawShow: String): Either[String, TvShow] = {                        |
    |     val bracket = rawShow.indexOf( ( )             |  |     for {                                                                         |
    |     if (bracketOpen > 0) {                         |  |         name <- extractName(rawShow)                                              |
    |         Right(rawShow.substring(0, bracket).trim)) |  |         yearStart <- extractYearStart(rawShow).orElse(extractSingleYear(rawShow)) |
    |     else {                                         |  |         yearEnd <- extractYearEnd(rawShow).orElse(extractSingleYear(rawShow))     |
    |         Left(s  Cant extract name from $rawShow )  |  |     }                                                                             |
    |     }                                              |  |     yield TvShow(name, yearStart, yearEnd)                                        |
    | }                                                  |  | }                                                                                 |
    +----------------------------------------------------+  +-----------------------------------------------------------------------------------+


    - working with Options                   working with Either
    val year: Option[Int] = Some(996)
    val noYear: Option[Int] = None
    +----------------------------------+    +---------------------------------------------+
    | year.map(_ * 2))                 |    | year.map(_ * 2)                             |
    |     Some(1992)                   |    |     Right(1992)                             |
    | noYear.map(_ * 2)                |    | noYear.map(_ * 2)                           |
    |     None                         |    |     Left( no year )                         |
    | Some(year).flatten               |    | Right(year).flatten                         |
    |     Some(996)                    |    |     Right(996)                              |
    | Some(noYear).flatten             |    | Right(noYear).flatten                       |
    |     None                         |    |     Left( no year )                         |
    | year.flatMap(y => Some(y * 2))   |    | year.flatMap(y => Right(y * 2))             |
    |     Some(1992)                   |    |     Right(1992)                             |
    | noYear.flatMap(y => Some(y * 2)) |    | noYear.flatMap(y => Right(y * 2))           |
    |     None                         |    |     Left( no year )                         |
    | year.flatMap(y => None)          |    | year.flatMap(y => Left( can t progress ))   |
    |     None                         |    |     Left( can t progress )                  |
    | noYear.flatMap(y => None)        |    | noYear.flatMap(y => Left( can t progress )) |
    |     None                         |    |     Left( no year )                         |
    | year.orElse(Some(2020))          |    | year.orElse(Right(2020))                    |
    |     Some(996)                    |    |     Right(996)                              |
    | noYear.orElse(Some(2020))        |    | noYear.orElse(Right(2020))                  |
    |     Some(2020)                   |    |     Right(2020)                             |
    | year.orElse(None)                |    | year.orElse(Left( cant recover ))           |
    |     Some(996)                    |    |     Right(996)                              |
    | noYear.orElse(None)              |    | noYear.orElse(Left( can t recover ))        |
    |     None                         |    |     Left( can t recover )                   |
    | year.toRight(no year given)      |    | year.toOption                               |
    |     Right(996)                   |    |     Some(996)                               |
    | noYear.toRight(no year given)    |    | noYear.toOption                             |
    |     Left(no year given)          |    |     None                                    |
    | year.forall(_ == 996)            |    +---------------------------------------------+
    |     true                         |
    | noYear.forall(_ == 996)          |
    |     true // non intuitive        |    // if this represents a value, check if it satisfies the given condition, if there is no value, ignore the condition
    +----------------------------------+

    
--------------------
| requirements as types
--------------------
    
    +--------------------------------------------------------------------------------------------------------------------------------+
    | case class Artist(name: String, genre: String, origin: String, yearsActiveStart: Int, isActive: Boolean, yearsActiveEnd: Int)) |
    +--------------------------------------------------------------------------------------------------------------------------------+

    +------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    | def searchArtists(artists: List[Artist], genres: List[String], locations: List[String], searchByActiveYears: Boolean, activeAfter: Int, activeBefore: Int): List[Artist] = { |
    |   artists.filter(artist =>                                                                                                                                                   |
    |     (genres.isEmpty || genres.contains(artist.genre)) &&                                                                                                                     |
    |       (locations.isEmpty || locations.contains(artist.origin)) &&                                                                                                            |
    |       (!searchByActiveYears || (                                                                                                                                             |
    |         (artist.isActive || artist.yearsActiveEnd >= activeAfter) &&                                                                                                         |
    |           (artist.yearsActiveStart <= activeBefore))))}                                                                                                                      |
    +------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    - Problems:
        -Programmers need to be careful about the order of parameters
        -Programmers need to know additional meaning of parameter combinations
        -Programmers need to ensure that some parameters have finite set of values
        -Programmers need to come up with, understand and convey additional meanings to raw types
        -Programmers need to remember that some parameters only make sense when used together

    - value classes
        +--------------------------------------------------+    // Location("U.S.")
        | case class Location(name: String) extends AnyVal |    // extends AnyVal we state that Location type is only checked in the compile time,
        +--------------------------------------------------+    // but still is treated as an unwrapped String in the runtime!

    - option type
        +----------------------------------------+  // represent one logical entity         +------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
        | isActive: Boolean, yearsActiveEnd: Int |  // yearsActiveEnd: Option[Int]          | def searchArtists(artists: List[Artist], genres: List[String], locations: List[String], searchByActiveYears: Boolean, activeAfter: Int, activeBefore: Int): List[Artist] = { |
        +----------------------------------------+                                          |   artists.filter(artist =>                                                                                                                                                   |
        updated                                                                             |     (genres.isEmpty || genres.contains(artist.genre)) &&                                                                                                                     |
        +----------------------------------------------------------------------------+      |       (locations.isEmpty || locations.contains(artist.origin.name)) &&                                                                                                       |
        | Artist("Metallica", "Heavy Metal", Location("U.S."), 1983, None)           |      |       (!searchByActiveYears || (                                                                                                                                             |
        | Artist("Led Zeppelin", "Hard Rock", Location("England"), 1968, Some(1980)) |      |         (artist.isActive || artist.yearsActiveEnd >= activeAfter) &&                                                                                                         |
        +----------------------------------------------------------------------------+      |           (artist.yearsActiveStart <= activeBefore)))                                                                                                                        |
                                                                                            |   )                                                                                                                                                                          |
                                                                                            | }                                                                                                                                                                            |
                                                                                            +------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
        updated                                                                                            
        +----------------------------------------------------------------------------------------------------------------------+
        | case class Artist(name: String, genre: String, origin: Location, yearsActiveStart: Int, yearsActiveEnd: Option[Int]) |
        +----------------------------------------------------------------------------------------------------------------------+

        +-----------------------------------------------------------+
        | (artist.isActive || artist.yearsActiveEnd >= activeAfter) |
        | changed to                                                |
        | (artist.yearsActiveEnd.forall(_ >= activeAfter))          |   // forall returns true if the element inside the given Option(if the Option is Some) satisfies the condition
        +-----------------------------------------------------------+   // or if there is no element inside the Option (i.e. it is None)
        // if this represents a value, check if it satisfies the given condition, if there is no value, ignore the condition

    val year: Option[Int] = Some(996)
    val noYear: Option[Int] = None
    forall                          exists                          filter
    +-------------------------+     +-------------------------+     +-------------------------+
    | year.forall(_ < 2020)   |     | year.exists(_ < 2020)   |     | year.filter(_ < 2020)   |
    | -> true                 |     | -> true                 |     | -> Some(996)            |
    | noYear.forall(_ < 2020) |     | noYear.exists(_ < 2020) |     | noYear.filter(_ < 2020) |
    | -> true                 |     | -> false                |     | -> None                 |
    | year.forall(_ > 2020)   |     | year.exists(_ > 2020)   |     | year.filter(_ > 2020)   |
    | -> false                |     | -> false                |     | -> None                 |
    | noYear.forall(_ > 2020) |     | noYear.exists(_ > 2020) |     | noYear.filter(_ > 2020) |
    | -> true                 |     | -> false                |     | -> None                 |
    +-------------------------+     +-------------------------+     +-------------------------+

    +------------------------------------------------------------------------------------+
    | case class User(name: String, city: Option[String], favoriteArtists: List[String]) |
    |                                                                                    |
    | def f1(users: List[User]): List[User] = {                                          |
    |     users.filter(_.city.forall(_ == Melbourne))                                    |  // users that havent specified their city or live in Melbourne
    | }                                                                                  |
    | def f2(users: List[User]): List[User] = {                                          |
    |     users.filter(_.city.contains(Lagos))                                           |  // users that live in Lagos.
    | }                                                                                  |
    | def f3(users: List[User]): List[User] = {                                          |
    |     users.filter(_.favoriteArtists.contains(Bee Gees))                             |  // users that like Bee Gees.
    | }                                                                                  |
    | def f4(users: List[User]): List[User] = {                                          |
    |     users.filter(_.city.exists(_.startsWith(T)))                                   |  // users that live in cities that start with a letter T.
    | }                                                                                  |
    | def f5(users: List[User]): List[User] = {                                          |  // users that only like artists that have
    |     users.filter(_.favoriteArtists.forall(_.length > 8))                           |  // a name longer than 8 characters (or no favorite artists at all).
    | }                                                                                  |
    | def f6(users: List[User]): List[User] = {                                          |
    |     users.filter(_.favoriteArtists.exists(_.startsWith(M)))                        |  // users that like some artists whose names start with M.
    | }                                                                                  |
    +------------------------------------------------------------------------------------+

    - coupling a concept inside one case class
        +----------------------------------------------------------------------------------------------+
        | case class PeriodInYears(start: Int, end: Option[Int])                                       |
        | case class Artist(name: String, genre: String, origin: Location, yearsActive: PeriodInYears) |
        | Artist("Led Zeppelin", "Hard Rock", Location("England"),PeriodInYears(1968, None))           |
        | Artist("Bee Gees",     "Pop",       Location("England"),PeriodInYears(1958, Some(2003)))     |
        +----------------------------------------------------------------------------------------------+

    - modeling finite possibilities
        +-------------------------------------------+
        | sealed trait MusicGenre                   |   // sum type (sealed trait). Type that can only take a finite set of values
        | case object HeavyMetal extends MusicGenre |
        | case object Pop extends MusicGenre        |
        | case object HardRock extends MusicGenre   |
        +-------------------------------------------+ 
        // better modeling with sealed traits
        +--------------------------------------------------------------------------------------------------+
        | case class Artist(name: String, genre: MusicGenre, origin: Location, yearsActive: PeriodInYears) |
        +--------------------------------------------------------------------------------------------------+

        +--------------------------------------------------------+
        | case class PeriodInYears(start: Int, end: Option[Int]) |
        +--------------------------------------------------------+

        +-------------------------------------------+   +----------------------------------------------------------------------+
        | sealed trait MusicGenre                   |   | sealed trait YearsActive                                             |
        | case object HeavyMetal extends MusicGenre |   | case class StillActive(since: Int) extends YearsActive               |
        | case object Pop extends MusicGenre        |   | case class ActiveBetween(start: Int, until: Int) extends YearsActive |
        | case object HardRock extends MusicGenre   |   +----------------------------------------------------------------------+
        +-------------------------------------------+

        // last version
        +-------------------------------------------------------------------------------------+
        | Artist("Metallica",    ThrashMetal, Location("U.S."),    StillActive(1983))         |
        | Artist("Led Zeppelin", HardRock,    Location("England"), ActiveBetween(1968, 1980)) |
        +-------------------------------------------------------------------------------------+

    - using ADT-based models in behaviors (functions)
        +------------------------------------------------------------------------------+        +-------------------------------------------------------------------------------------------------------+
        | sealed trait SearchCondition                                                 |        | def searchArtists(artists: List[Artist], requiredConditions: List[SearchCondition]): List[Artist] = { |
        | case class SearchByGenre(genres: List[MusicGenre]) extends SearchCondition   |        |   artists.filter(artist =>                                                                            |
        | case class SearchByOrigin(locations: List[Location]) extends SearchCondition |        |     requiredConditions.forall(condition =>                                                            |
        | case class SearchByActiveYears(start: Int, end: Int) extends SearchCondition |        |       condition match {                                                                               |
        +------------------------------------------------------------------------------+        |         case SearchByGenre(genres) => genres.contains(artist.genre)                                   |
          two parameters instead of seven, no raw types, no nested                              |         case SearchByOrigin(locations) => locations.contains(artist.origin)                           |
          if conditions, no boolean flags. Only the code that’s really needed                   |         case SearchByActiveYears(start, end) => wasArtistActive(artist, start, end)}))}               |
                                                                                                +-------------------------------------------------------------------------------------------------------+