####################
# pure functions
####################
    #rules
    -returns one value
    -calculates the return value based only on the arguments
    -doesn’t mutate any existing values
    
    #referential transparency
    you could substitute the function call, f(20), with its result, 19, without changing the program’s behavior
    
    # ShoppingCart
        v1                                                          v2                                              v3                                                          v4
        items, bookAdded - states                                   add remove method
        cart.getItems().remove("Book") - breaks code                cart.removeItem("Book") - breaks code
        fix: return new ArrayList<>(items)                          if we added 2 and removed 1
        +---------------------------------------------------+   =>  +---------------------------------------+   =>  +--------------------------------------------------+    =>  +--------------------------------------------------------------+
        | public class ShoppingCart {                       |       | public void removeItem(String item) { |       |public class ShoppingCart {                       |        | object ShoppingCartDiscounts {                               |
        |   private List<String> items = new ArrayList<>(); |       |   items.remove(item);                 |       |  private List<String> items = new ArrayList<>(); |        |     def getDiscountPercentage(items: List[String]): Int = {  |
        |   private boolean bookAdded = false;              |       |   if(item.equals(ôBookö)) {           |       |  public int addItem(String item) {               |        |         if (items.contains(Book)) {                          |
        |   public int addItem(String item) {               |       |     bookAdded = false;                |       |    items.add(item);                              |        |             5                                                |
        |     items.add(item);                              |       |   }                                   |       |  }                                               |        |         } else {                                             |
        |     if(item.equals(ôBookö)) {                     |       | }                                     |       |  public int getDiscountPercentage() {            |        |             0                                                |
        |       bookAdded = true;                           |       +---------------------------------------+       |    if(items.contains("Book")) {                  |        |         }                                                    |
        |     }                                             |                                                       |      return 5;                                   |        |     }                                                        |
        |   }                                               |                                                       |    } else {                                      |        | }                                                            |
        |   public int getDiscountPercentage() {            |                                                       |      return 0;                                   |        +--------------------------------------------------------------+
        |     if(bookAdded) {                               |                                                       |    }                                             |
        |       return 5;                                   |                                                       |  }                                               |
        |     } else {                                      |                                                       |  public List<String> getItems() {                |
        |       return 0;                                   |                                                       |    return new ArrayList<>(items);                |
        |     }                                             |                                                       |  }                                               |
        |   }                                               |                                                       |  public void removeItem(String item) {           |
        |   public List<String> getItems() {                |                                                       |    items.remove(item)                            |
        |     return items;                                 |                                                       |  }                                               |
        |   }                                               |                                                       |}                                                 |
        | }                                                 |                                                       +--------------------------------------------------+
        +---------------------------------------------------+
        - refactoring                                               - state as argument, pass copies of data, recalculate instead of storing
        +--------------------------------------------------+    =>  +--------------------------------------------------------------------+
        | class TipCalculator {                            |        | class TipCalculator {                                              |
        |   private val names = new util.ArrayList[AnyRef] |        |   public List<String> addPerson(List<String> names, String name) { |
        |   private var tipPercentage = 0                  |        |     List<String> updated = new ArrayList<>(names);                 |
        |   def addPerson(name: String): Unit = {          |        |     updated.add(name);                                             |
        |     names.add(name)                              |        |     return updated;                                                |
        |     if (names.size > 5) tipPercentage = 20       |        |   }                                                                |
        |     else if (names.size > 0) tipPercentage = 10  |        |   public static int getTipPercentage(List<String> names) {         |
        |   }                                              |        |     if(names.size() > 5) {                                         |
        |   def getNames: Nothing = names                  |        |       return 20;                                                   |
        |   def getTipPercentage: Int = tipPercentage      |        |     } else if(names.size() > 0) {                                  |
        | }                                                |        |       return 10;                                                   |
        +--------------------------------------------------+        |     } else return 0;                                               |
                                                                    |   }                                                                |
                                                                    | }                                                                  |
                                                                    +--------------------------------------------------------------------+


####################
# immutable values
####################
    -fight mutability by working with copies
    -pure function can mutate internal state
    # replan
    +-------------------------------------------------------------------------------------+
    | def replan(plan: List[String], newCity: String,beforeCity: String): List[String] = {|
    |      val beforeCityIndex = plan.indexOf(beforeCity)                                 |
    |      val citiesBefore = plan.slice(0, beforeCityIndex)                              |
    |      val citiesAfter = plan.slice(beforeCityIndex, plan.size)                       |
    |      citiesBefore.appended(newCity).appendedAll(citiesAfter)                        |
    |  }                                                                                  |
    +-------------------------------------------------------------------------------------+

    v1                                                                                          v2                                                                                                  v3
    - is mutable- is not mutating argument                                                      - making functions pure by mutating copies                                                          - encapsulation
    +------------------------------------------------------------------------------------+  =>  +--------------------------------------------------------------------------------------------+  =>  +---------------------------------------------------------+
    | static List<String> replan(List<String> plan, String newCity, String beforeCity) { |      | static List<String> replan(List<String> plan, String splitPoint, List<String> newEnding) { |      | private List<String> plan = new ArrayList<>();          |
    |   int newCityIndex = plan.indexOf(beforeCity);                                     |      |   int newCityIndex = plan.indexOf(beforeCity);                                             |      | public void replan(String newCity, String beforeCity) { |
    |   plan.add(newCityIndex, newCity);                                                 |      |   List<String> replanned = new ArrayList<>(plan);                                          |      |   int newCityIndex = plan.indexOf(beforeCity);          |
    |   return plan;                                                                     |      |   replanned.add(newCityIndex, newCity);                                                    |      |   plan.add(newCityIndex, newCity);                      |
    | }                                                                                  |      |   return replanned;                                                                        |      | }                                                       |
    +------------------------------------------------------------------------------------+      | }                                                                                          |      | public void add(String city) {                          |
                                                                                                +--------------------------------------------------------------------------------------------+      |   plan.add(city);                                       |
                                                                                                                                                                                                    | }                                                       |
                                                                                                                                                                                                    | public List<String> getPlan() {                         |
                                                                                                                                                                                                    |   return Collections.unmodifiableList(plan);            |
                                                                                                                                                                                                    | }                                                       |
####################                                                                                                                                                                                +---------------------------------------------------------+
# functions as values
####################
    # rankedWords -  rank the words by the number of letters different than a
    v1                                                          v2 - with streams, bad - scoreComparator defined elsewhere  v3 - 
    +------------------------------------------------------+    +------------------------------------------------------+    +-------------------------------------------------------------------------------------+
    |static int score(String word) {                       |    |static List<String> rankedWords(List<String> words) { |    |static List<String> rankedWords(Comparator<String> comparator, List<String> words) { |
    |  return word.replaceAll("a", "").length();           |    |  return words.stream()                               |    |  return words.stream()                                                              |
    |}                                                     |    |    .sorted(scoreComparator)                          |    |    .sorted(comparator)                                                              |
    |Comparator<String> scoreComparator =                  |    |    .collect(Collectors.toList());                    |    |    .collect(Collectors.toList());                                                   |
    |  new Comparator<String>() {                          |    |}                                                     |    |}                                                                                    |
    |    public int compare(String w1, String w2) {        |    +------------------------------------------------------+    +-------------------------------------------------------------------------------------+
    |      return Integer.compare(score(w2), score(w1));   |
    |    }                                                 |
    |  };                                                  |
    |static List<String> rankedWords(List<String> words) { |
    |  words.sort(scoreComparator);                        |
    |  return words;                                       |
    |}                                                     |
    +------------------------------------------------------+

    - changing requirments - bonus score of 5 needs to be added to the score if the word contains a 'c'
    v4                                                          v5                                                                  v6
    duplication in scoreWithBonusComparator & scoreComparator   - pass a function, comparator creates inside                        - score,bonus,penalty
    +-----------------------------------------------+           +--------------------------------------------------------------+    +--------------------------------------------------------------+
    |static int scoreWithBonus(String word) {       |           |List<String> rankedWords(Function<String, Integer> wordScore, |    |   static int bonus(String word) {                            |
    |  int base = score(word);                      |           |  List<String> words) {                                       |    |     return word.contains(ôcö) ? 5 : 0;                       |
    |  if (word.contains("c")) return base + 5;     |           |  Comparator<String> wordComparator =                         |    |   }                                                          |
    |  else return base;                            |           |    (w1, w2) -> Integer.compare(                              |    |   static int penalty(String word) {                          |
    |}                                              |           |      wordScore.apply(w2),                                    |    |     return word.contains(ôsö) ? 7 : 0;                       |
    |Comparator<String> scoreWithBonusComparator =  |           |      wordScore.apply(w1)                                     |    |   }                                                          |
    |  new Comparator<String>() {                   |           |    );                                                        |    |   rankedWords(w -> score(w) + bonus(w) - penalty(w), words); |
    |    public int compare(String w1, String w2) { |           |  return words                                                |    +--------------------------------------------------------------+
    |      return Integer.compare(                  |           |    .stream()                                                 |
    |        scoreWithBonus(w2),                    |           |    .sorted(wordComparator)                                   |
    |        scoreWithBonus(w1));                   |           |    .collect(Collectors.toList());                            |
    |    }                                          |           |}                                                             |
    |  };                                           |           |rankedWords(w -> score(w), words);                            |
    |rankedWords(scoreWithBonusComparator, words);  |           |rankedWords(w -> scoreWithBonus(w), words);                   |
    +-----------------------------------------------+           +--------------------------------------------------------------+
    - implemented in Scala                                                                  - passing functions inline
    +----------------------------------------------------------------------------------+    +-----------------------------------------------+
    | def rankedWords(wordScore: String => Int, words: List[String]): List[String] = { |    | def score(word: String): Int =                |
    |     words.sortBy(wordScore).reverse                                              |    |     word.replaceAll(a, ).length               |
    | }                                                                                |    | def bonus(word: String): Int =                |
    | def score(word: String): Int = word.replaceAll(a, ).length                       |    |     if (word.contains(c)) 5 else 0            |
    | rankedWords(score, words)                                                        |    | rankedWords(w => score(w) + bonus(w), words); |
    | List(haskell, rust, scala, java, ada)                                            |    | List(scala, haskell, rust, java, ada)         |
    +----------------------------------------------------------------------------------+    +-----------------------------------------------+

    ----------
    - map
    ----------
    List[A].map(f: A => B): List[B]
    # wordScores using map
    +------------------------------------------------------------------------------+    +--------------------------------------+
    | def wordScores(wordScore: String => Int, words: List[String]): List[Int] = { |    |     def penalty(word: String): Int = |
    |     words.map(wordScore)                                                     |    |         if (word.contains(s)) 7      |
    | }                                                                            |    |     else 0                           |
    | wordScores(w => score(w) + bonus(w) - penalty(w), words)                     |    +--------------------------------------+
    +------------------------------------------------------------------------------+    

    ----------
    - filter
    ----------
    +---------------------------------------------------------------------------------------+
    | def highScoringWords(wordScore: String => Int, words: List[String]): List[String] = { |   // returning only elements that satisfied this condition
    |     words.filter(word => wordScore(word) > 1)                                         |   // how do we parametrize 1 ?
    | }                                                                                     |
    +---------------------------------------------------------------------------------------+

    ----------
    - return functions
    ----------
    +----------------------------------------------------------------------------------------------+
    | def highScoringWords(wordScore: String => Int, words: List[String]): Int => List[String] = { |
    |     higherThan => words.filter(word => wordScore(word) > higherThan)                         |
    | }                                                                                            |
    +----------------------------------------------------------------------------------------------+
    - using return function
    +--------------------------------------------------------------------------------------------------------------------+
    | val wordsWithScoreHigherThan: Int => List[String] = highScoringWords(w => score(w) + bonus(w) - penalty(w), words) |
    | wordsWithScoreHigherThan(1)                                                                                        |
    |   List(java)                                                                                                       |
    | wordsWithScoreHigherThan(0)                                                                                        |
    |   List(ada, scala, java                                                                                            |
    +--------------------------------------------------------------------------------------------------------------------+

    ----------
    - return functions from returned functions
    ----------

    we can replace def 3 param function
        +------------------------------------------------------------------------------------------------+
        | highScoringWords(wordScore: String => Int, words: List[String], higherThan: Int): List[String] |
        +------------------------------------------------------------------------------------------------+
    with 2 param function that returns 1 param function
        +------------------------------------------------------------------------------------------+
        | def highScoringWords(wordScore: String => Int words: List[String]): Int => List[String]  |
        +------------------------------------------------------------------------------------------+    
    then
    we can replace 2 param function
        +------------------------------------------------------------------------------------------+
        | def highScoringWords(wordScore: String => Int words: List[String]): Int => List[String]  |
        +------------------------------------------------------------------------------------------+    
    with 1 param function
        +-----------------------------------------------------------------------------------------+
        | def highScoringWords(wordScore: String => Int): Int => List[String] => List[String] = { | // reutns a function which takes Int and returns a function which takes List[String] and returns List[String]
        |     higherThan => words => words.filter(word => wordScore(word) > higherThan)           |
        | }                                                                                       |
        +-----------------------------------------------------------------------------------------+
    usage:
        +-----------------------------------------------------------------------------------------------------------------------------+
        | val wordsWithScoreHigherThan: Int => List[String] => List[String] = highScoringWords(w => score(w) + bonus(w) - penalty(w)) |
        | wordsWithScoreHigherThan(1)(words)                                                                                          |
        |   List(java)                                                                                                                |
        | wordsWithScoreHigherThan(0)(words2)                                                                                         |
        |   List(football, f1, hockey, basketball)                                                                                    |
        | wordsWithScoreHigherThan(5)(words2)                                                                                         |
        |   List(football, hockey)                                                                                                    |
        +-----------------------------------------------------------------------------------------------------------------------------+

    ----------
    - Currying
    ----------
    Transforming multiple-parameter functions into a series of 1-parameter functions returned from each other is called currying.
    +----------------------------+  +-------------------------------------------------+
    | def f(a: A, b: B, c: C): D |  | def largerThan(n: Int)(i: Int): Boolean = i > n |
    | def f(a: A): B => C => D   |  | List(5, 1, 2, 4, 0).filter(largerThan(4))       |
    | def f(a: A)(b: B)(c: C): D |  +-------------------------------------------------+
    +----------------------------+

    ----------
    - foldLeft
    ----------
    List[A].foldLeft(z: B)(f: (B, A) => B): B
    foldLeft accumulates a value by going through all elements of the list and calling the provided function
    +-----------------------------------------------------------------+
    | words.foldLeft(0)((total, word) => total + wordScore(word))     |
    +-----------------------------------------------------------------+

    ----------
    - case classes
    ----------
    +---------------------------------------------------------+
    | case class ProgrammingLanguage(name: String, year: Int) |
    | ProgrammingLanguage("Java", 1995)                       |
    | java.name                                               |
    +---------------------------------------------------------+



####################
# sequential programs
####################
                                                                        - how many have word Scala
    +---------------------------------------------------------------+   +-----------------------------------------------------------------------------+
    | case class Book(title: String, authors: List[String])         |   | books.map(book => book.title).filter(title => title.contains("Scala")).size |
    |                                                               |   +-----------------------------------------------------------------------------+
    | val books = List(                                             |
    |     Book(FP in Scala, List(Chiusano, Bjarnason)),             |
    |     Book(The Hobbit, List(Tolkien)),                          |
    |     Book(Java 8 in Action, List(Urma, Fusco, Mycroft)         |
    | )                                                             |
    +---------------------------------------------------------------+

    # book adaptations
        1. for each book take author
        2. for each author run bookAdaptations returning movies
        3. for each movie construct a recommendation feed string
        +-------------------------------------------------------+
        | case class Book(title: String, authors: List[String]) |
        | case class Movie(title: String)                       |
        |                                                       |
        | val books = List(                                     |
        |     Book(FP in Scala, List(Chiusano, Bjarnason)),     |
        |     Book(The Hobbit, List(Tolkien)))                  |
        |                                                       |
        | def bookAdaptations(author: String): List[Movie] =    |
        |     if (author == Tolkien)                            |
        |         List(Movie(An Unexpected Journey),            |
        |             Movie(The Desolation of Smaug))           |
        | else List.empty                                       |
        +-------------------------------------------------------+

        -imperative approach
        bad:
            mutable list return
            nesting for
            statemnts in for instead of expressions
        +-----------------------------------------------------------+
        |static List<String> recommendationFeed(List<Book> books) { |
        |  List<String> result = new ArrayList<>();                 |
        |  for (Book book : books)                                  |
        |    for (String author : book.authors)                     |
        |      for (Movie movie : bookAdaptations(author)) {        |
        |        result.add(movie.title, author, book.title);       |
        |  }                                                        |
        |  return result;                                           |
        |}                                                          |
        +-----------------------------------------------------------+

        +---------
        | flatMap
        +---------
            flatMap not only can change the type of the list (e.g. from Book to String), but also can change the size of the resulting list, which isn’t possible with map
        1. for each book take author
            +----------------------------------------------------+
            | books.map(book => book.authors)                    |
            |     List(List(Chiusano, Bjarnason), List(Tolkien)) |  // need to fix
            +----------------------------------------------------+
            - flatten goes through the list of lists and takes all elements from the first list, then second, and so on...

            +----------------------------------------------------+
            | books.map(book => book.authors).flatten            |  // fix
            |     List(Chiusano, Bjarnason, Tolkien)             |
            +----------------------------------------------------+
            or
            +----------------------------------------------------+
            | books.flatMap(book => book.authors)                |
            |     List(Chiusano, Bjarnason, Tolkien)             |
            +----------------------------------------------------+

        2. for each author run bookAdaptations returning movies
            +---------------------------------------------+
            | books.flatMap(book => book.authors)         |
            | .flatMap(author => bookAdaptations(author)) |
            |                                             |
            | List(Movie(An Unexpected Journey),          |
            |      Movie(The Desolation of Smaug))        |
            +---------------------------------------------+
        - flatMap can change the type and size of returned list                     flatten
            map on 3 elements results in 3 lists                                    goes through each list and extracts elements to new list
            +-----------------------------------------------------------------+     +------------------------------------------+
            | val movieLists = authors.map(author => bookAdaptations(author)) |     | movieLists.flatten                       |
            | List(List.empty,                                                |     |     List(Movie(An Unexpected Journey),   |
            |      List.empty,                                                |     |          Movie(The Desolation of Smaug)) |
            |      List(Movie(An Unexpected Journey),                         |     +------------------------------------------+
            |           Movie(The Desolation of Smaug))))                     |
            +-----------------------------------------------------------------+

            +---------------------------------------------+
            | List(1, 2, 3).flatMap(i => List(i, i + 10)) | // List(1,11,2,12,3,13)
            +---------------------------------------------+

    - List signatures:
        +----------------------------------------------+
        | def map(f: A => B): List[B]                  |
        | def flatten: List[B] // A needs to be a List |
        | def flatMap(f: A => List[B]): List[B]        |
        +----------------------------------------------+

    +---------
    | Chained flatMaps & maps
    +---------
        3. for each movie construct a recommendation feed string
        - use nested flatMap
        - flatMap always returns a List
        - we wouldn’t be able to transform chained maps into nested maps, because we don’t have the guarantee that it returns a List, no matter what function we pass.
        +------------------------------------------------+
        | books.flatMap(book => {                        |
        |     book.authors.flatMap(author => {           |
        |         bookAdaptations(author).map(movie => { |
        |             // access to book, author, movie   |
        |         }                                      |
        |     }                                          |
        | }                                              |
        +------------------------------------------------+

    +---------
    | for comprehension
    +---------
        - for each element x in xs and for each element y in ys, call the function doSomething(x, y)
        - expression after yield defines result of whole expression
        - result is list of type which dictated by yields
            +-------------------------------------------------+
            | for {                                           |
            |     x <- xs                                     |
            |     y <- ys                                     |
            | } yield doSomething(x, y)                       |
            | transormed into                                 |
            | xs.flatMap(x => ys.map(y => doSomething(x, y))) |
            +-------------------------------------------------+

        - full solution
            +-------------------------------------------------+
            | for {                                           |
            |     book <- books                               |
            |     author <- book.authors                      |
            |     movie <- bookAdaptations(author)            |
            | } yield sYou may like ${movie.title},  +        |
            | sbecause you liked $authors ${book.title}       |
            |     -> List(You may like An Unexpected Journey, |
            |     because you liked Tolkiens The Hobbit,      |
            |     You may like The Desolation of Smaug,       |
            |     because you liked Tolkiens The Hobbit))     |
            +-------------------------------------------------+

        - for gurad expressions                             - using filter
            +-------------------------------------------+   +-------------------------------------------------+ +--------------------------------------------+
            | for {                                     |   | for {                                           | | for {                                      |
            |     r <- radiuses                         |   |     r <- radiuses                               | |     r <- radiuses                          |
            |     point <- points if isInside(point, r) |   |     point <- points.filter(p => isInside(p, r)) | |     point <- points                        |
            | } yield s$point is within a radius of $r  |   | } yield s"$point is within a radius of $r"      | |     if isInside(point, r)                  |
            +-------------------------------------------+   +-------------------------------------------------+ | } yield s" $point is within a radius of $r"|
                                                                                                                +--------------------------------------------+


    +---------
    | Comparing map, foldLeft and flatMap
    +---------
        +-------------------------------------------+
        | List[A].map(f: A => B): List[B]           |   // applies function passed as f to each element of the original list, producing a new list with modified elements        
        | List[A].foldLeft(z: B)(f: (B, A) => B): B |   // accumulates a value of type B by applying the function passed as f to each element of the original list (A) and current accumulator value (B).
        | List[A].flatMap(f: A => List[B]): List[B] |   // applies the function passed as f to each element of the original list—producing n lists which are joined in the same order as the elements they originated from.
        +-------------------------------------------+

    +---------
    | parsing as pipeline
    +---------

        +------------------------------------------------------+
        | case class Event(name: String, start: Int, end: Int) |
        +------------------------------------------------------+
        v1                                                          v2
        bad:
            All the concerns are entangled in one line of code
            has nulls
        +--------------------------------------------------------+  +------------------------------------------------------------------+
        | def parse(name: String, start: Int, end: Int): Event = |  | def parse(name: String, start: Int, end: Int): Option[Event] = { |
        |     if (name.size > 0 && end < 3000 & start <= end)    |  |     if (name.size > 0 && end < 3000 & start <= end)              |
        |         Event(name, start, end)                        |  |         Some(Event(name, start, end))                            |
        |     else                                               |  |     else                                                         |
        |         null                                           |  |         None                                                     |
        | parse("Apollo Program", 1961, 1972)                    |  | }                                                                |
        | Event("Apollo Program", 1961, 1972))                   |  +------------------------------------------------------------------+
        | parse("", 1939, 1945)                                  |
        | null                                                   |
        +--------------------------------------------------------+
        v3
        +----------------------------------------------------------------+
        | def validateName(name: String): Option[String] =               |
        |     if (name.size > 0) Some(name) else None                    |
        | def validateEnd(end: Int): Option[Int] =                       |
        |     if (end < 3000) Some(end) else None                        |
        | def validateStart(start: Int, end: Int): Option[Int] =         |
        |     if (start <= end) Some(start) else None                    |
        |                                                                |
        | def parse(name: String, start: Int, end: Int): Option[Event] = |
        |     for {                                                      |
        |     validName <- validateName(name)                            |
        |     validEnd <- validateEnd(end)                               |
        |     validStart <- validateStart(start, end)                    |
        |     } yield Event(validName, validStart, validEnd)             |
        | parse("Apollo Program", 1961, 1972)                            |
        | Some(Event("Apollo Program", 1961, 1972)))                     |
        +----------------------------------------------------------------+

####################
# error handling
####################

    - Task to sort tv shows which arrive in string as:
        List("Breaking Bad (2008-2013)",
             "The Wire (2002-2008)",
             "Mad Men (2007-2015)")
    +---------------------------------------------------------------+
    | case class TvShow(title: String, start: Int, end: Int)        |
    |                                                               |
    | def sortShows(shows: List[TvShow]): List[TvShow]              |
    |                                                               |
    | def sortShows(shows: List[TvShow]): List[TvShow] = {          |
    |     shows.sortBy(tvShow => tvShow.end - tvShow.start).reverse |
    | }                                                             |
    +---------------------------------------------------------------+

    - need to develop a parse functions
    - parsing all is poarsing one
    +----------------------------------------------------------+
    | def parseShows(rawShows: List[String]): List[TvShow] = { |
    |     rawShows.map(parseShow)                              |
    | }                                                        |
    | def parseShow(rawShow: String): TvShow                   |
    +----------------------------------------------------------+

    - parseShow
    v1                                                                                  v2                                              
    bad:                                                                                catch ex and return null                        
        function lies - "Breaking Bad, 2008-2013" - will give exception
    +--------------------------------------------------------------------------------+  +---------------------------------------+
    | def parseShow(rawShow: String): TvShow = {                                     |  | try {                                 |
    |     val bracketOpen = rawShow.indexOf("(")                                     |  |     return parseShow(invalidRawShow); |
    |     val bracketClose = rawShow.indexOf(")")                                    |  | } catch(Exception e) {                |
    |     val dash = rawShow.indexOf("-")                                            |  |     return null;                      |
    |     val name = rawShow.substring(0, bracketOpen).trim                          |  | }                                     |
    |     val yearStart = Integer.parseInt(rawShow.substring(bracketOpen + 1, dash)) |  +---------------------------------------+
    |     val yearEnd = Integer.parseInt(rawShow.substring(dash + 1, bracketClose))  |  - would need to do this later
    |     TvShow(name, yearStart, yearEnd)                                           |  +------------------------------------------+
    | }                                                                              |  | TvShow show = parseShow(invalidRawShow); |
    +--------------------------------------------------------------------------------+  | if(show != null) {                       |
                                                                                        |     // do more things with the show      |
                                                                                        | }                                        |
                                                                                        +------------------------------------------+

    v3
    use options instead
    Pure functions should not throw exceptions
    - If any step returns None, the whole for comprehension will be None
    +----------------------------------------------------+  +----------------------------------------------------+  +-----------------------------------------------------------------------+   +---------------------------------------------------------------------+
    | def parseShow(rawShow: String): Option[TvShow] = { |  | def extractName(rawShow: String): Option[String]   |  | def extractYearStart(rawShow: String): Option[Int] = {                |   | def extractYearStart(rawShow: String): Option[Int] = {              |
    |     for {                                          |  | def extractYearStart(rawShow: String): Option[Int] |  |     val bracketOpen = rawShow.indexOf(()                              |   |     val bracketOpen = rawShow.indexOf("(")                          |
    |         name <- extractName(rawShow)               |  | def extractYearEnd(rawShow: String): Option[Int]   |  |     val dash = rawShow.indexOf(-)                                     |   |     val dash = rawShow.indexOf("-")                                 |
    |         yearStart <- extractYearStart(rawShow)     |  +----------------------------------------------------+  |     val yearStrOpt = if (bracketOpen != -1 && dash > bracketOpen + 1) |   |     for {                                                           |
    |         yearEnd <- extractYearEnd(rawShow)         |                                                          |         Some(rawShow.substring(bracketOpen + 1, dash))                |   |         yearStr <- if (bracketOpen != -1 && dash > bracketOpen + 1) |
    |     }                                              |  Each functions need to return an Option                 |     else None                                                         |   |                     Some(rawShow.substring(bracketOpen + 1, dash))  |
    |     yield TvShow(name, yearStart, yearEnd)         |                                                          |     yearStrOpt.map(yearStr => yearStr.toIntOption).flatten            |   |                    else None                                        |
    | }                                                  |                                                          | }                                                                     |   |         year <- yearStr.toIntOption                                 |
    +----------------------------------------------------+                                                          | extractYearStart(rawShow).orElse(extractSingleYear(rawShow))          |   |         } yield year}                                               |
                                                                                                                    +-----------------------------------------------------------------------+   +---------------------------------------------------------------------+
                                                            translates to                                                   pass "Mad Men (-2015)", yearsStart is None - whole expression is None
    +----------------------------------------------------+  +----------------------------------------------------------+    +------------------------------------------------------+
    | def parseShow(rawShow: String): Option[TvShow] = { |  | def parseShow(rawShow: String): Option[TvShow] = {       |    | def parseShow(rawShow: String): Option[TvShow] = {   |
    |     for {                                          |  |     extractName(rawShow).flatMap(name => {               |    |     Some(Mad Men).flatMap(name => {                  |
    |         name <- extractName(rawShow)               |  |         extractYearStart(rawShow).flatMap(yearStart => { |    |         None.flatMap(yearStart => {                  |
    |         yearStart <- extractYearStart(rawShow)     |  |             extractYearEnd(rawShow).map(yearEnd => {     |    |             extractYearEnd(rawShow).map(yearEnd => { |
    |         yearEnd <- extractYearEnd(rawShow)         |  |                 TvShow(name, yearStart, yearEnd)}}}}     |    |                 TvShow(name, yearStart, yearEnd)}}}  |
    |     } yield TvShow(name, yearStart, yearEnd)       |  +----------------------------------------------------------+    +------------------------------------------------------+
    | }                                                  |
    +----------------------------------------------------+

    - exception recovery
        Checked exceptions dont compose—Options do                                          vs
    +-----------------------------------------------------------------------------------+   +---------------------------------------------+
    | def parseShow(rawShow: String): Option[TvShow] = {                                |   | Integer yearStart = null;                   |
    |     for {                                                                         |   | try {                                       |
    |         name <- extractName(rawShow)                                              |   |     yearStart = extractYearStart(rawShow);  |
    |         yearStart <- extractYearStart(rawShow).orElse(extractSingleYear(rawShow)) |   | } catch(Exception e) {                      |
    |         yearEnd <- extractYearEnd(rawShow).orElse(extractSingleYear(rawShow))     |   |     yearStart = extractSingleYear(rawShow); |
    |     } yield TvShow(name, yearStart, yearEnd)                                      |   | }                                           |
    | }                                                                                 |   +---------------------------------------------+
    +-----------------------------------------------------------------------------------+

    - Two different error handling strategies                               
        - best-effort error handling                                        - All-or-nothing error handling
        try to parse every show - return only valid ones                    try to parse all TV show only if all are valid
        may be frustrating if we get only some shows from input             val resSome = addOrResign(initialResult, Some("new"))                       // Some(List(new))
        parseShows(List(“Chernobyl [2019]”, “Breaking Bad (2008-2013)”))    val resNone = addOrResign(initialResult, None)                              // None
            -List(TvShow(“Breaking Bad”, 2008, 2013))                       val resNone2 = List(Some("new"), None).foldLeft(initialResult)(addOrResign) // None
        +----------------------------------------------------------+        +------------------------------------------------------------------+    +-------------------------------------------------------------------------------------------------------------+
        | def parseShows(rawShows: List[String]): List[TvShow] = { |        | def parseShows(rawShows: List[String]): Option[List[TvShow]] = { |    | def addOrResign(parsedShows: Option[List[TvShow]], newParsedShow: Option[TvShow]): Option[List[TvShow]] = { |
        |     rawShows // List[String]                             |        |     val initialResult: Option[List[TvShow]] = Some(List.empty)   |    |     for {                                                                                                   |
        |         .map(parseShow) // List[Option[TvShow]]          |        |     rawShows                                                     |    |         shows <- parsedShows                                                                                |
        |         .map(_.toList) // List[List[TvShow]]             |        |     .map(parseShow)                                              |    |         parsedShow <- newParsedShow                                                                         |
        |         .flatten // List[TvShow]                         |        |     .foldLeft(initialResult)(addOrResign)                        |    |     } yield shows.appended(parsedShow)                                                                      |
        | }                                                        |        | }                                                                |    | }                                                                                                           |
        +----------------------------------------------------------+        +------------------------------------------------------------------+    +-------------------------------------------------------------------------------------------------------------+

    +---------
    | Either
    +---------    

    +----------------------------------------------------+  +-----------------------------------------------------------------------------------+
    | def f(rawShow: String): Either[String, String] = { |  | def parseShow(rawShow: String): Either[String, TvShow] = {                        |
    |     val bracket = rawShow.indexOf( ( )             |  |     for {                                                                         |
    |     if (bracketOpen > 0) {                         |  |         name <- extractName(rawShow)                                              |
    |         Right(rawShow.substring(0, bracket).trim)) |  |         yearStart <- extractYearStart(rawShow).orElse(extractSingleYear(rawShow)) |
    |     else {                                         |  |         yearEnd <- extractYearEnd(rawShow).orElse(extractSingleYear(rawShow))     |
    |         Left(s  Cant extract name from $rawShow )  |  |     }                                                                             |
    |     }                                              |  |     yield TvShow(name, yearStart, yearEnd)                                        |
    | }                                                  |  | }                                                                                 |
    +----------------------------------------------------+  +-----------------------------------------------------------------------------------+


    - working with Options                   working with Either
    val year: Option[Int] = Some(996)
    val noYear: Option[Int] = None
    +----------------------------------+    +---------------------------------------------+
    | year.map(_ * 2))                 |    | year.map(_ * 2)                             |
    |     Some(1992)                   |    |     Right(1992)                             |
    | noYear.map(_ * 2)                |    | noYear.map(_ * 2)                           |
    |     None                         |    |     Left( no year )                         |
    | Some(year).flatten               |    | Right(year).flatten                         |
    |     Some(996)                    |    |     Right(996)                              |
    | Some(noYear).flatten             |    | Right(noYear).flatten                       |
    |     None                         |    |     Left( no year )                         |
    | year.flatMap(y => Some(y * 2))   |    | year.flatMap(y => Right(y * 2))             |
    |     Some(1992)                   |    |     Right(1992)                             |
    | noYear.flatMap(y => Some(y * 2)) |    | noYear.flatMap(y => Right(y * 2))           |
    |     None                         |    |     Left( no year )                         |
    | year.flatMap(y => None)          |    | year.flatMap(y => Left( can t progress ))   |
    |     None                         |    |     Left( can t progress )                  |
    | noYear.flatMap(y => None)        |    | noYear.flatMap(y => Left( can t progress )) |
    |     None                         |    |     Left( no year )                         |
    | year.orElse(Some(2020))          |    | year.orElse(Right(2020))                    |
    |     Some(996)                    |    |     Right(996)                              |
    | noYear.orElse(Some(2020))        |    | noYear.orElse(Right(2020))                  |
    |     Some(2020)                   |    |     Right(2020)                             |
    | year.orElse(None)                |    | year.orElse(Left( cant recover ))           |
    |     Some(996)                    |    |     Right(996)                              |
    | noYear.orElse(None)              |    | noYear.orElse(Left( can t recover ))        |
    |     None                         |    |     Left( can t recover )                   |
    | year.toRight(no year given)      |    | year.toOption                               |
    |     Right(996)                   |    |     Some(996)                               |
    | noYear.toRight(no year given)    |    | noYear.toOption                             |
    |     Left(no year given)          |    |     None                                    |
    | year.forall(_ == 996)            |    +---------------------------------------------+
    |     true                         |
    | noYear.forall(_ == 996)          |
    |     true // non intuitive        |    // if this represents a value, check if it satisfies the given condition, if there is no value, ignore the condition
    +----------------------------------+

    
####################
# requirements as types
####################
    
    +--------------------------------------------------------------------------------------------------------------------------------+
    | case class Artist(name: String, genre: String, origin: String, yearsActiveStart: Int, isActive: Boolean, yearsActiveEnd: Int)) |
    +--------------------------------------------------------------------------------------------------------------------------------+

    +------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    | def searchArtists(artists: List[Artist], genres: List[String], locations: List[String], searchByActiveYears: Boolean, activeAfter: Int, activeBefore: Int): List[Artist] = { |
    |   artists.filter(artist =>                                                                                                                                                   |
    |     (genres.isEmpty || genres.contains(artist.genre)) &&                                                                                                                     |
    |       (locations.isEmpty || locations.contains(artist.origin)) &&                                                                                                            |
    |       (!searchByActiveYears || (                                                                                                                                             |
    |         (artist.isActive || artist.yearsActiveEnd >= activeAfter) &&                                                                                                         |
    |           (artist.yearsActiveStart <= activeBefore))))}                                                                                                                      |
    +------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    - Problems:
        -Programmers need to be careful about the order of parameters
        -Programmers need to know additional meaning of parameter combinations
        -Programmers need to ensure that some parameters have finite set of values
        -Programmers need to come up with, understand and convey additional meanings to raw types
        -Programmers need to remember that some parameters only make sense when used together

    - value classes (solve order of parameters)
        +--------------------------------------------------+    // Location("U.S.")
        | case class Location(name: String) extends AnyVal |    // extends AnyVal we state that Location type is only checked in the compile time,
        +--------------------------------------------------+    // but still is treated as an unwrapped String in the runtime!

    - option type (solve additional meaning of parameter combinations)
        +----------------------------------------+  // represent one logical entity         +------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
        | isActive: Boolean, yearsActiveEnd: Int |  // yearsActiveEnd: Option[Int]          | def searchArtists(artists: List[Artist], genres: List[String], locations: List[String], searchByActiveYears: Boolean, activeAfter: Int, activeBefore: Int): List[Artist] = { |
        +----------------------------------------+                                          |   artists.filter(artist =>                                                                                                                                                   |
        updated                                                                             |     (genres.isEmpty || genres.contains(artist.genre)) &&                                                                                                                     |
        +----------------------------------------------------------------------------+      |       (locations.isEmpty || locations.contains(artist.origin.name)) &&                                                                                                       |
        | Artist("Metallica", "Heavy Metal", Location("U.S."), 1983, None)           |      |       (!searchByActiveYears || (                                                                                                                                             |
        | Artist("Led Zeppelin", "Hard Rock", Location("England"), 1968, Some(1980)) |      |         (artist.isActive || artist.yearsActiveEnd >= activeAfter) &&                                                                                                         |
        +----------------------------------------------------------------------------+      |           (artist.yearsActiveStart <= activeBefore)))                                                                                                                        |
                                                                                            |   )                                                                                                                                                                          |
                                                                                            | }                                                                                                                                                                            |
                                                                                            +------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
        updated                                                                                            
        +----------------------------------------------------------------------------------------------------------------------+
        | case class Artist(name: String, genre: String, origin: Location, yearsActiveStart: Int, yearsActiveEnd: Option[Int]) |
        +----------------------------------------------------------------------------------------------------------------------+

        +-----------------------------------------------------------+
        | (artist.isActive || artist.yearsActiveEnd >= activeAfter) |
        | changed to                                                |
        | (artist.yearsActiveEnd.forall(_ >= activeAfter))          |   // forall returns true if the element inside the given Option(if the Option is Some) satisfies the condition
        +-----------------------------------------------------------+   // or if there is no element inside the Option (i.e. it is None)
        // if this represents a value, check if it satisfies the given condition, if there is no value, ignore the condition

    val year: Option[Int] = Some(996)
    val noYear: Option[Int] = None
    forall                          exists                          filter
    +-------------------------+     +-------------------------+     +-------------------------+
    | year.forall(_ < 2020)   |     | year.exists(_ < 2020)   |     | year.filter(_ < 2020)   |
    | -> true                 |     | -> true                 |     | -> Some(996)            |
    | noYear.forall(_ < 2020) |     | noYear.exists(_ < 2020) |     | noYear.filter(_ < 2020) |
    | -> true                 |     | -> false                |     | -> None                 |
    | year.forall(_ > 2020)   |     | year.exists(_ > 2020)   |     | year.filter(_ > 2020)   |
    | -> false                |     | -> false                |     | -> None                 |
    | noYear.forall(_ > 2020) |     | noYear.exists(_ > 2020) |     | noYear.filter(_ > 2020) |
    | -> true                 |     | -> false                |     | -> None                 |
    +-------------------------+     +-------------------------+     +-------------------------+

    +------------------------------------------------------------------------------------+
    | case class User(name: String, city: Option[String], favoriteArtists: List[String]) |
    |                                                                                    |
    | def f1(users: List[User]): List[User] = {                                          |
    |     users.filter(_.city.forall(_ == Melbourne))                                    |  // users that havent specified their city or live in Melbourne
    | }                                                                                  |
    | def f2(users: List[User]): List[User] = {                                          |
    |     users.filter(_.city.contains(Lagos))                                           |  // users that live in Lagos.
    | }                                                                                  |
    | def f3(users: List[User]): List[User] = {                                          |
    |     users.filter(_.favoriteArtists.contains(Bee Gees))                             |  // users that like Bee Gees.
    | }                                                                                  |
    | def f4(users: List[User]): List[User] = {                                          |
    |     users.filter(_.city.exists(_.startsWith(T)))                                   |  // users that live in cities that start with a letter T.
    | }                                                                                  |
    | def f5(users: List[User]): List[User] = {                                          |  // users that only like artists that have
    |     users.filter(_.favoriteArtists.forall(_.length > 8))                           |  // a name longer than 8 characters (or no favorite artists at all).
    | }                                                                                  |
    | def f6(users: List[User]): List[User] = {                                          |
    |     users.filter(_.favoriteArtists.exists(_.startsWith(M)))                        |  // users that like some artists whose names start with M.
    | }                                                                                  |
    +------------------------------------------------------------------------------------+

    - coupling a concept inside one case class (solve additional meaning of parameter combinations)
        +----------------------------------------------------------------------------------------------+
        | case class PeriodInYears(start: Int, end: Option[Int])                                       |    // yearsActiveStart and yearsActiveEnd represent one concept
        | case class Artist(name: String, genre: String, origin: Location, yearsActive: PeriodInYears) |
        | Artist("Led Zeppelin", "Hard Rock", Location("England"),PeriodInYears(1968, None))           |
        | Artist("Bee Gees",     "Pop",       Location("England"),PeriodInYears(1958, Some(2003)))     |
        +----------------------------------------------------------------------------------------------+

    - modeling finite possibilities (solve ensure that some parameters have finite set of values)
        +-------------------------------------------+
        | sealed trait MusicGenre                   |   // sum type (sealed trait). Type that can only take a finite set of values
        | case object HeavyMetal extends MusicGenre |   +---------------------------------+
        | case object Pop extends MusicGenre        |   | val genre: MusicGenre = Pop     | // Pop
        | case object HardRock extends MusicGenre   |   | val x: MusicGenre = HeavyMeta   | // compilation error!
        +-------------------------------------------+   | val y: MusicGenre = "HeavyMeta" | // compilation error!
        // better modeling with sealed traits           +---------------------------------+
        // sum types make sure value of its type is defined by us
        // sum types with case classes (product types) can model many concepts
        +--------------------------------------------------------------------------------------------------+
        | case class Artist(name: String, genre: MusicGenre, origin: Location, yearsActive: PeriodInYears) |
        +--------------------------------------------------------------------------------------------------+
        // lets improve PeriodInYears
        +--------------------------------------------------------+
        | case class PeriodInYears(start: Int, end: Option[Int]) |
        +--------------------------------------------------------+
                                                        // there are two cases of YearsActive(still active, or not)
        +-------------------------------------------+   // there are two options - use sealed trait
        | sealed trait MusicGenre                   |   +----------------------------------------------------------------------+   
        | case object HeavyMetal extends MusicGenre |   | sealed trait YearsActive                                             |
        | case object Pop extends MusicGenre        |   | case class StillActive(since: Int) extends YearsActive               |
        | case object HardRock extends MusicGenre   |   | case class ActiveBetween(start: Int, until: Int) extends YearsActive |
        +-------------------------------------------+   +----------------------------------------------------------------------+

        // last version
        +-------------------------------------------------------------------------------------+
        | Artist("Metallica",    ThrashMetal, Location("U.S."),    StillActive(1983))         |
        | Artist("Led Zeppelin", HardRock,    Location("England"), ActiveBetween(1968, 1980)) |
        +-------------------------------------------------------------------------------------+

    - using ADT-based models in behaviors (functions)
        - sealed trait - models a thing that may be one of many things at once
        - case class - models opposite - something that is one or many things at once (product types)
        - sum types and product types called ADT`s
        +------------------------------------------------------------------------------+        +-------------------------------------------------------------------------------------------------------+
        | sealed trait SearchCondition                                                 |        | def searchArtists(artists: List[Artist], requiredConditions: List[SearchCondition]): List[Artist] = { |
        | case class SearchByGenre(genres: List[MusicGenre]) extends SearchCondition   |        |   artists.filter(artist =>                                                                            |
        | case class SearchByOrigin(locations: List[Location]) extends SearchCondition |        |     requiredConditions.forall(condition =>                                                            |
        | case class SearchByActiveYears(start: Int, end: Int) extends SearchCondition |        |       condition match {                                                                               |
        +------------------------------------------------------------------------------+        |         case SearchByGenre(genres) => genres.contains(artist.genre)                                   |
          two parameters instead of seven, no raw types, no nested                              |         case SearchByOrigin(locations) => locations.contains(artist.origin)                           |
          if conditions, no boolean flags. Only the code that’s really needed                   |         case SearchByActiveYears(start, end) => wasArtistActive(artist, start, end)}))}               |
                                                                                                +-------------------------------------------------------------------------------------------------------+
        - ADT and inheritence diffs:
            1. ADT dont contain behaviour (in FP data is modeled using immutable values, behaviour - independent functions)
            2. when we define sealed trait - we mut provide all possible values of this type
        - In FP we define ADT and immutable types - data part
          Behavior part - create pure functions that use immutable types



####################
# IO as values
####################
    - requirment:                                                                       imperative solution
        having 2 persons, meeting length - find a common slot                           +-----------------------------------------------------------------------------------------+
        persist meeting in calendar                                                     | static MeetingTime schedule(String person1, String person2,int lengthHours) {           |
        should use impure functions calendarEntriesApiCall and createMeetingApiCall     |     List<MeetingTime> person1Entries = calendarEntriesApiCall(person1);                 |
        simulation API:                                                                 |     List<MeetingTime> person2Entries = calendarEntriesApiCall(person2);                 |
            // API call may return different results for the same argument              |     List<MeetingTime> scheduledMeetings = new ArrayList<>();                            |
            // API call may take too long to finish                                     |     scheduledMeetings.addAll(person1Entries);                                           | 
            // API call may fail with a connection (or another) error                   |     scheduledMeetings.addAll(person2Entries);                                           |
        +--------------------------------------------------------------------------+    |     List<MeetingTime> slots = new ArrayList<>();                                        |
        | class MeetingTime {                                                      |    |                                                                                         |  
        |     public final int startHour;                                          |    |     for (int startHour = 8; startHour < 16 - lengthHours + 1; startHour++) {            |    
        |     public final int endHour;                                            |    |         slots.add(new MeetingTime(startHour, startHour + lengthHours));                 |   
        |     MeetingTime(int startHour, int endHour) { ... }                      |    |     }                                                                                   |
        | }                                                                        |    |                                                                                         |
        | List<MeetingTime> calendarEntriesApiCall(String name) {                  |    |     List<MeetingTime> possibleMeetings = new ArrayList<>();                             |
        |     if (name.equals(Alice))                                              |    |     for (var slot : slots) {                                                            |
        |         return List.of(new MeetingTime(8, 10), new MeetingTime(11, 12)); |    |         var meetingPossible = true;                                                     |
        |     else if (name.equals(Bob)) return List.of(new MeetingTime(9, 10));   |    |         for (var meeting : scheduledMeetings) {                                         |
        |     else {                                                               |    |             if (slot.endHour > meeting.startHour && meeting.endHour > slot.startHour) { |
        |         Random rand = new Random();                                      |    |             meetingPossible = false;                                                    |
        |         return List.of(                                                  |    |             break;                                                                      |
        |             new MeetingTime(rand.nextInt(5) + 8, rand.nextInt(4) + 13)); |    |             }                                                                           |
        |     }                                                                    |    |         }                                                                               |
        | }                                                                        |    |         if (meetingPossible) {                                                          |
        | void createMeetingApiCall(List<String> names, MeetingTime meetingTime)   |    |         possibleMeetings.add(slot);                                                     |
        +--------------------------------------------------------------------------+    |         }                                                                               |       
    imperative problems                                                                 |     }                                                                                   |
    - The function has at least two responsibilities                                    |     if (!possibleMeetings.isEmpty()) {                                                  |
        calls external APIs plus it finds a free slot                                   |         createMeetingApiCall(List.of(person1, person2),possibleMeetings.get(0));        |
    - If any of the three external API calls fails, the whole function fails            |         return possibleMeetings.get(0);                                                 |
    - Signature lies                                                                    |     } else return null;                                                                 |
                                                                                        | }                                                                                       |
                                                                                        +-----------------------------------------------------------------------------------------+
    - handle IO imperatively
        -retry
        -other options: more retries, using a cached value, using a default value (fallback) or retrying after some backoff period to name a few
        +-------------------------------------------------------+
        | List<MeetingTime> person1Entries = null;              |   // we shouldnt care about recovery strategy inside the schedule function
        | try {                                                 |   // retry should not be entangled in business code
        |     person1Entries = calendarEntriesApiCall(person1); |
        | } catch(Exception e) {                                |
        | // retry                                              |
        |     person1Entries = calendarEntriesApiCall(person1); |
        | }                                                     |
        +-------------------------------------------------------+

    - IO values
        IO - we’ll do, however, is wrap this external, impure, side-effectful function within a function that returns IO
        - unsafe function   
        +--------------------------------------------------------------+
        | static List<MeetingTime> calendarEntriesApiCall(String name) |
        +--------------------------------------------------------------+
        - wrapped
        +--------------------------------------------------------------+
        | def calendarEntries(name: String): IO[List[MeetingTime]] = { |
        |     IO.delay(calendarEntriesApiCall(name))                   |
        | }                                                            |
        +--------------------------------------------------------------+              
        - example function with side effect
        +--------------------------------------------+  castTheDieImpure()
        | static int castTheDieImpure() {            |      The die is cast     // prints a side effect
        |     System.out.println(ôThe die is castö); |      3
        |     Random rand = new Random();            |  - wrap in IO
        |     return rand.nextInt(6) + 1;            |  +----------------------------------------------------------+
        | }                                          |  | def castTheDie(): IO[Int] = IO.delay(castTheDieImpure()) |
        +--------------------------------------------+  | castTheDie()                                             |
        - IO delay did not execute the code             |     IO[Int]                                              |
        - responsobility to run the code is delegated   +----------------------------------------------------------+

        - running IO
        +-------------------------------------+
        | val dieCast: IO[Int] = castTheDie() | // IO values, just like Lists, Options and Eithers can be transformed using pure functions
        |     dieCast: IO[Int]                |
        | dieCast.unsafeRunSync()             | // usually only once, at the end of our program
        |     The die is cast                 |
        |     3                               |                     
        +-------------------------------------+                     +-----------------------------------------------------+
                                                                    | static int castTheDieImpure() {                     |
        - cast die twice and return result of it                    |     System.out.println(ôThe die is castö);          |
        +-----------------------------------------+ if exception -> |     Random rand = new Random();                     |    
        | castTheDieImpure() + castTheDieImpure() |                 |     if(rand.nextBoolean())                          |
        |     The die is cast                     |                 |         throw new RuntimeException(ôDie fell offö); |
        |     The die is cast                     |                 |     return rand.nextInt(6) + 1;                     |
        |     9                                   |                 | }                                                   |    
        +-----------------------------------------+                 +-----------------------------------------------------+    
        - we just want to implement business logic                      +---------------------------+
            // get two numbers and if they exist sum                    | Some(2) + Some(4)         |
            // IO[int] does not have addition                           |     compilation error!    |
        +----------------------------------------------------------+ -> | val result: Option[Int] = |    
        | def castTheDie(): IO[Int] = IO.delay(castTheDieImpure()) |    |     for {                 |
        |     def castTheDie(): IO[Int]                            |    |         a <- aOption      |
        | castTheDie() + castTheDie()                              |    |         b <- bOption      |   // result Some(6)
        |     compilation error!                                   |    |     } yield a + b         |   // but could be None 
        +----------------------------------------------------------+    +---------------------------+   // if either is None
        - IO has flatMap
        +--------------------------------------+
        | def castTheDieTwice(): IO[Int] = {   |
        |     for {                            |
        |         firstCast <- castTheDie()    |
        |         secondCast <- castTheDie()   |    // result is IO
        |     } yield firstCast + secondCast}  |    // to be executed in other place
        +--------------------------------------+          

        - combining IO
        +------------------------------------------------------------------------------------+
        | def calendarEntries(name: String): IO[List[MeetingTime]] = {                       |
        |     IO.delay(calendarEntriesApiCall(name))                                         |  // describes an input action (reads a value)
        | }                                                                                  |
        | def createMeeting(names: List[String], meeting: MeetingTime): IO[Unit] = {         |
        |     IO.delay(createMeetingApiCall(names, meeting))                                 |  // IO[Unit] means that it's an output action (writes a value).
        | }                                                                                  |
        | def scheduledMeetings(person1: String, person2: String): IO[List[MeetingTime]] = { |
        | for {                                                                              |
        |     person1Entries <- calendarEntries(person1)                                     |
        |     person2Entries <- calendarEntries(person2)                                     |
        | } yield person1Entries.appendedAll(person2Entries)}                                |
        +------------------------------------------------------------------------------------+  

        - Disentangling concerns by working with values only
            when we wrap impure function with IO - we do not execute it
            if we want to use a function that returns an IO inside a new function, we are forced to return an IO value

        - problem 1. IO solved problem 1: The function has at least two responsibilitiesmple
            function describes a program that will execute so IO actions                                                                    - execution
        +-------------------------------------------------------------------------------------------------------------------------------+   +-------------------------------------------+
        | def meetingsOverlap(meeting1: MeetingTime, meeting2: MeetingTime): Boolean = {                                                |   | val program = schedule("Alice", "Bob", 1) |
        |     meeting1.endHour > meeting2.startHour && meeting2.endHour > meeting1.startHour                                            |   |     IO[Option[MeetingTime]]               |
        | }                                                                                                                             |   | program.unsafeRunSync()                   |
        |                                                                                                                               |   |     Some(MeetingTime(10, 11))             |
        | def possibleMeetings(existingMeetings: List[MeetingTime],startHour: Int,endHour: Int,lengthHours: Int): List[MeetingTime] = { |   +-------------------------------------------+
        |     val slots = List.range(startHour, endHour - lengthHours + 1)                                                              |
        |         .map(startHour => MeetingTime(startHour, startHour + lengthHours))                                                    |   - current solution
        |     slots.filter(slot =>existing.forall(meeting => !meetingsOverlap(meeting, slot)))                                          |   +--------------------------------------------------------------------------------+
        | }                                                                                                                             |   | def calendarEntries(name: String): IO[List[MeetingTime]]                       |
        |                                                                                                                               |   |                                                                                |
        | def schedule(person1: String, person2: String, lengthHours: Int): IO[Option[MeetingTime]] = {                                 |   | def createMeeting(names: List[String], meeting: MeetingTime): IO[Unit]         |
        |     for {                                                                                                                     |   |                                                                                |
        |         existingMeetings <- scheduledMeetings(person1, person2)                                                               |   | def scheduledMeetings(person1: String, person2: String): IO[List[MeetingTime]] |
        |         meetings = possibleMeetings(existingMeetings, 8, 16, lengthHours)                                                     |   +--------------------------------------------------------------------------------+
        |     } yield meetings.headOption                                                                                               |
        | }                                                                                                                             |
        +-------------------------------------------------------------------------------------------------------------------------------+        

        - problem 2 - if external API calls fail
        -imperative solution                                                                        - error recovery (retry)
            // may fail                                                                             implementation should not entangle with business logic
        +--------------------------------------------------------------------------------------+    +-----------------------------------------------------------+    
        | List<MeetingTime> calendarEntriesApiCall(String name) {                              |    | List<MeetingTime> person1Entries = null;                  |
        |     Random rand = new Random();                                                      |    |     try {                                                 |
        |     if (rand.nextFloat() < 0.25)                                                     |    |         person1Entries = calendarEntriesApiCall(person1); |
        |         throw new RuntimeException("Connection error");                              |    |     } catch(Exception e) {                                |
        |     if (name.equals(ôAliceö))                                                        |    |         person1Entries = calendarEntriesApiCall(person1); |
        |         return List.of(new MeetingTime(8, 10), new MeetingTime(11, 12));             |    | }                                                         |
        |     else if (name.equals(ôBobö)) return List.of(new MeetingTime(9, 10));             |    +-----------------------------------------------------------+
        |     else return List.of(new MeetingTime(rand.nextInt(5) + 8, rand.nextInt(4) + 13)); |
        | }                                                                                    |
        +--------------------------------------------------------------------------------------+

        - IO.orElse
            IO non successfull case is fail
            IO.delay    // lazy                             val program = IO.pure(2021).orElse(IO.delay(throw new Exception()))     // will not get to exception
            IO.pure(42) // eagar - evaluated immediately    val program = IO.pure(2021).orElse(IO.pure(throw new Exception())       // exception thrown

            val year: IO[Int] = IO.delay(996)
            val noYear: IO[Int] = IO.delay(throw new Exception("no year"))
            +---------------------------------------------------------------------------+   +--------------------------------------------+
            | val program1 = year.orElse(IO.delay(2020))                                |   | program1.unsafeRunSync()                   |
            | -> IO[Int]                                                                |   | -> 996                                     |
            | val program2 = noYear.orElse(IO.delay(2020))                              |   | program2.unsafeRunSync()                   |
            | -> IO[Int]                                                                |   | -> 2020                                    |
            | val program3 = year.orElse(IO.delay(throw new Exception(cant recover)))   |   | program3.unsafeRunSync()                   |
            | -> IO[Int]                                                                |   | -> 996                                     |
            | val program4 = noYear.orElse(IO.delay(throw new Exception(cant recover))) |   | program4.unsafeRunSync()                   |
            | -> IO[Int]                                                                |   | -> Exception in thread main: cant recover  |
            +---------------------------------------------------------------------------+   +--------------------------------------------+

        - one retry strategy
            +-----------------------------------------------------------+
            | calendarEntries("Alice").orElse(calendarEntries("Alice")) |
            +-----------------------------------------------------------+
        - fallback strtegy
            +---------------------------------------+
            | calendarEntries("Alice")              |
            |     .orElse(calendarEntries("Alice")) |
            |     .orElse(IO.pure(List.empty))      |   // evaluated eagerly, will always succeed
            +---------------------------------------+

        - cast the die
            +-------------------------------------------------------------------------+ +-----------------------------------------------------------+
            | static int castTheDie() {                                               | | IO.delay(castTheDie()).orElse(IO.pure(0))                 |   // fail - return 0
            |     Random rand = new Random();                                         | |                                                           |
            |     if (rand.nextBoolean()) throw new RuntimeException("Die fell off"); | | IO.delay(drawAPointCard()).orElse(IO.delay(castTheDie())) |   // draw fails - roll the dice
            |     return rand.nextInt(6) + 1;                                         | |                                                           |
            | }                                                                       | | IO.delay(castTheDie())                                    |   // retry once, still fail - return 0
            | static int drawAPointCard() {                                           | |     .orElse(IO.delay(castTheDie()))                       |
            |     Random rand = new Random();                                         | |     .orElse(IO.pure(0))                                   |
            |     if (rand.nextBoolean()) throw new RuntimeException("No cards");     | |                                                           |
            |     return rand.nextInt(14) + 1;                                        | | for {                                                     |   // cast dice - fallback 0
            | }                                                                       | |     die <- IO.delay(castTheDie()).orElse(IO.pure(0))      |   // draw card - fallback 0
            +-------------------------------------------------------------------------+ |     card <- IO.delay(drawAPointCard()).orElse(IO.pure(0)) |   // sum both
                                                                                        | } yield die + card                                        |
                                                                                        |                                                           |
                                                                                        | (for {                                                    |   // draw and cast dice twice
                                                                                        |     card <- IO.delay(drawAPointCard())                    |   // sum 3 or return 0 if any fails
                                                                                        |     die1 <- IO.delay(castTheDie())                        |
                                                                                        |     die2 <- IO.delay(castTheDie())                        |
                                                                                        | } yield card + die1 + die2).orElse(IO.pure(0))            |
                                                                                        +-----------------------------------------------------------+
        - functionl solution
            option 1                                                            option 2                                                                                option 3
            +--------------------------------------------------------------+    +-----------------------------------------------------------------------------------+   +----------------------------------------------------------------------------------------------+
            | def calendarEntries(name: String): IO[List[MeetingTime]] = { |    | def scheduledMeetings(person1: String,person2: String): IO[List[MeetingTime]] = { |   | def schedule(person1: String, person2: String,lengthHours: Int): IO[Option[MeetingTime]] = { |
            |     IO.delay(calendarEntriesApiCall(name))                   |    |     for {                                                                         |   |     for {                                                                                    |
            |         .orElse(IO.delay(calendarEntriesApiCall(name)))      |    |         person1Entries <- calendarEntries(person1)                                |   |         existingMeetings <- scheduledMeetings(person1, person2)                              |
            |         .orElse(IO.pure(List.empty))                         |    |             .orElse(calendarEntries(person1))                                     |   |             .orElse(scheduledMeetings(person1, person2))                                     |
            | }                                                            |    |             .orElse(IO.pure(List.empty))                                          |   |             .orElse(IO.pure(List.empty))                                                     |
            +--------------------------------------------------------------+    |         person2Entries <- calendarEntries(person2)                                |   |         meetings = possibleMeetings(existingMeetings, 8, 16, lengthHours)                    |
                                                                                |             .orElse(calendarEntries(person2))                                     |   |     } yield meetings.headOption                                                              |             
                                                                                |             .orElse(IO.pure(List.empty))                                          |   | }                                                                                            |
                                                                                |     } yield person1Entries.appendedAll(person2Entries)                            |   +----------------------------------------------------------------------------------------------+
                                                                                | }                                                                                 |
                                                                                +-----------------------------------------------------------------------------------+

        - problem 3 - signature lies

        - Functional architecture
            functional core should be pure
            push impurity out of functional core

        - write action
            // in for comprehension each step is done in sequence. if prev step succeeded
            +-------------------------------------------------------------------------------------------------------+
            | def schedulingProgram(getName: IO[String],showMeeting: Option[MeetingTime] => IO[Unit]): IO[Unit] = { |   // inject getName, showMeeting
            |     for {                                                                                             |
            |         name1 <- getName                                                                              |   // get name from outside
            |         name2 <- getName                                                                              |
            |         possibleMeeting <- schedule(name1, name2, 2)                                                  |   // schedule returns IO[Option[MeetingTime]]
            |         _ <- showMeeting(possibleMeeting)                                                             |   // flatMap will extract it to Option[MeetingTime]
            |     } yield ()                                                                                        |   // produces IO[Unit]
            | }                                                                                                     |
            +-------------------------------------------------------------------------------------------------------+    
            //usage
            +---------------------------------------------------------------------------+
            | static void consolePrint(String message) { System.out.println(message); } |
            | static String consoleGet() { return new Scanner(System.in).nextLine(); }  |
            | schedulingProgram(                                                        |
            |     IO.delay(consoleGet()),                                               |
            |     meeting => IO.delay(consolePrint(meeting.toString))                   |
            | ).unsafeRunSync()                                                         |
            +---------------------------------------------------------------------------+   

        - final version
            +-----------------------------------------------------------------------------------------------+
            | def schedule(person1: String, person2: String, lengthHours: Int): IO[Option[MeetingTime]] = { |
            |     for {                                                                                     |
            |         existingMeetings <- scheduledMeetings(person1, person2)                               |
            |             .orElse(scheduledMeetings(person1, person2))                                      |
            |             .orElse(IO.pure(List.empty))                                                      |
            |         meetings = possibleMeetings(existingMeetings, 8, 16, lengthHours)                     |   // create value based of type List[MeetingTime] (not IO)
            |         possibleMeeting = meetings.headOption                                                 |   // get first wrapped in Some or None
            |         _ <- possibleMeeting match {                                                          |   // pattern match Option[MeetingTime]
            |             case Some(meeting) => createMeeting(List(person1, person2), meeting)              |   // both cases should return IO[Unit]
            |             case None => IO.unit // same as IO.pure(())                                       |
            |         }                                                                                     |
            |     } yield possibleMeeting                                                                   |
            | }                                                                                             |
            +-----------------------------------------------------------------------------------------------+                                                       


####################
# Streams as values
####################
    - problem: currency exchange when rate is trending (0.81, 0.82, 0.85), given exchangeTable API which fetch given cur to all other curs
        example: users wants to exhange 1000 USD to EUR but only when 3 prev rates are increasing (trending)

    - using only IO
        as FP devs we will use:
        1. value class
            +--------------------------------------------------+
            | case class Currency(name: String) extends AnyVal |
            +--------------------------------------------------+
        2. external data available through input IO action
            +------------------------------------------------------------------+
            | def exchangeTable(from: Currency): IO[Map[Currency, BigDecimal]] |
            +------------------------------------------------------------------+
        3. bottom-up approach (start implementing small functions)
            function to decide whether seq is trending
            +----------------------------------------------------------------------------+              +--------------------------------------------------------------+
            | def trending(rates: List[BigDecimal]): Boolean                             |  //          | def trending(rates: List[BigDecimal]): Boolean = {           |
            | trending(List.empty)                                                       |  // false    |     rates.size > 1 &&                                        |
            | trending(List(BigDecimal(1), BigDecimal(2), BigDecimal(3), BigDecimal(8))) |  // true     |     rates.zip(rates.drop(1))                                 |
            | trending(List(BigDecimal(1), BigDecimal(4), BigDecimal(3), BigDecimal(8))) |  // false    |         .forall(ratePair => ratePair match {                 |
            +----------------------------------------------------------------------------+              |             case (previousRate, rate) => rate > previousRate |
                                                                                                        |         })                                                   |
                                                                                                        | }                                                            |
                                                                                                        +--------------------------------------------------------------+
            function to extract single currency from table                              v1                                                                      v2
            +-----------------------------------------------------------------------+   +--------------------------------------------------------------------+  +----------------------------------------------------------------+  
            | val usdExchangeTables = List(                                         |   | def extractSingleCurrencyRate(currencyToExtract: Currency)         |  | def extractSingleCurrencyRate(currencyToExtract: Currency)     |
            |     Map(Currency(“EUR”) -> BigDecimal(0.82)),                         |   |     (table: Map[Currency, BigDecimal]): Option[BigDecimal] = {     |  |     (table: Map[Currency, BigDecimal]): Option[BigDecimal] = { |
            |     Map(Currency(“EUR”) -> BigDecimal(0.83)),                         |   |         table.filter(kv => kv match {                              |  |         table.get(currencyToExtract)                           |
            |     Map(Currency(“JPY”) -> BigDecimal(104))                           |   |             case (currency, rate) => currency == currencyToExtract |  | }                                                              |
            | )                                                                     |   |         }).values.headOption                                       |  +----------------------------------------------------------------+
            | usdExchangeTables.map(extractSingleCurrencyRate(Currency(“EUR”))))    |   |     }                                                              |
            | // List(Some(BigDecimal(0.82)), Some(BigDecimal(0.83)), None)         |   +--------------------------------------------------------------------+   
            +-----------------------------------------------------------------------+

        4. linking all together
            +-----------------------------------------------------------------------+   +------------------------------------------------------------------------------------------------------+
            | def lastRates(from: Currency, to: Currency): IO[List[BigDecimal]] = { |   | def exchangeIfTrending(amount: BigDecimal, from: Currency, to: Currency): IO[Option[BigDecimal]] = { |
            |     for {                                                             |   |     lastRates(from, to).map(rates => if (trending(rates)) Some(amount * rates.last) else None)       |
            |         table1 <- retry(exchangeTable(from), 10)                      |   | }                                                                                                    |
            |         table2 <- retry(exchangeTable(from), 10)                      |   +------------------------------------------------------------------------------------------------------+
            |         table3 <- retry(exchangeTable(from), 10)                      |
            |         lastTables = List(table1, table2, table3)                     |
            |     } yield lastTables.flatMap(extractSingleCurrencyRate(to))         |
            | }                                                                     |
            +-----------------------------------------------------------------------+
        problem - we fetch 3 table and make a decision, instead we would like to fetch thousands of tables and make a decision when its trending

    - using IO with recursion
        // possible when you call unsafeRunSync the IO value returned that it will run infinitely
        +------------------------------------------------------------------------------------------------------+    +----------------------------------------------------------------------------------------------+
        | def exchangeIfTrending(amount: BigDecimal, from: Currency, to: Currency): IO[Option[BigDecimal]] = { |    | def exchangeIfTrending(amount: BigDecimal, from: Currency, to: Currency): IO[BigDecimal] = { |    
        |     for {                                                                                            |    |     for {                                                                                    |
        |         rates <- lastRates(from, to)                                                                 |    |         rates <- lastRates(from, to)                                                         |
        |         result <- if (trending(rates)) IO.pure(Some(amount * rates.last))                            |    |         result <- if (trending(rates)) IO.pure(amount * rates.last)                          |
        |                     else exchangeIfTrending(amount, from, to)                                        |    |         else exchangeIfTrending(amount, from, to)                                            |
        |     } yield result                                                                                   |    |     } yield result                                                                           |
        | }                                                                                                    |    | }                                                                                            |
        +------------------------------------------------------------------------------------------------------+    +----------------------------------------------------------------------------------------------+

        - change lastRates to make arbitrary number of calls
        v1                                                                                  v2
        +-------------------------------------------------------------------------------+   +-------------------------------------------------------------------------------+
        | def lastRates(from: Currency, to: Currency, n: Int): IO[List[BigDecimal]] = { |   | def lastRates(from: Currency, to: Currency, n: Int): IO[List[BigDecimal]] = { |
        |     List.range(0, n).map(_ => currencyRate(from, to)).sequence                |   |     if (n < 1) {                                                              |
        | }                                                                             |   |     IO.pure(List.empty)                                                       |
        +-------------------------------------------------------------------------------+   |     } else {                                                                  ||     for {                                                                     |
                                                                                            |         currencyRate <- currencyRate(from, to)                                |
                                                                                            |         remainingRates <- if (n == 1) IO.pure(List.empty)                     |
                                                                                            |         else lastRates(from, to, n - 1)                                       |
                                                                                            |     } yield remainingRates.prepended(currencyRate)                            |
                                                                                            |     }                                                                         |
                                                                                            | }                                                                             |
                                                                                            +-------------------------------------------------------------------------------+
        -problem - it fetces n rates and makes a decision but we need a sliding windows

    - using IO with Streams
        -data streams
            // one function should be responsible for fetching something
            // one function should be responsible for timeouts, delays between calls, retries

        -streams in imperative languages
            // executed only after usig a termina operation                         // lazy infinite stream
            +------------------------------------------------------------------+    +---------------------------------------------------------------------------------+
            | Stream<Integer> numbers = Stream.of(1, 2, 3);                    |    | Stream<Integer> infiniteNumbers = Stream.iterate(0, i -> i + 1);                |
            | static Stream<Integer> oddNumbers(Stream<Integer> numbers) {     |    | Stream<Integer> infiniteOddNumbers = oddNumbers(infiniteNumbers);               |
            |     return numbers.filter(n -> n % 2 != 0);                      |    | // infiniteOddNumbers.collect(Collectors.toList());                             |
            | }                                                                |    | Stream<Integer> limitedStream = infiniteOddNumbers.limit(3);                    |
            | Stream<Integer> oddNumbers = oddNumbers(numbers);                |    | List<Integer> limitedResult = limitedStream.collect(Collectors.toList());       |
            | List<Integer> result = oddNumbers.collect(Collectors.toList());  |    +---------------------------------------------------------------------------------+
            +------------------------------------------------------------------+
        
        - functional stream
            +----------------------------------------------------------+    +---------------------------------------+   +---------------------------------------+   +-------------------------------+
            | import fs2.Stream                                        |    | val stream1 = Stream(1, 2, 3)         |   | val stream4 = stream1.append(stream1) |   | val stream5 = stream4.take(4) |
            | val numbers = Stream(1, 2, 3)                            |    | val stream2 = Stream(4, 5, 6)         |   | stream4.toList                        |   | stream5.toList                |
            | val oddNumbers = numbers.filter(_ % 2 != 0)              |    | val stream3 = stream1.append(stream2) |   | // List(1, 2, 3, 1, 2, 3)             |   | // List(1, 2, 3, 1)           |
            | oddNumbers.toList                       // List(1, 3)    |    | stream3.toList                        |   +---------------------------------------+   +-------------------------------+
            | numbers.toList                          // List(1, 2, 3) |    | // List(1, 2, 3, 4, 5, 6)             |
            | oddNumbers.map(_ + 17).take(1).toList   // List(18)      |    +---------------------------------------+
            +----------------------------------------------------------+
            -recursive stream                           -stream functions
            +---------------------------------------+   +--------------------------------------+        +------------------------------------------------------+
            | def numbers(): Stream[Pure, Int] = {  |   | val numbers = Stream(1, 2, 3).repeat |        | Stream(1).repeat.take(3).toList                      |    // 1,1,1
            |     Stream(1, 2, 3).append(numbers()) |   | numbers.take(8).toList               |        | Stream(1).append(Stream(0, 1).repeat).take(4).toList |    // 1,0,1,0
            | }                                     |   | // List(1, 2, 3, 1, 2, 3, 1, 2)      |        | Stream(2).map(_ * 13).repeat.take(1).toList          |    // 26
            | val infinite123s = numbers()          |   +--------------------------------------+        | Stream(13).filter(_ % 2 != 0).repeat.take(2).toList  |    // 13, 13
            | infinite123s.take(8).toList           |   // repeat call append and itself recursively    +------------------------------------------------------+
            | // List(1, 2, 3, 1, 2, 3, 1, 2)       |
            +---------------------------------------+

        // we can have streams of IO values that will be automatically executed, on demand, when someone else consumes elements from the stream
            // delays execution of side effect                              // if we dont know upfront how many times we need to roll dice
            // we can now use it in for comprhension to call it twice, etc  // cast the die until we get 6
            +----------------------------------------------------------+    +---------------------------------------------------------------+
            | static int castTheDieImpure() {                          |    | val dieCast: Stream[IO, Int] = Stream.eval(castTheDie())      |   // stream of a single IO value, eval executes IO when consumer requests
            |     System.out.println(“The die is cast”);               |    | val oneDieCastProgram: IO[List[Int]] = dieCast.compile.toList |   // .compile.toList on the dieCast stream, we transform it to another value: IO[List[Int]]
            |     Random rand = new Random();                          |    +---------------------------------------------------------------+
            |     return rand.nextInt(6) + 1;                          |    +-----------------------------------+
            | }                                                        |    | oneDieCastProgram.unsafeRunSync() |
            | def castTheDie(): IO[Int] = IO.delay(castTheDieImpure()) |    | The die is cast                   |    
            +----------------------------------------------------------+    | // List(4)                        |
                                                                            +-----------------------------------+
        -infinite stream of IO based values
            // will run infinitely
            +------------------------------------------------------------------------------+    +------------------------------------------------------------------------------+
            | val infiniteDieCasts: Stream[IO, Int] = Stream.eval(castTheDie()).repeat     |    | val firstThreeCasts: IO[List[Int]] = infiniteDieCasts.take(3).compile.toList |
            | val infiniteDieCastsProgram: IO[List[Int]] = infiniteDieCasts.compile.toList |    | firstThreeCasts.unsafeRunSync()                                              |
            |//val infiniteDieCastsProgram: IO[Unit] = infiniteDieCasts.compile.drain      |    | The die is cast                                                              |
            | infiniteDieCastsProgram.unsafeRunSync()                                      |    | The die is cast                                                              |    
            +------------------------------------------------------------------------------+    | The die is cast                                                              |
                                                                                                | //List(6, 2, 6)                                                              |
                                                                                                +------------------------------------------------------------------------------+
            // filter
            +---------------------------------------------------------------------------------+
            | val six: IO[List[Int]] = infiniteDieCasts.filter(_ == 6).take(1).compile.toList |
            | six.unsafeRunSync()                                                             |
            | The die is cast                                                                 |
            | The die is cast                                                                 |
            | The die is cast                                                                 |
            | The die is cast                                                                 |
            | //List(6)                                                                       |
            +---------------------------------------------------------------------------------+

        - original problem
            // need to have a sliding windows
            // need to put timeouts between calls

            - infinite stream of exchange tables
            +---------------------------------------------------------------------+
            | def rates(from: Currency, to: Currency): Stream[IO, BigDecimal] = { |
            |     Stream.eval(exchangeTable(from))                                | // Stream.eval function to create a single-element stream that uses the provided IO action to produce a single BigDecimal
            |         .repeat                                                     | // make stream infinite
            |         .map(extractSingleCurrencyRate(to))                         | // map each value in a stream to extract a single rate
            |         .unNone                                                     | // filtering nones from a stream of options
            | }                                                                   |
            +---------------------------------------------------------------------+

            - exception handling
            +----------------------------------------------------------------------------------------------------------------------------------+
            | val year: Stream[IO, Int] = Stream.eval(IO.pure(996))                                                                            |
            | val noYear: Stream[IO, Int] = Stream.raiseError[IO](new Exception("no year"))                                                    |
            |                                                                                                                                  |
            | val stream1 = year.orElse(Stream.eval(IO.delay(2020)))                              // Stream[IO, Int]                           |
            | val stream2 = noYear.orElse(Stream.eval(IO.delay(2020)))                            // Stream[IO, Int]                           |
            | val stream3 = year.orElse(Stream.raiseError[IO](new Exception("can't recover")))    // Stream[IO, Int]                           |
            | val stream4 = noYear.orElse(Stream.raiseError[IO](new Exception("can't recover")))  // Stream[IO, Int]                           |
            | stream1.compile.toList.unsafeRunSync()                                              // 996                                       |
            | stream2.compile.toList.unsafeRunSync()                                              // 2020                                      |
            | stream3.compile.toList.unsafeRunSync()                                              // 996                                       |
            | stream4.compile.toList.unsafeRunSync()                                              // Exception in thread "main": can't recover |
            +----------------------------------------------------------------------------------------------------------------------------------+

            - rates with error handling                                                             - if we want 3 - take 3
            // dont fail recover with the given fallback stream (which is exactly the same one)
            +---------------------------------------------------------------------+                 +--------------------------------------------------------------------------------------+
            | def rates(from: Currency, to: Currency): Stream[IO, BigDecimal] = { |                 | val firstThreeRates = rates(Currency(“USD”), Currency(“EUR”)).take(3).compile.toList |
            |     Stream.eval(exchangeTable(from))                                |                 | // O[List[BigDecimal]]                                                               |
            |         .repeat                                                     |                 +--------------------------------------------------------------------------------------+
            |         .map(extractSingleCurrencyRate(to))                         |
            |         .unNone                                                     |
            |         .orElse(rates(from, to))                                    | 
            | }                                                                   |
            +---------------------------------------------------------------------+

            -sliding window
            +----------------------------------------------------------------------------------------------+                                                    // rates
            | def exchangeIfTrending(amount: BigDecimal, from: Currency, to: Currency): IO[BigDecimal] = { |                                                    +------+    +------+    +------+    +------+
            |     rates(from, to)                                                                          |                                                    | 0.86 | -> | 0.78 | -> | 0.80 | -> | 0.87 |
            |         .sliding(3)                                                                          |    // sliding windows of 3 rates (uses a Queue)    +------+    +------+    +------+    +------+
            |         .map(_.toList)                                                                       |                                                    // sliding
            |         .filter(trending)                                                                    |    // Stream[IO, List[BigDecimal]]                 +----------------+    +----------------+
            |         .map(_.last)                                                                         |                                                    | 0.86 0.78 0.80 | -> | 0.78 0.80 0.87 |
            |         .take(1)                                                                             |                                                    +----------------+    +----------------+
            |         .compile                                                                             |                                                    // .filter(trending)
            |         .lastOrError                                                                         |                                                    +----------------+
            |         .map(_ * amount)                                                                     |                                                    | 0.78 0.80 0.87 |
            | }                                                                                            |                                                    +----------------+
            +----------------------------------------------------------------------------------------------+                                                    //.map(_.last)
            - waiting between calls
            // ticks is a Stream value that represents a stream that emits Unit values (()) every 1 second, once executed
            +-----------------------------------------------------+
            | val firstThreeRates: IO[List[(BigDecimal, Unit)]] = |
            |     rates(Currency(“USD”), Currency(“EUR”))         |
            |         .zip(ticks).take(3).compile.toList          | // When we zip two streams, we need to wait for an element from both streams to produce an element of the combined stream
            |         firstThreeRates.unsafeRunSync()             |
            | // List((0.80,()), (0.79,()), (0.82,()))            |
            +-----------------------------------------------------+

            - zip strems
            +----------------------------------------------------------------------------------------------+
            | def exchangeIfTrending(amount: BigDecimal, from: Currency, to: Currency): IO[BigDecimal] = { |
            |     rates(from, to)                                                                          |
            |         .zipLeft(ticks)                                                                      |
            |         .sliding(3)                                                                          |
            |         .map(_.toList)                                                                       |
            |         .filter(trending)                                                                    |
            |         .map(_.last)                                                                         |
            |         .take(1)                                                                             |
            |         .compile                                                                             |
            |         .lastOrError                                                                         |
            |         .map(_ * amount)                                                                     |
            | }                                                                                            |
            +----------------------------------------------------------------------------------------------+
           
         
####################
# Concurrent Programs
####################
    - task: gathers tourist "check-ins" in cities, provides ranking of cities
        1. process a stream of check-ins from people (a Stream[IO, City])
        2. program should allow to get the current top three cities ranking, while the check-ins are still being processed

    - model
    +---------------------------------------------------------------+
    | case class City(name: String) extends AnyVal                  |
    | case class CityStats(city: City, checkIns: Int)               |   // check-ins counter for a given City
    | def processCheckIns(checkIns: Stream[IO, City]): IO[Unit]     |   // function that processes each check-in one-by-one and produces a current ranking
    +---------------------------------------------------------------+   // function should return a program which, once executed, prints seven ranking updates (including the first, empty ranking) to the console and returns a Unit value: ()
    
    - step 1: Sequential IOs
    // sequantial thinking                                                                                                    
    +----------------------------------+                                                                                        +---------------------------------------------------------------------------------------------+
    | val checkIns: Stream[IO, City] = |    // stream to test solution                                                          | processCheckIns(checkIns).unsafeRunSync()                                                   |
    |     Stream(                      |    // checkIns is a Stream of six programs that will return cities when executed       | List()                                                                                      |
    |         City(“Sydney”),          |    // programs will be evaluated in the given order                                    | List(CityStats(City(Sydney),1))                                                             |
    |         City(“Sydney”),          |                                                                                        | List(CityStats(City(Sydney),2))                                                             |
    |         City(“Cape Town”),       |                                                                                        | List(CityStats(City(Sydney),2), CityStats(City(Cape Town),1))v                              |
    |         City(“Singapore”),       |                                                                                        | List(CityStats(City(Sydney),2), CityStats(City(Singapore),1), CityStats(City(Cape Town),1)) |
    |         City(“Cape Town”),       |                                                                                        | List(CityStats(City(Cape Town),2), CityStats(City(Sydney),2), CityStats(City(Singapore),1)) |
    |         City(“Sydney”)           |                                                                                        | List(CityStats(City(Sydney),3), CityStats(City(Cape Town),2), CityStats(City(Singapore),1)) |
    |     ).covary[IO]                 |    // covary transforms a Stream of pure values into a stream of IO-based values       | ()                                                                                          |
    +----------------------------------+                                                                                        +---------------------------------------------------------------------------------------------+

    // first version (bad: more elements in map - more to sort)
    // map to list, tuple to CityStats, sort, take 3                        // going through a stream and accumulating values                   // after .map(topCities) - we have Stream of List[City]
    +------------------------------------------------------------------+    // use scan to accumulate as a Map[City, Int]                       // use foreach function that takes an IO value describing a program that needs
    | def topCities(cityCheckIns: Map[City, Int]): List[CityStats] = { |    +---------------------------------------------------------------+      to be executed for each element of the stream
    |     cityCheckIns.toList                                          |    | checkIns.scan(Map.empty[City, Int])((cityCheckIns, city) => { |   //
    |         .map {                                                   |    |     val newCheckIns = cityCheckIns.get(city) match {          |   +----------------------------------------------------------------------+
    |             case (city, checkIns) => CityStats(city, checkIns)   |    |         case None => 1                                        |   | def processCheckIns(checkIns: Stream[IO, City]): IO[Unit] = {        |
    |         }                                                        |    |         case Some(checkIns) => checkIns + 1                   |   |     checkIns.scan(Map.empty[City, Int])((cityCheckIns, city) =>      |
    |         .sortBy(_.checkIns)                                      |    |     }                                                         |   |         cityCheckIns.updatedWith(city)(_.map(_ + 1).orElse(Some(1))) |
    |         .reverse                                                 |    |     cityCheckIns.updated(city, newCheckIns)                   |   |     )                                                                |
    |         .take(3)                                                 |    | })                                                            |   |     .map(topCities)                                                  |
    | }                                                                |    +---------------------------------------------------------------+   |     .foreach(IO.println)                                             |
    +------------------------------------------------------------------+                                                                        |     .compile.drain                                                   |
                                                                                                                                                | }                                                                    |
                                                                                                                                                +----------------------------------------------------------------------+
    // second version
    // create larger stream                                                                         // first version will take some time
    +--------------------------------------------------------------------------------------------+  +--------------------------------------------+
    | val checkIns: Stream[IO, City] =                                                           |  | processCheckIns(checkIns).unsafeRunSync()  |
    | Stream(City(“Sydney”), City(“Dublin”), City(“Cape Town”), City(“Lima”), City(“Singapore”)) |  | ... // a long, long time (several minutes) |
    |     .repeatN(100_000)                                                                      |  +--------------------------------------------+
    |     .append(Stream.range(0, 100_000).map(i => City(s"City $i")))                           |
    |     .append(Stream(City(“Sydney”), City(“Sydney”), City(“Lima”)))                          |
    |     .covary[IO]                                                                            |
    +--------------------------------------------------------------------------------------------+
    // Batching implementation
    // trade-off: bigger batch - lower frequency of ranking updates
       need to handle edge cases like you have 590_000 check-ins and 5 mins silence
    +----------------------------------------------------------------------+
    | def processCheckIns(checkIns: Stream[IO, City]): IO[Unit] = {        |
    |     checkIns.scan(Map.empty[City, Int])((cityCheckIns, city) =>      |    // Each check-in is processed and produces an accumulator Map, as was the case before
    |         cityCheckIns.updatedWith(city)(_.map(_ + 1).orElse(Some(1))) |    // in this version, we batch (chunk) the accumulators into batches of 100_000 elements
    |     )                                                                |    // then take only the last accumulator from a batch to compute the ranking
    |     .chunkN(100_000)                                                 |    // takes a number n and transforms n elements into a single collection-like element which is then emitted
    |     .map(_.last)                                                     |       (Sydney, Dublin, Cape Town, Lima) -> chunkN(2) -> ((Sydney, Dublin), (Cape Town, Lima))
    |     .unNone                                                          |
    |     .map(topCities)                                                  |
    |     .foreach(IO.println)                                             |
    |     .compile.drain                                                   |
    | }                                                                    |
    +----------------------------------------------------------------------+

    - step 2: IOs with fibers
    // we could use n threads to process batches of check-ins in parallel and a single thread that updates the ranking
    // exposes us to a problem of shared mutable state
    // ranking functionality needs access to the current checkIns Map, which is updated by the check-in processing functionality
    // all execution threads will need to access the same memory address, which additionally changes over time

    // dealing with threads in Java 8+
    +-------------------------------------------------------------------+
    | var cityCheckIns = new HashMap<String, Integer>();                |   // mutable HashMap that models our concurrent state
    | Runnable task = () -> {                                           |
    | for(int i = 0; i < 1000; i++) {                                   |
    |     var cityName = i % 2 == 0 ? "Cairo" : "Auckland";             |
    |         cityCheckIns.compute(cityName,                            |
    |         (city, checkIns) -> checkIns != null ? checkIns + 1 : 1); |
    |     }                                                             |
    | };                                                                |
    | new Thread(task).start();                                         |   // as a result map will contain much less then 100 elements
    | new Thread(task).start();                                         |   // can get ConcurrentModificationException
    +-------------------------------------------------------------------+
   
    // synchronization primitives are the most popular in Java
    // Monitors and locks
    +-----------------------------------------------------------------------+
    | var cityCheckIns = new HashMap<String, Integer>();                    |
    | Runnable task = () -> {                                               |
    |     for(int i = 0; i < 1000; i++) {                                   |
    |         var cityName = i % 2 == 0 ? “Cairo” : “Auckland”;             |
    |         synchronized (cityCheckIns) {                                 |   // only a single thread uses it at a time
    |             cityCheckIns.compute(cityName,                            |   // keeps track of all other threads that want to use (or acquire) the resource and notifies them once it becomes available
    |             (city, checkIns) -> checkIns != null ? checkIns + 1 : 1); |
    |         }                                                             |
    |     }                                                                 |
    | };                                                                    |
    +-----------------------------------------------------------------------+
    
    // The actor model
    +-------------------------------------------------------------------------------+
    | class CheckInsActor extends AbstractActor {                                   |    // Actors encapsulate the state and the only way we can interact with an actor and its state is by sending and receiving asynchronous messages
    |     private Map<String, Integer> cityCheckIns = new HashMap<>();              |    // making sure only a single thread has access to its state at a given time
    |     public Receive createReceive() {                                          |
    |         return receiveBuilder()                                               |
    |             .match(StoreCheckIn.class, message -> {                           |
    |                 cityCheckIns.compute(message.cityName,                        |
    |                     (city, checkIns) -> checkIns != null ? checkIns + 1 : 1); |
    |             }).match(GetCurrentCheckIns.class, message -> {                   |
    |                 getSender().tell(new HashMap<>(cityCheckIns), null);          |
    |             }).build();                                                       |
    |     }                                                                         |
    | }                                                                             |
    +-------------------------------------------------------------------------------+

    // Thread-safe data structures
    +-----------------------------------------------------------------------+
    | var cityCheckIns = new ConcurrentHashMap<String, Integer>();          |
    | Runnable task = () -> {                                               |
    |     for(int i = 0; i < 1000; i++) {                                   |
    |         var cityName = i % 2 == 0 ? “Cairo” : “Auckland”;             |
    |         cityCheckIns.compute(cityName,                                |
    |             (city, checkIns) -> checkIns != null ? checkIns + 1 : 1); |
    | }                                                                     |
    +-----------------------------------------------------------------------+

    // Atomic references
    // makes use of the compare-and-set which do not use locks
    +-----------------------------------------------------------------------------------------------------+
    | var cityCheckIns = new AtomicReference<>(new HashMap<String, Integer>());                           | // compareAndSet function that takes two values:
    | Runnable task = () -> {                                                                             |    the first is what we think is the current value stored inside the atomic reference
    |     for(int i = 0; i < 1000; i++) {                                                                 |    the second is the value we'd like to store there
    |         var cityName = i % 2 == 0 ? “Cairo” : “Auckland”;                                           |
    |         var updated = false;                                                                        | // function returns true if the value was successfully replaced and false if the current value we provided is not valid 
    |         while(!updated) {                                                                           | // functional java
    |             var currentCheckIns = cityCheckIns.get();                                               | +--------------------------------------------------------------------------------------------+
    |             var newCheckIns = new HashMap<>(currentCheckIns);                                       | | cityCheckIns.updateAndGet(oldCheckIns -> {                                                 |
    |             newCheckIns.compute(cityName, (city, checkIns) -> checkIns != null ? checkIns + 1 : 1); | |     var newCheckIns = new HashMap<>(oldCheckIns);                                          |
    |             updated = cityCheckIns.compareAndSet(currentCheckIns, newCheckIns);                     | |     newCheckIns.compute(cityName,(city, checkIns) -> checkIns != null ? checkIns + 1 : 1); |
    |         }                                                                                           | |     return newCheckIns;                                                                    |
    +-----------------------------------------------------------------------------------------------------+ | });                                                                                        |
                                                                                                            +--------------------------------------------------------------------------------------------+

    // functional tools for multithreading
    // functional atomic reference - allow us to safely store a changing value using just pure functions and IO values
    // Ref[IO, A] is an immutable value that represents an asynchronous concurrent mutable reference to an immutable value of type A
    // like Java’s AtomicReference? It required us to use immutable values. We used copies, but real immutable values are far easier to use
    +---------------------------------+ 
    | Ref[IO, A]                      | // value representing a concurrently accessible mutable reference
    | def update(f: A => A): IO[Unit] | // alternative to CAS, Ref type internals take care of everything (possibility of value A being changed by another thread)
    | // Thread #1                    | // Nothing is executed until somebody, outside of the functional core, executes this IO value
    | ref.update(_ + 1).unsafeRunSync | // when both threads are finished we will have value 3 
    | // Thread #2                    |
    | ref.update(_ + 2).unsafeRunSync |
    +---------------------------------+


    - step 3: Concurrent IOs and asynchronous access




          




            
      
       





        