###############
# week1
###############

- dynamic connectivity													###############################			
	given a set of N objects:											# +-+   +-+   +-+   +-+   +-+ #
	・Union command: connect two objects                             	# |0|   |1+---+2|   |3+---+4| #  union(4,3) 
	・Find/connected query: is there a path connecting two objects   	# +-+   +-+   +-+   +++   +++ #  union(3,8) 
																		#                    |     |  #  union(6,5)
	applications:                                                   	#                    |     |  #  union(9,4)
	・Pixels in a digital photo.                                     	# +-+   +-+   +-+   +++   +++ #  union(2,1) 
	・Computers in a network.                                        	# |5+---+6|   |7|   |8|   |9| # 
	・Friends in a social network.                                   	# +-+   +-+   +-+   +-+   +-+ # 
	・Transistors in a computer chip.                                	############################### 
	・Elements in a mathematical set.
	・Variable names in Fortran program.
	・Metallic sites in a composite system.
	
	############################################################
	# +-+   +-+   +-+   +-+              +-+   +-+   +-+   +-+ #
	# |0|   |1|   |2+---+3|              |0|   |1|   |2+---+3| #
	# +-+   +-+   +++   +++              +-+   +-+   +++   +++ #
	#      X       |   X |   union(2,5)       X     X |   X |  #
	#    X         | X   |   +------->      X     X   | X   |  #
	# +-+   +-+   +++   +++              +-+   +-+   +++   +++ #
	# |4+---+5|   |6|   |7|              |4+---+5|   |6|   |7| #
	# +-+   +-+   +-+   +-+              +-+   +-+   +-+   +-+ #
	#                                                          #
	# {0}, {1 4 5}, {2 3 6 7}            {0}, {1 2 3 4 5 6 7}  #
	############################################################


- quick find
																###############################			implementation
	################################################		 	# +-+   +-+   +-+   +-+   +-+ #         ############################################## 
	#      0 1 2 3 4 5 6 7 8 9   0 5 6 connected   #            # |0|   |1+---+2|   |3+---+4| #         # public class QuickFindUF{                  #
	#     +-------------------+  1 2 7 connected   # +------->  # +-+   +-+   +-+   +++   +++ #         # 	private int[] id;                        #
	# id[]|0|1|1|8|8|0|0|1|8|8|  3 4 8 9 connected #            #  |           |     |     |  #         # 	public QuickFindUF(int N){               #
	#     +-------------------+                    #            #  |           |     |     |  #         # 		id = new int[N];                     #
	################################################            # +-+   +-+   +-+   +++   +++ #         # 		for (int i = 0; i < N; i++)          #	<-- set id of each object
																# |5+---+6|   |7|   |8|   |9| #         # 		id[i] = i;}                          #
																# +-+   +-+   +-+   +-+   +-+ #         # 	public boolean connected(int p, int q)   #
																###############################         # 	{ return id[p] == id[q]; }               #	<-- check if p and q are in same component
	check if p and q have same id:		id[6]=0; id[1]=1	-->		not connected                       # 	public void union(int p, int q)          #
	union - to merge components containing p and q change all entries whose id equals id[p] to id[q]    # 	{                                        #
	##############################                                                                      # 		int pid = id[p];                     #	<-- change all entries with id[p] to id[q]
	#      0 1 2 3 4 5 6 7 8 9   #	after union 6 and 1                                                 # 		int qid = id[q];                     #
	#     +-------------------+  #                                                                      # 		for (int i = 0; i < id.length; i++)  #
	# id[]|1|1|1|8|8|1|1|1|8|8|  #                                                                      # 		if (id[i] == pid) id[i] = qid;       #
	#     +-------------------+  #                                                                      # 	}                                        #
	#      ・         ・ ・			 #                                                                      # }                                          #
	##############################                                                                      ##############################################


- quick union
	interpretation: id[i] is parent of i	 #######################################
	                                         # +-+   +-+   +-+     +-+   +-+   +-+ #	root of 3 is 9
	##############################           # |0|   |1|   |9|     |6|   |7|   |8| #	root of 5 is 6
	#      0 1 2 3 4 5 6 7 8 9   #           # +-+   +-+   +-+     +-+   +-+   +-+ #
	#     +-------------------+  #           #            X   X       X            #
	# id[]|0|1|9|4|9|6|6|7|8|9|  #           #         +-+     +-+     +-+         #
	#     +-------------------+  #           #         |2|     |4|     |5|         #
	##############################           #         +-+     +++     +-+         #
	                                         #                  |                  #
 	                                         #                 +++                 #
                                             #                 |3|                 #
                                             #                 +-+                 #
                                             #######################################
	
	to merge components containing p and q - set the id of p`s root to the id of q`s root
	
	##############################			###############################			implementation
	#      0 1 2 3 4 5 6 7 8 9   #          # +-+   +-+   +-+   +-+   +-+ #         ################################################
	#     +-------------------+  #          # |0|   |1|   |6|   |7|   |8| #         # public class QuickUnionUF {                  #
	# id[]|0|1|9|4|9|6|6|7|8|6|  #          # +-+   +-+   +-+   +-+   +-+ #         #     private int[] id;                        #
	#     +-------------------+  #          #            X   X            #         #     public QuickUnionUF(int N) {             #
	#                        ・	 #          #         +-+     +-+         #         #         id = new int[N];                     #	<-- set id of each object
	##############################          #         |9|     |5|         #         #         for (int i = 0; i < N; i++)          #
 	                                        #         +-+     +-+         #         #             id[i] = i;                       #
                                            #        X   X                #         #     }                                        #
                                            #     +-+     +-+             #         #     private int root(int i) {                #
                                            #     |2|     |4|             #         #         while (i != id[i])                   #	<-- chase parent pointers until reach root
                                            #     +-+     +++             #         #             i = id[i];                       #
                                            #              |              #         #         return i;                            #
                                            #             +++             #         #     }                                        #
                                            #             |3|             #         #     public boolean connected(int p, int q) { #
                                            #             +-+             #         #         return root(p) == root(q);           #	<-- check if p and q have same root
                                            ###############################         #     }                                        #
                                                                                    #     public void union(int p, int q) {        #
                                                                                    #         int i = root(p);                     #	<-- change root of p to point to root of q
                                                                                    #         int j = root(q);                     #
                                                                                    #         id[i] = j;                           #
                                                                                    #     }                                        #
                                                                                    # }                                            #
                                                                                    ################################################
- quick union improvements
	・Modify quick union to avoid tall trees
	・Keep track of size of each tree
	・balance by linking root of smaller tree to root od largert tree
																    union(4 3)													 union(3 8)
	#############################################################       #######################################################       ########################################################
	# +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+ #       # +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+ #       # +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+  #
	# |0|   |1|   |2|   |3|   |4|   |5|   |6|   |7|   |8|   |9| #  -->  # |0|   |1|   |2|   |4|   |5|   |6|   |7|   |8|   |9| #  -->  # |0|   |1|   |2|   |4|   |5|   |6|   |7|   |8|   |9|  #
	# +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+ #       # +-+   +-+   +-+   +++   +-+   +-+   +-+   +-+   +-+ #       # +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+  #
	#############################################################       #                    |                                #       #                  #   #                               #
																		#                   +++                               #       #               +-+     +-+                            #
																		#                   |3|                               #       #               |3|     |8|                            #
																		#                   +-+                               #       #               +-+     +-+                            #
																		#######################################################       ########################################################
	
	union(6 5)												union(9 4)									  union(2 1)								    union(5 0)
	#################################################       #######################################       #######################################       #############################
	# +-+   +-+   +-+   +-+         +-+   +-+   +-+ #       # +-+   +-+   +-+   +-+     +-+   +-+ #       # +-+   +-+         +-+     +-+   +-+ #       # +-+     +-+     +-+   +-+ #
	# |0|   |1|   |2|   |4|         |6|   |7|   |9| #       # |0|   |1|   |2|   |4|     |6|   |7| #       # |0|   |2|         |4|     |6|   |7| #       # |2|     |4|     |6|   |7| #
	# +-+   +-+   +-+   +-+         +++   +-+   +-+ #  -->  # +-+   +-+   +-+   +-+     +-+   +-+ #  -->  # +-+   +++         +++     +++   +-+ #  -->  # +++     +++     +++   +-+ #
	#                  X   X         |              #       #                  X | X     |        #       #        |         X | X     |        #       #  |     X | X     | X      #
	#               +-+     +-+     +++             #       #               +-+ +-+ +-+ +-+       #       #       +++     +-+ +++ +-+ +++       #       # +++ +-+ +++ +-+ +++ +-+   #
	#               |3|     |8|     |5|             #       #               |3| |9| |8| |5|       #       #       |1|     |3| |9| |8| |5|       #       # |1| |3| |9| |8| |5| |0|   #
	#               +-+     +-+     +-+             #       #               +-+ +-+ +-+ +-+       #       #       +-+     +-+ +-+ +-+ +-+       #       # +-+ +-+ +-+ +-+ +-+ +-+   #
	#################################################       #######################################       #######################################       #############################
	
	union(7 2)								 union(6 1)						    union(7 3)
	###################################      ############################       ############################
	#     +-+         +-+     +-+     #      #     +-+          +-+     #       #           +-+            #
	#     |2|         |4|     |6|     #      #     |4|          |6|     #       #           |6|            #
	#     +++         +++     +++     #  --> #     +++          +++     #  -->  #           +-+            #
	#    X |         X | X     | X    #      #    X | X        X | X    #       #        X   X   X         #
	# +-+ +++     +-+ +++ +-+ +++ +-+ #      # +-+ +++ +-+  +-+ +++ +-+ #       #     +-+ +-+ +-+ +-+      #
	# |7| |1|     |3| |9| |8| |5| |0| #      # |3| |9| |8|  |2| |5| |0| #       #     |2| |5| |0| |4|      #
	# +-+ +-+     +-+ +-+ +-+ +-+ +-+ #      # +-+ +-+ +-+  +++ +-+ +-+ #       #     +++ +-+ +-+ +++      #
	###################################      #             X |          #       #    X |         X | X     #
											 #          +-+ +++         #       # +-+ +++     +-+ +++ +-+  #
											 #          |7| |1|         #       # |7| |1|     |3| |9| |8|  #
											 #          +-+ +-+         #       # +-+ +-+     +-+ +-+ +-+  #
											 ############################       ############################

	implementation:
	・Same as quick-union, but maintain extra array sz[i] to count number of objects in the tree rooted at i.
	・Find. Identical to quick-union.
	・Union. Modify quick-union to:
		・Link root of smaller tree to root of larger tree.
		・Update the sz[] array.
		####################################################
		#int i = root(p);                                  #
		#int j = root(q);                                  #
		#if (i == j) return;                               #
		#if (sz[i] < sz[j]) { id[i] = j; sz[j] += sz[i]; } #
		#else { id[j] = i; sz[i] += sz[j]; }               #
		####################################################
		
	improvement2:
	・Just after computing the root of p, set the id of each examined node to point to that root
	・Make every other node in path point to its grandparent (thereby halving path length).
	##############################	
	# private int root(int i) {  #
	#     while (i != id[i]) {   #
	#         id[i] = id[id[i]]; #  <--  added code
	#         i = id[i];         #
	#     }                      #
	#     return i;              #
	# }                          #
	##############################


###############
# week2
###############	

- stacks
	・Parsing in a compiler.							 ##################################																				
	・Java virtual machine.                           #  stack                         # 
	・Undo in a word processor.                       #  +-+-+-+-+-+-+-+-+-+-+ <-+push # 
	・Back button in a Web browser.                   #  | | | | | | | | | | |         # 
	・PostScript language for printers.               #  +-+-+-+-+-+-+-+-+-+-+ +->pop  # 
	・Implementing function calls in a compiler.      ################################## 

	implementation parametrized					array implementation
	#######################################     ######################################################
	# public class Stack<Item> {          #     # public class FixedCapacityStack<Item> {            #
    # private Node first = null;          #     # private Item[] s;                                  #
    # private class Node {                #     # private int N = 0;                                 #
    #     Item item;                      #     #                                                    #
    #     Node next;                      #     # public FixedCapacityStackOfStrings(int capacity) { #
    # }                                   #     #     s = (Item[])new Object[capacity];              #
	#                                     #     # }                                                  #
    # public boolean isEmpty() {          #     #                                                    #
    #     return first == null;           #     # public boolean isEmpty() {                         #
    # }                                   #     #     return N == 0;                                 #
    # public void push(String item) {     #     # }                                                  #
    #     Node oldfirst = first;          #     #                                                    #
    #     first = new Node();             #     # public void push(Item item) {                      #										+-------------------------+
    #     first.item = item;              #     #     s[N ++] = item;                                #                                      | public String pop() {   |
    #     first.next = oldfirst;          #     # }                                                  #                                      | 	String item = s[--N]; |
    # }                                   #     #                                                    #										| 	s[N] = null;          |
    # public Item pop() {                 #     # public Item pop() {                                #                                      | 	return item;          |
    #     Item item = first.item;         #     #     return s[-- N];                                #  <-- holding a reference to object   | }                       |
    #     first = first.next;             #     # }}                                                 #                                      +-------------------------+
    #     return item;                    #     ######################################################
    # }}	                              #
	#######################################


- resizing arrays
	when array fills - crate a new one twice a size
	###################################################																				Arithmetic expression evaluation
	# public ResizingArrayStackOfStrings() {          #		   ##########################################################           ################################################################################# 	
	#     s = new String[1];                          #        # public String pop() {                                  #           # public class Evaluate {                                                       #   Two-stack algorithm. [E. W. Dijkstra]
	# }                                               #  <---  #     String item = s[--N];                              #           # 	public static void main(String[] args) {                                    #   ・Value: push onto the value stack.
	# public void push(String item) {                 #        #     s[N] = null;                                       #           # 		Stack<String> ops = new Stack<String>();                                #   ・Operator: push onto the operator stack.
	#     if(N == s.length) resize(2 * s.length);     #        #     if(N > 0 && N == s.length / 4) resize(s.length/2); #           # 		Stack<Double> vals = new Stack<Double>();                               #   ・Left parenthesis: ignore.
	#     s[N++] = item;                              #        #     return item;                                       #           # 		while (!StdIn.isEmpty()) {                                              #   ・Right parenthesis: pop operator and two values;
	# }                                               #        # }                                                      #           # 			String s = StdIn.readString();                                      #   push the result of applying that operator
	# private void resize(int capacity) {             #        ##########################################################           # 			if (s.equals("(")) ;                                                #   to those values onto the operand stack.
	#     String[] copy = new String[capacity];       #                                                                             # 			else if (s.equals("+")) ops.push(s);                                #
	#     for (int i = 0; i < N; i++) copy[i] = s[i]; #                                                                             # 			else if (s.equals("*")) ops.push(s);                                #
	#     s = copy;                                   #                                                                             # 			else if (s.equals(")")){                                            #
	# }                                               #                                                                             # 				String op = ops.pop();                                          #
	###################################################                                                                             # 				if (op.equals("+")) vals.push(vals.pop() + vals.pop());         #
	                                                                                                                                # 				else if (op.equals("*")) vals.push(vals.pop() * vals.pop());    #
	・linked list - uses extra time and space to deal with the links                                                                 # 			}                                                                   # 
	・array - every operation takes constant amortized time.                                                                         # 			else vals.push(Double.parseDouble(s));                              # 
	                                                                                                                                # 		}                                                                       #
- queues                                                                                                                            # 	StdOut.println(vals.pop());                                                 #
	############################################                                                                                    # }}                                                                            #
	#          queue                           #                                                                                    #################################################################################
	#          +-+-+-+-+-+-+-+-+-+-+           #
	# enque+-> | | | | | | | | | | | +->deque  #
	#          +-+-+-+-+-+-+-+-+-+-+           #
	############################################
	
	linked list implementation								array implemeentation
	#############################################			・Use array q[] to store items in queue.
	# public class LinkedQueueOfStrings {       #           ・enqueue(): add new item at q[tail].
	#     private Node first, last;             #           ・dequeue(): remove item from q[head].
	#                                           #           ・Update head and tail modulo the capacity.
	#     private class Node {                  #           ・Add resizing array.
	#         ; /* same as in StackOfStrings */ #
	#     }                                     #
	#                                           #
	#     public boolean isEmpty() {            #
	#         return first == null;             #
	#     }                                     #
	#                                           #
	#     public void enqueue(String item) {    #
	#         Node oldlast = last;              #
	#         last = new Node();                #
	#         last.item = item;                 #
	#         last.next = null;                 #
	#         if(isEmpty()) first = last;       #
	#         else oldlast.next = last;         #
	#     }                                     #
	#                                           #
	#     public String dequeue() {             #
	#         String item = first.item;         #
	#         first = first.next;               #
	#         if(isEmpty()) last = null;        #
	#         return item;                      #
	#     }                                     #
	# }                                         #
	#############################################


- iterators																							implementation															array implementation
	######################################															################################################################		########################################################################															
	# public interface Iterable<Item > { #                                                          # import java.util.Iterator;                                   #        # import java.util.Iterator;                                           #
	#     Iterator<Item> iterator();     #                                                          # public class Stack<Item > implements Iterable<Item > {       #        # public class Stack<Item > implements Iterable<Item > {               #
    # }                                  #                                                          #     public Iterator<Item > iterator() {                      #        #     public Iterator<Item > iterator() {                              #
    #                                    #	<-- allows for (String s : stack) StdOut.println(s);    #         return new ListIterator();                           #        #         return new ReverseArrayIterator();                           #
    # public interface Iterator<Item > { #                                                          #     }                                                        #        #     }                                                                #
    #     boolean hasNext();             #                                                          #     private class ListIterator implements Iterator<Item > {  #        #     private class ReverseArrayIterator implements Iterator<Item > {  #
    #     Item next();                   #                                                          #         private Node current = first;                        #        #         private int i = N;                                           #
    #     void remove();                 #                                                          #         public boolean hasNext() {                           #        #         public boolean hasNext() {                                   #
    # }                                  #                                                          #             return current != null;                          #        #             return i > 0;                                            #
    ######################################                                                          #         }                                                    #        #         }                                                            #
                                                                                                    #         public void remove() {                               #        #         public void remove() {                                       #
                                                                                                    #             ; /* not supported */                            #        #             ; /* not supported */                                    #
                                                                                                    #         }                                                    #        #         }                                                            #
                                                                                                    #         public Item next() {                                 #        #         public Item next() {                                         #
                                                                                                    #             Item item = current.item;                        #        #             return s[--i];                                           #
                                                                                                    #             current = current.next;                          #        #         }                                                            #
                                                                                                    #             return item;                                     #        #     }                                                                #
                                                                                                    #         }                                                    #        # }                                                                    #
                                                                                                    #     }                                                        #        ########################################################################
                                                                                                    # }                                                            #
                                                                                                    ################################################################

- selection sort
	・In iteration i, find index min of smallest remaining entry.
	・Swap a[i] and a[min].
	################################################################################
	# public class Selection {                                                     #
	#     public static void sort(Comparable[] a) {                                #
	#         int N = a.length;                                                    #
	#         for(int i = 0; i < N; i++) {                                         #
	#             int min = i;                                                     #
	#             for (int j = i+1; j < N; j++) if (less(a[j], a[min])) min = j;   #
	#             exch(a, i, min);                                                 #
	#         }                                                                    #
	#     }                                                                        #
	#     private static boolean less(Comparable v, Comparable w) {                #
	#         return v.compareTo(w) < 0;                                           #
    #     }                                                                        #
    #     private static void exch(Comparable[] a, int i, int j) {                 #
    #         Comparable swap = a[i];                                              #
    #         a[i] = a[j];                                                         #
    #         a[j] = swap;                                                         #
    #     }                                                                        #
    # }                                                                            #
    ################################################################################


- insertion sort

- shellsort

- shuffling

- convex hull



 







###############
# week3
###############	

###############
# week4
###############	

###############
# week5
###############	

###############
# week6
###############	
