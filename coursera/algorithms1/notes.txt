###############
# week1
###############

- dynamic connectivity													###############################			
	given a set of N objects:											# +-+   +-+   +-+   +-+   +-+ #
	・Union command: connect two objects                             	# |0|   |1+---+2|   |3+---+4| #  union(4,3) 
	・Find/connected query: is there a path connecting two objects   	# +-+   +-+   +-+   +++   +++ #  union(3,8) 
																		#                    |     |  #  union(6,5)
	applications:                                                   	#                    |     |  #  union(9,4)
	・Pixels in a digital photo.                                     	# +-+   +-+   +-+   +++   +++ #  union(2,1) 
	・Computers in a network.                                        	# |5+---+6|   |7|   |8|   |9| # 
	・Friends in a social network.                                   	# +-+   +-+   +-+   +-+   +-+ # 
	・Transistors in a computer chip.                                	############################### 
	・Elements in a mathematical set.
	・Variable names in Fortran program.
	・Metallic sites in a composite system.
	
	############################################################
	# +-+   +-+   +-+   +-+              +-+   +-+   +-+   +-+ #
	# |0|   |1|   |2+---+3|              |0|   |1|   |2+---+3| #
	# +-+   +-+   +++   +++              +-+   +-+   +++   +++ #
	#      X       |   X |   union(2,5)       X     X |   X |  #
	#    X         | X   |   +------->      X     X   | X   |  #
	# +-+   +-+   +++   +++              +-+   +-+   +++   +++ #
	# |4+---+5|   |6|   |7|              |4+---+5|   |6|   |7| #
	# +-+   +-+   +-+   +-+              +-+   +-+   +-+   +-+ #
	#                                                          #
	# {0}, {1 4 5}, {2 3 6 7}            {0}, {1 2 3 4 5 6 7}  #
	############################################################


- quick find
																###############################			implementation
	################################################		 	# +-+   +-+   +-+   +-+   +-+ #         ############################################## 
	#      0 1 2 3 4 5 6 7 8 9   0 5 6 connected   #            # |0|   |1+---+2|   |3+---+4| #         # public class QuickFindUF{                  #
	#     +-------------------+  1 2 7 connected   # +------->  # +-+   +-+   +-+   +++   +++ #         # 	private int[] id;                        #
	# id[]|0|1|1|8|8|0|0|1|8|8|  3 4 8 9 connected #            #  |           |     |     |  #         # 	public QuickFindUF(int N){               #
	#     +-------------------+                    #            #  |           |     |     |  #         # 		id = new int[N];                     #
	################################################            # +-+   +-+   +-+   +++   +++ #         # 		for (int i = 0; i < N; i++)          #	<-- set id of each object
																# |5+---+6|   |7|   |8|   |9| #         # 		id[i] = i;}                          #
																# +-+   +-+   +-+   +-+   +-+ #         # 	public boolean connected(int p, int q)   #
																###############################         # 	{ return id[p] == id[q]; }               #	<-- check if p and q are in same component
	check if p and q have same id:		id[6]=0; id[1]=1	-->		not connected                       # 	public void union(int p, int q)          #
	union - to merge components containing p and q change all entries whose id equals id[p] to id[q]    # 	{                                        #
	##############################                                                                      # 		int pid = id[p];                     #	<-- change all entries with id[p] to id[q]
	#      0 1 2 3 4 5 6 7 8 9   #	after union 6 and 1                                                 # 		int qid = id[q];                     #
	#     +-------------------+  #                                                                      # 		for (int i = 0; i < id.length; i++)  #
	# id[]|1|1|1|8|8|1|1|1|8|8|  #                                                                      # 		if (id[i] == pid) id[i] = qid;       #
	#     +-------------------+  #                                                                      # 	}                                        #
	#      ・         ・ ・			 #                                                                      # }                                          #
	##############################                                                                      ##############################################


- quick union
	interpretation: id[i] is parent of i	 #######################################
	                                         # +-+   +-+   +-+     +-+   +-+   +-+ #	root of 3 is 9
	##############################           # |0|   |1|   |9|     |6|   |7|   |8| #	root of 5 is 6
	#      0 1 2 3 4 5 6 7 8 9   #           # +-+   +-+   +-+     +-+   +-+   +-+ #
	#     +-------------------+  #           #            X   X       X            #
	# id[]|0|1|9|4|9|6|6|7|8|9|  #           #         +-+     +-+     +-+         #
	#     +-------------------+  #           #         |2|     |4|     |5|         #
	##############################           #         +-+     +++     +-+         #
	                                         #                  |                  #
 	                                         #                 +++                 #
                                             #                 |3|                 #
                                             #                 +-+                 #
                                             #######################################
	
	to merge components containing p and q - set the id of p`s root to the id of q`s root
	
	##############################			###############################			implementation
	#      0 1 2 3 4 5 6 7 8 9   #          # +-+   +-+   +-+   +-+   +-+ #         ################################################
	#     +-------------------+  #          # |0|   |1|   |6|   |7|   |8| #         # public class QuickUnionUF {                  #
	# id[]|0|1|9|4|9|6|6|7|8|6|  #          # +-+   +-+   +-+   +-+   +-+ #         #     private int[] id;                        #
	#     +-------------------+  #          #            X   X            #         #     public QuickUnionUF(int N) {             #
	#                        ・	 #          #         +-+     +-+         #         #         id = new int[N];                     #	<-- set id of each object
	##############################          #         |9|     |5|         #         #         for (int i = 0; i < N; i++)          #
 	                                        #         +-+     +-+         #         #             id[i] = i;                       #
                                            #        X   X                #         #     }                                        #
                                            #     +-+     +-+             #         #     private int root(int i) {                #
                                            #     |2|     |4|             #         #         while (i != id[i])                   #	<-- chase parent pointers until reach root
                                            #     +-+     +++             #         #             i = id[i];                       #
                                            #              |              #         #         return i;                            #
                                            #             +++             #         #     }                                        #
                                            #             |3|             #         #     public boolean connected(int p, int q) { #
                                            #             +-+             #         #         return root(p) == root(q);           #	<-- check if p and q have same root
                                            ###############################         #     }                                        #
                                                                                    #     public void union(int p, int q) {        #
                                                                                    #         int i = root(p);                     #	<-- change root of p to point to root of q
                                                                                    #         int j = root(q);                     #
                                                                                    #         id[i] = j;                           #
                                                                                    #     }                                        #
                                                                                    # }                                            #
                                                                                    ################################################
- quick union improvements
	・Modify quick union to avoid tall trees
	・Keep track of size of each tree
	・balance by linking root of smaller tree to root od largert tree
																    union(4 3)													 union(3 8)
	#############################################################       #######################################################       ########################################################
	# +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+ #       # +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+ #       # +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+  #
	# |0|   |1|   |2|   |3|   |4|   |5|   |6|   |7|   |8|   |9| #  -->  # |0|   |1|   |2|   |4|   |5|   |6|   |7|   |8|   |9| #  -->  # |0|   |1|   |2|   |4|   |5|   |6|   |7|   |8|   |9|  #
	# +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+ #       # +-+   +-+   +-+   +++   +-+   +-+   +-+   +-+   +-+ #       # +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+  #
	#############################################################       #                    |                                #       #                  #   #                               #
																		#                   +++                               #       #               +-+     +-+                            #
																		#                   |3|                               #       #               |3|     |8|                            #
																		#                   +-+                               #       #               +-+     +-+                            #
																		#######################################################       ########################################################
	
	union(6 5)												union(9 4)									  union(2 1)								    union(5 0)
	#################################################       #######################################       #######################################       #############################
	# +-+   +-+   +-+   +-+         +-+   +-+   +-+ #       # +-+   +-+   +-+   +-+     +-+   +-+ #       # +-+   +-+         +-+     +-+   +-+ #       # +-+     +-+     +-+   +-+ #
	# |0|   |1|   |2|   |4|         |6|   |7|   |9| #       # |0|   |1|   |2|   |4|     |6|   |7| #       # |0|   |2|         |4|     |6|   |7| #       # |2|     |4|     |6|   |7| #
	# +-+   +-+   +-+   +-+         +++   +-+   +-+ #  -->  # +-+   +-+   +-+   +-+     +-+   +-+ #  -->  # +-+   +++         +++     +++   +-+ #  -->  # +++     +++     +++   +-+ #
	#                  X   X         |              #       #                  X | X     |        #       #        |         X | X     |        #       #  |     X | X     | X      #
	#               +-+     +-+     +++             #       #               +-+ +-+ +-+ +-+       #       #       +++     +-+ +++ +-+ +++       #       # +++ +-+ +++ +-+ +++ +-+   #
	#               |3|     |8|     |5|             #       #               |3| |9| |8| |5|       #       #       |1|     |3| |9| |8| |5|       #       # |1| |3| |9| |8| |5| |0|   #
	#               +-+     +-+     +-+             #       #               +-+ +-+ +-+ +-+       #       #       +-+     +-+ +-+ +-+ +-+       #       # +-+ +-+ +-+ +-+ +-+ +-+   #
	#################################################       #######################################       #######################################       #############################
	
	union(7 2)								 union(6 1)						    union(7 3)
	###################################      ############################       ############################
	#     +-+         +-+     +-+     #      #     +-+          +-+     #       #           +-+            #
	#     |2|         |4|     |6|     #      #     |4|          |6|     #       #           |6|            #
	#     +++         +++     +++     #  --> #     +++          +++     #  -->  #           +-+            #
	#    X |         X | X     | X    #      #    X | X        X | X    #       #        X   X   X         #
	# +-+ +++     +-+ +++ +-+ +++ +-+ #      # +-+ +++ +-+  +-+ +++ +-+ #       #     +-+ +-+ +-+ +-+      #
	# |7| |1|     |3| |9| |8| |5| |0| #      # |3| |9| |8|  |2| |5| |0| #       #     |2| |5| |0| |4|      #
	# +-+ +-+     +-+ +-+ +-+ +-+ +-+ #      # +-+ +-+ +-+  +++ +-+ +-+ #       #     +++ +-+ +-+ +++      #
	###################################      #             X |          #       #    X |         X | X     #
											 #          +-+ +++         #       # +-+ +++     +-+ +++ +-+  #
											 #          |7| |1|         #       # |7| |1|     |3| |9| |8|  #
											 #          +-+ +-+         #       # +-+ +-+     +-+ +-+ +-+  #
											 ############################       ############################

	implementation:
	・Same as quick-union, but maintain extra array sz[i] to count number of objects in the tree rooted at i.
	・Find. Identical to quick-union.
	・Union. Modify quick-union to:
		・Link root of smaller tree to root of larger tree.
		・Update the sz[] array.
		####################################################
		#int i = root(p);                                  #
		#int j = root(q);                                  #
		#if (i == j) return;                               #
		#if (sz[i] < sz[j]) { id[i] = j; sz[j] += sz[i]; } #
		#else { id[j] = i; sz[i] += sz[j]; }               #
		####################################################
		
	improvement2:
	・Just after computing the root of p, set the id of each examined node to point to that root
	・Make every other node in path point to its grandparent (thereby halving path length).
	##############################	
	# private int root(int i) {  #
	#     while (i != id[i]) {   #
	#         id[i] = id[id[i]]; #  <--  added code
	#         i = id[i];         #
	#     }                      #
	#     return i;              #
	# }                          #
	##############################









	  



###############
# week2
###############	

###############
# week3
###############	

###############
# week4
###############	

###############
# week5
###############	

###############
# week6
###############	
